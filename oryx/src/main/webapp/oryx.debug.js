
/**
 * @namespace Oryx name space for different utility methods
 * @name ORYX.Utils
*/
ORYX.Utils = {
    /**
     * General helper method for parsing a param out of current location url
     * @example
     * // Current url in Browser => "http://oryx.org?param=value"
     * ORYX.Utils.getParamFromUrl("param") // => "value" 
     * @param {Object} name
     */
    getParamFromUrl: function(name){
        name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + name + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(window.location.href);
        if (results == null) {
            return null;
        }
        else {
            return results[1];
        }
    },
	
	adjustGradient: function(gradient, reference){
		
		if (ORYX.CONFIG.DISABLE_GRADIENT && gradient){
		
			var col = reference.getAttributeNS(null, "stop-color") || "#ffffff";
			
			$A(gradient.getElementsByTagName("stop")).each(function(stop){
				if (stop == reference){ return; }
				stop.setAttributeNS(null, "stop-color", col);
			})
		}
	}
}
/**
 * @author martin.czuchra
 */

XMLNS = {
	ATOM:	"http://www.w3.org/2005/Atom",
	XHTML:	"http://www.w3.org/1999/xhtml",
	ERDF:	"http://purl.org/NET/erdf/profile",
	RDFS:	"http://www.w3.org/2000/01/rdf-schema#",
	RDF:	"http://www.w3.org/1999/02/22-rdf-syntax-ns#",
	RAZIEL: "http://b3mn.org/Raziel",

	SCHEMA: ""
};

//TODO kann kickstart sich vielleicht auch um die erzeugung von paketen/
// namespaces k�mmern? z.b. requireNamespace("ORYX.Core.SVG");
var Kickstart = {
 	started: false,
	callbacks: [],
	alreadyLoaded: [],
	PATH: '',

	load: function() { Kickstart.kick(); },

	kick: function() {
		//console.profile("loading");
		if(!Kickstart.started) {
			Kickstart.started = true;
			Kickstart.callbacks.each(function(callback){
				// call the registered callback asynchronously.
				window.setTimeout(callback, 1);
			});
		}
	},

	register: function(callback) {
		//TODO Add some mutual exclusion between kick and register calls.
		with(Kickstart) {
			if(started) window.setTimeout(callback, 1);
			else Kickstart.callbacks.push(callback)
		}
	},

	/**
	 * Loads a js, assuring that it has only been downloaded once.
	 * @param {String} url the script to load.
	 */
	require: function(url) {
		// if not already loaded, include it.
		if(Kickstart.alreadyLoaded.member(url))
			return false;
		return Kickstart.include(url);
	},

	/**
	 * Loads a js, regardless of whether it has only been already downloaded.
	 * @param {String} url the script to load.
	 */
	include: function(url) {

		// prepare a script tag and place it in html head.
		var head = document.getElementsByTagNameNS(XMLNS.XHTML, 'head')[0];
		var s = document.createElementNS(XMLNS.XHTML, "script");
		s.setAttributeNS(XMLNS.XHTML, 'type', 'text/javascript');
	   	s.src = Kickstart.PATH + url;

		//TODO macht es sinn, dass neue skript als letztes kind in den head
		// einzubinden (stichwort reihenfolge der skript tags)?
	   	head.appendChild(s);

		// remember this url.
		Kickstart.alreadyLoaded.push(url);

		return true;
	}
}

// register kickstart as the new onload event listener on current window.
// previous listener(s) are triggered to launch with kickstart.
Event.observe(window, 'load', Kickstart.load);/**
 * @author martin.czuchra
 */

var ERDF = {

	LITERAL: 0x01,
	RESOURCE: 0x02,
	DELIMITERS: ['.', '-'],
	HASH: '#',
	HYPHEN: "-",

	schemas: [],
	callback: undefined,
	log: undefined,

	init: function(callback) {
		
		// init logging.
		//ERDF.log = Log4js.getLogger("oryx");
		//ERDF.log.setLevel(Log4js.Level.ALL);
		//ERDF.log.addAppender(new ConsoleAppender(ERDF.log, false));

		//if(ERDF.log.isTraceEnabled())
		//	ERDF.log.trace("ERDF Parser is initialized.");

		// register callbacks and default schemas.
		ERDF.callback = callback;
		ERDF.registerSchema('schema', XMLNS.SCHEMA);
		ERDF.registerSchema('rdfs', XMLNS.RDFS);
	},

	run: function() {

		//if(ERDF.log.isTraceEnabled())
		//	ERDF.log.trace("ERDF Parser is running.");

		// do the work.
		return ERDF._checkProfile() && ERDF.parse();
	},
	
	parse: function() {
		
		//(ERDF.log.isDebugEnabled())
		//	ERDF.log.debug("Begin parsing document metadata.");
		
		// time measuring
		ERDF.__startTime = new Date();

		var bodies = document.getElementsByTagNameNS(XMLNS.XHTML, 'body');
		var subject = {type: ERDF.RESOURCE, value: ''};

		var result = ERDF._parseDocumentMetadata() &&
			ERDF._parseFromTag(bodies[0], subject);
			
		// time measuring
		ERDF.__stopTime = new Date();

		var duration = (ERDF.__stopTime - ERDF.__startTime)/1000.;
		//alert('ERDF parsing took ' + duration + ' s.');
		
		return result;
	},
	
	_parseDocumentMetadata: function() {

		// get links from head element.
		var heads = document.getElementsByTagNameNS(XMLNS.XHTML, 'head');
		var links = heads[0].getElementsByTagNameNS(XMLNS.XHTML, 'link');
		var metas = heads[0].getElementsByTagNameNS(XMLNS.XHTML, 'meta');

		// process links first, since they could contain schema definitions.
		$A(links).each(function(link) {
			var properties = link.getAttribute('rel');
			var reversedProperties = link.getAttribute('rev');
			var value = link.getAttribute('href');
			
			ERDF._parseTriplesFrom(
				ERDF.RESOURCE, '',
				properties,
				ERDF.RESOURCE, value);
				
			ERDF._parseTriplesFrom(
				ERDF.RESOURCE, value,
				reversedProperties,
				ERDF.RESOURCE, '');
		});

		// continue with metas.
		$A(metas).each(function(meta) {
			var property = meta.getAttribute('name');
			var value = meta.getAttribute('content');
			
			ERDF._parseTriplesFrom(
				ERDF.RESOURCE, '',
				property,
				ERDF.LITERAL, value);
		});

		return true;
	},
	
	_parseFromTag: function(node, subject, depth) {
		
		// avoid parsing non-xhtml content.
		if(node.namespaceURI != XMLNS.XHTML) { return; }
		
		// housekeeping.
		if(!depth) depth=0;
		var id = node.getAttribute('id');

		// some logging.
		//if(ERDF.log.isTraceEnabled())
		//	ERDF.log.trace(">".times(depth) + " Parsing " + node.nodeName + " ("+node.nodeType+") for data on " +
		//		((subject.type == ERDF.RESOURCE) ? ('&lt;' + subject.value + '&gt;') : '') +
		//		((subject.type == ERDF.LITERAL) ? '"' + subject.value + '"' : ''));
		
		/* triple finding! */
		
		// in a-tags...
		if(node.nodeName.endsWith(':a') || node.nodeName == 'a') {
			var properties = node.getAttribute('rel');
			var reversedProperties = node.getAttribute('rev');
			var value = node.getAttribute('href');
			var title = node.getAttribute('title');
			var content = node.textContent;

			// rel triples
			ERDF._parseTriplesFrom(
				subject.type, subject.value,
				properties,
				ERDF.RESOURCE, value,
				function(triple) {
					var label = title? title : content;
					
					// label triples
					ERDF._parseTriplesFrom(
						triple.object.type, triple.object.value,
						'rdfs.label',
						ERDF.LITERAL, label);
				});

			// rev triples
			ERDF._parseTriplesFrom(
				subject.type, subject.value,
				reversedProperties,
				ERDF.RESOURCE, '');
				
			// type triples
			ERDF._parseTypeTriplesFrom(
				subject.type, subject.value,
				properties);

		// in img-tags...
		} else if(node.nodeName.endsWith(':img') || node.nodeName == 'img') {
			var properties = node.getAttribute('class');
			var value = node.getAttribute('src');
			var alt = node.getAttribute('alt');

			ERDF._parseTriplesFrom(
				subject.type, subject.value,
				properties,
				ERDF.RESOURCE, value,
				function(triple) {
					var label = alt;
					
					// label triples
					ERDF._parseTriplesFrom(
						triple.object.type, triple.object.value,
						'rdfs.label',
						ERDF.LITERAL, label);
				});

		}
		
		// in every tag
		var properties = node.getAttribute('class');
		var title = node.getAttribute('title');
		var content = node.textContent;
		var label = title ? title : content;
		
		// regular triples
		ERDF._parseTriplesFrom(
			subject.type, subject.value,
			properties,
			ERDF.LITERAL, label);

		if(id) subject = {type: ERDF.RESOURCE, value: ERDF.HASH+id};
		
		// type triples
		ERDF._parseTypeTriplesFrom(
			subject.type, subject.value,
			properties);

		// parse all children that are element nodes.
		var children = node.childNodes;
		if(children) $A(children).each(function(_node) {
			if(_node.nodeType == _node.ELEMENT_NODE)
				ERDF._parseFromTag(_node, subject, depth+1); });
	},
	
	_parseTriplesFrom: function(subjectType, subject, properties,
		objectType, object, callback) {
		
		if(!properties) return;
		properties.toLowerCase().split(' ').each( function(property) {
			
			//if(ERDF.log.isTraceEnabled())
			//	ERDF.log.trace("Going for property " + property);

			var schema = ERDF.schemas.find( function(schema) {
				return false || ERDF.DELIMITERS.find( function(delimiter) {
					return property.startsWith(schema.prefix + delimiter);
				});
			});
			
			if(schema && object) {
				property = property.substring(
					schema.prefix.length+1, property.length);
				var triple = ERDF.registerTriple(
					new ERDF.Resource(subject),
					{prefix: schema.prefix, name: property},
					(objectType == ERDF.RESOURCE) ?
						new ERDF.Resource(object) :
						new ERDF.Literal(object));
						
				if(callback) callback(triple);
			}
		});
	},
	
	_parseTypeTriplesFrom: function(subjectType, subject, properties, callback) {
		
		if(!properties) return;
		properties.toLowerCase().split(' ').each( function(property) {
			
			//if(ERDF.log.isTraceEnabled())
			//	ERDF.log.trace("Going for property " + property);
				
			var schema = ERDF.schemas.find( function(schema) {
				return false || ERDF.DELIMITERS.find( function(delimiter) {
					return property.startsWith(ERDF.HYPHEN + schema.prefix + delimiter);
				});
			});
			
			if(schema && subject) {
				property = property.substring(schema.prefix.length+2, property.length);
				var triple = ERDF.registerTriple(
					(subjectType == ERDF.RESOURCE) ?
						new ERDF.Resource(subject) :
						new ERDF.Literal(subject),
					{prefix: 'rdf', name: 'type'},
					new ERDF.Resource(schema.namespace+property));
				if(callback) callback(triple);
			}
		});
	},
	
	/**
	 * Checks for ERDF profile declaration in head of document.
	 */
	_checkProfile: function() {

		// get profiles from head element.
		var heads = document.getElementsByTagNameNS(XMLNS.XHTML, 'head');
		var profiles = heads[0].getAttribute("profile");
		var found = false;

		// if erdf profile is contained.
		if(profiles && profiles.split(" ").member(XMLNS.ERDF)) {

			// pass check.
			//if(ERDF.log.isTraceEnabled())
			//	ERDF.log.trace("Found ERDF profile " + XMLNS.ERDF);
			return true;
			
		} else {
		
			// otherwise fail check.
			//if(ERDF.log.isFatalEnabled())
			//	ERDF.log.fatal("No ERDF profile found.");
			return false;
		}
	},
	
	__stripHashes: function(s) {
		return (s && s.substring(0, 1)=='#') ? s.substring(1, s.length) : s;
	},
	
	registerSchema: function(prefix, namespace) {
		
		// TODO check whether already registered, if so, complain.
		ERDF.schemas.push({
			prefix: prefix,
			namespace: namespace
		});
		
		//if(ERDF.log.isDebugEnabled())
		//	ERDF.log.debug("Prefix '"+prefix+"' for '"+namespace+"' registered.");
	},
	
	registerTriple: function(subject, predicate, object) {
		
		// if prefix is schema, this is a schema definition.
		if(predicate.prefix.toLowerCase() == 'schema')
			this.registerSchema(predicate.name, object.value);
			
		var triple = new ERDF.Triple(subject, predicate, object);
		ERDF.callback(triple);
		
		//if(ERDF.log.isInfoEnabled())
		//	ERDF.log.info(triple)
		
		// return the registered triple.
		return triple;
	},
	
	__enhanceObject: function() {
		
		/* Resource state querying methods */
		this.isResource = function() {
			return this.type == ERDF.RESOURCE };
		this.isLocal = function() {
			return this.isResource() && this.value.startsWith('#') };
		this.isCurrentDocument = function() {
			return this.isResource() && (this.value == '') };
		
		/* Resource getter methods.*/
		this.getId = function() {
			return this.isLocal() ? ERDF.__stripHashes(this.value) : false; };

		/* Liiteral state querying methods  */
		this.isLiteral = function() {
			return this.type == ERDF.LIITERAL };
	},
	
	serialize: function(literal) {
		
		if(!literal){
			return "";
		}else if(literal.constructor == String) {
			return literal;
		} else if(literal.constructor == Boolean) {
			return literal? 'true':'false';
		} else {
			return literal.toString();
		}
	}
};


ERDF.Triple = function(subject, predicate, object) {
	
	this.subject = subject;
	this.predicate = predicate;
	this.object = object;
	
	this.toString = function() {
		
		return "[ERDF.Triple] " +
			this.subject.toString() + ' ' +
			this.predicate.prefix + ':' + this.predicate.name + ' ' +
			this.object.toString();
		};
};

ERDF.Resource = function(uri) {
	
	this.type = ERDF.RESOURCE;
	this.value = uri;
	ERDF.__enhanceObject.apply(this);
	
	this.toString = function() {
		return '&lt;' + this.value + '&gt;';
	}
	
};

ERDF.Literal = function(literal) {
	
	this.type = ERDF.LITERAL;
	this.value = ERDF.serialize(literal);
	ERDF.__enhanceObject.apply(this);

	this.toString = function() {
		return '"' + this.value + '"';
	}
};/**
 * @author martin.czuchra
 */

/*
 * Save and triple generation behaviour. Use this area to configure
 * data management to your needs.
 */
var USE_ASYNCHRONOUS_REQUESTS =		true;
var DISCARD_UNUSED_TRIPLES =			true;
var PREFER_SPANS_OVER_DIVS =			true;
var PREFER_TITLE_OVER_TEXTNODE =		false;
var RESOURCE_ID_PREFIX =				'resource';

var SHOW_DEBUG_ALERTS_WHEN_SAVING =	false;
var SHOW_EXTENDED_DEBUG_INFORMATION =	false;

/*
 * Back end specific workarounds.
 */

var USE_ARESS_WORKAROUNDS =		true;

/*
 * Data management constants. Do not change these, as they are used
 * both internally and externally to communicate on events and to identify
 * command object actions in triple production and embedding rules.
 */

// Resource constants
var RESOURCE_CREATED =			0x01;
var RESOURCE_REMOVED =			0x02;
var RESOURCE_SAVED =				0x04;
var RESOURCE_RELOADED =			0x08;
var RESOURCE_SYNCHRONIZED = 		0x10;

// Triple constants
var TRIPLE_REMOVE =	0x01;
var TRIPLE_ADD =		0x02;
var TRIPLE_RELOAD =	0x04;
var TRIPLE_SAVE =		0x08;

var PROCESSDATA_REF = 'processdata';

// HTTP status code constants
//
//// 2xx
//const 200_OK =			'Ok';
//const 201_CREATED =		'Created';
//const 202_ACCEPTED =		'Accepted';
//const 204_NO_CONTENT =	'No Content';
//
//// 3xx
//const 301_MOVED_PERMANENTLY =	'Moved Permanently';
//const 302_MOVED_TEMPORARILY =	'Moved Temporarily';
//const 304_NOT_MODIFIED =		'Not Modified';
//
//// 4xx
//const 400_BAD_REQUEST =	'Bad Request';
//const 401_UNAUTHORIZED =	'Unauthorized';
//const 403_FORBIDDEN =		'Forbidden';
//const 404_NOT_FOUND =		'Not Found';
//const 409_CONFLICT =		'Conflict';
//
//// 5xx
//const 500_INTERNAL_SERVER_ERROR =		'Internal Server Error';
//const 501_NOT_IMPLEMENTED =			'Not Implemented';
//const 502_BAD_GATEWAY =				'Bad Gateway';
//const 503_SERVICE_UNAVAILABLE =		'Service Unavailable';
//
/**
 * The Data Management object. Use this one when interacting with page internal
 * data. Initialize data management by DataManager.init();
 * @class DataManager
 */
var DataManager = {
	
	/**
	 * The init method should be called once in the DataManagers lifetime.
	 * It causes the DataManager to initialize itself, the erdf parser, do all
	 * neccessary registrations and configurations, to run the parser and
	 * from then on deliver all resulting triples.
	 * No parameters needed are needed in a call to this method.
	 */
	init: function() {
		ERDF.init(DataManager._registerTriple);
		DataManager.__synclocal();
	},
	
	/**
	 * This triple array is meant to be the whole knowledge of the DataManager.
	 */
	_triples: [],
	
	/**
	 * This method is meant for callback from erdf parsing. It is not to be
	 * used in another way than to add triples to the triple store.
	 * @param {Object} triple the triple to add to the triple store.
	 */
	_registerTriple: function(triple) {
		DataManager._triples.push(triple)
	},
	
	/**
	 * The __synclocal method is for internal usage only.
	 * It performs synchronization with the local document, that is, the triple
	 * store is adjustet to the content of the document, which could have been
	 * changed by any other applications running on the same page.
	 */
	__synclocal: function() {
		DataManager._triples = [];
		ERDF.run();
	},
	
	/**
	 * Makes the shape passed into this method synchronize itself with the DOM.
	 * This method returns the shapes resource object for further manipulation.
	 * @param {Object} shape
	 */
	__synchronizeShape: function(shape) {

		var r = ResourceManager.getResource(shape.resourceId);
		var serialize = shape.serialize();

		// store all serialize values
		serialize.each( function(ser) {
			
			var resource = (ser.type == 'resource');
			var _triple = new ERDF.Triple(
				new ERDF.Resource(shape.resourceId),
				{prefix: ser.prefix, name: ser.name},
				resource ?
					new ERDF.Resource(ser.value) :
					new ERDF.Literal(ser.value)
			);
			DataManager.setObject(_triple);
		});
		
		return r;
	},

	__storeShape: function(shape) {
		
		// first synchronize the shape,
		var resource = DataManager.__synchronizeShape(shape);
		
		// then save the synchronized dom.
		resource.save();
	},
		
	__forceExistance: function(shape) {
		
		if(!$(shape.resourceId)) {
			
			if(!$$('.' + PROCESSDATA_REF)[0])
				DataManager.graft(XMLNS.XHTML,
					document.getElementsByTagNameNS(XMLNS.XHTML, 'body').item(0), ['div', {'class': PROCESSDATA_REF, 'style':'display:none;'}]);
				
			// object is literal
			DataManager.graft(XMLNS.XHTML,
				$$('.' + PROCESSDATA_REF)[0], [
				
				'div', {
                    'id': shape.resourceId,
                    //This should be done in a more dynamic way!!!!!
                    'class': (shape instanceof ORYX.Core.Canvas) ? "-oryx-canvas" : undefined
                }
			]);
			
		} else {
			var resource = $(shape.resourceId)
			var children = $A(resource.childNodes)
			children.each( function(child) {
				resource.removeChild(child);
			});
		};
	},
	
	__persistShape: function(shape) {

		// a shape serialization.
		var shapeData = shape.serialize();
		
		// initialize a triple array and construct a shape resource
		// to be used in triple generation.
		var triplesArray = [];
		var shapeResource = new ERDF.Resource(shape.resourceId);

		// remove all triples for this particular shape's resource
		DataManager.removeTriples( DataManager.query(
			shapeResource, undefined, undefined));

		// for each data set in the shape's serialization
		shapeData.each( function(data) {

			// construct a triple's value
			var value = (data.type == 'resource') ?
				new ERDF.Resource(data.value) :
				new ERDF.Literal(data.value);

			// construct triple and add it to the DOM.
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: data.prefix, name: data.name},
				value
			));
		});
	},
	
	__persistDOM: function(facade) {

		// getChildShapes gets all shapes (nodes AND edges), deep flag
		// makes it return a flattened child hierarchy.
		
		var canvas = facade.getCanvas();
		var shapes = canvas.getChildShapes(true);
		var result = '';
		
		// persist all shapes.
		shapes.each( function(shape) {
			DataManager.__forceExistance(shape);
		});
		//DataManager.__synclocal();
		
		DataManager.__renderCanvas(facade);
		result += DataManager.serialize(
				$(ERDF.__stripHashes(facade.getCanvas().resourceId)), true);
				
		shapes.each( function(shape) {
			
			DataManager.__persistShape(shape);
			result += DataManager.serialize(
				$(ERDF.__stripHashes(shape.resourceId)), true);
		});
		
		//result += DataManager.__renderCanvas(facade);
		
		return result;
	},

	__renderCanvas: function(facade) {

		var canvas = facade.getCanvas();
		var stencilSets = facade.getStencilSets();
		var shapes = canvas.getChildShapes(true);
		
		DataManager.__forceExistance(canvas);
		
		DataManager.__persistShape(canvas);
		
		var shapeResource = new ERDF.Resource(canvas.resourceId);

		// remove all triples for this particular shape's resource
		DataManager.removeTriples( DataManager.query(
			shapeResource, undefined, undefined));

		DataManager.addTriple( new ERDF.Triple(
			shapeResource,
			{prefix: "oryx", name: "mode"},
			new ERDF.Literal("writable")
		));

		DataManager.addTriple( new ERDF.Triple(
			shapeResource,
			{prefix: "oryx", name: "mode"},
			new ERDF.Literal("fullscreen")
		));

		stencilSets.values().each(function(stencilset) {
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: "oryx", name: "stencilset"},
				new ERDF.Resource(stencilset.source().replace(/&/g, "%26"))
			));
			
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: "oryx", name: "ssnamespace"},
				new ERDF.Resource(stencilset.namespace())
			));
			
			stencilset.extensions().keys().each(function(extension) {
				DataManager.addTriple( new ERDF.Triple(
					shapeResource,
					{prefix: "oryx", name: "ssextension"},
					new ERDF.Literal(extension)
				));
			});
		});
						
		shapes.each(function(shape) {
			DataManager.addTriple( new ERDF.Triple(
				shapeResource,
				{prefix: "oryx", name: "render"},
				new ERDF.Resource("#" + shape.resourceId)
			));
		});
	},

	__counter: 0,
	__provideId: function() {
		
		while($(RESOURCE_ID_PREFIX+DataManager.__counter))
			DataManager.__counter++;
			
		return RESOURCE_ID_PREFIX+DataManager.__counter;
	},
		
	serializeDOM: function(facade) {
		
		return DataManager.__persistDOM(facade);
	},
	
	syncGlobal: function(facade) {
		
		return DataManager.__syncglobal(facade);
	},
	
	/**
	 * This method is used to synchronize local DOM with remote resources.
	 * Local changes are commited to the server, and remote changes are
	 * performed to the local document.
	 * @param {Object} facade The facade of the editor that holds certain
	 * resource representations as shapes.
	 */
	__syncglobal: function(facade) {

		// getChildShapes gets all shapes (nodes AND edges), deep flag
		// makes it return a flattened child hierarchy.
		
		var canvas = facade.getCanvas();
		var shapes = canvas.getChildShapes(true);

		// create dummy resource representations in the dom
		// for all shapes that were newly created.

		shapes.select( function(shape) {

			// select shapes without resource id.

			return !($(shape.resourceId));

		}).each( function(shape) {

			// create new resources for them.
			if(USE_ARESS_WORKAROUNDS) {
				
				/*
				 * This is a workaround due to a bug in aress. Resources are
				 * ignoring changes to raziel:type property once they are
				 * created. As long as this is not fixed, the resource is now
				 * being created using a randomly guessed id, this temporary id
				 * is then used in references and the appropriate div is being
				 * populated with properties.
				 * 
				 * AFTER THIS PHASE THE DATA IS INCONSISTENT AS REFERENCES POINT
				 * TO IDS THAT ARE UNKNOWN TO THE BACK END.
				 * 
				 * After the resource is actually created in aress, it gets an id
				 * that is persistent. All shapes are then being populated with the
				 * correct id references and stored on the server.
				 * 
				 * AFTER THE SAVE PROCESS HAS RETURNED, THE DATA IS CONSISTENT
				 * REGARDING THE ID REFERENCES AGAIN.
				 */
				
				var razielType = shape.properties['raziel-type'];
				
				var div = '<div xmlns="http://www.w3.org/1999/xhtml">' +
					'<span class="raziel-type">'+razielType+'</span></div>';

				var r = ResourceManager.__createResource(div);
				shape.resourceId = r.id();
				
			} else {
		
				var r = ResourceManager.__createResource();
				shape.resourceId = r.id();
			}

		});

		shapes.each( function(shape) {
			
			// store all shapes.
			DataManager.__storeShape(shape);
		});
	},
	
	/**
	 * This method serializes a single div into a string that satisfies the
	 * client/server communication protocol. It ingnores all elements that have
	 * an attribute named class that includes 'transient'.
	 * @param {Object} node the element to serialize.
	 * @param {Object} preserveNamespace whether to preserve the parent's
	 *                 namespace. If you are not sure about namespaces, provide
	 *                 just the element to be serialized.
	 */
	serialize: function(node, preserveNamespace) {

		if (node.nodeType == node.ELEMENT_NODE) {
			// serialize an element node.
			
			var children = $A(node.childNodes);
			var attributes = $A(node.attributes);
			var clazz = new String(node.getAttribute('class'));
			var ignore = clazz.split(' ').member('transient');

			// ignore transients.

			if(ignore)
				return '';

			// start serialization.
			
			var result = '<' + node.nodeName;
			
			// preserve namespace?
			if(!preserveNamespace) 
				result += ' xmlns="' + (node.namespaceURI ? node.namespaceURI : XMLNS.XHTML) + '" xmlns:oryx="http://oryx-editor.org"';
			
			// add all attributes.
			
			attributes.each(function(attribute) {
				result += ' ' + attribute.nodeName + '="' +
					attribute.nodeValue + '"';});
			
			// close if no children.
			
			if(children.length == 0)
				result += '/>';
				
			else {
				
				// serialize all children.
				
				result += '>';
				children.each(function(_node) {
					result += DataManager.serialize(_node, true)});
				result += '</' + node.nodeName + '>'
			}

			return result;
			
		} else if (node.nodeType == node.TEXT_NODE) {
			
			// serialize a text node.
			return  node.nodeValue;
		}
		
		//TODO serialize cdata areas also.
		//TODO work on namespace awareness.
	},

	addTriple: function(triple) {

		// assert the subject is a resource
		
		if(!triple.subject.type == ERDF.LITERAL)
			throw 'Cannot add the triple ' + triple.toString() +
				' because the subject is not a resource.'
		
		// get the element which represents this triple's subject.
		var elementId = ERDF.__stripHashes(triple.subject.value);
		var element = $(elementId);
				
		// assert the subject is inside this document.
		if(!element)
			throw 'Cannot add the triple ' + triple.toString() +
				' because the subject "'+elementId+'" is not in the document.';

		if(triple.object.type == ERDF.LITERAL)

			// object is literal
			DataManager.graft(XMLNS.XHTML, element, [
				'span', {'class': (triple.predicate.prefix + "-" +
					triple.predicate.name)}, triple.object.value.escapeHTML()
			]);
			
		else {

			// object is resource
			DataManager.graft(XMLNS.XHTML, element, [
				'a', {'rel': (triple.predicate.prefix + "-" +
					triple.predicate.name), 'href': triple.object.value}
			]);
			
		}

		return true;
	},
	
	removeTriples: function(triples) {

		// alert('Removing ' +triples.length+' triples.');

		// from all the triples select those ...
		var removed = triples.select(

			function(triple) {
				
				// TODO remove also from triple store.
				// ... that were actually removed.
				return DataManager.__removeTriple(triple);
			});
		
		// sync and return removed triples.
		// DataManager.__synclocal();
		return removed;
	},
	
	removeTriple: function(triple) {
		
		// remember whether the triple was actually removed.
		var result = DataManager.__removeTriple(triple);

		// sync and return removed triples.
		// DataManager.__synclocal();
		return result;
	},

	__removeTriple: function(triple) {
		
		// assert the subject is a resource
		if(!triple.subject.type == ERDF.LITERAL)
		
			throw 'Cannot remove the triple ' + triple.toString() +
				' because the subject is not a resource.';

		// get the element which represents this triple's subject.
		var elementId = ERDF.__stripHashes(triple.subject.value);
		var element = $(elementId);

		// assert the subject is inside this document.
		if(!element)
		
			throw 'Cannot remove the triple ' + triple.toString() +
				' because the subject is not in the document.';
	  
		if(triple.object.type == ERDF.LITERAL) {
	  
  			// continue searching actively for the triple.
			var result = DataManager.__removeTripleRecursively(triple, element);
			return result;
		}
	},

	__removeTripleRecursively: function(triple, continueFrom) {  

		// return when this node is not an element node.
		if(continueFrom.nodeType != continueFrom.ELEMENT_NODE)
			return false;
		
		var classes = new String(continueFrom.getAttribute('class'));
		var children = $A(continueFrom.childNodes);
		
		if(classes.include(triple.predicate.prefix + '-' + triple.predicate.name)) {
		  
			var content = continueFrom.textContent;
			if(	(triple.object.type == ERDF.LITERAL) &&
				(triple.object.value == content))

				continueFrom.parentNode.removeChild(continueFrom);
			
			return true;
		  
		} else {
		 
			children.each(function(_node) {
			DataManager.__removeTripleRecursively(triple, _node)});
			return false;
		}

	},

	/**
	 * graft() function
	 * Originally by Sean M. Burke from interglacial.com, altered for usage with
	 * SVG and namespace (xmlns) support. Be sure you understand xmlns before
	 * using this funtion, as it creates all grafted elements in the xmlns
	 * provided by you and all element's attribures in default xmlns. If you
	 * need to graft elements in a certain xmlns and wish to assign attributes
	 * in both that and another xmlns, you will need to do stepwise grafting,
	 * adding non-default attributes yourself or you'll have to enhance this
	 * function. Latter, I would appreciate: martin�apfelfabrik.de
	 * @param {Object} namespace The namespace in which
	 * 					elements should be grafted.
	 * @param {Object} parent The element that should contain the grafted
	 * 					structure after the function returned.
	 * @param {Object} t the crafting structure.
	 * @param {Object} doc the document in which grafting is performed.
	 */
	graft: function(namespace, parent, t, doc) {
		
	    doc = (doc || (parent && parent.ownerDocument) || document);
	    var e;
	    if(t === undefined) {
	        echo( "Can't graft an undefined value");
	    } else if(t.constructor == String) {
	        e = doc.createTextNode( t );
	    } else {
	        for(var i = 0; i < t.length; i++) {
	            if( i === 0 && t[i].constructor == String ) {
					var snared = t[i].match( /^([a-z][a-z0-9]*)\.([^\s\.]+)$/i );
	                if( snared ) {
	                    e = doc.createElementNS(namespace, snared[1]);
	                    e.setAttributeNS(null, 'class', snared[2] );
	                    continue;
	                }
	                snared = t[i].match( /^([a-z][a-z0-9]*)$/i );
	                if( snared ) {
	                    e = doc.createElementNS(namespace, snared[1]);  // but no class
	                    continue;
	                }
	
	                // Otherwise:
	                e = doc.createElementNS(namespace, "span");
	                e.setAttribute(null, "class", "namelessFromLOL" );
	            }
	
	            if( t[i] === undefined ) {
	                echo("Can't graft an undefined value in a list!");
	            } else if( t[i].constructor == String || t[i].constructor == Array) {
	                this.graft(namespace, e, t[i], doc );
	            } else if(  t[i].constructor == Number ) {
	                this.graft(namespace, e, t[i].toString(), doc );
	            } else if(  t[i].constructor == Object ) {
	                // hash's properties => element's attributes
	                for(var k in t[i]) { e.setAttributeNS(null, k, t[i][k] ); }
	            } else if(  t[i].constructor == Boolean ) {
	                this.graft(namespace, e, t[i] ? 'true' : 'false', doc );
				} else
					throw "Object " + t[i] + " is inscrutable as an graft arglet.";
	        }
	    }
		
		if(parent) parent.appendChild(e);
	
	    return Element.extend(e); // return the topmost created node
	},

	setObject: function(triple) {

		/**
		 * Erwartungen von Arvid an diese Funktion:
		 * - Es existiert genau ein triple mit dem Subjekt und Praedikat,
		 *   das uebergeben wurde, und dieses haelt uebergebenes Objekt.
		 */

		var triples = DataManager.query(
			triple.subject,
			triple.predicate,
			undefined
		);
		
		DataManager.removeTriples(triples);

		DataManager.addTriple(triple);

		return true;
	},
	
	query: function(subject, predicate, object) {

		/*
		 * Typical triple.
		 *	{value: subject, type: subjectType},
		 *	{prefix: schema.prefix, name: property},
		 *	{value: object, type: objectType});
		 */	
		 	
		return DataManager._triples.select(function(triple) {
			
			var select = ((subject) ?
				(triple.subject.type == subject.type) &&
				(triple.subject.value == subject.value) : true);
			if(predicate) {
				select = select && ((predicate.prefix) ?
					(triple.predicate.prefix == predicate.prefix) : true);
				select = select && ((predicate.name) ?
					(triple.predicate.name == predicate.name) : true);
			}
			select = select && ((object) ?
				(triple.object.type == object.type) &&
				(triple.object.value == object.value) : true);
			return select;
		});
	}
}

Kickstart.register(DataManager.init);

function assert(expr, m) { if(!expr) throw m; };

function DMCommand(action, triple) {
	
	// store action and triple.
	this.action = action;
	this.triple = triple;
	
	this.toString = function() {
		return 'Command('+action+', '+triple+')';
	};
}

function DMCommandHandler(nextHandler) {
	
	/**
	 * Private method to set the next handler in the Chain of Responsibility
	 * (see http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern for
	 * details).
	 * @param {DMCommandHandler} handler The handler that is next in the chain.
	 */
	this.__setNext = function(handler) {
		var _next = this.__next;
		this.__next = nextHandler;
		return _next ? _next : true;
	};
	this.__setNext(nextHandler);

	/**
	 * Invokes the next handler. If there is no next handler, this method
	 * returns false, otherwise it forwards the result of the handling.
	 * @param {Object} command The command object to be processed.
	 */
	this.__invokeNext = function(command) {
		return this.__next ? this.__next.handle(command) : false;
	};
	
	/**
	 * Handles a command. The abstract method process() is called with the
	 * command object that has been passed. If the process method catches the
	 * command (returns true on completion), the handle() method returns true.
	 * If the process() method doesn't catch the command, the next handler will
	 * be invoked.
	 * @param {Object} command The command object to be processed.
	 */
	this.handle = function(command) {
		return this.process(command) ? true : this.__invokeNext(command);
	}
	
	/**
	 * Empty process() method returning false. If javascript knew abstract
	 * class members, this would be one.
	 * @param {Object} command The command object to process.
	 */
	this.process = function(command) { return false; };
};

/**
 * This Handler manages the addition and the removal of meta elements in the
 * head of the document.
 * @param {DMCommandHandler} next The handler that is next in the chain.
 */
function MetaTagHandler(next) {
	
	DMCommandHandler.apply(this, [next]);
	this.process = function(command) {
		
		with(command.triple) {
			
			/* assert prerequisites */
			if( !(
				(subject instanceof ERDF.Resource) &&
				(subject.isCurrentDocument()) &&
				(object instanceof ERDF.Literal)
			))	return false;
		}
		
	};
};

var chain =	new MetaTagHandler();
var command = new DMCommand(TRIPLE_ADD, new ERDF.Triple(
	new ERDF.Resource(''),
	'rdf:tool',
	new ERDF.Literal('')
));

/*
if(chain.handle(command))
	alert('Handled!');
*/

ResourceManager = {
	
	__corrupt: false,
	__latelyCreatedResource: undefined,
	__listeners: $H(),
	__token: 1,
	
	addListener: function(listener, mask) {

		if(!(listener instanceof Function))
			throw 'Resource event listener is not a function!';
		if(!(mask))
			throw 'Invalid mask for resource event listener registration.';

		// construct controller and token.
		var controller = {listener: listener, mask: mask};
		var token = ResourceManager.__token++;
		
		// add new listener.
		ResourceManager.__listeners[token] = controller;
		
		// return the token generated.
		return token;
	},
	
	removeListener: function(token) {
		
		// remove the listener with the token and return it.
		return ResourceManager.__listners.remove(token);
	},
	
	__Event: function(action, resourceId) {
		this.action = action;
		this.resourceId = resourceId;
	},
	
	__dispatchEvent: function(event) {
		
		// get all listeners. for each listener, ...
		ResourceManager.__listeners.values().each(function(controller) {
			
			// .. if listener subscribed to this type of event ...
			if(event.action & controller.mask)
				return controller.listener(event);
		});
	},

	getResource: function(id) {

		// get all possible resources for this.
		id = ERDF.__stripHashes(id);
		var resources = DataManager.query(
			new ERDF.Resource('#'+id),
			{prefix: 'raziel', name: 'entry'},
			undefined
		);

		// check for consistency.
		if((resources.length == 1) && (resources[0].object.isResource())) {
			var entryUrl = resources[0].object.value;
			return new ResourceManager.__Resource(id, entryUrl);
		}

		// else throw an error message.
		throw ('Resource with id ' +id+ ' not recognized as such. ' +
			((resources.length > 1) ?
				' There is more than one raziel:entry URL.' :
				' There is no raziel:entry URL.'));

		return false;
	},

	__createResource: function(alternativeDiv) {
		
		var collectionUrls = DataManager.query(
			new ERDF.Resource(''),
			// TODO This will become raziel:collection in near future.
			{prefix: 'raziel', name: 'collection'},
			undefined
		);

		// check for consistency.
		
		if(	(collectionUrls.length == 1) &&
			(collectionUrls[0].object.isResource())) {

			// get the collection url.
			
			var collectionUrl = collectionUrls[0].object.value;
			var resource = undefined;
			
			// if there is an old id, serialize the dummy div from there,
			// otherwise create a dummy div on the fly.
			
			var serialization = alternativeDiv? alternativeDiv : 
					'<div xmlns="http://www.w3.org/1999/xhtml"></div>';
					
			ResourceManager.__request(
				'POST', collectionUrl, serialization,

				// on success
				function() {
					
					// get div and id that have been generated by the server.
					
					var response = (this.responseXML);
					var div = response.childNodes[0];
					var id = div.getAttribute('id');
					
					// store div in DOM
					if(!$$('.' + PROCESSDATA_REF)[0])
						DataManager.graft(XMLNS.XHTML,
							document.getElementsByTagNameNS(XMLNS.XHTML, 'body').item(0), ['div', {'class': PROCESSDATA_REF, 'style':'display:none;'}]);
				
					$$('.' + PROCESSDATA_REF)[0].appendChild(div.cloneNode(true));

					// parse local erdf data once more.
					
					DataManager.__synclocal();
					
					// get new resource object.

					resource = new ResourceManager.getResource(id);

					// set up an action informing of the creation.
					
					ResourceManager.__resourceActionSucceeded(
						this, RESOURCE_CREATED, undefined);
				},

				function() { ResourceManager.__resourceActionFailed(
					this, RESOURCE_CREATED, undefined);},
				false
			);
			
			return resource;
		}
		
		// else
		throw 'Could not create resource! raziel:collection URL is missing!';
		return false;

	},
	
	__Resource: function(id, url) {
		
		this.__id = id;
		this.__url = url;
		
		/*
		 * Process URL is no longer needed to refer to the shape element on the
		 * canvas. AReSS uses the id's to gather information on fireing
		 * behaviour now.
		 */
		
//		// find the process url.		
//		var processUrl = undefined;
//		
//		var urls = DataManager.query(
//			new ERDF.Resource('#'+this.__id),
//			{prefix: 'raziel', name: 'process'},
//			undefined
//		);
//		
//		if(urls.length == 0) { throw 'The resource with the id ' +id+ ' has no process url.'};
//		
//		urls.each( function(triple) {
//			
//			// if there are more urls, use the last one.
//			processUrl = triple.object.value;
//		});
//		
//		this.__processUrl = processUrl;
//
//		// convenience function for getting the process url.
//		this.processUrl = function() {
//			return this.__processUrl;
//		}


		// convenience finction for getting the id.
		this.id = function() {
			return this.__id;
		}

		// convenience finction for getting the entry url.
		this.url = function() {
			return this.__url;
		}
		
		this.reload = function() {
			var _url = this.__url;
			var _id = this.__id;
			ResourceManager.__request(
				'GET', _url, null,
				function() { ResourceManager.__resourceActionSucceeded(
					this, RESOURCE_RELOADED, _id); },
				function() { ResourceManager.__resourceActionFailed(
					this, RESURCE_RELOADED, _id); },
				USE_ASYNCHRONOUS_REQUESTS
			);
		};
		
		this.save = function(synchronize) {
			var _url = this.__url;
			var _id = this.__id;
			data = DataManager.serialize($(_id));
			ResourceManager.__request(
				'PUT', _url, data,
				function() { ResourceManager.__resourceActionSucceeded(
					this, synchronize ? RESOURCE_SAVED | RESOURCE_SYNCHRONIZED : RESOURCE_SAVED, _id); },
				function() { ResourceManager.__resourceActionFailed(
					this, synchronize ? RESOURCE_SAVED | RESOURCE_SYNCHRONIZED : RESOURCE.SAVED, _id); },
				USE_ASYNCHRONOUS_REQUESTS
			);
		};
		
		this.remove = function() {
			var _url = this.__url;
			var _id = this.__id;
			ResourceManager.__request(
				'DELETE', _url, null,
				function() { ResourceManager.__resourceActionSucceeded(
					this, RESOURCE_REMOVED, _id); },
				function() { ResourceManager.__resourceActionFailed(
					this, RESOURCE_REMOVED, _id);},
				USE_ASYNCHRONOUS_REQUESTS
			);
		};
	},

	request: function(url, requestOptions) {

		var options = {
			method:       'get',
			asynchronous: true,
			parameters:   {}
		};

		Object.extend(options, requestOptions || {});
 		
		var params = Hash.toQueryString(options.parameters);
		if (params) 
			url += (url.include('?') ? '&' : '?') + params;
   
		return ResourceManager.__request(
			options.method, 
			url, 
			options.data, 
			(options.onSuccess instanceof Function ? function() { options.onSuccess(this); } : undefined ), 
			(options.onFailure instanceof Function ? function() { options.onFailure(this); } : undefined ), 
			options.asynchronous && USE_ASYNCHRONOUS_REQUESTS,
			options.headers);
	},
	
	__request: function(method, url, data, success, error, async, headers) {
		
		// get a request object
		var httpRequest = Try.these(

			/* do the Mozilla/Safari/Opera stuff */
			function() { return new XMLHttpRequest(); },
			
			/* do the IE stuff */
			function() { return new ActiveXObject("Msxml2.XMLHTTP"); },
			function() { return new ActiveXObject("Microsoft.XMLHTTP") }
		);

		// if there is no request object ...
        if (!httpRequest) {
			if(!this.__corrupt)
				throw 'This browser does not provide any AJAX functionality. You will not be able to use the software provided with the page you are viewing. Please consider installing appropriate extensions.';
			this.__corrupt = true;
			return false;
        }
		
		if(success instanceof Function)
			httpRequest.onload = success;
		if(error instanceof Function) {
			httpRequest.onerror = error;
		}
		
		var h = $H(headers)
		h.keys().each(function(key) {
			
			httpRequest.setRequestHeader(key, h[key]);
		}); 
		
		try {

			if(SHOW_DEBUG_ALERTS_WHEN_SAVING)
			
				alert(method + ' ' + url + '\n' +
					SHOW_EXTENDED_DEBUG_INFORMATION ? data : '');

			// TODO Remove synchronous calls to the server as soon as xenodot
			// handles asynchronous requests without failure.
	        httpRequest.open(method, url, !async?false:true);
	        httpRequest.send(data);
			
		} catch(e) {
			return false;
		}
		return true;
    },

	__resourceActionSucceeded: function(transport, action, id) {
		
		var status = transport.status;
		var response = transport.responseText;
		
		if(SHOW_DEBUG_ALERTS_WHEN_SAVING)

			alert(status + ' ' + url + '\n' +
				SHOW_EXTENDED_DEBUG_INFORMATION ? data : '');

		// if the status code is not in 2xx, throw an error.
		if(status >= 300)
			throw 'The server responded with an error: ' + status + '\n' + (SHOW_EXTENDED_DEBUG_INFORMATION ? + data : 'If you need additional information here, including the data sent by the server, consider setting SHOW_EXTENDED_DEBUG_INFORMATION to true.');

		switch(action) {
			
			case RESOURCE_REMOVED:

				// get div and id
				var response = (transport.responseXML);
				var div = response.childNodes[0];
				var id = div.getAttribute('id');
				
				// remove the resource from DOM
				var localDiv = document.getElementById(id);
				localDiv.parentNode.removeChild(localDiv);
				break;

			case RESOURCE_CREATED:

				// nothing remains to be done.
				break;
	
			case RESOURCE_SAVED | RESOURCE_SYNCHRONIZED:

				DataManager.__synclocal();

			case RESOURCE_SAVED:

				// nothing remains to be done.
				break;

			case RESOURCE_RELOADED:
			
				// get div and id
				var response = (transport.responseXML);
				var div = response.childNodes[0];
				var id = div.getAttribute('id');
				
				// remove the local resource representation from DOM
				var localDiv = document.getElementById(id)
				localDiv.parentNode.removeChild(localDiv);
				
				// store div in DOM
				if(!$$(PROCESSDATA_REF)[0])
					DataManager.graft(XMLNS.XHTML,
						document.getElementsByTagNameNS(XMLNS.XHTML, 'body').item(0), ['div', {'class': PROCESSDATA_REF, 'style':'display:none;'}]);
				
				$$(PROCESSDATA_REF)[0].appendChild(div.cloneNode(true));
				DataManager.__synclocal();
				break;

			default:
				DataManager.__synclocal();

		}
		 
		// dispatch to all listeners ...
		ResourceManager.__dispatchEvent(

			// ... an event describing the change that happened here.
			new ResourceManager.__Event(action, id)
		);
	},

	__resourceActionFailed: function(transport, action, id) {
		throw "Fatal: Resource action failed. There is something horribly " +
			"wrong with either the server, the transport protocol or your " +
			"online status. Sure you're online?";
	}
}/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * The super class for all classes in ORYX. Adds some OOP feeling to javascript.
 * See article "Object Oriented Super Class Method Calling with JavaScript" on
 * http://truecode.blogspot.com/2006/08/object-oriented-super-class-method.html
 * for a documentation on this. Fairly good article that points out errors in
 * Douglas Crockford's inheritance and super method calling approach.
 * Worth reading.
 * @class Clazz
 */
var Clazz = function() {};

/**
 * Empty constructor.
 * @methodOf Clazz.prototype
 */
Clazz.prototype.construct = function() {};

/**
 * Can be used to build up inheritances of classes.
 * @example
 * var MyClass = Clazz.extend({
 *   construct: function(myParam){
 *     // Do sth.
 *   }
 * });
 * var MySubClass = MyClass.extend({
 *   construct: function(myParam){
 *     // Use this to call constructor of super class
 *     arguments.callee.$.construct.apply(this, arguments);
 *     // Do sth.
 *   }
 * });
 * @param {Object} def The definition of the new class.
 */
Clazz.extend = function(def) {
    var classDef = function() {
        if (arguments[0] !== Clazz) { this.construct.apply(this, arguments); }
    };
    
    var proto = new this(Clazz);
    var superClass = this.prototype;
    
    for (var n in def) {
        var item = def[n];                        
        if (item instanceof Function) item.$ = superClass;
        proto[n] = item;
    }

    classDef.prototype = proto;
    
    //Give this new class the same static extend method    
    classDef.extend = this.extend;        
    return classDef;
};/**
 * @author martin.czuchra
 */
if(!ORYX) var ORYX = {};

if(!ORYX.CONFIG) ORYX.CONFIG = {};

//This is usually the name of the war file!
ORYX.CONFIG.ROOT_PATH =					"/oryx/";
ORYX.CONFIG.WEB_URL = "http://oryx-project.org";
	
ORYX.CONFIG.VERSION_URL =				ORYX.CONFIG.ROOT_PATH + "VERSION";
ORYX.CONFIG.LICENSE_URL =				ORYX.CONFIG.ROOT_PATH + "LICENSE";

ORYX.CONFIG.SERVER_HANDLER_ROOT = 		"";

ORYX.CONFIG.STENCILSET_HANDLER = 		ORYX.CONFIG.SERVER_HANDLER_ROOT + "";
    
	/* Editor-Mode */
ORYX.CONFIG.MODE_READONLY =				"readonly";
ORYX.CONFIG.MODE_FULLSCREEN =			"fullscreen";
	
		
	/* Show grid line while dragging */
ORYX.CONFIG.SHOW_GRIDLINE = true;
ORYX.CONFIG.DISABLE_GRADIENT = true;

	/* Plugins */
ORYX.CONFIG.PLUGINS_ENABLED =			true;
ORYX.CONFIG.PLUGINS_CONFIG =			ORYX.CONFIG.ROOT_PATH + "plugins.xml";
ORYX.CONFIG.PROFILE_PATH =				ORYX.CONFIG.ROOT_PATH + "profiles/";
ORYX.CONFIG.PLUGINS_FOLDER =			"Plugins/";
ORYX.CONFIG.PDF_EXPORT_URL =			ORYX.CONFIG.ROOT_PATH + "pdf";
ORYX.CONFIG.PNML_EXPORT_URL =			ORYX.CONFIG.ROOT_PATH + "pnml";
ORYX.CONFIG.SIMPLE_PNML_EXPORT_URL =	ORYX.CONFIG.ROOT_PATH + "simplepnmlexporter";
ORYX.CONFIG.DESYNCHRONIZABILITY_URL =	ORYX.CONFIG.ROOT_PATH + "desynchronizability";
ORYX.CONFIG.IBPMN2BPMN_URL =			ORYX.CONFIG.ROOT_PATH + "ibpmn2bpmn";
ORYX.CONFIG.BPMN2YAWL_URL =				ORYX.CONFIG.ROOT_PATH + "bpmn2yawl";
ORYX.CONFIG.QUERYEVAL_URL =             ORYX.CONFIG.ROOT_PATH + "query";
ORYX.CONFIG.QUERYVARIANTEVAL_URL =      ORYX.CONFIG.ROOT_PATH + "queryvarianteval";
ORYX.CONFIG.SYNTAXCHECKER_URL =			ORYX.CONFIG.ROOT_PATH + "syntaxchecker";
ORYX.CONFIG.VALIDATOR_URL =				ORYX.CONFIG.ROOT_PATH + "validator";
ORYX.CONFIG.AUTO_LAYOUTER_URL =			ORYX.CONFIG.ROOT_PATH + "layouter";
ORYX.CONFIG.SS_EXTENSIONS_FOLDER =		ORYX.CONFIG.ROOT_PATH + "stencilsets/extensions/";
ORYX.CONFIG.SS_EXTENSIONS_CONFIG =		ORYX.CONFIG.ROOT_PATH + "stencilsets/extensions/extensions.json";	
ORYX.CONFIG.ORYX_NEW_URL =				"/new";	
ORYX.CONFIG.STEP_THROUGH =				ORYX.CONFIG.ROOT_PATH + "stepthrough";
ORYX.CONFIG.STEP_THROUGH_CHECKER =		ORYX.CONFIG.ROOT_PATH + "stepthroughchecker";
ORYX.CONFIG.XFORMS_EXPORT_URL =			ORYX.CONFIG.ROOT_PATH + "xformsexport";
ORYX.CONFIG.XFORMS_EXPORT_ORBEON_URL =	ORYX.CONFIG.ROOT_PATH + "xformsexport-orbeon";
ORYX.CONFIG.XFORMS_IMPORT_URL =			ORYX.CONFIG.ROOT_PATH + "xformsimport";
ORYX.CONFIG.BPEL_EXPORT_URL =			ORYX.CONFIG.ROOT_PATH + "bpelexporter";
ORYX.CONFIG.BPEL4CHOR_EXPORT_URL =		ORYX.CONFIG.ROOT_PATH + "bpel4chorexporter";
ORYX.CONFIG.BPEL4CHOR2BPEL_EXPORT_URL =	ORYX.CONFIG.ROOT_PATH + "bpel4chor2bpelexporter";
ORYX.CONFIG.TREEGRAPH_SUPPORT =			ORYX.CONFIG.ROOT_PATH + "treegraphsupport";
ORYX.CONFIG.XPDL4CHOR2BPEL4CHOR_TRANSFORMATION_URL = ORYX.CONFIG.ROOT_PATH + "xpdl4chor2bpel4chor";
ORYX.CONFIG.RESOURCE_LIST =				ORYX.CONFIG.ROOT_PATH + "resourceList";
ORYX.CONFIG.BPMN_LAYOUTER =				ORYX.CONFIG.ROOT_PATH + "bpmnlayouter";
ORYX.CONFIG.EPC_LAYOUTER =				ORYX.CONFIG.ROOT_PATH + "epclayouter";
ORYX.CONFIG.BPMN2MIGRATION =			ORYX.CONFIG.ROOT_PATH + "bpmn2migration";
ORYX.CONFIG.BPMN20_SCHEMA_VALIDATION_ON = true;
//Backend plugin for the fragmentRepository client plugin.
ORYX.CONFIG.BPMN20_COMPLIANCE_TEMPLATE_SAT_SOLVER = ORYX.CONFIG.ROOT_PATH + "satSolver";
ORYX.CONFIG.JPDLIMPORTURL =				ORYX.CONFIG.ROOT_PATH + "jpdlimporter";
ORYX.CONFIG.JPDLEXPORTURL =				ORYX.CONFIG.ROOT_PATH + "jpdlexporter";
ORYX.CONFIG.CPNTOOLSEXPORTER = 			ORYX.CONFIG.ROOT_PATH + "cpntoolsexporter";
ORYX.CONFIG.CPNTOOLSIMPORTER = 			ORYX.CONFIG.ROOT_PATH + "cpntoolsimporter";
ORYX.CONFIG.BPMN2XPDLPATH =				ORYX.CONFIG.ROOT_PATH + "bpmn2xpdl";
ORYX.CONFIG.VISIOIMPORT =               ORYX.CONFIG.ROOT_PATH + "visioimport";


	/* Namespaces */
ORYX.CONFIG.NAMESPACE_ORYX =			"http://www.b3mn.org/oryx";
ORYX.CONFIG.NAMESPACE_SVG =				"http://www.w3.org/2000/svg";

	/* UI */
ORYX.CONFIG.CANVAS_WIDTH =				1485; 
ORYX.CONFIG.CANVAS_HEIGHT =				1050;
ORYX.CONFIG.CANVAS_RESIZE_INTERVAL =	300;
ORYX.CONFIG.SELECTED_AREA_PADDING =		4;
ORYX.CONFIG.CANVAS_BACKGROUND_COLOR =	"none";
ORYX.CONFIG.GRID_DISTANCE =				30;
ORYX.CONFIG.GRID_ENABLED =				true;
ORYX.CONFIG.ZOOM_OFFSET =				0.1;
ORYX.CONFIG.DEFAULT_SHAPE_MARGIN =		60;
ORYX.CONFIG.SCALERS_SIZE =				7;
ORYX.CONFIG.MINIMUM_SIZE =				20;
ORYX.CONFIG.MAXIMUM_SIZE =				10000;
ORYX.CONFIG.OFFSET_MAGNET =				15;
ORYX.CONFIG.OFFSET_EDGE_LABEL_TOP =		14;
ORYX.CONFIG.OFFSET_EDGE_LABEL_BOTTOM =	12;
ORYX.CONFIG.OFFSET_EDGE_BOUNDS =		5;
ORYX.CONFIG.COPY_MOVE_OFFSET =			30;
ORYX.CONFIG.SHOW_GRIDLINE =             true;

ORYX.CONFIG.BORDER_OFFSET =				14;

ORYX.CONFIG.MAX_NUM_SHAPES_NO_GROUP	=	13;

ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER = 30;
ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET = 45;

	/* Shape-Menu Align */
ORYX.CONFIG.SHAPEMENU_RIGHT =			"Oryx_Right";
ORYX.CONFIG.SHAPEMENU_BOTTOM =			"Oryx_Bottom";
ORYX.CONFIG.SHAPEMENU_LEFT =			"Oryx_Left";
ORYX.CONFIG.SHAPEMENU_TOP =				"Oryx_Top";

	/* Morph-Menu Item */
ORYX.CONFIG.MORPHITEM_DISABLED =		"Oryx_MorphItem_disabled";

	/* Property type names */
ORYX.CONFIG.TYPE_STRING =				"string";
ORYX.CONFIG.TYPE_BOOLEAN =				"boolean";
ORYX.CONFIG.TYPE_INTEGER =				"integer";
ORYX.CONFIG.TYPE_FLOAT =				"float";
ORYX.CONFIG.TYPE_COLOR =				"color";
ORYX.CONFIG.TYPE_DATE =					"date";
ORYX.CONFIG.TYPE_CHOICE =				"choice";
ORYX.CONFIG.TYPE_URL =					"url";
ORYX.CONFIG.TYPE_DIAGRAM_LINK =			"diagramlink";
ORYX.CONFIG.TYPE_COMPLEX =				"complex";
ORYX.CONFIG.TYPE_TEXT =					"text";
	
	/* Vertical line distance of multiline labels */
ORYX.CONFIG.LABEL_LINE_DISTANCE =		2;
ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT =	12;

ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER = true;

	/* Editor constants come here */
ORYX.CONFIG.EDITOR_ALIGN_BOTTOM =		0x01;
ORYX.CONFIG.EDITOR_ALIGN_MIDDLE =		0x02;
ORYX.CONFIG.EDITOR_ALIGN_TOP =			0x04;
ORYX.CONFIG.EDITOR_ALIGN_LEFT =			0x08;
ORYX.CONFIG.EDITOR_ALIGN_CENTER =		0x10;
ORYX.CONFIG.EDITOR_ALIGN_RIGHT =		0x20;
ORYX.CONFIG.EDITOR_ALIGN_SIZE =			0x30;

	/* Event types */
ORYX.CONFIG.EVENT_MOUSEDOWN =			"mousedown";
ORYX.CONFIG.EVENT_MOUSEUP =				"mouseup";
ORYX.CONFIG.EVENT_MOUSEOVER =			"mouseover";
ORYX.CONFIG.EVENT_MOUSEOUT =			"mouseout";
ORYX.CONFIG.EVENT_MOUSEMOVE =			"mousemove";
ORYX.CONFIG.EVENT_DBLCLICK =			"dblclick";
ORYX.CONFIG.EVENT_KEYDOWN =				"keydown";
ORYX.CONFIG.EVENT_KEYUP =				"keyup";

ORYX.CONFIG.EVENT_LOADED =				"editorloaded";
	
ORYX.CONFIG.EVENT_EXECUTE_COMMANDS =		"executeCommands";
ORYX.CONFIG.EVENT_STENCIL_SET_LOADED =		"stencilSetLoaded";
ORYX.CONFIG.EVENT_SELECTION_CHANGED =		"selectionchanged";
ORYX.CONFIG.EVENT_SHAPEADDED =				"shapeadded";
ORYX.CONFIG.EVENT_PROPERTY_CHANGED =		"propertyChanged";
ORYX.CONFIG.EVENT_DRAGDROP_START =			"dragdrop.start";
ORYX.CONFIG.EVENT_SHAPE_MENU_CLOSE =		"shape.menu.close";
ORYX.CONFIG.EVENT_DRAGDROP_END =			"dragdrop.end";
ORYX.CONFIG.EVENT_RESIZE_START =			"resize.start";
ORYX.CONFIG.EVENT_RESIZE_END =				"resize.end";
ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED =		"dragDocker.docked";
ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW =			"highlight.showHighlight";
ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE =			"highlight.hideHighlight";
ORYX.CONFIG.EVENT_LOADING_ENABLE =			"loading.enable";
ORYX.CONFIG.EVENT_LOADING_DISABLE =			"loading.disable";
ORYX.CONFIG.EVENT_LOADING_STATUS =			"loading.status";
ORYX.CONFIG.EVENT_OVERLAY_SHOW =			"overlay.show";
ORYX.CONFIG.EVENT_OVERLAY_HIDE =			"overlay.hide";
ORYX.CONFIG.EVENT_ARRANGEMENT_TOP =			"arrangement.setToTop";
ORYX.CONFIG.EVENT_ARRANGEMENT_BACK =		"arrangement.setToBack";
ORYX.CONFIG.EVENT_ARRANGEMENT_FORWARD =		"arrangement.setForward";
ORYX.CONFIG.EVENT_ARRANGEMENT_BACKWARD =	"arrangement.setBackward";
ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED =	"propertyWindow.propertyChanged";
ORYX.CONFIG.EVENT_LAYOUT_ROWS =				"layout.rows";
ORYX.CONFIG.EVENT_LAYOUT_BPEL =				"layout.BPEL";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_VERTICAL =    "layout.BPEL.vertical";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_HORIZONTAL =  "layout.BPEL.horizontal";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_SINGLECHILD = "layout.BPEL.singlechild";
ORYX.CONFIG.EVENT_LAYOUT_BPEL_AUTORESIZE =	"layout.BPEL.autoresize";
ORYX.CONFIG.EVENT_AUTOLAYOUT_LAYOUT =		"autolayout.layout";
ORYX.CONFIG.EVENT_UNDO_EXECUTE =			"undo.execute";
ORYX.CONFIG.EVENT_UNDO_ROLLBACK =			"undo.rollback";
ORYX.CONFIG.EVENT_BUTTON_UPDATE =           "toolbar.button.update";
ORYX.CONFIG.EVENT_LAYOUT = 					"layout.dolayout";
ORYX.CONFIG.EVENT_COLOR_CHANGE = 			"color.change";
ORYX.CONFIG.EVENT_DOCKERDRAG = 				"dragTheDocker";	
ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW =		"propertywindow.show";
ORYX.CONFIG.EVENT_SHAPE_MORPHED =			"shapemorphed";
ORYX.CONFIG.EVENT_WINDOW_FOCUS =            "window.focus";  // raised by plugin toolbar.js
ORYX.CONFIG.EVENT_TBPM_BACKGROUND_UPDATE =	"tbpm.background";
ORYX.CONFIG.EVENT_MODEL_SAVED =				"model.saved";
ORYX.CONFIG.EVENT_REGISTER_LABEL_TEMPLATE = "register.label.template";
	
	/* Selection Shapes Highlights */
ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE =				5;
ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR =				"#4444FF";
ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR2 =			"#9999FF";
	
ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_CORNER = 		"corner";
ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE = 	"rectangle";
	
ORYX.CONFIG.SELECTION_VALID_COLOR =					"#00FF00";
ORYX.CONFIG.SELECTION_INVALID_COLOR =				"#FF0000";


ORYX.CONFIG.DOCKER_DOCKED_COLOR =		"#00FF00";
ORYX.CONFIG.DOCKER_UNDOCKED_COLOR =		"#FF0000";
ORYX.CONFIG.DOCKER_SNAP_OFFSET =		10;
		
	/* Copy & Paste */
ORYX.CONFIG.EDIT_OFFSET_PASTE =			10;

	/* Key-Codes */
ORYX.CONFIG.KEY_CODE_X = 				88;
ORYX.CONFIG.KEY_CODE_C = 				67;
ORYX.CONFIG.KEY_CODE_V = 				86;
ORYX.CONFIG.KEY_CODE_DELETE = 			46;
ORYX.CONFIG.KEY_CODE_META =				224;
ORYX.CONFIG.KEY_CODE_BACKSPACE =		8;
ORYX.CONFIG.KEY_CODE_LEFT =				37;
ORYX.CONFIG.KEY_CODE_RIGHT =			39;
ORYX.CONFIG.KEY_CODE_UP =				38;
ORYX.CONFIG.KEY_CODE_DOWN =				40;

	// TODO Determine where the lowercase constants are still used and remove them from here.
ORYX.CONFIG.KEY_Code_enter =			12;
ORYX.CONFIG.KEY_Code_left =				37;
ORYX.CONFIG.KEY_Code_right =			39;
ORYX.CONFIG.KEY_Code_top =				38;
ORYX.CONFIG.KEY_Code_bottom =			40;

/* Supported Meta Keys */
	
ORYX.CONFIG.META_KEY_META_CTRL = 		"metactrl";
ORYX.CONFIG.META_KEY_ALT = 				"alt";
ORYX.CONFIG.META_KEY_SHIFT = 			"shift";

/* Key Actions */

ORYX.CONFIG.KEY_ACTION_DOWN = 			"down";
ORYX.CONFIG.KEY_ACTION_UP = 			"up";

/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/function printf() {		var result = arguments[0];	for (var i=1; i<arguments.length; i++)		result = result.replace('%' + (i-1), arguments[i]);	return result;}// oryx constants.var ORYX_LOGLEVEL_TRACE = 5;var ORYX_LOGLEVEL_DEBUG = 4;var ORYX_LOGLEVEL_INFO = 3;var ORYX_LOGLEVEL_WARN = 2;var ORYX_LOGLEVEL_ERROR = 1;var ORYX_LOGLEVEL_FATAL = 0;var ORYX_LOGLEVEL = 1;var ORYX_CONFIGURATION_DELAY = 100;var ORYX_CONFIGURATION_WAIT_ATTEMPTS = 10;if(!ORYX) var ORYX = {};ORYX = Object.extend(ORYX, {	//set the path in the config.js file!!!!	PATH: ORYX.CONFIG.ROOT_PATH,	//CONFIGURATION: "config.js",	URLS: [			/*		 * No longer needed, since compiled into one source file that		 * contains all of this files concatenated in the exact order		 * as defined in build.xml.		 */		/*		"scripts/Core/SVG/editpathhandler.js",		"scripts/Core/SVG/minmaxpathhandler.js",		"scripts/Core/SVG/pointspathhandler.js",		"scripts/Core/SVG/svgmarker.js",		"scripts/Core/SVG/svgshape.js",		"scripts/Core/SVG/label.js",		"scripts/Core/Math/math.js",				"scripts/Core/StencilSet/stencil.js",		"scripts/Core/StencilSet/property.js",		"scripts/Core/StencilSet/propertyitem.js",		"scripts/Core/StencilSet/rules.js",		"scripts/Core/StencilSet/stencilset.js",		"scripts/Core/StencilSet/stencilsets.js",		"scripts/Core/bounds.js",		"scripts/Core/uiobject.js",		"scripts/Core/abstractshape.js",		"scripts/Core/canvas.js",		"scripts/Core/main.js",		"scripts/Core/svgDrag.js",		"scripts/Core/shape.js",		"scripts/Core/Controls/control.js",		"scripts/Core/Controls/docker.js",		"scripts/Core/Controls/magnet.js",				"scripts/Core/node.js",		"scripts/Core/edge.js"*/	],	alreadyLoaded: [],	configrationRetries: 0,	Version: '0.1.1',	availablePlugins: [],	/**	 * The ORYX.Log logger.	 */	Log: {				__appenders: [			{				// Firebug console log appender, 				// will only react if window.console is present				append: function(level, args) {										//			messageParts[0] = (new Date()).getTime() + " "					//				+ prefix + " " + messageParts[0];					//			var message = printf.apply(null, args);										if (window.console) {						switch(level) {							case 'TRACE': 	                            args.unshift("[TRACE|" + (new Date()).getTime()+"]"); 								// missing break is intentional							case 'DEBUG':								window.console.debug.apply(window.console, args); 								break;							case 'INFO':								window.console.info.apply(window.console, args); 							break;							case 'WARN':								window.console.warn.apply(window.console, args); 								break;							case 'FATAL':								args.unshift("[FATAL]"); 								// missing break is intentional							case 'ERROR':								window.console.error.apply(window.console, args); 								break;							default:								args.unshift("["+level.toUpperCase()+"]");								window.console.log.apply(window.console, args); 						}						}				}			}		],			trace: function() {	if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_TRACE)			ORYX.Log.__log('TRACE', arguments); },		debug: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_DEBUG)			ORYX.Log.__log('DEBUG', arguments); },		info: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_INFO)			ORYX.Log.__log('INFO', arguments); },		warn: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_WARN)			ORYX.Log.__log('WARN', arguments); },		error: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_ERROR)			ORYX.Log.__log('ERROR', arguments); },		fatal: function() { if(ORYX_LOGLEVEL >= ORYX_LOGLEVEL_FATAL)			ORYX.Log.__log('FATAL', arguments); },				__log: function(prefix, args) {						ORYX.Log.__appenders.each(function(appender) {				appender.append(prefix, $A(args));			});		},				addAppender: function(appender) {			ORYX.Log.__appenders.push(appender);		}	},	/**	 * First bootstrapping layer. The Oryx loading procedure begins. In this	 * step, all preliminaries that are not in the responsibility of Oryx to be	 * met have to be checked here, such as the existance of the prototpe	 * library in the current execution environment. After that, the second	 * bootstrapping layer is being invoked. Failing to ensure that any	 * preliminary condition is not met has to fail with an error.	 */	load: function() {		var waitingpanel = new Ext.Window({renderTo:Ext.getBody(),id:'oryx-loading-panel',bodyStyle:'padding: 8px;background:white',title:ORYX.I18N.Oryx.title,width:'auto',height:'auto',modal:true,resizable:false,closable:false,html:'<span style="font-size:11px;">' + ORYX.I18N.Oryx.pleaseWait + '</span>'})		waitingpanel.show()						ORYX.Log.debug("Oryx begins loading procedure.");				// check for prototype		if( (typeof Prototype=='undefined') ||			(typeof Element == 'undefined') ||			(typeof Element.Methods=='undefined') ||			parseFloat(Prototype.Version.split(".")[0] + "." +				Prototype.Version.split(".")[1]) < 1.5)			throw("Application requires the Prototype JavaScript framework >= 1.5.3");				ORYX.Log.debug("Prototype > 1.5 found.");		// continue loading.		ORYX._load();	},	/**	 * Second bootstrapping layer. The oryx configuration is checked. When not	 * yet loaded, config.js is being requested from the server. A repeated	 * error in retrieving the configuration will result in an error to be	 * thrown after a certain time of retries. Once the configuration is there,	 * all urls that are registered with oryx loading are being requested from	 * the server. Once everything is loaded, the third layer is being invoked.	 */	_load: function() {	/*		// if configuration not there already,		if(!(ORYX.CONFIG)) {						// if this is the first attempt...			if(ORYX.configrationRetries == 0) {								// get the path and filename.				var configuration = ORYX.PATH + ORYX.CONFIGURATION;					ORYX.Log.debug("Configuration not found, loading from '%0'.",					configuration);								// require configuration file.				Kickstart.require(configuration);							// else if attempts exceeded ...			} else if(ORYX.configrationRetries >= ORYX_CONFIGURATION_WAIT_ATTEMPTS) {								throw "Tried to get configuration" +					ORYX_CONFIGURATION_WAIT_ATTEMPTS +					" times from '" + configuration + "'. Giving up."								} else if(ORYX.configrationRetries > 0){								// point out how many attempts are left...				ORYX.Log.debug("Waiting once more (%0 attempts left)",					(ORYX_CONFIGURATION_WAIT_ATTEMPTS -						ORYX.configrationRetries));			}						// any case: continue in a moment with increased retry count.			ORYX.configrationRetries++;			window.setTimeout(ORYX._load, ORYX_CONFIGURATION_DELAY);			return;		}				ORYX.Log.info("Configuration loaded.");				// load necessary scripts.		ORYX.URLS.each(function(url) {			ORYX.Log.debug("Requireing '%0'", url);			Kickstart.require(ORYX.PATH + url) });	*/		// configurate logging and load plugins.		ORYX.loadPlugins();	},	/**	 * Third bootstrapping layer. This is where first the plugin coniguration	 * file is loaded into oryx, analyzed, and where all plugins are being	 * requested by the server. Afterwards, all editor instances will be	 * initialized.	 */	loadPlugins: function() {				// load plugins if enabled.		if(ORYX.CONFIG.PLUGINS_ENABLED)			ORYX._loadPlugins()		else			ORYX.Log.warn("Ignoring plugins, loading Core only.");		// init the editor instances.		init();	},		_loadPlugins: function() {		// load plugin configuration file.		var source = ORYX.CONFIG.PLUGINS_CONFIG;		ORYX.Log.debug("Loading plugin configuration from '%0'.", source);			new Ajax.Request(source, {			asynchronous: false,			method: 'get',			onSuccess: function(result) {				/*				 * This is the method that is being called when the plugin				 * configuration was successfully loaded from the server. The				 * file has to be processed and the contents need to be				 * considered for further plugin requireation.				 */								ORYX.Log.info("Plugin configuration file loaded.");						// get plugins.xml content				var resultXml = result.responseXML;								// TODO: Describe how properties are handled.				// Get the globale Properties				var globalProperties = [];				var preferences = $A(resultXml.getElementsByTagName("properties"));				preferences.each( function(p) {					var props = $A(p.childNodes);					props.each( function(prop) {						var property = new Hash(); 												// get all attributes from the node and set to global properties						var attributes = $A(prop.attributes)						attributes.each(function(attr){property[attr.nodeName] = attr.nodeValue});										if(attributes.length > 0) { globalProperties.push(property) };									});				});								// TODO Why are we using XML if we don't respect structure anyway?				// for each plugin element in the configuration..				var plugin = resultXml.getElementsByTagName("plugin");				$A(plugin).each( function(node) {										// get all element's attributes.					// TODO: What about: var pluginData = $H(node.attributes) !?					var pluginData = new Hash();					$A(node.attributes).each( function(attr){						pluginData[attr.nodeName] = attr.nodeValue});														// ensure there's a name attribute.					if(!pluginData['name']) {						ORYX.Log.error("A plugin is not providing a name. Ingnoring this plugin.");						return;					}					// ensure there's a source attribute.					if(!pluginData['source']) {						ORYX.Log.error("Plugin with name '%0' doesn't provide a source attribute.", pluginData['name']);						return;					}										// Get all private Properties					var propertyNodes = node.getElementsByTagName("property");					var properties = [];					$A(propertyNodes).each(function(prop) {						var property = new Hash(); 												// Get all Attributes from the Node									var attributes = $A(prop.attributes)						attributes.each(function(attr){property[attr.nodeName] = attr.nodeValue});										if(attributes.length > 0) { properties.push(property) };											});										// Set all Global-Properties to the Properties					properties = properties.concat(globalProperties);										// Set Properties to Plugin-Data					pluginData['properties'] = properties;										// Get the RequieredNodes					var requireNodes = node.getElementsByTagName("requires");					var requires;					$A(requireNodes).each(function(req) {									var namespace = $A(req.attributes).find(function(attr){ return attr.name == "namespace"})						if( namespace && namespace.nodeValue ){							if( !requires ){								requires = {namespaces:[]}							}													requires.namespaces.push(namespace.nodeValue)						} 					});															// Set Requires to the Plugin-Data, if there is one					if( requires ){						pluginData['requires'] = requires;					}					// Get the RequieredNodes					var notUsesInNodes = node.getElementsByTagName("notUsesIn");					var notUsesIn;					$A(notUsesInNodes).each(function(not) {									var namespace = $A(not.attributes).find(function(attr){ return attr.name == "namespace"})						if( namespace && namespace.nodeValue ){							if( !notUsesIn ){								notUsesIn = {namespaces:[]}							}													notUsesIn.namespaces.push(namespace.nodeValue)						} 					});															// Set Requires to the Plugin-Data, if there is one					if( notUsesIn ){						pluginData['notUsesIn'] = notUsesIn;					}																				var url = ORYX.PATH + ORYX.CONFIG.PLUGINS_FOLDER + pluginData['source'];							ORYX.Log.debug("Requireing '%0'", url);							// Add the Script-Tag to the Site					//Kickstart.require(url);							ORYX.Log.info("Plugin '%0' successfully loaded.", pluginData['name']);							// Add the Plugin-Data to all available Plugins					ORYX.availablePlugins.push(pluginData);						});					},			onFailure:this._loadPluginsOnFails		});	},	_loadPluginsOnFails: function(result) {		ORYX.Log.error("Plugin configuration file not available.");	}});ORYX.Log.debug('Registering Oryx with Kickstart');Kickstart.register(ORYX.load);/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}


/**
 * EditPathHandler
 * 
 * Edit SVG paths' coordinates according to specified from-to movement and
 * horizontal and vertical scaling factors. 
 * The resulting path's d attribute is stored in instance variable d.
 * 
 * @constructor
 */
ORYX.Core.SVG.EditPathHandler = Clazz.extend({
	
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
		
		this.x = 0;
		this.y = 0;
		this.oldX = 0;
		this.oldY = 0;
		this.deltaWidth = 1;
		this.deltaHeight = 1;
		
		this.d = "";
	},
	
	/**
	 * init
	 * 
	 * @param {float} x Target point's x-coordinate
	 * @param {float} y Target point's y-coordinate
	 * @param {float} oldX Reference point's x-coordinate
	 * @param {float} oldY Reference point's y-coordinate
	 * @param {float} deltaWidth Horizontal scaling factor
	 * @param {float} deltaHeight Vertical scaling factor
	 */
	init: function(x, y, oldX, oldY, deltaWidth, deltaHeight) {
		this.x = x;
		this.y = y;
		this.oldX = oldX;
		this.oldY = oldY;
		this.deltaWidth = deltaWidth;
		this.deltaHeight = deltaHeight;
		
		this.d = "";
	},

	/**
	 * editPointsAbs
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	editPointsAbs: function(points) {
		if(points instanceof Array) {
			var newPoints = [];
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = (parseFloat(points[i]) - this.oldX)*this.deltaWidth + this.x;
				i++;
				y = (parseFloat(points[i]) - this.oldY)*this.deltaHeight + this.y;
				newPoints.push(x);
				newPoints.push(y);
			}
			
			return newPoints;
		} else {
			//TODO error
		}
	},
	
	/**
	 * editPointsRel
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	editPointsRel: function(points) {
		if(points instanceof Array) {
			var newPoints = [];
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = parseFloat(points[i])*this.deltaWidth;
				i++;
				y = parseFloat(points[i])*this.deltaHeight;
				newPoints.push(x);
				newPoints.push(y);
			}
			
			return newPoints;
		} else {
			//TODO error
		}
	},

	/**
	 * arcAbs - A
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcAbs: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		var pointsRel = this.editPointsRel([rx, ry]);
		
		this.d = this.d.concat(" A" + pointsRel[0] + " " + pointsRel[1] + 
								" " + xAxisRotation + " " + largeArcFlag + 
								" " + sweepFlag + " " + pointsAbs[0] + " " +
								pointsAbs[1] + " ");					
	},

	/**
	 * arcRel - a
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcRel: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
		var pointsRel = this.editPointsRel([rx, ry, x, y]);
		
		this.d = this.d.concat(" a" + pointsRel[0] + " " + pointsRel[1] + 
								" " + xAxisRotation + " " + largeArcFlag + 
								" " + sweepFlag + " " + pointsRel[2] + " " +
								pointsRel[3] + " ");	
	},

	/**
	 * curvetoCubicAbs - C
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicAbs: function(x1, y1, x2, y2, x, y) {
	    var pointsAbs = this.editPointsAbs([x1, y1, x2, y2, x, y]);
		
		this.d = this.d.concat(" C" + pointsAbs[0] + " " + pointsAbs[1] + 
								" " + pointsAbs[2] + " " + pointsAbs[3] + 
								" " + pointsAbs[4] + " " + pointsAbs[5] + " ");	
	},

	/**
	 * curvetoCubicRel - c
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicRel: function(x1, y1, x2, y2, x, y) {
	    var pointsRel = this.editPointsRel([x1, y1, x2, y2, x, y]);
		
		this.d = this.d.concat(" c" + pointsRel[0] + " " + pointsRel[1] + 
								" " + pointsRel[2] + " " + pointsRel[3] + 
								" " + pointsRel[4] + " " + pointsRel[5] + " ");	
	},

	/**
	 * linetoHorizontalAbs - H
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalAbs: function(x) {
	    var pointsAbs = this.editPointsAbs([x, 0]);
		
		this.d = this.d.concat(" H" + pointsAbs[0] + " ");	
	},

	/**
	 * linetoHorizontalRel - h
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalRel: function(x) {
	    var pointsRel = this.editPointsRel([x, 0]);
		
		this.d = this.d.concat(" h" + pointsRel[0] + " ");	
	},

	/**
	 * linetoAbs - L
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoAbs: function(x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		
		this.d = this.d.concat(" L" + pointsAbs[0] + " " + pointsAbs[1] + " ");
	},

	/**
	 * linetoRel - l
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoRel: function(x, y) {
	    var pointsRel = this.editPointsRel([x, y]);
		
		this.d = this.d.concat(" l" + pointsRel[0] + " " + pointsRel[1] + " ");
	},

	/**
	 * movetoAbs - M
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoAbs: function(x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		
		this.d = this.d.concat(" M" + pointsAbs[0] + " " + pointsAbs[1] + " ");
	},

	/**
	 * movetoRel - m
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoRel: function(x, y) {
	    var pointsRel;
		if(this.d === "") {
			pointsRel = this.editPointsAbs([x, y]);
		} else {
			pointsRel = this.editPointsRel([x, y]);
		}
		
		this.d = this.d.concat(" m" + pointsRel[0] + " " + pointsRel[1] + " ");
	},

	/**
	 * curvetoQuadraticAbs - Q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticAbs: function(x1, y1, x, y) {
	    var pointsAbs = this.editPointsAbs([x1, y1, x, y]);
		
		this.d = this.d.concat(" Q" + pointsAbs[0] + " " + pointsAbs[1] + " " +
								pointsAbs[2] + " " + pointsAbs[3] + " ");
	},

	/**
	 * curvetoQuadraticRel - q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticRel: function(x1, y1, x, y) {
	    var pointsRel = this.editPointsRel([x1, y1, x, y]);
		
		this.d = this.d.concat(" q" + pointsRel[0] + " " + pointsRel[1] + " " +
								pointsRel[2] + " " + pointsRel[3] + " ");
	},

	/**
	 * curvetoCubicSmoothAbs - S
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothAbs: function(x2, y2, x, y) {
	    var pointsAbs = this.editPointsAbs([x2, y2, x, y]);
		
		this.d = this.d.concat(" S" + pointsAbs[0] + " " + pointsAbs[1] + " " +
								pointsAbs[2] + " " + pointsAbs[3] + " ");
	},

	/**
	 * curvetoCubicSmoothRel - s
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothRel: function(x2, y2, x, y) {
	    var pointsRel = this.editPointsRel([x2, y2, x, y]);
		
		this.d = this.d.concat(" s" + pointsRel[0] + " " + pointsRel[1] + " " +
								pointsRel[2] + " " + pointsRel[3] + " ");
	},

	/**
	 * curvetoQuadraticSmoothAbs - T
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothAbs: function(x, y) {
	    var pointsAbs = this.editPointsAbs([x, y]);
		
		this.d = this.d.concat(" T" + pointsAbs[0] + " " + pointsAbs[1] + " ");
	},

	/**
	 * curvetoQuadraticSmoothRel - t
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothRel: function(x, y) {
	    var pointsRel = this.editPointsRel([x, y]);
		
		this.d = this.d.concat(" t" + pointsRel[0] + " " + pointsRel[1] + " ");
	},

	/**
	 * linetoVerticalAbs - V
	 * 
	 * @param {Number} y
	 */
	linetoVerticalAbs: function(y) {
	    var pointsAbs = this.editPointsAbs([0, y]);
		
		this.d = this.d.concat(" V" + pointsAbs[1] + " ");
	},

	/**
	 * linetoVerticalRel - v
	 * 
	 * @param {Number} y
	 */
	linetoVerticalRel: function(y) {
	    var pointsRel = this.editPointsRel([0, y]);
		
		this.d = this.d.concat(" v" + pointsRel[1] + " ");
	},

	/**
	 * closePath - z or Z
	 */
	closePath: function() {
	    this.d = this.d.concat(" z");
	}

});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}


/**
 * MinMaxPathHandler
 * 
 * Determine the minimum and maximum of a SVG path's absolute coordinates.
 * For relative coordinates the absolute value is computed for consideration.
 * The values are stored in attributes minX, minY, maxX, and maxY.
 * 
 * @constructor
 */
ORYX.Core.SVG.MinMaxPathHandler = Clazz.extend({
	
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
		
		this.minX = undefined;
		this.minY = undefined;
		this.maxX = undefined;
		this.maxY = undefined;
		
		this._lastAbsX = undefined;
		this._lastAbsY = undefined;
	},

	/**
	 * Store minimal and maximal coordinates of passed points to attributes minX, maxX, minY, maxY
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	calculateMinMax: function(points) {
		if(points instanceof Array) {
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = parseFloat(points[i]);
				i++;
				y = parseFloat(points[i]);
				
				this.minX = (this.minX !== undefined) ? Math.min(this.minX, x) : x;
				this.maxX = (this.maxX !== undefined) ? Math.max(this.maxX, x) : x;
				this.minY = (this.minY !== undefined) ? Math.min(this.minY, y) : y;
				this.maxY = (this.maxY !== undefined) ? Math.max(this.maxY, y) : y;
					
				this._lastAbsX = x;
				this._lastAbsY = y;
			}
		} else {
			//TODO error
		}
	},

	/**
	 * arcAbs - A
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcAbs: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * arcRel - a
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcRel: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicAbs - C
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicAbs: function(x1, y1, x2, y2, x, y) {
	    this.calculateMinMax([x1, y1, x2, y2, x, y]);
	},

	/**
	 * curvetoCubicRel - c
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicRel: function(x1, y1, x2, y2, x, y) {
	    this.calculateMinMax([this._lastAbsX + x1, this._lastAbsY + y1,
							  this._lastAbsX + x2, this._lastAbsY + y2,
							  this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoHorizontalAbs - H
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalAbs: function(x) {
	    this.calculateMinMax([x, this._lastAbsY]);
	},

	/**
	 * linetoHorizontalRel - h
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalRel: function(x) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY]);
	},

	/**
	 * linetoAbs - L
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoAbs: function(x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * linetoRel - l
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoRel: function(x, y) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * movetoAbs - M
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoAbs: function(x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * movetoRel - m
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoRel: function(x, y) {
	    if(this._lastAbsX && this._lastAbsY) {
			this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
		} else {
			this.calculateMinMax([x, y]);
		}
	},

	/**
	 * curvetoQuadraticAbs - Q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticAbs: function(x1, y1, x, y) {
	    this.calculateMinMax([x1, y1, x, y]);
	},

	/**
	 * curvetoQuadraticRel - q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticRel: function(x1, y1, x, y) {
	    this.calculateMinMax([this._lastAbsX + x1, this._lastAbsY + y1, this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicSmoothAbs - S
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothAbs: function(x2, y2, x, y) {
	    this.calculateMinMax([x2, y2, x, y]);
	},

	/**
	 * curvetoCubicSmoothRel - s
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothRel: function(x2, y2, x, y) {
	    this.calculateMinMax([this._lastAbsX + x2, this._lastAbsY + y2, this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoQuadraticSmoothAbs - T
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothAbs: function(x, y) {
	    this.calculateMinMax([x, y]);
	},

	/**
	 * curvetoQuadraticSmoothRel - t
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothRel: function(x, y) {
	    this.calculateMinMax([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoVerticalAbs - V
	 * 
	 * @param {Number} y
	 */
	linetoVerticalAbs: function(y) {
	    this.calculateMinMax([this._lastAbsX, y]);
	},

	/**
	 * linetoVerticalRel - v
	 * 
	 * @param {Number} y
	 */
	linetoVerticalRel: function(y) {
	    this.calculateMinMax([this._lastAbsX, this._lastAbsY + y]);
	},

	/**
	 * closePath - z or Z
	 */
	closePath: function() {
	    return;// do nothing
	}

});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}


/**
 * PathHandler
 * 
 * Determine absolute points of a SVG path. The coordinates are stored 
 * sequentially in the attribute points (x-coordinates at even indices,
 * y-coordinates at odd indices).
 * 
 * @constructor
 */
ORYX.Core.SVG.PointsPathHandler = Clazz.extend({
	
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
		
		this.points = [];
		
		this._lastAbsX = undefined;
		this._lastAbsY = undefined;
	},

	/**
	 * addPoints
	 * 
	 * @param {Array} points Array of absolutePoints
	 */
	addPoints: function(points) {
		if(points instanceof Array) {
			var x, y;
			for(var i = 0; i < points.length; i++) {
				x = parseFloat(points[i]);
				i++;
				y = parseFloat(points[i]);
				
				this.points.push(x);
				this.points.push(y);
				//this.points.push({x:x, y:y});
					
				this._lastAbsX = x;
				this._lastAbsY = y;
			}
		} else {
			//TODO error
		}
	},

	/**
	 * arcAbs - A
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcAbs: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * arcRel - a
	 * 
	 * @param {Number} rx
	 * @param {Number} ry
	 * @param {Number} xAxisRotation
	 * @param {Boolean} largeArcFlag
	 * @param {Boolean} sweepFlag
	 * @param {Number} x
	 * @param {Number} y
	 */
	arcRel: function(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicAbs - C
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicAbs: function(x1, y1, x2, y2, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoCubicRel - c
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicRel: function(x1, y1, x2, y2, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoHorizontalAbs - H
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalAbs: function(x) {
	    this.addPoints([x, this._lastAbsY]);
	},

	/**
	 * linetoHorizontalRel - h
	 * 
	 * @param {Number} x
	 */
	linetoHorizontalRel: function(x) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY]);
	},

	/**
	 * linetoAbs - L
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoAbs: function(x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * linetoRel - l
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	linetoRel: function(x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * movetoAbs - M
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoAbs: function(x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * movetoRel - m
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	movetoRel: function(x, y) {
	    if(this._lastAbsX && this._lastAbsY) {
			this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
		} else {
			this.addPoints([x, y]);
		}
	},

	/**
	 * curvetoQuadraticAbs - Q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticAbs: function(x1, y1, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoQuadraticRel - q
	 * 
	 * @param {Number} x1
	 * @param {Number} y1
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticRel: function(x1, y1, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoCubicSmoothAbs - S
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothAbs: function(x2, y2, x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoCubicSmoothRel - s
	 * 
	 * @param {Number} x2
	 * @param {Number} y2
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoCubicSmoothRel: function(x2, y2, x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * curvetoQuadraticSmoothAbs - T
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothAbs: function(x, y) {
	    this.addPoints([x, y]);
	},

	/**
	 * curvetoQuadraticSmoothRel - t
	 * 
	 * @param {Number} x
	 * @param {Number} y
	 */
	curvetoQuadraticSmoothRel: function(x, y) {
	    this.addPoints([this._lastAbsX + x, this._lastAbsY + y]);
	},

	/**
	 * linetoVerticalAbs - V
	 * 
	 * @param {Number} y
	 */
	linetoVerticalAbs: function(y) {
	    this.addPoints([this._lastAbsX, y]);
	},

	/**
	 * linetoVerticalRel - v
	 * 
	 * @param {Number} y
	 */
	linetoVerticalRel: function(y) {
	    this.addPoints([this._lastAbsX, this._lastAbsY + y]);
	},

	/**
	 * closePath - z or Z
	 */
	closePath: function() {
	    return;// do nothing
	}

});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 *
 * Config variables
 */
NAMESPACE_ORYX = "http://www.b3mn.org/oryx";
NAMESPACE_SVG = "http://www.w3.org/2000/svg/";

/**
 * @classDescription This class wraps the manipulation of a SVG marker.
 * @namespace ORYX.Core.SVG
 * uses Inheritance (Clazz)
 * uses Prototype 1.5.0
 *
 */

/**
 * Init package
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}

ORYX.Core.SVG.SVGMarker = Clazz.extend({

	/**
	 * Constructor
	 * @param markerElement {SVGMarkerElement}
	 */
	construct: function(markerElement) {
		arguments.callee.$.construct.apply(this, arguments);

		this.id = undefined;
		this.element = markerElement;
		this.refX = undefined;
		this.refY = undefined;
		this.markerWidth = undefined;
		this.markerHeight = undefined;
		this.oldRefX = undefined;
		this.oldRefY = undefined;
		this.oldMarkerWidth = undefined;
		this.oldMarkerHeight = undefined;
		this.optional = false;
		this.enabled = true;
		this.minimumLength = undefined;
		this.resize = false;

		this.svgShapes = [];

		this._init(); //initialisation of all the properties declared above.
	},

	/**
	 * Initializes the values that are defined in the constructor.
	 */
	_init: function() {
		//check if this.element is a SVGMarkerElement
		if(!( this.element == "[object SVGMarkerElement]")) {
			throw "SVGMarker: Argument is not an instance of SVGMarkerElement.";
		}

		this.id = this.element.getAttributeNS(null, "id");
		
		//init svg marker attributes
		var refXValue = this.element.getAttributeNS(null, "refX");
		if(refXValue) {
			this.refX = parseFloat(refXValue);
		} else {
			this.refX = 0;
		}
		var refYValue = this.element.getAttributeNS(null, "refY");
		if(refYValue) {
			this.refY = parseFloat(refYValue);
		} else {
			this.refY = 0;
		}
		var markerWidthValue = this.element.getAttributeNS(null, "markerWidth");
		if(markerWidthValue) {
			this.markerWidth = parseFloat(markerWidthValue);
		} else {
			this.markerWidth = 3;
		}
		var markerHeightValue = this.element.getAttributeNS(null, "markerHeight");
		if(markerHeightValue) {
			this.markerHeight = parseFloat(markerHeightValue);
		} else {
			this.markerHeight = 3;
		}

		this.oldRefX = this.refX;
		this.oldRefY = this.refY;
		this.oldMarkerWidth = this.markerWidth;
		this.oldMarkerHeight = this.markerHeight;

		//init oryx attributes
		var optionalAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "optional");
		if(optionalAttr) {
			optionalAttr = optionalAttr.strip();
			this.optional = (optionalAttr.toLowerCase() === "yes");
		} else {
			this.optional = false;
		}

		var enabledAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "enabled");
		if(enabledAttr) {
			enabledAttr = enabledAttr.strip();
			this.enabled = !(enabledAttr.toLowerCase() === "no");
		} else {
			this.enabled = true;
		}

		var minLengthAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "minimumLength");
		if(minLengthAttr) {
			this.minimumLength = parseFloat(minLengthAttr);
		}

		var resizeAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "resize");
		if(resizeAttr) {
			resizeAttr = resizeAttr.strip();
			this.resize = (resizeAttr.toLowerCase() === "yes");
		} else {
			this.resize = false;
		}

		//init SVGShape objects
		//this.svgShapes = this._getSVGShapes(this.element);
	},

	/**
	 *
	 */
	_getSVGShapes: function(svgElement) {
		if(svgElement.hasChildNodes) {
			var svgShapes = [];
			var me = this;
			$A(svgElement.childNodes).each(function(svgChild) {
				try {
					var svgShape = new ORYX.Core.SVG.SVGShape(svgChild);
					svgShapes.push(svgShape);
				} catch (e) {
					svgShapes = svgShapes.concat(me._getSVGShapes(svgChild));
				}
			});
			return svgShapes;
		}
	},

	/**
	 * Writes the changed values into the SVG marker.
	 */
	update: function() {
		//TODO mache marker resizebar!!! aber erst wenn der rest der connectingshape funzt!

//		//update marker attributes
//		if(this.refX != this.oldRefX) {
//			this.element.setAttributeNS(null, "refX", this.refX);
//		}
//		if(this.refY != this.oldRefY) {
//			this.element.setAttributeNS(null, "refY", this.refY);
//		}
//		if(this.markerWidth != this.oldMarkerWidth) {
//			this.element.setAttributeNS(null, "markerWidth", this.markerWidth);
//		}
//		if(this.markerHeight != this.oldMarkerHeight) {
//			this.element.setAttributeNS(null, "markerHeight", this.markerHeight);
//		}
//
//		//update SVGShape objects
//		var widthDelta = this.markerWidth / this.oldMarkerWidth;
//		var heightDelta = this.markerHeight / this.oldMarkerHeight;
//		if(widthDelta != 1 && heightDelta != 1) {
//			this.svgShapes.each(function(svgShape) {
//
//			});
//		}

		//update old values to prepare the next update
		this.oldRefX = this.refX;
		this.oldRefY = this.refY;
		this.oldMarkerWidth = this.markerWidth;
		this.oldMarkerHeight = this.markerHeight;
	},
	
	toString: function() { return (this.element) ? "SVGMarker " + this.element.id : "SVGMarker " + this.element;}
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 *
 * Config variables
 */
NAMESPACE_ORYX = "http://www.b3mn.org/oryx";
NAMESPACE_SVG = "http://www.w3.org/2000/svg/";

/**
 * @classDescription This class wraps the manipulation of a SVG basic shape or a path.
 * @namespace ORYX.Core.SVG
 * uses Inheritance (Clazz)
 * uses Prototype 1.5.0
 * uses PathParser by Kevin Lindsey (http://kevlindev.com/)
 * uses MinMaxPathHandler
 * uses EditPathHandler
 *
 */

//init package
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}

ORYX.Core.SVG.SVGShape = Clazz.extend({

	/**
	 * Constructor
	 * @param svgElem {SVGElement} An SVGElement that is a basic shape or a path.
	 */
	construct: function(svgElem) {
		arguments.callee.$.construct.apply(this, arguments);

		this.type;
		this.element = svgElem;
		this.x = undefined;
		this.y = undefined;
		this.width = undefined;
		this.height = undefined;
		this.oldX = undefined;
		this.oldY = undefined;
		this.oldWidth = undefined;
		this.oldHeight = undefined;
		this.radiusX = undefined;
		this.radiusY = undefined;
		this.isHorizontallyResizable = false;
		this.isVerticallyResizable = false;
		//this.anchors = [];
		this.anchorLeft = false;
		this.anchorRight = false;
		this.anchorTop = false;
		this.anchorBottom = false;
		
		//attributes of path elements of edge objects
		this.allowDockers = true;
		this.resizeMarkerMid = false;

		this.editPathParser;
		this.editPathHandler;

		this.init(); //initialisation of all the properties declared above.
	},

	/**
	 * Initializes the values that are defined in the constructor.
	 */
	init: function() {

		/**initialize position and size*/
		if(ORYX.Editor.checkClassType(this.element, SVGRectElement) || ORYX.Editor.checkClassType(this.element, SVGImageElement)) {
			this.type = "Rect";
			
			var xAttr = this.element.getAttributeNS(null, "x");
			if(xAttr) {
				this.oldX = parseFloat(xAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var yAttr = this.element.getAttributeNS(null, "y");
			if(yAttr) {
				this.oldY = parseFloat(yAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var widthAttr = this.element.getAttributeNS(null, "width");
			if(widthAttr) {
				this.oldWidth = parseFloat(widthAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var heightAttr = this.element.getAttributeNS(null, "height");
			if(heightAttr) {
				this.oldHeight = parseFloat(heightAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}

		} else if(ORYX.Editor.checkClassType(this.element, SVGCircleElement)) {
			this.type = "Circle";
			
			var cx = undefined;
			var cy = undefined;
			//var r = undefined;

			var cxAttr = this.element.getAttributeNS(null, "cx");
			if(cxAttr) {
				cx = parseFloat(cxAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var cyAttr = this.element.getAttributeNS(null, "cy");
			if(cyAttr) {
				cy = parseFloat(cyAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var rAttr = this.element.getAttributeNS(null, "r");
			if(rAttr) {
				//r = parseFloat(rAttr);
				this.radiusX = parseFloat(rAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			this.oldX = cx - this.radiusX;
			this.oldY = cy - this.radiusX;
			this.oldWidth = 2*this.radiusX;
			this.oldHeight = 2*this.radiusX;

		} else if(ORYX.Editor.checkClassType(this.element, SVGEllipseElement)) {
			this.type = "Ellipse";
			
			var cx = undefined;
			var cy = undefined;
			//var rx = undefined;
			//var ry = undefined;
			var cxAttr = this.element.getAttributeNS(null, "cx");
			if(cxAttr) {
				cx = parseFloat(cxAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var cyAttr = this.element.getAttributeNS(null, "cy");
			if(cyAttr) {
				cy = parseFloat(cyAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var rxAttr = this.element.getAttributeNS(null, "rx");
			if(rxAttr) {
				this.radiusX = parseFloat(rxAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var ryAttr = this.element.getAttributeNS(null, "ry");
			if(ryAttr) {
				this.radiusY = parseFloat(ryAttr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			this.oldX = cx - this.radiusX;
			this.oldY = cy - this.radiusY;
			this.oldWidth = 2*this.radiusX;
			this.oldHeight = 2*this.radiusY;

		} else if(ORYX.Editor.checkClassType(this.element, SVGLineElement)) {
			this.type = "Line";
			
			var x1 = undefined;
			var y1 = undefined;
			var x2 = undefined;
			var y2 = undefined;
			var x1Attr = this.element.getAttributeNS(null, "x1");
			if(x1Attr) {
				x1 = parseFloat(x1Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var y1Attr = this.element.getAttributeNS(null, "y1");
			if(y1Attr) {
				y1 = parseFloat(y1Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var x2Attr = this.element.getAttributeNS(null, "x2");
			if(x2Attr) {
				x2 = parseFloat(x2Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			var y2Attr = this.element.getAttributeNS(null, "y2");
			if(y2Attr) {
				y2 = parseFloat(y2Attr);
			} else {
				throw "Missing attribute in element " + this.element;
			}
			this.oldX = Math.min(x1,x2);
			this.oldY = Math.min(y1,y2);
			this.oldWidth = Math.abs(x1-x2);
			this.oldHeight = Math.abs(y1-y2);

		} else if(ORYX.Editor.checkClassType(this.element, SVGPolylineElement) || ORYX.Editor.checkClassType(this.element, SVGPolygonElement)) {
			this.type = "Polyline";
			
			var points = this.element.getAttributeNS(null, "points");

			if(points) {
				points = points.replace(/,/g , " ");
				var pointsArray = points.split(" ");
				pointsArray = pointsArray.without("");

				if(pointsArray && pointsArray.length && pointsArray.length > 1) {
					var minX = parseFloat(pointsArray[0]);
					var minY = parseFloat(pointsArray[1]);
					var maxX = parseFloat(pointsArray[0]);
					var maxY = parseFloat(pointsArray[1]);

					for(var i = 0; i < pointsArray.length; i++) {
						minX = Math.min(minX, parseFloat(pointsArray[i]));
						maxX = Math.max(maxX, parseFloat(pointsArray[i]));
						i++;
						minY = Math.min(minY, parseFloat(pointsArray[i]));
						maxY = Math.max(maxY, parseFloat(pointsArray[i]));
					}

					this.oldX = minX;
					this.oldY = minY;
					this.oldWidth = maxX-minX;
					this.oldHeight = maxY-minY;
				} else {
					throw "Missing attribute in element " + this.element;
				}
			} else {
				throw "Missing attribute in element " + this.element;
			}

		} else if(ORYX.Editor.checkClassType(this.element, SVGPathElement)) {
			this.type = "Path";
			
			this.editPathParser = new PathParser();
			this.editPathHandler = new ORYX.Core.SVG.EditPathHandler();
			this.editPathParser.setHandler(this.editPathHandler);
		
			var parser = new PathParser();
			var handler = new ORYX.Core.SVG.MinMaxPathHandler();
			parser.setHandler(handler);
			parser.parsePath(this.element);

			this.oldX = handler.minX;
			this.oldY = handler.minY;
			this.oldWidth = handler.maxX - handler.minX;
			this.oldHeight = handler.maxY - handler.minY;

			delete parser;
			delete handler;
		} else {
			throw "Element is not a shape.";
		}

		/** initialize attributes of oryx namespace */
		//resize
		var resizeAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "resize");
		if(resizeAttr) {
			resizeAttr = resizeAttr.toLowerCase();
			if(resizeAttr.match(/horizontal/)) {
				this.isHorizontallyResizable = true;
			} else {
				this.isHorizontallyResizable = false;
			}
			if(resizeAttr.match(/vertical/)) {
				this.isVerticallyResizable = true;
			} else {
				this.isVerticallyResizable = false;
			}
		} else {
			this.isHorizontallyResizable = false;
			this.isVerticallyResizable = false;
		}

		//anchors
		var anchorAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "anchors");
		if(anchorAttr) {
			anchorAttr = anchorAttr.replace("/,/g", " ");
			var anchors = anchorAttr.split(" ").without("");
			
			for(var i = 0; i < anchors.length; i++) {
				switch(anchors[i].toLowerCase()) {
					case "left":
						this.anchorLeft = true;
						break;
					case "right":
						this.anchorRight = true;
						break;
					case "top":
						this.anchorTop = true;
						break;
					case "bottom":
						this.anchorBottom = true;
						break;
				}
			}
		}
		
		//allowDockers and resizeMarkerMid
		if(ORYX.Editor.checkClassType(this.element, SVGPathElement)) {
			var allowDockersAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "allowDockers"); 
			if(allowDockersAttr) {
				if(allowDockersAttr.toLowerCase() === "no") {
					this.allowDockers = false; 
				} else {
					this.allowDockers = true;
				}
			}
			
			var resizeMarkerMidAttr = this.element.getAttributeNS(NAMESPACE_ORYX, "resizeMarker-mid"); 
			if(resizeMarkerMidAttr) {
				if(resizeMarkerMidAttr.toLowerCase() === "yes") {
					this.resizeMarkerMid = true; 
				} else {
					this.resizeMarkerMid = false;
				}
			}
		}	
			
		this.x = this.oldX;
		this.y = this.oldY;
		this.width = this.oldWidth;
		this.height = this.oldHeight;
	},

	/**
	 * Writes the changed values into the SVG element.
	 */
	update: function() {
		
		if(this.x !== this.oldX || this.y !== this.oldY || this.width !== this.oldWidth || this.height !== this.oldHeight) {
			switch(this.type) {
				case "Rect":
					if(this.x !== this.oldX) this.element.setAttributeNS(null, "x", this.x);
					if(this.y !== this.oldY) this.element.setAttributeNS(null, "y", this.y);
				 	if(this.width !== this.oldWidth) this.element.setAttributeNS(null, "width", this.width);
					if(this.height !== this.oldHeight) this.element.setAttributeNS(null, "height", this.height);
					break;
				case "Circle":
					//calculate the radius
					//var r;
//					if(this.width/this.oldWidth <= this.height/this.oldHeight) {
//						this.radiusX = ((this.width > this.height) ? this.width : this.height)/2.0;
//					} else {
					 	this.radiusX = ((this.width < this.height) ? this.width : this.height)/2.0;
					//}
	
					this.element.setAttributeNS(null, "cx", this.x + this.width/2.0);
					this.element.setAttributeNS(null, "cy", this.y + this.height/2.0);
					this.element.setAttributeNS(null, "r", this.radiusX);
					break;
				case "Ellipse":
					this.radiusX = this.width/2;
					this.radiusY = this.height/2;
	
					this.element.setAttributeNS(null, "cx", this.x + this.radiusX);
					this.element.setAttributeNS(null, "cy", this.y + this.radiusY);
					this.element.setAttributeNS(null, "rx", this.radiusX);
					this.element.setAttributeNS(null, "ry", this.radiusY);
					break;
				case "Line":
					if(this.x !== this.oldX)
						this.element.setAttributeNS(null, "x1", this.x);
						
					if(this.y !== this.oldY)
						this.element.setAttributeNS(null, "y1", this.y);
						
					if(this.x !== this.oldX || this.width !== this.oldWidth)
						this.element.setAttributeNS(null, "x2", this.x + this.width);
					
					if(this.y !== this.oldY || this.height !== this.oldHeight)
						this.element.setAttributeNS(null, "y2", this.y + this.height);
					break;
				case "Polyline":
					var points = this.element.getAttributeNS(null, "points");
					if(points) {
						points = points.replace(/,/g, " ").split(" ").without("");
	
						if(points && points.length && points.length > 1) {
	
							//TODO what if oldWidth == 0?
							var widthDelta = (this.oldWidth === 0) ? 0 : this.width / this.oldWidth;
						    var heightDelta = (this.oldHeight === 0) ? 0 : this.height / this.oldHeight;
	
							var updatedPoints = "";
						    for(var i = 0; i < points.length; i++) {
								var x = (parseFloat(points[i])-this.oldX)*widthDelta + this.x;
								i++;
								var y = (parseFloat(points[i])-this.oldY)*heightDelta + this.y;
		    					updatedPoints += x + " " + y + " ";
						    }
							this.element.setAttributeNS(null, "points", updatedPoints);
						} else {
							//TODO error
						}
					} else {
						//TODO error
					}
					break;
				case "Path":
					//calculate scaling delta
					//TODO what if oldWidth == 0?
					var widthDelta = (this.oldWidth === 0) ? 0 : this.width / this.oldWidth;
					var heightDelta = (this.oldHeight === 0) ? 0 : this.height / this.oldHeight;
	
					//use path parser to edit each point of the path
					this.editPathHandler.init(this.x, this.y, this.oldX, this.oldY, widthDelta, heightDelta);
					this.editPathParser.parsePath(this.element);
	
					//change d attribute of path
					this.element.setAttributeNS(null, "d", this.editPathHandler.d);
					break;
			}

			this.oldX = this.x;
			this.oldY = this.y;
			this.oldWidth = this.width;
			this.oldHeight = this.height;
		}
	},
	
	isPointIncluded: function(pointX, pointY) {

		// Check if there are the right arguments and if the node is visible
		if(!pointX || !pointY || !this.isVisible()) {
			return false;
		}

		switch(this.type) {
			case "Rect":
				return (pointX >= this.x && pointX <= this.x + this.width &&
						pointY >= this.y && pointY <= this.y+this.height);
				break;
			case "Circle":
				//calculate the radius
//				var r;
//				if(this.width/this.oldWidth <= this.height/this.oldHeight) {
//					r = ((this.width > this.height) ? this.width : this.height)/2.0;
//				} else {
//				 	r = ((this.width < this.height) ? this.width : this.height)/2.0;
//				}
				return ORYX.Core.Math.isPointInEllipse(pointX, pointY, this.x + this.width/2.0, this.y + this.height/2.0, this.radiusX, this.radiusX);
				break;
			case "Ellipse":
				return ORYX.Core.Math.isPointInEllipse(pointX, pointY, this.x + this.radiusX, this.y + this.radiusY, this.radiusX, this.radiusY);			
				break;
			case "Line":
				return ORYX.Core.Math.isPointInLine(pointX, pointY, this.x, this.y, this.x + this.width, this.y + this.height);
				break;
			case "Polyline":
				var points = this.element.getAttributeNS(null, "points");
	
				if(points) {
					points = points.replace(/,/g , " ").split(" ").without("");
	
					points = points.collect(function(n) {
						return parseFloat(n);
					});
					
					return ORYX.Core.Math.isPointInPolygone(pointX, pointY, points);
				} else {
					return false;
				}
				break;
			case "Path":
				var parser = new PathParser();
				var handler = new ORYX.Core.SVG.PointsPathHandler();
				parser.setHandler(handler);
				parser.parsePath(this.element);
	
				return ORYX.Core.Math.isPointInPolygone(pointX, pointY, handler.points);

				break;
			default:
				return false;
		}
	},

	/**
	 * Returns true if the element is visible
	 * @param {SVGElement} elem
	 * @return boolean
	 */
	isVisible: function(elem) {
			
		if (!elem) {
			elem = this.element;
		}

		var hasOwnerSVG = false;
		try { 
			hasOwnerSVG = !!elem.ownerSVGElement;
		} catch(e){}
		
		if ( hasOwnerSVG ) {
			if (ORYX.Editor.checkClassType(elem, SVGGElement)) {
				if (elem.className && elem.className.baseVal == "me") 
					return true;
			}

			var fill = elem.getAttributeNS(null, "fill");
			var stroke = elem.getAttributeNS(null, "stroke");
			if (fill && fill == "none" && stroke && stroke == "none") {
				return false;
			}
			var attr = elem.getAttributeNS(null, "display");
			if(!attr)
				return this.isVisible(elem.parentNode);
			else if (attr == "none") 
				return false;
			else {
				return true;
			}
		}

		return true;
	},

	toString: function() { return (this.element) ? "SVGShape " + this.element.id : "SVGShape " + this.element;}
 });/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.SVG) {ORYX.Core.SVG = {};}

/**
 * @classDescription Class for adding text to a shape.
 * 
 */
ORYX.Core.SVG.Label = Clazz.extend({
	
	_characterSets:[
		"%W",
		"@",
		"m",
		"wDGMOQÖ#+=<>~^",
		"ABCHKNRSUVXZÜÄ&",
		"bdghnopquxöüETY1234567890ß_§${}*´`µ€",
		"aeksvyzäFLP?°²³",
		"c-",
		"rtJ\"/()[]:;!|\\",
		"fjI., ",
		"'",
		"il"
		],
	_characterSetValues:[15,14,13,11,10,9,8,7,6,5,4,3],

	/**
	 * Constructor
	 * @param options {Object} :
	 * 	textElement
	 * 
	 */
	construct: function(options) {
		arguments.callee.$.construct.apply(this, arguments);
		
		if(!options.textElement) {
			throw "Label: No parameter textElement." 
		} else if (!ORYX.Editor.checkClassType( options.textElement, SVGTextElement ) ) {
			throw "Label: Parameter textElement is not an SVGTextElement."	
		}
		
		this.invisibleRenderPoint = -5000;
		
		this.node = options.textElement;
		
		
		this.node.setAttributeNS(null, 'stroke-width', '0pt');
		this.node.setAttributeNS(null, 'letter-spacing', '-0.01px');
		
		this.shapeId = options.shapeId;
		
		this.id;
		
		this.fitToElemId;
		
		this.edgePosition;
		
		this.x;
		this.y;
		this.oldX;
		this.oldY;
		
		this.isVisible = true;
		
		this._text;
		this._verticalAlign;
		this._horizontalAlign;
		this._rotate;
		this._rotationPoint;
		
		//this.anchors = [];
		this.anchorLeft;
		this.anchorRight;
		this.anchorTop;
		this.anchorBottom;
		
		this._isChanged = true;

		//if the text element already has an id, don't change it.
		var _id = this.node.getAttributeNS(null, 'id');
		if(_id) {
			this.id = _id;
		}
		
		//initialization	
		
		//set referenced element the text is fit to
		this.fitToElemId = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'fittoelem');
		if(this.fitToElemId)
			this.fitToElemId = this.shapeId + this.fitToElemId;
		
		//set alignment	
		var alignValues = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'align');
		if(alignValues) {
			alignValues = alignValues.replace(/,/g, " ");
			alignValues = alignValues.split(" ");
			alignValues = alignValues.without("");
			
			alignValues.each((function(alignValue) {
				switch (alignValue) {
					case 'top':
					case 'middle':
					case 'bottom':
						if(!this._verticalAlign) {this._verticalAlign = alignValue;}
						break;
					case 'left':
					case 'center':
					case 'right':
						if(!this._horizontalAlign) {this._horizontalAlign = alignValue;}
						break;
				}
			}).bind(this));
		}
		
		//set edge position (only in case the label belongs to an edge)
		this.edgePosition = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'edgePosition');
		if(this.edgePosition) {
			this.edgePosition = this.edgePosition.toLowerCase();
		}
		
		
		//get offset top
		this.offsetTop = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'offsetTop') || ORYX.CONFIG.OFFSET_EDGE_LABEL_TOP;
		if(this.offsetTop) {
			this.offsetTop = parseInt(this.offsetTop);
		}
		
		//get offset top
		this.offsetBottom = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'offsetBottom') || ORYX.CONFIG.OFFSET_EDGE_LABEL_BOTTOM;
		if(this.offsetBottom) {
			this.offsetBottom = parseInt(this.offsetBottom);
		}
		
				
		//set rotation
		var rotateValue = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'rotate');
		if(rotateValue) {
			try {
				this._rotate = parseFloat(rotateValue);
			} catch (e) {
				this._rotate = 0;
			}
		} else {
			this._rotate = 0;
		}
		
		//anchors
		var anchorAttr = this.node.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "anchors");
		if(anchorAttr) {
			anchorAttr = anchorAttr.replace("/,/g", " ");
			var anchors = anchorAttr.split(" ").without("");
			
			for(var i = 0; i < anchors.length; i++) {
				switch(anchors[i].toLowerCase()) {
					case "left":
						this.anchorLeft = true;
						break;
					case "right":
						this.anchorRight = true;
						break;
					case "top":
						this.anchorTop = true;
						break;
					case "bottom":
						this.anchorBottom = true;
						break;
				}
			}
		}
		
		//if no alignment defined, set default alignment
		if(!this._verticalAlign) { this._verticalAlign = 'bottom'; }
		if(!this._horizontalAlign) { this._horizontalAlign = 'left'; }

		var xValue = this.node.getAttributeNS(null, 'x');
		if(xValue) {
			this.x = parseFloat(xValue);
			this.oldX = this.x;
		} else {
			//TODO error
		}
		
		var yValue = this.node.getAttributeNS(null, 'y');
		if(yValue) {
			this.y = parseFloat(yValue);
			this.oldY = this.y;
		} else {
			//TODO error
		}
		
		//set initial text
		this.text(this.node.textContent);
	},
	
	changed: function() {
		this._isChanged = true;
	},
	
	/**
	 * Update the SVG text element.
	 */
	update: function() {
		if(this._isChanged || this.x !== this.oldX || this.y !== this.oldY) {
			if (this.isVisible) {
				this._isChanged = false;
				
				this.node.setAttributeNS(null, 'x', this.x);
				this.node.setAttributeNS(null, 'y', this.y);
				
				//this.node.setAttributeNS(null, 'font-size', this._fontSize);
				//this.node.setAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, 'align', this._horizontalAlign + " " + this._verticalAlign);
				
				//set horizontal alignment
				switch (this._horizontalAlign) {
					case 'left':
						this.node.setAttributeNS(null, 'text-anchor', 'start');
						break;
					case 'center':
						this.node.setAttributeNS(null, 'text-anchor', 'middle');
						break;
					case 'right':
						this.node.setAttributeNS(null, 'text-anchor', 'end');
						break;
				}
				
				this.oldX = this.x;
				this.oldY = this.y;
				
				//set rotation
				if (this._rotate !== undefined) {
					if (this._rotationPoint) 
						this.node.setAttributeNS(null, 'transform', 'rotate(' + this._rotate + ' ' + this._rotationPoint.x + ' ' + this._rotationPoint.y + ')');
					else 
						this.node.setAttributeNS(null, 'transform', 'rotate(' + this._rotate + ' ' + this.x + ' ' + this.y + ')');
				}
				
				var textLines = this._text.split("\n");
				while (textLines.last() == "") 
					textLines.pop();
				
				this.node.textContent = "";
				
				if (this.node.ownerDocument) {
					textLines.each((function(textLine, index){
						var tspan = this.node.ownerDocument.createElementNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
						tspan.textContent = textLine;
						tspan.setAttributeNS(null, 'x', this.invisibleRenderPoint);
						tspan.setAttributeNS(null, 'y', this.invisibleRenderPoint);
						
						/*
						 * Chrome's getBBox() method fails, if a text node contains an empty tspan element.
						 * So, we add a whitespace to such a tspan element.
						 */
						if(tspan.textContent === "") {
							tspan.textContent = " ";
						}
						
						//append tspan to text node
						this.node.appendChild(tspan);
					}).bind(this));
					
					//Work around for Mozilla bug 293581
					if (this.isVisible) {
						this.node.setAttributeNS(null, 'visibility', 'hidden');
					}
					
					if (this.fitToElemId) 
						window.setTimeout(this._checkFittingToReferencedElem.bind(this), 0);
					else 
						window.setTimeout(this._positionText.bind(this), 0);
				}
			} else {
				this.node.textContent = "";
			}
		}
	},
	
	_checkFittingToReferencedElem: function() {
		try {
			var tspans = $A(this.node.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan'));
			
			//only do this in firefox 3. all other browsers do not support word wrapping!!!!!
			//if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent) && new Number(RegExp.$1)>=3) {
				var newtspans = [];
				
				var refNode = this.node.ownerDocument.getElementById(this.fitToElemId);
				
				if (refNode) {
				
					var refbb = refNode.getBBox();
					
					var fontSize = this.getFontSize();
					
					for (var j = 0; j < tspans.length; j++) {
						var tspan = tspans[j];
						
						var textLength = this._getRenderedTextLength(tspan, undefined, undefined, fontSize);
						
						/* Depending on the rotation of the text element, take
						 * the width or height as reference respectively. */
						var refBoxLength = (this._rotate != 0 
								&& this._rotate % 180 != 0 
								&& this._rotate % 90 == 0 ? 
										refbb.height : refbb.width);
						
						if (textLength > refBoxLength) {
						
							var startIndex = 0;
							var lastSeperatorIndex = 0;
							
							var numOfChars = this.getTrimmedTextLength(tspan.textContent);
							for (var i = 0; i < numOfChars; i++) {
								var sslength = this._getRenderedTextLength(tspan, startIndex, i-startIndex, fontSize);
								
								if (sslength > refBoxLength - 3) {
									var newtspan = this.node.ownerDocument.createElementNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
									if (lastSeperatorIndex <= startIndex) {
										lastSeperatorIndex = (i == 0) ? i : i-1;
										newtspan.textContent = tspan.textContent.slice(startIndex, lastSeperatorIndex);
										//lastSeperatorIndex = i;
									}
									else {
										newtspan.textContent = tspan.textContent.slice(startIndex, ++lastSeperatorIndex);
									}
									
									newtspan.setAttributeNS(null, 'x', this.invisibleRenderPoint);
									newtspan.setAttributeNS(null, 'y', this.invisibleRenderPoint);
									
									//insert tspan to text node
									//this.node.insertBefore(newtspan, tspan);
									newtspans.push(newtspan);
									
									startIndex = lastSeperatorIndex;
									
								}
								else {
									var curChar = tspan.textContent.charAt(i);
									if (curChar == ' ' ||
									curChar == '-' ||
									curChar == "." ||
									curChar == "," ||
									curChar == ";" ||
									curChar == ":") {
										lastSeperatorIndex = i;
									}
								}
							}
							
							tspan.textContent = tspan.textContent.slice(startIndex);
						}
						
						newtspans.push(tspan);
					}
					
					while (this.node.hasChildNodes()) 
						this.node.removeChild(this.node.childNodes[0]);
					
					while (newtspans.length > 0) {
						this.node.appendChild(newtspans.shift());
					}
				}
			//}
		} catch (e) {
			//console.log(e);
		}
		
		window.setTimeout(this._positionText.bind(this), 0);
	},
	
	/**
	 * This is a work around method for Mozilla bug 293581.
	 * Before the method getComputedTextLength works, the text has to be rendered.
	 */
	_positionText: function() {
		try {
			var tspans = this.node.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
			
			var fontSize = this.getFontSize(this.node); 
			
			var invalidTSpans = [];
			
			$A(tspans).each((function(tspan, index){
				
				if(tspan.textContent.trim() === "") {
					invalidTSpans.push(tspan);
				} else {
					//set vertical position
					var dy = 0;
					switch (this._verticalAlign) {
						case 'bottom':
							dy = -(tspans.length - index - 1) * (fontSize);
							break;
						case 'middle':
							dy = -(tspans.length / 2.0 - index - 1) * (fontSize);
							dy -= ORYX.CONFIG.LABEL_LINE_DISTANCE / 2;
							break;
						case 'top':
							dy = index * (fontSize);
							dy += fontSize;
							break;
					}
					
					tspan.setAttributeNS(null, 'dy', dy);
					
					tspan.setAttributeNS(null, 'x', this.x);
					tspan.setAttributeNS(null, 'y', this.y);
				}
				
			}).bind(this));
			
			invalidTSpans.each(function(tspan) {
				this.node.removeChild(tspan)
			}.bind(this));
			
		} catch(e) {
			//console.log(e);
			this._isChanged = true;
		}
		
		
		if(this.isVisible) {
			this.node.setAttributeNS(null, 'visibility', 'inherit');
		}				
	},
	
	/**
	 * Returns the text length of the text content of an SVG tspan element.
	 * For all browsers but Firefox 3 the values are estimated.
	 * @param {TSpanSVGElement} tspan
	 * @param {int} startIndex Optional, for sub strings
	 * @param {int} endIndex Optional, for sub strings
	 */
	_getRenderedTextLength: function(tspan, startIndex, endIndex, fontSize) {
		if (/Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent) && new Number(RegExp.$1) >= 3) {
			if(startIndex === undefined) {
//test string: abcdefghijklmnopqrstuvwxyzöäü,.-#+ 1234567890ßABCDEFGHIJKLMNOPQRSTUVWXYZ;:_'*ÜÄÖ!"§$%&/()=?[]{}|<>'~´`\^°µ@€²³
//				for(var i = 0; i < tspan.textContent.length; i++) {
//					console.log(tspan.textContent.charAt(i), tspan.getSubStringLength(i,1), this._estimateCharacterWidth(tspan.textContent.charAt(i))*(fontSize/14.0));
//				}
				return tspan.getComputedTextLength();
			} else {
				return tspan.getSubStringLength(startIndex, endIndex);
			}
		} else {
			if(startIndex === undefined) {
				return this._estimateTextWidth(tspan.textContent, fontSize);
			} else {
				return this._estimateTextWidth(tspan.textContent.substr(startIndex, endIndex).trim(), fontSize);
			}
		}
	},
	
	/**
	 * Estimates the text width for a string.
	 * Used for word wrapping in all browser but FF3.
	 * @param {Object} text
	 */
	_estimateTextWidth: function(text, fontSize) {
		var sum = 0.0;
		for(var i = 0; i < text.length; i++) {
			sum += this._estimateCharacterWidth(text.charAt(i));
		}
		
		return sum*(fontSize/14.0);
	},
	
	/**
	 * Estimates the width of a single character for font size 14.
	 * Used for word wrapping in all browser but FF3.
	 * @param {Object} character
	 */
	_estimateCharacterWidth: function(character) {
		for(var i = 0; i < this._characterSets.length; i++) {
 			if(this._characterSets[i].indexOf(character) >= 0) {
				return this._characterSetValues[i];
			}
 		}	
		return 9;
 	},
	
	getReferencedElementWidth: function() {
		var refNode = this.node.ownerDocument.getElementById(this.fitToElemId);
				
		if (refNode) {
			var refbb = refNode.getBBox();
			if(refbb) {
				return refbb.width;
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	},
	
	/**
	 * If no parameter is provided, this method returns the current text.
	 * @param text {String} Optional. Replaces the old text with this one.
	 */
	text: function() {
		switch (arguments.length) {
			case 0:
				return this._text
				break;
			
			case 1:
				var oldText = this._text;
				if(arguments[0]) {
					this._text = arguments[0].toString();
				} else {
					this._text = "";
				}
				if(oldText !== this._text) {
					this._isChanged = true;
				}
				break;
				
			default: 
				//TODO error
				break;
		}
	},
	
	verticalAlign: function() {
		switch(arguments.length) {
			case 0:
				return this._verticalAlign;
			case 1:
				if(['top', 'middle', 'bottom'].member(arguments[0])) {
					var oldValue = this._verticalAlign;
					this._verticalAlign = arguments[0];
					if(this._verticalAlign !== oldValue) {
						this._isChanged = true;
					}
				}
				break;
				
			default:
				//TODO error
				break;
		}
	},
	
	horizontalAlign: function() {
		switch(arguments.length) {
			case 0:
				return this._horizontalAlign;
			case 1:
				if(['left', 'center', 'right'].member(arguments[0])) {
					var oldValue = this._horizontalAlign;
					this._horizontalAlign = arguments[0];
					if(this._horizontalAlign !== oldValue) {
						this._isChanged = true;
					}	
				}
				break;
				
			default:
				//TODO error
				break;
		}
	},
	
	rotate: function() {
		switch(arguments.length) {
			case 0:
				return this._rotate;
			case 1:
				if (this._rotate != arguments[0]) {
					this._rotate = arguments[0];
					this._rotationPoint = undefined;
					this._isChanged = true;
				}
			case 2:
				if(this._rotate != arguments[0] ||
				   !this._rotationPoint ||
				   this._rotationPoint.x != arguments[1].x ||
				   this._rotationPoint.y != arguments[1].y) {
					this._rotate = arguments[0];
					this._rotationPoint = arguments[1];
					this._isChanged = true;
				}
				
		}
	},
	
	hide: function() {
		if(this.isVisible) {
			this.isVisible = false;
			this._isChanged = true;
		}
	},
	
	show: function() {
		if(!this.isVisible) {
			this.isVisible = true;
			this._isChanged = true;
		}
	},
	
	/**
	 * iterates parent nodes till it finds a SVG font-size
	 * attribute.
	 * @param {SVGElement} node
	 */
	getInheritedFontSize: function(node) {
		if(!node || !node.getAttributeNS)
			return;
			
		var attr = node.getAttributeNS(null, "font-size");
		if(attr) {
			return parseFloat(attr);
		} else if(!ORYX.Editor.checkClassType(node, SVGSVGElement)) {
			return this.getInheritedFontSize(node.parentNode);
		}
	},
	
	getFontSize: function(node) {
		var tspans = this.node.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan');
			
		//trying to get an inherited font-size attribute
		//NO CSS CONSIDERED!
		var fontSize = this.getInheritedFontSize(this.node); 
		
		if (!fontSize) {
			//because this only works in firefox 3, all other browser use the default line height
			if (tspans[0] && /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent) && new Number(RegExp.$1) >= 3) {
				fontSize = tspans[0].getExtentOfChar(0).height;
			}
			else {
				fontSize = ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT;
			}
			
			//handling of unsupported method in webkit
			if (fontSize <= 0) {
				fontSize = ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT;
			}
		}
		
		if(fontSize)
			this.node.setAttribute("oryx:fontSize", fontSize);
		
		return fontSize;
	},
	
	/**
	 * Get trimmed text length for use with
	 * getExtentOfChar and getSubStringLength.
	 * @param {String} text
	 */
	getTrimmedTextLength: function(text) {
		text = text.strip().gsub('  ', ' ');
		
		var oldLength;
		do {
			oldLength = text.length;
			text = text.gsub('  ', ' ');
		} while (oldLength > text.length);

		return text.length;
	},
	
	/**
	 * Returns the offset from
	 * edge to the label which is 
	 * positioned under the edge
	 * @return {int}
	 */
	getOffsetBottom: function(){
		return this.offsetBottom;
	},
	
		
	/**
	 * Returns the offset from
	 * edge to the label which is 
	 * positioned over the edge
	 * @return {int}
	 */
	getOffsetTop: function(){
		return this.offsetTop;
	},
	
	toString: function() { return "Label " + this.id }
 });/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}if(!ORYX.Core.Math) {ORYX.Core.Math = {};}	/** * Calculate the middle point between two given points * @param {x:double, y:double} point1 * @param {x:double, y:double} point2 * @return the middle point */ORYX.Core.Math.midPoint = function(point1, point2) {	return 	{				x: (point1.x + point2.x) / 2.0,				y: (point1.y + point2.y) / 2.0			}}			/** * Returns a TRUE if the point is over a line (defined by * point1 and point 2). In Addition a threshold can be set, * which defines the weight of those line. *  * @param {int} pointX - Point X * @param {int} pointY - Point Y * @param {int} lPoint1X - Line first Point X * @param {int} lPoint1Y - Line first Point Y * @param {int} lPoint2X - Line second Point X * @param {int} lPoint2Y - Line second Point y * @param {int} offset {optional} - maximal distance to line * @class ORYX.Core.Math.prototype */ORYX.Core.Math.isPointInLine = function (pointX, pointY, lPoint1X, lPoint1Y, lPoint2X, lPoint2Y, offset) {	offset = offset ? Math.abs(offset) : 1;		// Check if the edge is vertical	if(Math.abs(lPoint1X-lPoint2X)<=offset && Math.abs(pointX-lPoint1X)<=offset && pointY-Math.max(lPoint1Y, lPoint2Y)<=offset && Math.min(lPoint1Y, lPoint2Y)-pointY<=offset) {		return true	}	// Check if the edge is horizontal	if(Math.abs(lPoint1Y-lPoint2Y)<=offset && Math.abs(pointY-lPoint1Y)<=offset && pointX-Math.max(lPoint1X, lPoint2X)<=offset && Math.min(lPoint1X, lPoint2X)-pointX<=offset) {		return true	}	if(pointX > Math.max(lPoint1X, lPoint2X) || pointX < Math.min(lPoint1X, lPoint2X)) {		return false	}	if(pointY > Math.max(lPoint1Y, lPoint2Y) || pointY < Math.min(lPoint1Y, lPoint2Y)) {		return false	}				var s = (lPoint1Y - lPoint2Y) / (lPoint1X - lPoint2X);		return 	Math.abs(pointY - ((s * pointX) + lPoint1Y - s * lPoint1X)) < offset}/** * Get a boolean if the point is in the polygone *  */ORYX.Core.Math.isPointInEllipse = function (pointX, pointY, cx, cy, rx, ry) {	if(cx === undefined || cy === undefined || rx === undefined || ry === undefined) {		throw "ORYX.Core.Math.isPointInEllipse needs a ellipse with these properties: x, y, radiusX, radiusY"	} 	    var tx = (pointX - cx) / rx;    var ty = (pointY - cy) / ry;	    return tx * tx + ty * ty < 1.0;}	/** * Get a boolean if the point is in the polygone * @param {int} pointX * @param {int} pointY * @param {[int]} Cornerpoints of the Polygone (x,y,x,y,...) */ORYX.Core.Math.isPointInPolygone = function(pointX, pointY, polygone){	if (arguments.length < 3) {		throw "ORYX.Core.Math.isPointInPolygone needs two arguments"	}		var lastIndex = polygone.length-1;		if (polygone[0] !== polygone[lastIndex - 1] || polygone[1] !== polygone[lastIndex]) {		polygone.push(polygone[0]);		polygone.push(polygone[1]);	}		var crossings = 0;	var x1, y1, x2, y2, d;	    for (var i = 0; i < polygone.length - 3; ) {        x1=polygone[i];        y1=polygone[++i];        x2=polygone[++i];        y2=polygone[i+1];        d=(pointY - y1) * (x2 - x1) - (pointX - x1) * (y2 - y1);        if ((y1 >= pointY) != (y2 >= pointY)) {            crossings += y2 - y1 >= 0 ? d >= 0 : d <= 0;        }        if (!d && Math.min(x1,x2) <= pointX && pointX <= Math.max(x1,x2)            && Math.min(y1,y2) <= pointY && pointY <= Math.max(y1,y2)) {            return true;        }    }	return (crossings%2)?true:false;}/** *	Calculates the distance between a point and a line. It is also testable, if  *  the distance orthogonal to the line, matches the segment of the line. *   *  @param {float} lineP1 *  	The starting point of the line segment *  @param {float} lineP2 *  	The end point of the line segment *  @param {Point} point *  	The point to calculate the distance to. *  @param {boolean} toSegmentOnly *  	Flag to signal if only the segment of the line shell be evaluated. */ORYX.Core.Math.distancePointLinie = function(									lineP1, 									lineP2, 									point, 									toSegmentOnly) {		var intersectionPoint = 				ORYX.Core.Math.getPointOfIntersectionPointLine(lineP1, 																lineP2, 																point, 																toSegmentOnly);		if(!intersectionPoint) {		return null;	}		return ORYX.Core.Math.getDistancePointToPoint(point, intersectionPoint);};/** * Calculates the distance between two points. *  * @param {point} point1 * @param {point} point2 */ORYX.Core.Math.getDistancePointToPoint = function(point1, point2) {	return Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));};/** * Returns the intersection point of a line and a point that defines a line * orthogonal to the given line. *  *  @param {float} lineP1 *  	The starting point of the line segment *  @param {float} lineP2 *  	The end point of the line segment *  @param {Point} point *  	The point to calculate the distance to. *  @param {boolean} onSegmentOnly *  	Flag to signal if only the segment of the line shell be evaluated. */ORYX.Core.Math.getPointOfIntersectionPointLine = function(													lineP1, 													lineP2, 													point, 													onSegmentOnly) {	/* 	 * [P3 - P1 - u(P2 - P1)] dot (P2 - P1) = 0	 * u =((x3-x1)(x2-x1)+(y3-y1)(y2-y1))/(p2-p1)²	 */	var denominator = Math.pow(lineP2.x - lineP1.x, 2) 						+ Math.pow(lineP2.y - lineP1.y, 2);	if(denominator == 0) {		return undefined;	}		var u = ((point.x - lineP1.x) * (lineP2.x - lineP1.x)  			+ (point.y - lineP1.y) * (lineP2.y - lineP1.y))			/ denominator;				if(onSegmentOnly) {		if (!(0 <= u && u <= 1)) {			return undefined;		}	}		pointOfIntersection = new Object();	pointOfIntersection.x = lineP1.x + u * (lineP2.x - lineP1.x);	pointOfIntersection.y = lineP1.y + u * (lineP2.y - lineP1.y);			return pointOfIntersection;												};/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespace
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Stencil
 * uses Prototpye 1.5.0
 * uses Inheritance
 * 
 * This class represents one stencil of a stencil set.
 */
ORYX.Core.StencilSet.Stencil = {

	/**
	 * Constructor
	 */
	construct: function(jsonStencil, namespace, source, stencilSet, propertyPackages, defaultPosition) {
		arguments.callee.$.construct.apply(this, arguments); // super();
		
		// check arguments and set defaults.
		if(!jsonStencil) throw "Stencilset seems corrupt.";
		if(!namespace) throw "Stencil does not provide namespace.";
		if(!source) throw "Stencil does not provide SVG source.";
		if(!stencilSet) throw "Fatal internal error loading stencilset.";
		//if(!propertyPackages) throw "Fatal internal error loading stencilset.";
		
		this._source = source;
		this._jsonStencil = jsonStencil;
		this._stencilSet = stencilSet;
		this._namespace = namespace;
		this._propertyPackages = propertyPackages;
		
		if(defaultPosition && !this._jsonStencil.position) 
			this._jsonStencil.position = defaultPosition;
		
		this._view;
		this._properties = new Hash();

		// check stencil consistency and set defaults.
		/*with(this._jsonStencil) {
			
			if(!type) throw "Stencil does not provide type.";
			if((type != "edge") && (type != "node"))
				throw "Stencil type must be 'edge' or 'node'.";
			if(!id || id == "") throw "Stencil does not provide valid id.";
			if(!title || title == "")
				throw "Stencil does not provide title";
			if(!description) { description = ""; };
			if(!groups) { groups = []; }
			if(!roles) { roles = []; }

			// add id of stencil to its roles
			roles.push(id);
		}*/
		
		//init all JSON values
		if(!this._jsonStencil.type || !(this._jsonStencil.type === "edge" || this._jsonStencil.type === "node")) {
			throw "ORYX.Core.StencilSet.Stencil(construct): Type is not defined.";
		}
		if(!this._jsonStencil.id || this._jsonStencil.id === "") {
			throw "ORYX.Core.StencilSet.Stencil(construct): Id is not defined.";
		}
		if(!this._jsonStencil.title || this._jsonStencil.title === "") {
			throw "ORYX.Core.StencilSet.Stencil(construct): Title is not defined.";
		}

		if(!this._jsonStencil.description) { this._jsonStencil.description = ""; };
		if(!this._jsonStencil.groups) { this._jsonStencil.groups = []; }
		if(!this._jsonStencil.roles) { this._jsonStencil.roles = []; }
		
		//add id of stencil to its roles
		this._jsonStencil.roles.push(this._jsonStencil.id);

		//prepend namespace to each role
		this._jsonStencil.roles.each((function(role, index) {
			this._jsonStencil.roles[index] = namespace + role;
		}).bind(this));

		//delete duplicate roles
		this._jsonStencil.roles = this._jsonStencil.roles.uniq();

		//make id unique by prepending namespace of stencil set
		this._jsonStencil.id = namespace + this._jsonStencil.id;

		this.postProcessProperties();
		
		// init serialize callback
		if(!this._jsonStencil.serialize) {
			this._jsonStencil.serialize = {};
			//this._jsonStencil.serialize = function(shape, data) { return data;};
		}
		
		// init deserialize callback
		if(!this._jsonStencil.deserialize) {
			this._jsonStencil.deserialize = {};
			//this._jsonStencil.deserialize = function(shape, data) { return data;};
		}
		
		// init layout callback
		if(!this._jsonStencil.layout) {
			this._jsonStencil.layout = []
			//this._jsonStencil.layout = function() {return true;}
		}
		
		//TODO does not work correctly, if the url does not exist
		//How to guarantee that the view is loaded correctly before leaving the constructor???
		var url = source + "view/" + jsonStencil.view;
		// override content type when this is webkit.
		
		/*
		if(Prototype.Browser.WebKit) {
			
			var req = new XMLHttpRequest;
			req.open("GET", url, false);
			req.overrideMimeType('text/xml');
			req.send(null);
			req.onload = (function() { _loadSVGOnSuccess(req.responseXML); }).bind(this);

		// else just do it.
		} else
		*/
		
		if(this._jsonStencil.view.trim().match(/</)) {
			var parser	= new DOMParser();		
			var xml 	= parser.parseFromString( this._jsonStencil.view ,"text/xml");
			
			//check if result is a SVG document
			if( ORYX.Editor.checkClassType( xml.documentElement, SVGSVGElement )) {
	
				this._view = xml.documentElement;
				
				//updating link to images
				var imageElems = this._view.getElementsByTagNameNS("http://www.w3.org/2000/svg", "image");
				$A(imageElems).each((function(imageElem) {
					var link = imageElem.getAttributeNodeNS("http://www.w3.org/1999/xlink", "href");
					if(link && link.value.indexOf("://") == -1) {
						link.textContent = this._source + "view/" + link.value;
					}
				}).bind(this));
			} else {
				throw "ORYX.Core.StencilSet.Stencil(_loadSVGOnSuccess): The response is not a SVG document."
			}
		} else {
			new Ajax.Request(
				url, {
					asynchronous:false, method:'get',
					onSuccess:this._loadSVGOnSuccess.bind(this),
					onFailure:this._loadSVGOnFailure.bind(this)
			});
		}
	},

	postProcessProperties: function() {

		// add image path to icon
		if(this._jsonStencil.icon && this._jsonStencil.icon.indexOf("://") === -1) {
			this._jsonStencil.icon = this._source + "icons/" + this._jsonStencil.icon;
		} else {
			this._jsonStencil.icon = "";
		}
	
		// init property packages
		if(this._jsonStencil.propertyPackages && this._jsonStencil.propertyPackages instanceof Array) {
			this._jsonStencil.propertyPackages.each((function(ppId) {
				var pp = this._propertyPackages[ppId];
				
				if(pp) {
					pp.each((function(prop){
						var oProp = new ORYX.Core.StencilSet.Property(prop, this._namespace, this);
						this._properties[oProp.prefix() + "-" + oProp.id()] = oProp;
					}).bind(this));
				}
			}).bind(this));
		}
		
		// init properties
		if(this._jsonStencil.properties && this._jsonStencil.properties instanceof Array) {
			this._jsonStencil.properties.each((function(prop) {
				var oProp = new ORYX.Core.StencilSet.Property(prop, this._namespace, this);
				this._properties[oProp.prefix() + "-" + oProp.id()] = oProp;
			}).bind(this));
		}
		

	},

	/**
	 * @param {ORYX.Core.StencilSet.Stencil} stencil
	 * @return {Boolean} True, if stencil has the same namespace and type.
	 */
	equals: function(stencil) {
		return (this.id() === stencil.id());
	},

	stencilSet: function() {
		return this._stencilSet;
	},

	type: function() {
		return this._jsonStencil.type;
	},

	namespace: function() {
		return this._namespace;
	},

	id: function() {
		return this._jsonStencil.id;
	},
    
    idWithoutNs: function(){
        return this.id().replace(this.namespace(),"");
    },

	title: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonStencil, "title");
	},

	description: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonStencil, "description");
	},
	
	groups: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonStencil, "groups");
	},
	
	position: function() {
		return (isNaN(this._jsonStencil.position) ? 0 : this._jsonStencil.position);
	},

	view: function() {
		return this._view.cloneNode(true) || this._view;
	},

	icon: function() {
		return this._jsonStencil.icon;
	},
	
	fixedAspectRatio: function() {
		return this._jsonStencil.fixedAspectRatio === true;
	},
	
	hasMultipleRepositoryEntries: function() {
		return (this.getRepositoryEntries().length > 0);
	},
	
	getRepositoryEntries: function() {
		return (this._jsonStencil.repositoryEntries) ?
			$A(this._jsonStencil.repositoryEntries) : $A([]);
	},
	
	properties: function() {
		return this._properties.values();
	},

	property: function(id) {
		return this._properties[id];
	},

	roles: function() {
		return this._jsonStencil.roles;
	},
	
	defaultAlign: function() {
		if(!this._jsonStencil.defaultAlign)
			return "east";
		return this._jsonStencil.defaultAlign;
	},

	serialize: function(shape, data) {
		return this._jsonStencil.serialize;
		//return this._jsonStencil.serialize(shape, data);
	},
	
	deserialize: function(shape, data) {
		return this._jsonStencil.deserialize;
		//return this._jsonStencil.deserialize(shape, data);
	},
	
	// in which case is targetShape used?
//	layout: function(shape, targetShape) {
//		return this._jsonStencil.layout(shape, targetShape);
//	},
	// layout property to store events for layouting in plugins
	layout: function(shape) {
		return this._jsonStencil.layout
	},
	
	addProperty: function(property, namespace) {
		if(property && namespace) {
			var oProp = new ORYX.Core.StencilSet.Property(property, namespace, this);
			this._properties[oProp.prefix() + "-" + oProp.id()] = oProp;
		}
	},
	
	removeProperty: function(propertyId) {
		if(propertyId) {
			var oProp = this._properties.values().find(function(prop) {
				return (propertyId == prop.id());
			});
			if(oProp)
				delete this._properties[oProp.prefix() + "-" + oProp.id()];
		}
	},

	_loadSVGOnSuccess: function(result) {
		
		var xml = null;
		
		/*
		 * We want to get a dom object for the requested file. Unfortunately,
		 * safari has some issues here. this is meant as a fallback for all
		 * browsers that don't recognize the svg mimetype as XML but support
		 * data: urls on Ajax calls.
		 */
		
		// responseXML != undefined.
		// if(!(result.responseXML))
		
			// get the dom by data: url.
			// xml = _evenMoreEvilHack(result.responseText, 'text/xml');
		
		// else
		
			// get it the usual way.
			xml = result.responseXML;

		//check if result is a SVG document
		if( ORYX.Editor.checkClassType( xml.documentElement, SVGSVGElement )) {

			this._view = xml.documentElement;
			
			//updating link to images
			var imageElems = this._view.getElementsByTagNameNS("http://www.w3.org/2000/svg", "image");
			$A(imageElems).each((function(imageElem) {
				var link = imageElem.getAttributeNodeNS("http://www.w3.org/1999/xlink", "href");
				if(link && link.value.indexOf("://") == -1) {
					link.textContent = this._source + "view/" + link.value;
				}
			}).bind(this));
		} else {
			throw "ORYX.Core.StencilSet.Stencil(_loadSVGOnSuccess): The response is not a SVG document."
		}
	},

	_loadSVGOnFailure: function(result) {
		throw "ORYX.Core.StencilSet.Stencil(_loadSVGOnFailure): Loading SVG document failed."
	},

	toString: function() { return "Stencil " + this.title() + " (" + this.id() + ")"; }
};

ORYX.Core.StencilSet.Stencil = Clazz.extend(ORYX.Core.StencilSet.Stencil);

/**
 * Transform a string into an xml document, the Safari way, as long as
 * the nightlies are broken. Even more evil version.
 * @param {Object} str
 * @param {Object} contentType
 */
function _evenMoreEvilHack(str, contentType) {
	
	/*
	 * This even more evil hack was taken from
	 * http://web-graphics.com/mtarchive/001606.php#chatty004999
	 */
	
	if (window.ActiveXObject) {
		var d = new ActiveXObject("MSXML.DomDocument");
		d.loadXML(str);
		return d;
	} else if (window.XMLHttpRequest) {
		var req = new XMLHttpRequest;
		req.open("GET", "data:" + (contentType || "application/xml") +
						";charset=utf-8," + encodeURIComponent(str), false);
		if (req.overrideMimeType) {
			req.overrideMimeType(contentType);
		}
		req.send(null);
		return req.responseXML;
	}
}

/**
 * Transform a string into an xml document, the Safari way, as long as
 * the nightlies are broken.
 * @param {Object} result the xml document object.
 */
function _evilSafariHack(serializedXML) {
	
	/*
	 *  The Dave way. Taken from:
	 *  http://web-graphics.com/mtarchive/001606.php
	 *  
	 *  There is another possibility to parse XML in Safari, by implementing
	 *  the DOMParser in javascript. However, in the latest nightlies of
	 *  WebKit, DOMParser is already available, but still buggy. So, this is
	 *  the best compromise for the time being.
	 */		
	
	var xml = serializedXML;
	var url = "data:text/xml;charset=utf-8," + encodeURIComponent(xml);
	var dom = null;
	
	// your standard AJAX stuff
	var req = new XMLHttpRequest();
	req.open("GET", url);
	req.onload = function() { dom = req.responseXML; }
	req.send(null);
	
	return dom;
}
	
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
/**
 * Init namespace
 */
if (!ORYX) {
    var ORYX = {};
}
if (!ORYX.Core) {
    ORYX.Core = {};
}
if (!ORYX.Core.StencilSet) {
    ORYX.Core.StencilSet = {};
}

/**
 * Class Property
 * uses Prototpye 1.5.0
 * uses Inheritance
 */
ORYX.Core.StencilSet.Property = Clazz.extend({

    /**
     * Constructor
     */
    construct: function(jsonProp, namespace, stencil){
        arguments.callee.$.construct.apply(this, arguments);
        
        this._jsonProp = jsonProp || ORYX.Log.error("Parameter jsonProp is not defined.");
        this._namespace = namespace || ORYX.Log.error("Parameter namespace is not defined.");
        this._stencil = stencil || ORYX.Log.error("Parameter stencil is not defined.");
        
        this._items = new Hash();
        this._complexItems = new Hash();
        
        jsonProp.id = jsonProp.id || ORYX.Log.error("ORYX.Core.StencilSet.Property(construct): Id is not defined.");
		jsonProp.id = jsonProp.id.toLowerCase();
		
        if (!jsonProp.type) {
            ORYX.Log.info("Type is not defined for stencil '%0', id '%1'. Falling back to 'String'.", stencil, jsonProp.id);
            jsonProp.type = "string";
        }
        else {
            jsonProp.type = jsonProp.type.toLowerCase();
        }
        
        jsonProp.prefix = jsonProp.prefix || "oryx";
        jsonProp.title = jsonProp.title || "";
        jsonProp.value = jsonProp.value || "";
        jsonProp.description = jsonProp.description || "";
        jsonProp.readonly = jsonProp.readonly || false;
        if(jsonProp.optional != false)
        	jsonProp.optional = true;
        
        //init refToView
        if (this._jsonProp.refToView) {
            if (!(this._jsonProp.refToView instanceof Array)) {
                this._jsonProp.refToView = [this._jsonProp.refToView];
            }
        }
        else {
            this._jsonProp.refToView = [];
        }
        
        if (jsonProp.min === undefined || jsonProp.min === null) {
            jsonProp.min = Number.MIN_VALUE;
        }
        
        if (jsonProp.max === undefined || jsonProp.max === null) {
            jsonProp.max = Number.MAX_VALUE;
        }
        
        if (!jsonProp.fillOpacity) {
            jsonProp.fillOpacity = false;
        }
        
        if (!jsonProp.strokeOpacity) {
            jsonProp.strokeOpacity = false;
        }
        
        if (jsonProp.length === undefined || jsonProp.length === null) {
            jsonProp.length = Number.MAX_VALUE;
        }
        
        if (!jsonProp.wrapLines) {
            jsonProp.wrapLines = false;
        }
        
        if (!jsonProp.dateFormat) {
            jsonProp.dataFormat = "m/d/y";
        }
        
        if (!jsonProp.fill) {
            jsonProp.fill = false;
        }
        
        if (!jsonProp.stroke) {
            jsonProp.stroke = false;
        }
        
        if(!jsonProp.inverseBoolean) {
        	jsonProp.inverseBoolean = false;
        }
		
		if(!jsonProp.directlyEditable && jsonProp.directlyEditable != false) {
        	jsonProp.directlyEditable = true;
        }
		
		if(jsonProp.visible !== false) {
			jsonProp.visible = true;
		}
		
		if(!jsonProp.popular) {
			jsonProp.popular = false;
		}
        
        if (jsonProp.type === ORYX.CONFIG.TYPE_CHOICE) {
            if (jsonProp.items && jsonProp.items instanceof Array) {
                jsonProp.items.each((function(jsonItem){
                	// why is the item's value used as the key???
                    this._items[jsonItem.value] = new ORYX.Core.StencilSet.PropertyItem(jsonItem, namespace, this);
                }).bind(this));
            }
            else {
                throw "ORYX.Core.StencilSet.Property(construct): No property items defined."
            }
            // extended by Kerstin (start)
        }
        else 
            if (jsonProp.type === ORYX.CONFIG.TYPE_COMPLEX) {
                if (jsonProp.complexItems && jsonProp.complexItems instanceof Array) {
                    jsonProp.complexItems.each((function(jsonComplexItem){
                        this._complexItems[jsonComplexItem.id] = new ORYX.Core.StencilSet.ComplexPropertyItem(jsonComplexItem, namespace, this);
                    }).bind(this));
                }
                else {
                    throw "ORYX.Core.StencilSet.Property(construct): No complex property items defined."
                }
            }
        // extended by Kerstin (end)
    },
    
    /**
     * @param {ORYX.Core.StencilSet.Property} property
     * @return {Boolean} True, if property has the same namespace and id.
     */
    equals: function(property){
        return (this._namespace === property.namespace() &&
        this.id() === property.id()) ? true : false;
    },
    
    namespace: function(){
        return this._namespace;
    },
    
    stencil: function(){
        return this._stencil;
    },
    
    id: function(){
        return this._jsonProp.id;
    },
    
    prefix: function(){
        return this._jsonProp.prefix;
    },
    
    type: function(){
        return this._jsonProp.type;
    },
    
    inverseBoolean: function() {
    	return this._jsonProp.inverseBoolean;
    },
	
	popular: function() {
		return this._jsonProp.popular;
	},
	
	setPopular: function() {
		this._jsonProp.popular = true;
	},
	
	directlyEditable: function() {
		return this._jsonProp.directlyEditable;
	},
	
	visible: function() {
		return this._jsonProp.visible;
	},
    
    title: function(){
        return ORYX.Core.StencilSet.getTranslation(this._jsonProp, "title");
    },
    
    value: function(){
        return this._jsonProp.value;
    },
    
    readonly: function(){
        return this._jsonProp.readonly;
    },
    
    optional: function(){
        return this._jsonProp.optional;
    },
    
    description: function(){
        return ORYX.Core.StencilSet.getTranslation(this._jsonProp, "description");
    },
    
    /**
     * An optional link to a SVG element so that the property affects the
     * graphical representation of the stencil.
     */
    refToView: function(){
        return this._jsonProp.refToView;
    },
    
    /**
     * If type is integer or float, min is the lower bounds of value.
     */
    min: function(){
        return this._jsonProp.min;
    },
    
    /**
     * If type ist integer or float, max is the upper bounds of value.
     */
    max: function(){
        return this._jsonProp.max;
    },
    
    /**
     * If type is float, this method returns if the fill-opacity property should
     *  be set.
     *  @return {Boolean}
     */
    fillOpacity: function(){
        return this._jsonProp.fillOpacity;
    },
    
    /**
     * If type is float, this method returns if the stroke-opacity property should
     *  be set.
     *  @return {Boolean}
     */
    strokeOpacity: function(){
        return this._jsonProp.strokeOpacity;
    },
    
    /**
     * If type is string or richtext, length is the maximum length of the text.
     * TODO how long can a string be.
     */
    length: function(){
        return this._jsonProp.length ? this._jsonProp.length : Number.MAX_VALUE;
    },
    
    wrapLines: function(){
        return this._jsonProp.wrapLines;
    },
    
    /**
     * If type is date, dateFormat specifies the format of the date. The format
     * specification of the ext library is used:
     *
     * Format  Output      Description
     *	------  ----------  --------------------------------------------------------------
     *	  d      10         Day of the month, 2 digits with leading zeros
     *	  D      Wed        A textual representation of a day, three letters
     *	  j      10         Day of the month without leading zeros
     *	  l      Wednesday  A full textual representation of the day of the week
     *	  S      th         English ordinal day of month suffix, 2 chars (use with j)
     *	  w      3          Numeric representation of the day of the week
     *	  z      9          The julian date, or day of the year (0-365)
     *	  W      01         ISO-8601 2-digit week number of year, weeks starting on Monday (00-52)
     *	  F      January    A full textual representation of the month
     *	  m      01         Numeric representation of a month, with leading zeros
     *	  M      Jan        Month name abbreviation, three letters
     *	  n      1          Numeric representation of a month, without leading zeros
     *	  t      31         Number of days in the given month
     *	  L      0          Whether its a leap year (1 if it is a leap year, else 0)
     *	  Y      2007       A full numeric representation of a year, 4 digits
     *	  y      07         A two digit representation of a year
     *	  a      pm         Lowercase Ante meridiem and Post meridiem
     *	  A      PM         Uppercase Ante meridiem and Post meridiem
     *	  g      3          12-hour format of an hour without leading zeros
     *	  G      15         24-hour format of an hour without leading zeros
     *	  h      03         12-hour format of an hour with leading zeros
     *	  H      15         24-hour format of an hour with leading zeros
     *	  i      05         Minutes with leading zeros
     *	  s      01         Seconds, with leading zeros
     *	  O      -0600      Difference to Greenwich time (GMT) in hours
     *	  T      CST        Timezone setting of the machine running the code
     *	  Z      -21600     Timezone offset in seconds (negative if west of UTC, positive if east)
     *
     * Example:
     *  F j, Y, g:i a  ->  January 10, 2007, 3:05 pm
     */
    dateFormat: function(){
        return this._jsonProp.dateFormat;
    },
    
    /**
     * If type is color, this method returns if the fill property should
     *  be set.
     *  @return {Boolean}
     */
    fill: function(){
        return this._jsonProp.fill;
    },
    
    /**
     * If type is color, this method returns if the stroke property should
     *  be set.
     *  @return {Boolean}
     */
    stroke: function(){
        return this._jsonProp.stroke;
    },
    
    /**
     * If type is choice, items is a hash map with all alternative values
     * (PropertyItem objects) with id as keys.
     */
    items: function(){
        return this._items.values();
    },
    
    item: function(value){
        return this._items[value];
    },
    
    toString: function(){
        return "Property " + this.title() + " (" + this.id() + ")";
    },
    
    // extended by Kerstin (start)
    complexItems: function(){
        return this._complexItems.values();
    },
    
    complexItem: function(id){
        return this._complexItems[id];
    },
    // extended by Kerstin (end)
    
    complexAttributeToView: function(){
        return this._jsonProp.complexAttributeToView || "";
    }
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespace
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Stencil
 * uses Prototpye 1.5.0
 * uses Inheritance
 */
ORYX.Core.StencilSet.PropertyItem = Clazz.extend({

	/**
	 * Constructor
	 */
	construct: function(jsonItem, namespace, property) {
		arguments.callee.$.construct.apply(this, arguments);

		if(!jsonItem) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Parameter jsonItem is not defined.";
		}
		if(!namespace) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Parameter namespace is not defined.";
		}
		if(!property) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Parameter property is not defined.";
		}
		
		this._jsonItem = jsonItem;
		this._namespace = namespace;
		this._property = property;
		
		//init all values
		if(!jsonItem.value) {
			throw "ORYX.Core.StencilSet.PropertyItem(construct): Value is not defined.";
		}
		
		if(this._jsonItem.refToView) {
			if(!(this._jsonItem.refToView instanceof Array)) {
				this._jsonItem.refToView = [this._jsonItem.refToView];
			}
		} else {
			this._jsonItem.refToView = [];
		}
	},

	/**
	 * @param {ORYX.Core.StencilSet.PropertyItem} item
	 * @return {Boolean} True, if item has the same namespace and id.
	 */
	equals: function(item) {
		return (this.property().equals(item.property()) &&
			this.value() === item.value());
	},

	namespace: function() {
		return this._namespace;
	},

	property: function() {
		return this._property;
	},

	value: function() {
		return this._jsonItem.value;
	},
	
	title: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonItem, "title");
	},

	refToView: function() {
		return this._jsonItem.refToView;
	},
	
	icon: function() {
		return (this._jsonItem.icon) ? this.property().stencil()._source + "icons/" + this._jsonItem.icon : "";
	},

	toString: function() { return "PropertyItem " + this.property() + " (" + this.value() + ")"; }
});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Stencil
 * uses Prototpye 1.5.0
 * uses Inheritance
 */
ORYX.Core.StencilSet.ComplexPropertyItem = Clazz.extend({

	/**
	 * Constructor
	 */
	construct: function(jsonItem, namespace, property) {
		arguments.callee.$.construct.apply(this, arguments);

		if(!jsonItem) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Parameter jsonItem is not defined.";
		}
		if(!namespace) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Parameter namespace is not defined.";
		}
		if(!property) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Parameter property is not defined.";
		}
		
		this._jsonItem = jsonItem;
		this._namespace = namespace;
		this._property = property;
		this._items = new Hash();
		
		//init all values
		if(!jsonItem.name) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Name is not defined.";
		}
		
		if(!jsonItem.type) {
			throw "ORYX.Core.StencilSet.ComplexPropertyItem(construct): Type is not defined.";
		} else {
			jsonItem.type = jsonItem.type.toLowerCase();
		}
		
		if(jsonItem.type === ORYX.CONFIG.TYPE_CHOICE) {
			if(jsonItem.items && jsonItem.items instanceof Array) {
				jsonItem.items.each((function(item) {
					this._items[item.value] = new ORYX.Core.StencilSet.PropertyItem(item, namespace, this);
				}).bind(this));
			} else {
				throw "ORYX.Core.StencilSet.Property(construct): No property items defined."
			}
		}
	},

	/**
	 * @param {ORYX.Core.StencilSet.PropertyItem} item
	 * @return {Boolean} True, if item has the same namespace and id.
	 */
	equals: function(item) {
		return (this.property().equals(item.property()) &&
			this.name() === item.name());
	},

	namespace: function() {
		return this._namespace;
	},

	property: function() {
		return this._property;
	},

	name: function() {
		return ORYX.Core.StencilSet.getTranslation(this._jsonItem, "name");
	},
	
	id: function() {
		return this._jsonItem.id;
	},
	
	type: function() {
		return this._jsonItem.type;
	},
	
	optional: function() {
		return this._jsonItem.optional;
	},
	
	width: function() {
		return this._jsonItem.width;
	},
	
	value: function() {
		return this._jsonItem.value;
	},
	
	items: function() {
		return this._items.values();
	},
	
	disable: function() {
		return this._jsonItem.disable;
	}
});/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class Rules uses Prototpye 1.5.0 uses Inheritance
 * 
 * This class implements the API to check the stencil sets' rules.
 */
ORYX.Core.StencilSet.Rules = {

	/**
	 * Constructor
	 */
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);

		this._stencilSets = [];
		this._stencils = [];
		
		this._cachedConnectSET = new Hash();
		this._cachedConnectSE = new Hash();
		this._cachedConnectTE = new Hash();
		this._cachedCardSE = new Hash();
		this._cachedCardTE = new Hash();
		this._cachedContainPC = new Hash();
		this._cachedMorphRS = new Hash();
		
		this._connectionRules = new Hash();
		this._cardinalityRules = new Hash();
		this._containmentRules = new Hash();
		this._morphingRules = new Hash();
		this._layoutRules = new Hash();
	},
	
	/**
	 * Call this method to initialize the rules for a stencil set and all of its
	 * active extensions.
	 * 
	 * @param {Object}
	 *            stencilSet
	 */
	initializeRules: function(stencilSet) {
		
		var existingSS = this._stencilSets.find(function(ss) {
							return (ss.namespace() == stencilSet.namespace());
						});
		if (existingSS) {
			// reinitialize all rules
			var stencilsets = this._stencilSets.clone();
			stencilsets = stencilsets.without(existingSS);
			stencilsets.push(stencilSet);
			
			this._stencilSets = [];
			this._stencils = [];
			
			this._cachedConnectSET = new Hash();
			this._cachedConnectSE = new Hash();
			this._cachedConnectTE = new Hash();
			this._cachedCardSE = new Hash();
			this._cachedCardTE = new Hash();
			this._cachedContainPC = new Hash();
			this._cachedMorphRS = new Hash();
			
			this._connectionRules = new Hash();
			this._cardinalityRules = new Hash();
			this._containmentRules = new Hash();
			this._morphingRules = new Hash();
			this._layoutRules = new Hash();
			
			stencilsets.each(function(ss){
				this.initializeRules(ss);
			}.bind(this));
			return;
		}
		else {
			this._stencilSets.push(stencilSet);
			
			var jsonRules = new Hash(stencilSet.jsonRules());
			var namespace = stencilSet.namespace();
			var stencils = stencilSet.stencils();
			
			stencilSet.extensions().values().each(function(extension) {
				if(extension.rules) {
					if(extension.rules.connectionRules)
						jsonRules.connectionRules = jsonRules.connectionRules.concat(extension.rules.connectionRules);
					if(extension.rules.cardinalityRules)
						jsonRules.cardinalityRules = jsonRules.cardinalityRules.concat(extension.rules.cardinalityRules);
					if(extension.rules.containmentRules)
						jsonRules.containmentRules = jsonRules.containmentRules.concat(extension.rules.containmentRules);
					if(extension.rules.morphingRules)
						jsonRules.morphingRules = jsonRules.morphingRules.concat(extension.rules.morphingRules);
				}
				if(extension.stencils) 
					stencils = stencils.concat(extension.stencils);
			});
			
			this._stencils = this._stencils.concat(stencilSet.stencils());
			
			// init connection rules
			var cr = this._connectionRules;
			if (jsonRules.connectionRules) {
				jsonRules.connectionRules.each((function(rules){
					if (this._isRoleOfOtherNamespace(rules.role)) {
						if (!cr[rules.role]) {
							cr[rules.role] = new Hash();
						}
					}
					else {
						if (!cr[namespace + rules.role]) 
							cr[namespace + rules.role] = new Hash();
					}
					
					rules.connects.each((function(connect){
						var toRoles = [];
						if (connect.to) {
							if (!(connect.to instanceof Array)) {
								connect.to = [connect.to];
							}
							connect.to.each((function(to){
								if (this._isRoleOfOtherNamespace(to)) {
									toRoles.push(to);
								}
								else {
									toRoles.push(namespace + to);
								}
							}).bind(this));
						}
						
						var role, from;
						if (this._isRoleOfOtherNamespace(rules.role)) 
							role = rules.role;
						else 
							role = namespace + rules.role;
						
						if (this._isRoleOfOtherNamespace(connect.from)) 
							from = connect.from;
						else 
							from = namespace + connect.from;
						
						if (!cr[role][from]) 
							cr[role][from] = toRoles;
						else 
							cr[role][from] = cr[role][from].concat(toRoles);
						
					}).bind(this));
				}).bind(this));
			}
			
			// init cardinality rules
			var cardr = this._cardinalityRules;
			if (jsonRules.cardinalityRules) {
				jsonRules.cardinalityRules.each((function(rules){
					var cardrKey;
					if (this._isRoleOfOtherNamespace(rules.role)) {
						cardrKey = rules.role;
					}
					else {
						cardrKey = namespace + rules.role;
					}
					
					if (!cardr[cardrKey]) {
						cardr[cardrKey] = {};
						for (i in rules) {
							cardr[cardrKey][i] = rules[i];
						}
					}
					
					var oe = new Hash();
					if (rules.outgoingEdges) {
						rules.outgoingEdges.each((function(rule){
							if (this._isRoleOfOtherNamespace(rule.role)) {
								oe[rule.role] = rule;
							}
							else {
								oe[namespace + rule.role] = rule;
							}
						}).bind(this));
					}
					cardr[cardrKey].outgoingEdges = oe;
					var ie = new Hash();
					if (rules.incomingEdges) {
						rules.incomingEdges.each((function(rule){
							if (this._isRoleOfOtherNamespace(rule.role)) {
								ie[rule.role] = rule;
							}
							else {
								ie[namespace + rule.role] = rule;
							}
						}).bind(this));
					}
					cardr[cardrKey].incomingEdges = ie;
				}).bind(this));
			}
			
			// init containment rules
			var conr = this._containmentRules;
			if (jsonRules.containmentRules) {
				jsonRules.containmentRules.each((function(rules){
					var conrKey;
					if (this._isRoleOfOtherNamespace(rules.role)) {
						conrKey = rules.role;
					}
					else {
						conrKey = namespace + rules.role;
					}
					if (!conr[conrKey]) {
						conr[conrKey] = [];
					}
					rules.contains.each((function(containRole){
						if (this._isRoleOfOtherNamespace(containRole)) {
							conr[conrKey].push(containRole);
						}
						else {
							conr[conrKey].push(namespace + containRole);
						}
					}).bind(this));
				}).bind(this));
			}
			
			// init morphing rules
			var morphr = this._morphingRules;
			if (jsonRules.morphingRules) {
				jsonRules.morphingRules.each((function(rules){
					var morphrKey;
					if (this._isRoleOfOtherNamespace(rules.role)) {
						morphrKey = rules.role;
					}
					else {
						morphrKey = namespace + rules.role;
					}
					if (!morphr[morphrKey]) {
						morphr[morphrKey] = [];
					}
					if(!rules.preserveBounds) {
						rules.preserveBounds = false;
					}
					rules.baseMorphs.each((function(baseMorphStencilId){
						morphr[morphrKey].push(this._getStencilById(namespace + baseMorphStencilId));
					}).bind(this));
				}).bind(this));
			}
			
			// init layouting rules
			var layoutRules = this._layoutRules;
			if (jsonRules.layoutRules) {
				
				var getDirections = function(o){
					return {
							"edgeRole":o.edgeRole||undefined,
							"t": o["t"]||1,
							"r": o["r"]||1,
							"b": o["b"]||1,
							"l": o["l"]||1
						}
				}
				
				jsonRules.layoutRules.each(function(rules){
					var layoutKey;
					if (this._isRoleOfOtherNamespace(rules.role)) {
						layoutKey = rules.role;
					}
					else {
						layoutKey = namespace + rules.role;
					}
					if (!layoutRules[layoutKey]) {
						layoutRules[layoutKey] = {};
					}
					if (rules["in"]){
						layoutRules[layoutKey]["in"] = getDirections(rules["in"]);
					}
					if (rules["ins"]){
						layoutRules[layoutKey]["ins"] = (rules["ins"]||[]).map(function(e){ return getDirections(e) })
					}
					if (rules["out"]) {
						layoutRules[layoutKey]["out"] = getDirections(rules["out"]);
					}
					if (rules["outs"]){
						layoutRules[layoutKey]["outs"] = (rules["outs"]||[]).map(function(e){ return getDirections(e) })
					}
				}.bind(this));
			}			
		}
	},
	
	_getStencilById: function(id) {
		return this._stencils.find(function(stencil) {
			return stencil.id()==id;
		});
	},
	
	_cacheConnect: function(args) {
		result = this._canConnect(args);
		
		if (args.sourceStencil && args.targetStencil) {
			var source = this._cachedConnectSET[args.sourceStencil.id()];
			
			if(!source) {
				source = new Hash();
				this._cachedConnectSET[args.sourceStencil.id()] = source;
			}
			
			var edge = source[args.edgeStencil.id()];
			
			if(!edge) {
				edge = new Hash();
				source[args.edgeStencil.id()] = edge;
			}
			
			edge[args.targetStencil.id()] = result;
			
		} else if (args.sourceStencil) {
			var source = this._cachedConnectSE[args.sourceStencil.id()];
			
			if(!source) {
				source = new Hash();
				this._cachedConnectSE[args.sourceStencil.id()] = source;
			}
			
			source[args.edgeStencil.id()] = result;

		} else {
			var target = this._cachedConnectTE[args.targetStencil.id()];
			
			if(!target) {
				target = new Hash();
				this._cachedConnectTE[args.targetStencil.id()] = target;
			}
			
			target[args.edgeStencil.id()] = result;
		}
		
		return result;
	},
	
	_cacheCard: function(args) {
			
		if(args.sourceStencil) {
			var source = this._cachedCardSE[args.sourceStencil.id()]
			
			if(!source) {
				source = new Hash();
				this._cachedCardSE[args.sourceStencil.id()] = source;
			}
			
			var max = this._getMaximumNumberOfOutgoingEdge(args);
			if(max == undefined)
				max = -1;
				
			source[args.edgeStencil.id()] = max;
		}	
		
		if(args.targetStencil) {
			var target = this._cachedCardTE[args.targetStencil.id()]
			
			if(!target) {
				target = new Hash();
				this._cachedCardTE[args.targetStencil.id()] = target;
			}
			
			var max = this._getMaximumNumberOfIncomingEdge(args);
			if(max == undefined)
				max = -1;
				
			target[args.edgeStencil.id()] = max;
		}
	},
	
	/**
	 * The name of this method is misleading. 
	 * It returns the stencils that can be contained in a 
	 * stencil defined by the input parameter.  
	 */
	_cacheContain: function(args) {
		//The result variable is an array with two fields. 
		//The first field contains the result if the input
		//args.contained stencil can contain the args.containingStencil.
		//The second field returns the maximum number of time the 
		//args.containingStencil stencil can be contained in args.containedStencil
		var result = [this._canContain(args), 
					  this._getMaximumOccurrence(args.containingStencil, args.containedStencil)]
		
		//If there is no maximum number for the args.containingStencil
		//we set the second field of the result array to -1
		//which must be a common value for not defined values :-)
		if(result[1] == undefined) 
			result[1] = -1;
		
		//The rest of this method is useless besides the return statement
		//The children array isn't used anymore after it was assigned. 
		var children = this._cachedContainPC[args.containingStencil.id()];
		
		//If there are no children we create a new hashmap for future children
		//with an empty hash map
		if(!children) {
			children = new Hash();
			this._cachedContainPC[args.containingStencil.id()] = children;
		}
		

		children[args.containedStencil.id()] = result;
		
		return result;
	},
	
	/**
	 * Returns all stencils belonging to a morph group. (calculation result is
	 * cached)
	 */
	_cacheMorph: function(role) {
		
		var morphs = this._cachedMorphRS[role];
		
		if(!morphs) {
			morphs = [];
			
			if(this._morphingRules.keys().include(role)) {
				morphs = this._stencils.select(function(stencil) {
					return stencil.roles().include(role);
				});
			}
			
			this._cachedMorphRS[role] = morphs;
		}
		return morphs;
	},
	
	/** Begin connection rules' methods */
	
	/**
	 * 
	 * @param {Object}
	 *            args sourceStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            sourceShape: ORYX.Core.Shape | undefined
	 * 
	 * At least sourceStencil or sourceShape has to be specified
	 * 
	 * @return {Array} Array of stencils of edges that can be outgoing edges of
	 *         the source.
	 */
	outgoingEdgeStencils: function(args) {
		// check arguments
		if(!args.sourceShape && !args.sourceStencil) {
			return [];
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		
		var _edges = [];
		
		// test each edge, if it can connect to source
		this._stencils.each((function(stencil) {
			if(stencil.type() === "edge") {
				var newArgs = Object.clone(args);
				newArgs.edgeStencil = stencil;
				if(this.canConnect(newArgs)) {
					_edges.push(stencil);
				}
			}
		}).bind(this));

		return _edges;
	},

	/**
	 * 
	 * @param {Object}
	 *            args targetStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            targetShape: ORYX.Core.Shape | undefined
	 * 
	 * At least targetStencil or targetShape has to be specified
	 * 
	 * @return {Array} Array of stencils of edges that can be incoming edges of
	 *         the target.
	 */
	incomingEdgeStencils: function(args) {
		// check arguments
		if(!args.targetShape && !args.targetStencil) {
			return [];
		}
		
		// init arguments
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		
		var _edges = [];
		
		// test each edge, if it can connect to source
		this._stencils.each((function(stencil) {
			if(stencil.type() === "edge") {
				var newArgs = Object.clone(args);
				newArgs.edgeStencil = stencil;
				if(this.canConnect(newArgs)) {
					_edges.push(stencil);
				}
			}
		}).bind(this));

		return _edges;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            edgeShape: ORYX.Core.Edge | undefined targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined targetShape:
	 *            ORYX.Core.Node | undefined
	 * 
	 * At least edgeStencil or edgeShape has to be specified!!!
	 * 
	 * @return {Array} Returns an array of stencils that can be source of the
	 *         specified edge.
	 */
	sourceStencils: function(args) {
		// check arguments
		if(!args || 
		   !args.edgeShape && !args.edgeStencil) {
			return [];
		}
		
		// init arguments
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}
		
		var _sources = [];
		
		// check each stencil, if it can be a source
		this._stencils.each((function(stencil) {
			var newArgs = Object.clone(args);
			newArgs.sourceStencil = stencil;
			if(this.canConnect(newArgs)) {
				_sources.push(stencil);
			}
		}).bind(this));

		return _sources;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil | undefined
	 *            edgeShape: ORYX.Core.Edge | undefined sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined sourceShape:
	 *            ORYX.Core.Node | undefined
	 * 
	 * At least edgeStencil or edgeShape has to be specified!!!
	 * 
	 * @return {Array} Returns an array of stencils that can be target of the
	 *         specified edge.
	 */
	targetStencils: function(args) {
		// check arguments
		if(!args || 
		   !args.edgeShape && !args.edgeStencil) {
			return [];
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}
		
		var _targets = [];
		
		// check stencil, if it can be a target
		this._stencils.each((function(stencil) {
			var newArgs = Object.clone(args);
			newArgs.targetStencil = stencil;
			if(this.canConnect(newArgs)) {
				_targets.push(stencil);
			}
		}).bind(this));

		return _targets;
	},

	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil edgeShape:
	 *            ORYX.Core.Edge |undefined sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined sourceShape:
	 *            ORYX.Core.Node |undefined targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined targetShape:
	 *            ORYX.Core.Node |undefined
	 * 
	 * At least source or target has to be specified!!!
	 * 
	 * @return {Boolean} Returns, if the edge can connect source and target.
	 */
	canConnect: function(args) {	
		// check arguments
		if(!args ||
		   (!args.sourceShape && !args.sourceStencil &&
		    !args.targetShape && !args.targetStencil) ||
		    !args.edgeShape && !args.edgeStencil) {
		   	return false; 
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}
		
		var result;
		
		if(args.sourceStencil && args.targetStencil) {
			var source = this._cachedConnectSET[args.sourceStencil.id()];
			
			if(!source)
				result = this._cacheConnect(args);
			else {
				var edge = source[args.edgeStencil.id()];

				if(!edge)
					result = this._cacheConnect(args);
				else {	
					var target = edge[args.targetStencil.id()];

					if(target == undefined)
						result = this._cacheConnect(args);
					else
						result = target;
				}
			}
		} else if (args.sourceStencil) {	
			var source = this._cachedConnectSE[args.sourceStencil.id()];
			
			if(!source)
				result = this._cacheConnect(args);
			else {
				var edge = source[args.edgeStencil.id()];
					
				if(edge == undefined)
					result = this._cacheConnect(args);
				else
					result = edge;
			}
		} else { // args.targetStencil
			var target = this._cachedConnectTE[args.targetStencil.id()];
			
			if(!target)
				result = this._cacheConnect(args);
			else {
				var edge = target[args.edgeStencil.id()];
					
				if(edge == undefined)
					result = this._cacheConnect(args);
				else
					result = edge;
			}
		}	
			
		// check cardinality
		if (result) {
			if(args.sourceShape) {
				var source = this._cachedCardSE[args.sourceStencil.id()];
				
				if(!source) {
					this._cacheCard(args);
					source = this._cachedCardSE[args.sourceStencil.id()];
				}
				
				var max = source[args.edgeStencil.id()];
				
				if(max == undefined) {
					this._cacheCard(args);
				}
				
				max = source[args.edgeStencil.id()];
				
				if(max != -1) {
					result = args.sourceShape.getOutgoingShapes().all(function(cs) {
								if((cs.getStencil().id() === args.edgeStencil.id()) && 
								   ((args.edgeShape) ? cs !== args.edgeShape : true)) {
									max--;
									return (max > 0) ? true : false;
								} else {
									return true;
								}
							});
				}
			} 
			
			if (args.targetShape) {
				var target = this._cachedCardTE[args.targetStencil.id()];
				
				if(!target) {
					this._cacheCard(args);
					target = this._cachedCardTE[args.targetStencil.id()];
				}
				
				var max = target[args.edgeStencil.id()];
				
				if(max == undefined) {
					this._cacheCard(args);
				}
				
				max = target[args.edgeStencil.id()];
				
				if(max != -1) {
					result = args.targetShape.getIncomingShapes().all(function(cs){
								if ((cs.getStencil().id() === args.edgeStencil.id()) &&
								((args.edgeShape) ? cs !== args.edgeShape : true)) {
									max--;
									return (max > 0) ? true : false;
								}
								else {
									return true;
								}
							});
				}
			}
		}
		
		return result;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args edgeStencil: ORYX.Core.StencilSet.Stencil edgeShape:
	 *            ORYX.Core.Edge |undefined sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined sourceShape:
	 *            ORYX.Core.Node |undefined targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined targetShape:
	 *            ORYX.Core.Node |undefined
	 * 
	 * At least source or target has to be specified!!!
	 * 
	 * @return {Boolean} Returns, if the edge can connect source and target.
	 */
	_canConnect: function(args) {
		// check arguments
		if(!args ||
		   (!args.sourceShape && !args.sourceStencil &&
		    !args.targetShape && !args.targetStencil) ||
		    !args.edgeShape && !args.edgeStencil) {
		   	return false; 
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		if(args.edgeShape) {
			args.edgeStencil = args.edgeShape.getStencil();
		}

		// 1. check connection rules
		var resultCR;
		
		// get all connection rules for this edge
		var edgeRules = this._getConnectionRulesOfEdgeStencil(args.edgeStencil);

		// check connection rules, if the source can be connected to the target
		// with the specified edge.
		if(edgeRules.keys().length === 0) {
			resultCR = false;
		} else {
			if(args.sourceStencil) {
				resultCR = args.sourceStencil.roles().any(function(sourceRole) {
					var targetRoles = edgeRules[sourceRole];

					if(!targetRoles) {return false;}
		
					if(args.targetStencil) {
						return (targetRoles.any(function(targetRole) {
							return args.targetStencil.roles().member(targetRole);
						}));
					} else {
						return true;
					}
				});
			} else { // !args.sourceStencil -> there is args.targetStencil
				resultCR = edgeRules.values().any(function(targetRoles) {
					return args.targetStencil.roles().any(function(targetRole) {
						return targetRoles.member(targetRole);
					});
				});
			}
		}
		
		return resultCR;
	},

	/** End connection rules' methods */


	/** Begin containment rules' methods */

	/**
	 * Check if a stencil can be contained by another stencil. 
	 * @param {Object}
	 *            args containingStencil: ORYX.Core.StencilSet.Stencil
	 *            containingShape: ORYX.Core.AbstractShape containedStencil:
	 *            ORYX.Core.StencilSet.Stencil containedShape: ORYX.Core.Shape
	 */
	canContain: function(args) {
		if(!args ||
		   !args.containingStencil && !args.containingShape ||
		   !args.containedStencil && !args.containedShape) {
		   	return false;
		}
		
		// init arguments
		//Useless shifts. 
		if(args.containedShape) {
			args.containedStencil = args.containedShape.getStencil();
		}
		
		if(args.containingShape) {
			args.containingStencil = args.containingShape.getStencil();
		}
		
		
		//if(args.containingStencil.type() == 'edge' || args.containedStencil.type() == 'edge')
		//	return false;
		if(args.containedStencil.type() == 'edge') 
			return false;
		
		var childValues;
		//parent is a array of roles with a corresponding array. 
		//The array has two fields (Boolean, integer). The first field tells if a corresponding
		//role can be contained within the stencil we want to put another stencil in. 
		var parent = this._cachedContainPC[args.containingStencil.id()];
		
		//ChildValues contains an array of boolean and integer.  
		//If parent is undefined we 
		if(!parent)
			childValues = this._cacheContain(args);
		else {
			//Here we get one array out of the parent array
			//by querying with the stencil id of the stencil we 
			//just want to put into another stencil. 
			childValues = parent[args.containedStencil.id()];
			
			if(!childValues)
				childValues = this._cacheContain(args);
		}

		if(!childValues[0])
			return false;
		else if (childValues[1] == -1)
			return true;
		else {
			if(args.containingShape) {
				var max = childValues[1];
				return args.containingShape.getChildShapes(false).all(function(as) {
					if(as.getStencil().id() === args.containedStencil.id()) {
						max--;
						return (max > 0) ? true : false;
					} else {
						return true;
					}
				});
			} else {
				return true;
			}
		}
	},
	
	/**
	 * This method checks if the args.containingStencil stencil
	 * can contain the args.containedStencil stencil. 
	 * @param {Object}
	 *            args containingStencil: ORYX.Core.StencilSet.Stencil
	 *            containingShape: ORYX.Core.AbstractShape containedStencil:
	 *            ORYX.Core.StencilSet.Stencil containedShape: ORYX.Core.Shape
	 */
	_canContain: function(args) {
		//Check for undefined values
		if(!args ||
		   !args.containingStencil && !args.containingShape ||
		   !args.containedStencil && !args.containedShape) {
		   	return false;
		}
		
		// Useless checks. It would be better to describe the
		//args object instead of shifting values in it. 
		if(args.containedShape) {
			args.containedStencil = args.containedShape.getStencil();
		}
		
		if(args.containingShape) {
			args.containingStencil = args.containingShape.getStencil();
		}
		
//		if(args.containingShape) {
//			if(args.containingShape instanceof ORYX.Core.Edge) {
//				// edges cannot contain other shapes
//				return false;
//			}
//		}

		
		var result;
		
		// check containment rules
		//We loop through all roles of the stencil we just moved
		//over with the mouse while draging another stencil. 
		result = args.containingStencil.roles().any((function(role) {
			//this._containmentRules is an array of an array of roles.
			//The inner array are roles that can be contained by the roles
			//named by the outer array. Example: [subprocess[sequence_end, ...]]. 
			//So the roles are the roles that can be contained within a stencil
			//with the role from the current iteration. 
			var roles = this._containmentRules[role];
			if(roles) {
				return roles.any(function(role) {
					//Here we look if the role of the current stencil allows
					//it to contain the role of the stencil we just drag. 
					//The roles of these stencils must be the same. 
					return args.containedStencil.roles().member(role);
				});
			} else {
				return false;
			}
		}).bind(this));
		
		return result;
	},
	
	/** End containment rules' methods */
	
	
	/** Begin morphing rules' methods */
	
	/**
	 * 
	 * @param {Object}
	 *           args 
	 *            stencil: ORYX.Core.StencilSet.Stencil | undefined 
	 *            shape: ORYX.Core.Shape | undefined
	 * 
	 * At least stencil or shape has to be specified
	 * 
	 * @return {Array} Array of stencils that the passed stencil/shape can be
	 *         transformed to (including the current stencil itself)
	 */
	morphStencils: function(args) {
		// check arguments
		if(!args.stencil && !args.shape) {
			return [];
		}
		
		// init arguments
		if(args.shape) {
			args.stencil = args.shape.getStencil();
		}
		
		var _morphStencils = [];
		args.stencil.roles().each(function(role) {
			this._cacheMorph(role).each(function(stencil) {
				_morphStencils.push(stencil);
			})
		}.bind(this));

		return _morphStencils.uniq();
	},
	
	/**
	 * @return {Array} An array of all base morph stencils
	 */
	baseMorphs: function() {
		var _baseMorphs = [];
		this._morphingRules.each(function(pair) {
			pair.value.each(function(baseMorph) {
				_baseMorphs.push(baseMorph);
			});
		});
		return _baseMorphs;
	},
	
	/**
	 * Returns true if there are morphing rules defines
	 * @return {boolean} 
	 */
	containsMorphingRules: function(){
		return this._stencilSets.any(function(ss){ return !!ss.jsonRules().morphingRules});
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args 
	 *            sourceStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined 
	 *            sourceShape:
	 *            ORYX.Core.Node |undefined 
	 *            targetStencil:
	 *            ORYX.Core.StencilSet.Stencil | undefined 
	 *            targetShape:
	 *            ORYX.Core.Node |undefined
	 * 
	 * 
	 * @return {Stencil} Returns, the stencil for the connecting edge 
	 * or null if connection is not possible
	 */
	connectMorph: function(args) {	
		// check arguments
		if(!args ||
		   (!args.sourceShape && !args.sourceStencil &&
		    !args.targetShape && !args.targetStencil)) {
		   	return false; 
		}
		
		// init arguments
		if(args.sourceShape) {
			args.sourceStencil = args.sourceShape.getStencil();
		}
		if(args.targetShape) {
			args.targetStencil = args.targetShape.getStencil();
		}
		
		var incoming = this.incomingEdgeStencils(args);
		var outgoing = this.outgoingEdgeStencils(args);
		
		var edgeStencils = incoming.select(function(e) { return outgoing.member(e); }); // intersection of sets
		var baseEdgeStencils = this.baseMorphs().select(function(e) { return edgeStencils.member(e); }); // again: intersection of sets
		
		if(baseEdgeStencils.size()>0)
			return baseEdgeStencils[0]; // return any of the possible base morphs
		else if(edgeStencils.size()>0)
			return edgeStencils[0];	// return any of the possible stencils
		
		return null; //connection not possible
	},
	
	/**
	 * Return true if the stencil should be located in the shape menu
	 * @param {ORYX.Core.StencilSet.Stencil} morph
	 * @return {Boolean} Returns true if the morphs in the morph group of the
	 * specified morph shall be displayed in the shape menu
	 */
	showInShapeMenu: function(stencil) {
		return 	this._stencilSets.any(function(ss){
				    return ss.jsonRules().morphingRules
							.any(function(r){
								return 	stencil.roles().include(ss.namespace() + r.role) 
										&& r.showInShapeMenu !== false;
							})
				});
	},
	
	preserveBounds: function(stencil) {
		return this._stencilSets.any(function(ss) {
			return ss.jsonRules().morphingRules.any(function(r) {
				
				
				return stencil.roles().include(ss.namespace() + r.role) 
					&& r.preserveBounds;
			})
		})
	},
	
	/** End morphing rules' methods */


	/** Begin layouting rules' methods */
	
	/**
	 * Returns a set on "in" and "out" layouting rules for a given shape
	 * @param {Object} shape
	 * @param {Object} edgeShape (Optional)
	 * @return {Object} "in" and "out" with a default value of {"t":1, "r":1, "b":1, "r":1} if not specified in the json
	 */
	getLayoutingRules : function(shape, edgeShape){
		
		if (!shape||!(shape instanceof ORYX.Core.Shape)){ return }
		
		var layout = {"in":{},"out":{}};
		
		var parseValues = function(o, v){
			if (o && o[v]){
				["t","r","b","l"].each(function(d){
					layout[v][d]=Math.max(o[v][d],layout[v][d]||0);
				});
			}
			if (o && o[v+"s"] instanceof Array){
				["t","r","b","l"].each(function(d){
					var defaultRule = o[v+"s"].find(function(e){ return !e.edgeRole });
					var edgeRule;
					if (edgeShape instanceof ORYX.Core.Edge) {
						edgeRule = o[v + "s"].find(function(e){return this._hasRole(edgeShape, e.edgeRole) }.bind(this));
					}
					layout[v][d]=Math.max(edgeRule?edgeRule[d]:defaultRule[d],layout[v][d]||0);
				}.bind(this));
			}
		}.bind(this)
		
		// For each role
		shape.getStencil().roles().each(function(role) {
			// check if there are layout information
			if (this._layoutRules[role]){
				// if so, parse those information to the 'layout' variable
				parseValues(this._layoutRules[role], "in");
				parseValues(this._layoutRules[role], "out");
			}
		}.bind(this));
		
		// Make sure, that every attribute has an value,
		// otherwise set 1
		["in","out"].each(function(v){
			["t","r","b","l"].each(function(d){
					layout[v][d]=layout[v][d]!==undefined?layout[v][d]:1;
				});
		})
		
		return layout;
	},
	
	/** End layouting rules' methods */
	
	/** Helper methods */

	/**
	 * Checks wether a shape contains the given role or the role is equal the stencil id 
	 * @param {ORYX.Core.Shape} shape
	 * @param {String} role
	 */
	_hasRole: function(shape, role){
		if (!(shape instanceof ORYX.Core.Shape)||!role){ return }
		var isRole = shape.getStencil().roles().any(function(r){ return r == role});
		
		return isRole || shape.getStencil().id() == (shape.getStencil().namespace()+role);
	},

	/**
	 * 
	 * @param {String}
	 *            role
	 * 
	 * @return {Array} Returns an array of stencils that can act as role.
	 */
	_stencilsWithRole: function(role) {
		return this._stencils.findAll(function(stencil) {
			return (stencil.roles().member(role)) ? true : false;
		});
	},
	
	/**
	 * 
	 * @param {String}
	 *            role
	 * 
	 * @return {Array} Returns an array of stencils that can act as role and
	 *         have the type 'edge'.
	 */
	_edgesWithRole: function(role) {
		return this._stencils.findAll(function(stencil) {
			return (stencil.roles().member(role) && stencil.type() === "edge") ? true : false;
		});
	},
	
	/**
	 * 
	 * @param {String}
	 *            role
	 * 
	 * @return {Array} Returns an array of stencils that can act as role and
	 *         have the type 'node'.
	 */
	_nodesWithRole: function(role) {
		return this._stencils.findAll(function(stencil) {
			return (stencil.roles().member(role) && stencil.type() === "node") ? true : false;
		});
	},

	/**
	 * 
	 * @param {ORYX.Core.StencilSet.Stencil}
	 *            parent
	 * @param {ORYX.Core.StencilSet.Stencil}
	 *            child
	 * 
	 * @returns {Boolean} Returns the maximum occurrence of shapes of the
	 *          stencil's type inside the parent.
	 */
	_getMaximumOccurrence: function(parent, child) {
		var max;
		child.roles().each((function(role) {
			var cardRule = this._cardinalityRules[role];
			if(cardRule && cardRule.maximumOccurrence) {
				if(max) {
					max = Math.min(max, cardRule.maximumOccurrence);
				} else {
					max = cardRule.maximumOccurrence;
				}
			}
		}).bind(this));

		return max;
	},


	/**
	 * 
	 * @param {Object}
	 *            args sourceStencil: ORYX.Core.Node edgeStencil:
	 *            ORYX.Core.StencilSet.Stencil
	 * 
	 * @return {Boolean} Returns, the maximum number of outgoing edges of the
	 *         type specified by edgeStencil of the sourceShape.
	 */
	_getMaximumNumberOfOutgoingEdge: function(args) {
		if(!args ||
		   !args.sourceStencil ||
		   !args.edgeStencil) {
		   	return false;
		}
		
		var max;
		args.sourceStencil.roles().each((function(role) {
			var cardRule = this._cardinalityRules[role];

			if(cardRule && cardRule.outgoingEdges) {
				args.edgeStencil.roles().each(function(edgeRole) {
					var oe = cardRule.outgoingEdges[edgeRole];

					if(oe && oe.maximum) {
						if(max) {
							max = Math.min(max, oe.maximum);
						} else {
							max = oe.maximum;
						}
					}
				});
			}
		}).bind(this));

		return max;
	},
	
	/**
	 * 
	 * @param {Object}
	 *            args targetStencil: ORYX.Core.StencilSet.Stencil edgeStencil:
	 *            ORYX.Core.StencilSet.Stencil
	 * 
	 * @return {Boolean} Returns the maximum number of incoming edges of the
	 *         type specified by edgeStencil of the targetShape.
	 */
	_getMaximumNumberOfIncomingEdge: function(args) {
		if(!args ||
		   !args.targetStencil ||
		   !args.edgeStencil) {
		   	return false;
		}
		
		var max;
		args.targetStencil.roles().each((function(role) {
			var cardRule = this._cardinalityRules[role];
			if(cardRule && cardRule.incomingEdges) {
				args.edgeStencil.roles().each(function(edgeRole) {
					var ie = cardRule.incomingEdges[edgeRole];
					if(ie && ie.maximum) {
						if(max) {
							max = Math.min(max, ie.maximum);
						} else {
							max = ie.maximum;
						}
					}
				});
			}
		}).bind(this));

		return max;
	},
	
	/**
	 * 
	 * @param {ORYX.Core.StencilSet.Stencil}
	 *            edgeStencil
	 * 
	 * @return {Hash} Returns a hash map of all connection rules for
	 *         edgeStencil.
	 */
	_getConnectionRulesOfEdgeStencil: function(edgeStencil) {
		var edgeRules = new Hash();
		edgeStencil.roles().each((function(role) {
			if(this._connectionRules[role]) {
				this._connectionRules[role].each(function(cr) {
					if(edgeRules[cr.key]) {
						edgeRules[cr.key] = edgeRules[cr.key].concat(cr.value);
					} else {
						edgeRules[cr.key] = cr.value;
					}
				});
			}
		}).bind(this));
		
		return edgeRules;
	},
	
	_isRoleOfOtherNamespace: function(role) {
		return (role.indexOf("#") > 0);
	},

	toString: function() { return "Rules"; }
}
ORYX.Core.StencilSet.Rules = Clazz.extend(ORYX.Core.StencilSet.Rules);

/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
/**
 * Init namespace
 */
if (!ORYX) {
    var ORYX = {};
}
if (!ORYX.Core) {
    ORYX.Core = {};
}
if (!ORYX.Core.StencilSet) {
    ORYX.Core.StencilSet = {};
}

/**
 * This class represents a stencil set. It offers methods for accessing
 *  the attributes of the stencil set description JSON file and the stencil set's
 *  stencils.
 */
ORYX.Core.StencilSet.StencilSet = Clazz.extend({

    /**
     * Constructor
     * @param source {URL} A reference to the stencil set specification.
     *
     */
    construct: function(source){
        arguments.callee.$.construct.apply(this, arguments);
        
        if (!source) {
            throw "ORYX.Core.StencilSet.StencilSet(construct): Parameter 'source' is not defined.";
        }
        
        if (source.endsWith("/")) {
            source = source.substr(0, source.length - 1);
        }
		
		this._extensions = new Hash();
        
        this._source = source;
        this._baseUrl = source.substring(0, source.lastIndexOf("/") + 1);
        
        this._jsonObject = {};
        
        this._stencils = new Hash();
		this._availableStencils = new Hash();
        
		if(ORYX.CONFIG.BACKEND_SWITCH) {
			//get the url of the stencil set json file
			new Ajax.Request(source, {
	            asynchronous: false,
	            method: 'get',
	            onSuccess: this._getJSONURL.bind(this),
	            onFailure: this._cancelInit.bind(this)
	        });
		} else {
			new Ajax.Request(source, {
	            asynchronous: false,
	            method: 'get',
	            onSuccess: this._init.bind(this),
	            onFailure: this._cancelInit.bind(this)
	        });
		}
        
        if (this.errornous) 
            throw "Loading stencil set " + source + " failed.";
    },
    
    /**
     * Finds a root stencil in this stencil set. There may be many of these. If
     * there are, the first one found will be used. In Firefox, this is the
     * topmost definition in the stencil set description file.
     */
    findRootStencilName: function(){
    
        // find any stencil that may be root.
        var rootStencil = this._stencils.values().find(function(stencil){
            return stencil._jsonStencil.mayBeRoot
        });
        
		// if there is none, just guess the first.
		if (!rootStencil) {
			ORYX.Log.warn("Did not find any stencil that may be root. Taking a guess.");
			rootStencil = this._stencils.values()[0];
		}

        // return its id.
        return rootStencil.id();
    },
    
    /**
     * @param {ORYX.Core.StencilSet.StencilSet} stencilSet
     * @return {Boolean} True, if stencil set has the same namespace.
     */
    equals: function(stencilSet){
        return (this.namespace() === stencilSet.namespace());
    },
    
	/**
	 * 
	 * @param {Oryx.Core.StencilSet.Stencil} rootStencil If rootStencil is defined, it only returns stencils
	 * 			that could be (in)direct child of that stencil.
	 */
    stencils: function(rootStencil, rules, sortByGroup){
		if(rootStencil && rules) {
			var stencils = this._availableStencils.values();
			var containers = [rootStencil];
			var checkedContainers = [];
			
			var result = [];
			
			while (containers.size() > 0) {
				var container = containers.pop();
				checkedContainers.push(container);
				var children = stencils.findAll(function(stencil){
					var args = {
						containingStencil: container,
						containedStencil: stencil
					};
					return rules.canContain(args);
				});
				for(var i = 0; i < children.size(); i++) {
					if (!checkedContainers.member(children[i])) {
						containers.push(children[i]);
					}
				}
				result = result.concat(children).uniq();
			}
			
			// Sort the result to the origin order
			result = result.sortBy(function(stencil) {
				return stencils.indexOf(stencil);
			});
			
			
			if(sortByGroup) {
				result = result.sortBy(function(stencil) {
					return stencil.groups().first();
				});
			}
			
			var edges = stencils.findAll(function(stencil) {
				return stencil.type() == "edge";
			});
			result = result.concat(edges);
			
			return result;
			
		} else {
        	if(sortByGroup) {
				return this._availableStencils.values().sortBy(function(stencil) {
					return stencil.groups().first();
				});
			} else {
				return this._availableStencils.values();
			}
		}
    },
    
    nodes: function(){
        return this._availableStencils.values().findAll(function(stencil){
            return (stencil.type() === 'node')
        });
    },
    
    edges: function(){
        return this._availableStencils.values().findAll(function(stencil){
            return (stencil.type() === 'edge')
        });
    },
    
    stencil: function(id){
        return this._stencils[id];
    },
    
    title: function(){
        return ORYX.Core.StencilSet.getTranslation(this._jsonObject, "title");
    },
    
    description: function(){
        return ORYX.Core.StencilSet.getTranslation(this._jsonObject, "description");
    },
    
    namespace: function(){
        return this._jsonObject ? this._jsonObject.namespace : null;
    },
    
    jsonRules: function(){
        return this._jsonObject ? this._jsonObject.rules : null;
    },
    
    source: function(){
        return this._source;
    },
	
	extensions: function() {
		return this._extensions;
	},
	
	addExtension: function(url) {
		
		new Ajax.Request(url, {
            method: 'GET',
            asynchronous: false,
			onSuccess: (function(transport) {
				this.addExtensionDirectly(transport.responseText);
			}).bind(this),
			onFailure: (function(transport) {
				ORYX.Log.debug("Loading stencil set extension file failed. The request returned an error." + transport);
			}).bind(this),
			onException: (function(transport) {
				ORYX.Log.debug("Loading stencil set extension file failed. The request returned an error." + transport);
			}).bind(this)
		
		});
	},
	
	addExtensionDirectly: function(str){

		try {
			eval("var jsonExtension = " + str);

			if(!(jsonExtension["extends"].endsWith("#")))
					jsonExtension["extends"] += "#";
					
			if(jsonExtension["extends"] == this.namespace()) {
				this._extensions[jsonExtension.namespace] = jsonExtension;
				
				var defaultPosition = this._stencils.keys().size();
				//load new stencils
				if(jsonExtension.stencils) {
					$A(jsonExtension.stencils).each(function(stencil) {
						defaultPosition++;
						var oStencil = new ORYX.Core.StencilSet.Stencil(stencil, this.namespace(), this._baseUrl, this, undefined, defaultPosition);            
						this._stencils[oStencil.id()] = oStencil;
						this._availableStencils[oStencil.id()] = oStencil;
					}.bind(this));
				}
				
				//load additional properties
				if (jsonExtension.properties) {
					var stencils = this._stencils.values();
					
					stencils.each(function(stencil){
						var roles = stencil.roles();
						
						jsonExtension.properties.each(function(prop){
							prop.roles.any(function(role){
								role = jsonExtension["extends"] + role;
								if (roles.member(role)) {
									prop.properties.each(function(property){
										stencil.addProperty(property, jsonExtension.namespace);
									});
									
									return true;
								}
								else 
									return false;
							})
						})
					}.bind(this));
				}
				
				//remove stencil properties
				if(jsonExtension.removeproperties) {
					jsonExtension.removeproperties.each(function(remprop) {
						var stencil = this.stencil(jsonExtension["extends"] + remprop.stencil);
						if(stencil) {
							remprop.properties.each(function(propId) {
								stencil.removeProperty(propId);
							});
						}
					}.bind(this));
				}
				
				//remove stencils
				if(jsonExtension.removestencils) {
					$A(jsonExtension.removestencils).each(function(remstencil) {
						delete this._availableStencils[jsonExtension["extends"] + remstencil];
					}.bind(this));
				}
			}
		} catch (e) {
			ORYX.Log.debug("StencilSet.addExtension: Something went wrong when initialising the stencil set extension. " + e);
		}	
	},
	
	removeExtension: function(namespace) {
		var jsonExtension = this._extensions[namespace];
		if(jsonExtension) {
			
			//unload extension's stencils
			if(jsonExtension.stencils) {
				$A(jsonExtension.stencils).each(function(stencil) {
					var oStencil = new ORYX.Core.StencilSet.Stencil(stencil, this.namespace(), this._baseUrl, this);            
					delete this._stencils[oStencil.id()]; // maybe not ??
					delete this._availableStencils[oStencil.id()];
				}.bind(this));
			}
			
			//unload extension's properties
			if (jsonExtension.properties) {
				var stencils = this._stencils.values();
				
				stencils.each(function(stencil){
					var roles = stencil.roles();
					
					jsonExtension.properties.each(function(prop){
						prop.roles.any(function(role){
							role = jsonExtension["extends"] + role;
							if (roles.member(role)) {
								prop.properties.each(function(property){
									stencil.removeProperty(property.id);
								});
								
								return true;
							}
							else 
								return false;
						})
					})
				}.bind(this));
			}
			
			//restore removed stencil properties
			if(jsonExtension.removeproperties) {
				jsonExtension.removeproperties.each(function(remprop) {
					var stencil = this.stencil(jsonExtension["extends"] + remprop.stencil);
					if(stencil) {
						var stencilJson = $A(this._jsonObject.stencils).find(function(s) { return s.id == stencil.id() });
						remprop.properties.each(function(propId) {
							var propertyJson = $A(stencilJson.properties).find(function(p) { return p.id == propId });
							stencil.addProperty(propertyJson, this.namespace());
						}.bind(this));
					}
				}.bind(this));
			}
			
			//restore removed stencils
			if(jsonExtension.removestencils) {
				$A(jsonExtension.removestencils).each(function(remstencil) {
					var sId = jsonExtension["extends"] + remstencil;
					this._availableStencils[sId] = this._stencils[sId];
				}.bind(this));
			}
		}
		delete this._extensions[namespace];
	},
    
    __handleStencilset: function(response){
    
        try {
            // using eval instead of prototype's parsing,
            // since there are functions in this JSON.
            eval("this._jsonObject =" + response.responseText);
        } 
        catch (e) {
            throw "Stenciset corrupt: " + e;
        }
        
        // assert it was parsed.
        if (!this._jsonObject) {
            throw "Error evaluating stencilset. It may be corrupt.";
        }
        
        with (this._jsonObject) {
        
            // assert there is a namespace.
            if (!namespace || namespace === "") 
                throw "Namespace definition missing in stencilset.";
            
            if (!(stencils instanceof Array)) 
                throw "Stencilset corrupt.";
            
            // assert namespace ends with '#'.
            if (!namespace.endsWith("#")) 
                namespace = namespace + "#";
            
            // assert title and description are strings.
            if (!title) 
                title = "";
            if (!description) 
                description = "";
        }
    },
	
	_getJSONURL: function(response) {
		this._baseUrl = response.responseText.substring(0, response.responseText.lastIndexOf("/") + 1);
		this._source = response.responseText;
		new Ajax.Request(response.responseText, {
            asynchronous: false,
            method: 'get',
            onSuccess: this._init.bind(this),
            onFailure: this._cancelInit.bind(this)
        });
	},
    
    /**
     * This method is called when the HTTP request to get the requested stencil
     * set succeeds. The response is supposed to be a JSON representation
     * according to the stencil set specification.
     * @param {Object} response The JSON representation according to the
     * 			stencil set specification.
     */
    _init: function(response){
    
        // init and check consistency.
        this.__handleStencilset(response);
		
		var pps = new Hash();
		
		// init property packages
		if(this._jsonObject.propertyPackages) {
			$A(this._jsonObject.propertyPackages).each((function(pp) {
				pps[pp.name] = pp.properties;
			}).bind(this));
		}
		
		var defaultPosition = 0;
		
        // init each stencil
        $A(this._jsonObject.stencils).each((function(stencil){
        	defaultPosition++;
        	
            // instantiate normally.
            var oStencil = new ORYX.Core.StencilSet.Stencil(stencil, this.namespace(), this._baseUrl, this, pps, defaultPosition);      
			this._stencils[oStencil.id()] = oStencil;
			this._availableStencils[oStencil.id()] = oStencil;
            
        }).bind(this));
    },
    
    _cancelInit: function(response){
        this.errornous = true;
    },
    
    toString: function(){
        return "StencilSet " + this.title() + " (" + this.namespace() + ")";
    }
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespace
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.StencilSet) {ORYX.Core.StencilSet = {};}

/**
 * Class StencilSets
 * uses Prototpye 1.5.0
 * uses Inheritance
 *
 * Singleton
 */
//storage for loaded stencil sets by namespace
ORYX.Core.StencilSet._stencilSetsByNamespace = new Hash();

//storage for stencil sets by url
ORYX.Core.StencilSet._stencilSetsByUrl = new Hash();	

//storage for stencil set namespaces by editor instances
ORYX.Core.StencilSet._StencilSetNSByEditorInstance = new Hash();

//storage for rules by editor instances
ORYX.Core.StencilSet._rulesByEditorInstance = new Hash();

/**
 * 
 * @param {String} editorId
 * 
 * @return {Hash} Returns a hash map with all stencil sets that are loaded by
 * 					the editor with the editorId.
 */
ORYX.Core.StencilSet.stencilSets = function(editorId) {
	var stencilSetNSs = ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId];
	var stencilSets = new Hash();
	if(stencilSetNSs) {
		stencilSetNSs.each(function(stencilSetNS) {
			var stencilSet = ORYX.Core.StencilSet.stencilSet(stencilSetNS)
			stencilSets[stencilSet.namespace()] = stencilSet;
		});
	}
	return stencilSets;
};

/**
 * 
 * @param {String} namespace
 * 
 * @return {ORYX.Core.StencilSet.StencilSet} Returns the stencil set with the specified
 * 										namespace.
 * 
 * The method can handle namespace strings like
 *  http://www.example.org/stencilset
 *  http://www.example.org/stencilset#
 *  http://www.example.org/stencilset#ANode
 */
ORYX.Core.StencilSet.stencilSet = function(namespace) {
	ORYX.Log.trace("Getting stencil set %0", namespace);
	var splitted = namespace.split("#", 1);
	if(splitted.length === 1) {
		ORYX.Log.trace("Getting stencil set %0", splitted[0]);
		return ORYX.Core.StencilSet._stencilSetsByNamespace[splitted[0] + "#"];
	} else {
		return undefined;
	}
};

/**
 * 
 * @param {String} id
 * 
 * @return {ORYX.Core.StencilSet.Stencil} Returns the stencil specified by the id.
 * 
 * The id must be unique and contains the namespace of the stencil's stencil set.
 * e.g. http://www.example.org/stencilset#ANode
 */
ORYX.Core.StencilSet.stencil = function(id) {
	ORYX.Log.trace("Getting stencil for %0", id);
	var ss = ORYX.Core.StencilSet.stencilSet(id);
	if(ss) {
		return ss.stencil(id);
	} else {

		ORYX.Log.trace("Cannot fild stencil for %0", id);
		return undefined;
	}
};

/**
 * 
 * @param {String} editorId
 * 
 * @return {ORYX.Core.StencilSet.Rules} Returns the rules object for the editor
 * 									specified by its editor id.
 */
ORYX.Core.StencilSet.rules = function(editorId) {
	if(!ORYX.Core.StencilSet._rulesByEditorInstance[editorId]) {
		ORYX.Core.StencilSet._rulesByEditorInstance[editorId] = new ORYX.Core.StencilSet.Rules();;
	}
	return ORYX.Core.StencilSet._rulesByEditorInstance[editorId];
};

/**
 * 
 * @param {String} url
 * @param {String} editorId
 * 
 * Loads a stencil set from url, if it is not already loaded.
 * It also stores which editor instance loads the stencil set and 
 * initializes the Rules object for the editor instance.
 */
ORYX.Core.StencilSet.loadStencilSet = function(url, editorId) {
	var stencilSet = ORYX.Core.StencilSet._stencilSetsByUrl[url];

	if(!stencilSet) {
		//load stencil set
		stencilSet = new ORYX.Core.StencilSet.StencilSet(url);
		
		//store stencil set
		ORYX.Core.StencilSet._stencilSetsByNamespace[stencilSet.namespace()] = stencilSet;
		
		//store stencil set by url
		ORYX.Core.StencilSet._stencilSetsByUrl[url] = stencilSet;
	}
	
	var namespace = stencilSet.namespace();
	
	//store which editorInstance loads the stencil set
	if(ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId]) {
		ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId].push(namespace);
	} else {
		ORYX.Core.StencilSet._StencilSetNSByEditorInstance[editorId] = [namespace];
	}

	//store the rules for the editor instance
	if(ORYX.Core.StencilSet._rulesByEditorInstance[editorId]) {
		ORYX.Core.StencilSet._rulesByEditorInstance[editorId].initializeRules(stencilSet);
	} else {
		var rules = new ORYX.Core.StencilSet.Rules();
		rules.initializeRules(stencilSet);
		ORYX.Core.StencilSet._rulesByEditorInstance[editorId] = rules;
	}
};

/**
 * Returns the translation of an attribute in jsonObject specified by its name
 * according to navigator.language
 */
ORYX.Core.StencilSet.getTranslation = function(jsonObject, name) {
	var lang = ORYX.I18N.Language.toLowerCase();
	
	var result = jsonObject[name + "_" + lang];
	
	if(result)
		return result;
		
	result = jsonObject[name + "_" + lang.substr(0, 2)];
	
	if(result)
		return result;
		
	return jsonObject[name];
};
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}


/**
 * @classDescription With Bounds you can set and get position and size of UIObjects.
 */
ORYX.Core.Bounds = {

	/**
	 * Constructor
	 */
	construct: function() {
		this._changedCallbacks = []; //register a callback with changedCallacks.push(this.method.bind(this));
		this.a = {};
		this.b = {};
		this.set.apply(this, arguments);
		this.suspendChange = false;
		this.changedWhileSuspend = false;
	},
	
	/**
	 * Calls all registered callbacks.
	 */
	_changed: function(sizeChanged) {
		if(!this.suspendChange) {
			this._changedCallbacks.each(function(callback) {
				callback(this, sizeChanged);
			}.bind(this));
			this.changedWhileSuspend = false;
		} else
			this.changedWhileSuspend = true;
	},
	
	/**
	 * Registers a callback that is called, if the bounds changes.
	 * @param callback {Function} The callback function.
	 */
	registerCallback: function(callback) {
		if(!this._changedCallbacks.member(callback)) {
			this._changedCallbacks.push(callback);	
		}
	},
	
	/**
	 * Unregisters a callback.
	 * @param callback {Function} The callback function.
	 */
	unregisterCallback: function(callback) {
			this._changedCallbacks = this._changedCallbacks.without(callback);
	},
	
	/**
	 * Sets position and size of the shape dependent of four coordinates
	 * (set(ax, ay, bx, by);), two points (set({x: ax, y: ay}, {x: bx, y: by});)
	 * or one bound (set({a: {x: ax, y: ay}, b: {x: bx, y: by}});).
	 */
	set: function() {
		
		var changed = false;
		
		switch (arguments.length) {
		
			case 1:
				if(this.a.x !== arguments[0].a.x) {
					changed = true;
					this.a.x = arguments[0].a.x;
				}
				if(this.a.y !== arguments[0].a.y) {
					changed = true;
					this.a.y = arguments[0].a.y;
				}
				if(this.b.x !== arguments[0].b.x) {
					changed = true;
					this.b.x = arguments[0].b.x;
				}
				if(this.b.y !== arguments[0].b.y) {
					changed = true;
					this.b.y = arguments[0].b.y;
				}
				break;
			
			case 2:
				var ax = Math.min(arguments[0].x, arguments[1].x);
				var ay = Math.min(arguments[0].y, arguments[1].y);
				var bx = Math.max(arguments[0].x, arguments[1].x);
				var by = Math.max(arguments[0].y, arguments[1].y);
				if(this.a.x !== ax) {
					changed = true;
					this.a.x = ax;
				}
				if(this.a.y !== ay) {
					changed = true;
					this.a.y = ay;
				}
				if(this.b.x !== bx) {
					changed = true;
					this.b.x = bx;
				}
				if(this.b.y !== by) {
					changed = true;
					this.b.y = by;
				}
				break;
			
			case 4:
				var ax = Math.min(arguments[0], arguments[2]);
				var ay = Math.min(arguments[1], arguments[3]);
				var bx = Math.max(arguments[0], arguments[2]);
				var by = Math.max(arguments[1], arguments[3]);
				if(this.a.x !== ax) {
					changed = true;
					this.a.x = ax;
				}
				if(this.a.y !== ay) {
					changed = true;
					this.a.y = ay;
				}
				if(this.b.x !== bx) {
					changed = true;
					this.b.x = bx;
				}
				if(this.b.y !== by) {
					changed = true;
					this.b.y = by;
				}
				break;
		}
		
		if(changed) {
			this._changed(true);
		}
	},
	
	/**
	 * Moves the bounds so that the point p will be the new upper left corner.
	 * @param {Point} p
	 * or
	 * @param {Number} x
	 * @param {Number} y
	 */
	moveTo: function() {
		
		var currentPosition = this.upperLeft();
		switch (arguments.length) {
			case 1:
				this.moveBy({
					x: arguments[0].x - currentPosition.x,
					y: arguments[0].y - currentPosition.y
				});
				break;
			case 2:
				this.moveBy({
					x: arguments[0] - currentPosition.x,
					y: arguments[1] - currentPosition.y
				});
				break;
			default:
				//TODO error
		}
		
	},
	
	/**
	 * Moves the bounds relatively by p.
	 * @param {Point} p
	 * or
	 * @param {Number} x
	 * @param {Number} y
	 * 
	 */
	moveBy: function() {
		var changed = false;
		
		switch (arguments.length) {
			case 1:
				var p = arguments[0];
				if(p.x !== 0 || p.y !== 0) {
					changed = true;
					this.a.x += p.x;
					this.b.x += p.x;
					this.a.y += p.y;
					this.b.y += p.y;
				}
				break;	
			case 2:
				var x = arguments[0];
				var y = arguments[1];
				if(x !== 0 || y !== 0) {
					changed = true;
					this.a.x += x;
					this.b.x += x;
					this.a.y += y;
					this.b.y += y;
				}
				break;	
			default:
				//TODO error
		}
		
		if(changed) {
			this._changed();
		}
	},
	
	/***
	 * Includes the bounds b into the current bounds.
	 * @param {Bounds} b
	 */
	include: function(b) {
		
		if( (this.a.x === undefined) && (this.a.y === undefined) &&
			(this.b.x === undefined) && (this.b.y === undefined)) {
			return b;
		};
		
		var cx = Math.min(this.a.x,b.a.x);
		var cy = Math.min(this.a.y,b.a.y);
		
		var dx = Math.max(this.b.x,b.b.x);
		var dy = Math.max(this.b.y,b.b.y);

		
		this.set(cx, cy, dx, dy);
	},
	
	/**
	 * Relatively extends the bounds by p.
	 * @param {Point} p
	 */
	extend: function(p) {
		
		if(p.x !== 0 || p.y !== 0) {
			// this is over cross for the case that a and b have same coordinates.
			//((this.a.x > this.b.x) ? this.a : this.b).x += p.x;
			//((this.b.y > this.a.y) ? this.b : this.a).y += p.y;
			this.b.x += p.x;
			this.b.y += p.y;
			
			this._changed(true);
		}
	},
	
	/**
	 * Widens the scope of the bounds by x.
	 * @param {Number} x
	 */
	widen: function(x) {
		if (x !== 0) {
			this.suspendChange = true;
			this.moveBy({x: -x, y: -x});
			this.extend({x: 2*x, y: 2*x});
			this.suspendChange = false;
			if(this.changedWhileSuspend) {
				this._changed(true);
			}
		}
	},
	
	/**
	 * Returns the upper left corner's point regardless of the
	 * bound delimiter points.
	 */
	upperLeft: function() {
		
		return {x:this.a.x, y:this.a.y};
	},
	
	/**
	 * Returns the lower Right left corner's point regardless of the
	 * bound delimiter points.
	 */
	lowerRight: function() {
		
		return {x:this.b.x, y:this.b.y};
	},
	
	/**
	 * @return {Number} Width of bounds.
	 */
	width: function() {
		return this.b.x - this.a.x;
	},
	
	/**
	 * @return {Number} Height of bounds.
	 */
	height: function() {
		return this.b.y - this.a.y;
	},
	
	/**
	 * @return {Point} The center point of this bounds.
	 */
	center: function() {
		return {
			x: (this.a.x + this.b.x)/2.0, 
			y: (this.a.y + this.b.y)/2.0
		};
	},

	
	/**
	 * @return {Point} The center point of this bounds relative to upperLeft.
	 */
	midPoint: function() {
		return {
			x: (this.b.x - this.a.x)/2.0, 
			y: (this.b.y - this.a.y)/2.0
		};
	},
		
	/**
	 * Moves the center point of this bounds to the new position.
	 * @param p {Point} 
	 * or
	 * @param x {Number}
	 * @param y {Number}
	 */
	centerMoveTo: function() {
		var currentPosition = this.center();
		
		switch (arguments.length) {
			
			case 1:
				this.moveBy(arguments[0].x - currentPosition.x,
							arguments[0].y - currentPosition.y);
				break;
			
			case 2:
				this.moveBy(arguments[0] - currentPosition.x,
							arguments[1] - currentPosition.y);
				break;
		}
	},
	
	isIncluded: function(point, offset) {
		
		var pointX, pointY, offset;

		// Get the the two Points	
		switch(arguments.length) {
			case 1:
				pointX = arguments[0].x;
				pointY = arguments[0].y;
				offset = 0;
				
				break;
			case 2:
				if(arguments[0].x && arguments[0].y) {
					pointX = arguments[0].x;
					pointY = arguments[0].y;
					offset = Math.abs(arguments[1]);
				} else {
					pointX = arguments[0];
					pointY = arguments[1];
					offset = 0;
				}
				break;
			case 3:
				pointX = arguments[0];
				pointY = arguments[1];
				offset = Math.abs(arguments[2]);
				break;
			default:
				throw "isIncluded needs one, two or three arguments";
		}
				
		var ul = this.upperLeft();
		var lr = this.lowerRight();
		
		if(pointX >= ul.x - offset 
			&& pointX <= lr.x + offset && pointY >= ul.y - offset 
			&& pointY <= lr.y + offset)
			return true;
		else 
			return false;
	},
	
	/**
	 * @return {Bounds} A copy of this bounds.
	 */
	clone: function() {
		
		//Returns a new bounds object without the callback
		// references of the original bounds
		return new ORYX.Core.Bounds(this);
	},
	
	toString: function() {
		
		return "( "+this.a.x+" | "+this.a.y+" )/( "+this.b.x+" | "+this.b.y+" )";
	},
	
	serializeForERDF: function() {

		return this.a.x+","+this.a.y+","+this.b.x+","+this.b.y;
	}
 };
 
ORYX.Core.Bounds = Clazz.extend(ORYX.Core.Bounds);/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}/** * @classDescription Abstract base class for all objects that have a graphical representation * within the editor. * @extends Clazz */ORYX.Core.UIObject = {	/**	 * Constructor of the UIObject class.	 */	construct: function(options) {					this.isChanged = true;			//Flag, if UIObject has been changed since last update.		this.isResized = true;		this.isVisible = true;			//Flag, if UIObject's display attribute is set to 'inherit' or 'none'		this.isSelectable = false;		//Flag, if UIObject is selectable.		this.isResizable = false;		//Flag, if UIObject is resizable.		this.isMovable = false;			//Flag, if UIObject is movable.				this.id = ORYX.Editor.provideId();	//get unique id		this.parent = undefined;		//parent is defined, if this object is added to another uiObject.		this.node = undefined;			//this is a reference to the SVG representation, either locally or in DOM.		this.children = [];				//array for all add uiObjects				this.bounds = new ORYX.Core.Bounds();		//bounds with undefined values		this._changedCallback = this._changed.bind(this);	//callback reference for calling _changed		this.bounds.registerCallback(this._changedCallback);	//set callback in bounds				if(options && options.eventHandlerCallback) {			this.eventHandlerCallback = options.eventHandlerCallback;		}	},		/**	 * Sets isChanged flag to true. Callback for the bounds object.	 */	_changed: function(bounds, isResized) {		this.isChanged = true;		if(this.bounds == bounds)			this.isResized = isResized || this.isResized;	},		/**	 * If something changed, this method calls the refresh method that must be implemented by subclasses.	 */	update: function() {		if(this.isChanged) {			this.refresh();			this.isChanged = false;						//call update of all children			this.children.each(function(value) {				value.update();			});		}	},		/**	 * Is called in update method, if isChanged is set to true. Sub classes should call the super class method.	 */	refresh: function() {			},		/**	 * @return {Array} Array of all child UIObjects.	 */	getChildren: function() {		return this.children.clone();	},		/**	 * @return {Array} Array of all parent UIObjects.	 */	getParents: function(){		var parents = [];		var parent = this.parent;		while(parent){			parents.push(parent);			parent = parent.parent;		}		return parents;	},		/**	 * Returns TRUE if the given parent is one of the UIObjects parents or the UIObject themselves, otherwise FALSE.	 * @param {UIObject} parent	 * @return {Boolean} 	 */	isParent: function(parent){		var cparent = this;		while(cparent){			if (cparent === parent){				return true;			}			cparent = cparent.parent;		}		return false;	},		/**	 * @return {String} Id of this UIObject	 */	getId: function() {		return this.id;	},		/**	 * Method for accessing child uiObjects by id.	 * @param {String} id	 * @param {Boolean} deep	 * 	 * @return {UIObject} If found, it returns the UIObject with id.	 */	getChildById: function(id, deep) {		return this.children.find(function(uiObj) {			if(uiObj.getId() === id) {				return uiObj;			} else {				if(deep) {					var obj = uiObj.getChildById(id, deep);					if(obj) {						return obj;					}				}			}		});	},		/**	 * Adds an UIObject to this UIObject and sets the parent of the	 * added UIObject. It is also added to the SVG representation of this	 * UIObject.	 * @param {UIObject} uiObject	 */	add: function(uiObject) {		//add uiObject, if it is not already a child of this object		if (!(this.children.member(uiObject))) {			//if uiObject is child of another parent, remove it from that parent.			if(uiObject.parent) {				uiObject.remove(uiObject);			}						//add uiObject to children			this.children.push(uiObject);						//set parent reference			uiObject.parent = this;						//add uiObject.node to this.node			uiObject.node = this.node.appendChild(uiObject.node);						//register callback to get informed, if child is changed			uiObject.bounds.registerCallback(this._changedCallback);								if(this.eventHandlerCallback)				this.eventHandlerCallback({type:ORYX.CONFIG.EVENT_SHAPEADDED,shape:uiObject})			//uiObject.update();		} else {			ORYX.Log.info("add: ORYX.Core.UIObject is already a child of this object.");		}	},		/**	 * Removes UIObject from this UIObject. The SVG representation will also	 * be removed from this UIObject's SVG representation.	 * @param {UIObject} uiObject	 */	remove: function(uiObject) {		//if uiObject is a child of this object, remove it.		if (this.children.member(uiObject)) {			//remove uiObject from children			this.children = this._uiObjects.without(uiObject);						//delete parent reference of uiObject			uiObject.parent = undefined;						//delete uiObject.node from this.node			uiObject.node = this.node.removeChild(uiObject.node);						//unregister callback to get informed, if child is changed			uiObject.bounds.unregisterCallback(this._changedCallback);		} else {			ORYX.Log.info("remove: ORYX.Core.UIObject is not a child of this object.");		}			},		/**	 * Calculates absolute bounds of this UIObject.	 */	absoluteBounds: function() {		if(this.parent) {			var absUL = this.absoluteXY();			return new ORYX.Core.Bounds(absUL.x, absUL.y,							absUL.x + this.bounds.width(),							absUL.y + this.bounds.height());		} else {			return this.bounds.clone();		}	},	/**	 * @return {Point} The absolute position of this UIObject.	 */	absoluteXY: function() {		if(this.parent) {			var pXY = this.parent.absoluteXY();					return {x: pXY.x + this.bounds.upperLeft().x , y: pXY.y + this.bounds.upperLeft().y};					} else {			return {x: this.bounds.upperLeft().x , y: this.bounds.upperLeft().y};		}	},	/**	 * @return {Point} The absolute position from the Center of this UIObject.	 */	absoluteCenterXY: function() {		if(this.parent) {			var pXY = this.parent.absoluteXY();					return {x: pXY.x + this.bounds.center().x , y: pXY.y + this.bounds.center().y};					} else {			return {x: this.bounds.center().x , y: this.bounds.center().y};		}	},		/**	 * Hides this UIObject and all its children.	 */	hide: function() {		this.node.setAttributeNS(null, 'display', 'none');		this.isVisible = false;		this.children.each(function(uiObj) {			uiObj.hide();			});	},		/**	 * Enables visibility of this UIObject and all its children.	 */	show: function() {		this.node.setAttributeNS(null, 'display', 'inherit');		this.isVisible = true;		this.children.each(function(uiObj) {			uiObj.show();			});			},		addEventHandlers: function(node) {				node.addEventListener(ORYX.CONFIG.EVENT_MOUSEDOWN, this._delegateEvent.bind(this), false);		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this._delegateEvent.bind(this), false);			node.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this._delegateEvent.bind(this), false);		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOVER, this._delegateEvent.bind(this), false);		node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOUT, this._delegateEvent.bind(this), false);		node.addEventListener('click', this._delegateEvent.bind(this), false);		node.addEventListener(ORYX.CONFIG.EVENT_DBLCLICK, this._delegateEvent.bind(this), false);				},			_delegateEvent: function(event) {		if(this.eventHandlerCallback) {			this.eventHandlerCallback(event, this);		}	},		toString: function() { return "UIObject " + this.id } }; ORYX.Core.UIObject = Clazz.extend(ORYX.Core.UIObject);/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}

/**
 * Top Level uiobject.
 * @class ORYX.Core.AbstractShape
 * @extends ORYX.Core.UIObject
 */
ORYX.Core.AbstractShape = ORYX.Core.UIObject.extend(
/** @lends ORYX.Core.AbstractShape.prototype */
{

	/**
	 * Constructor
	 */
	construct: function(options, stencil) {
		
		arguments.callee.$.construct.apply(this, arguments);
		
		this.resourceId = ORYX.Editor.provideId(); //Id of resource in DOM
		
		// stencil reference
		this._stencil = stencil;
		// if the stencil defines a super stencil that should be used for its instances, set it.
		if (this._stencil._jsonStencil.superId){
			stencilId = this._stencil.id()
			superStencilId = stencilId.substring(0, stencilId.indexOf("#") + 1) + stencil._jsonStencil.superId;
			stencilSet =  this._stencil.stencilSet();
			this._stencil = stencilSet.stencil(superStencilId);
		}
		
		//Hash map for all properties. Only stores the values of the properties.
		this.properties = new Hash();
		this.propertiesChanged = new Hash();

		// List of properties which are not included in the stencilset, 
		// but which gets (de)serialized
		this.hiddenProperties = new Hash();
		
		
		//Initialization of property map and initial value.
		this._stencil.properties().each((function(property) {
			var key = property.prefix() + "-" + property.id();
			this.properties[key] = property.value();
			this.propertiesChanged[key] = true;
		}).bind(this));
		
		// if super stencil was defined, also regard stencil's properties:
		if (stencil._jsonStencil.superId) {
			stencil.properties().each((function(property) {
				var key = property.prefix() + "-" + property.id();
				var value = property.value();
				var oldValue = this.properties[key];
				this.properties[key] = value;
				this.propertiesChanged[key] = true;

				// Raise an event, to show that the property has changed
				// required for plugins like processLink.js
				//window.setTimeout( function(){

					this._delegateEvent({
							type	: ORYX.CONFIG.EVENT_PROPERTY_CHANGED, 
							name	: key, 
							value	: value,
							oldValue: oldValue
						});

				//}.bind(this), 10)

			}).bind(this));
		}

	},

	layout: function() {

	},
	
	/**
	 * Returns the stencil object specifiing the type of the shape.
	 */
	getStencil: function() {
		return this._stencil;
	},
	
	/**
	 * 
	 * @param {Object} resourceId
	 */
	getChildShapeByResourceId: function(resourceId) {

		resourceId = ERDF.__stripHashes(resourceId);
		
		return this.getChildShapes(true).find(function(shape) {
					return shape.resourceId == resourceId
				});
	},
	/**
	 * 
	 * @param {Object} deep
	 * @param {Object} iterator
	 */
	getChildShapes: function(deep, iterator) {
		var result = [];

		this.children.each(function(uiObject) {
			if(uiObject instanceof ORYX.Core.Shape && uiObject.isVisible ) {
				if(iterator) {
					iterator(uiObject);
				}
				result.push(uiObject);
				if(deep) {
					result = result.concat(uiObject.getChildShapes(deep, iterator));
				} 
			}
		});

		return result;
	},
    
    /**
     * @param {Object} shape
     * @return {boolean} true if any of shape's childs is given shape
     */
    hasChildShape: function(shape){
        return this.getChildShapes().any(function(child){
            return (child === shape) || child.hasChildShape(shape);
        });
    },
	
	/**
	 * 
	 * @param {Object} deep
	 * @param {Object} iterator
	 */
	getChildNodes: function(deep, iterator) {
		var result = [];

		this.children.each(function(uiObject) {
			if(uiObject instanceof ORYX.Core.Node && uiObject.isVisible) {
				if(iterator) {
					iterator(uiObject);
				}
				result.push(uiObject);
			}
			if(uiObject instanceof ORYX.Core.Shape) {
				if(deep) {
					result = result.concat(uiObject.getChildNodes(deep, iterator));
				}
			}
		});

		return result;
	},
	
	/**
	 * 
	 * @param {Object} deep
	 * @param {Object} iterator
	 */
	getChildEdges: function(deep, iterator) {
		var result = [];

		this.children.each(function(uiObject) {
			if(uiObject instanceof ORYX.Core.Edge && uiObject.isVisible) {
				if(iterator) {
					iterator(uiObject);
				}
				result.push(uiObject);
			}
			if(uiObject instanceof ORYX.Core.Shape) {
				if(deep) {
					result = result.concat(uiObject.getChildEdges(deep, iterator));
				}
			}
		});

		return result;
	},
	
	/**
	 * Returns a sorted array of ORYX.Core.Node objects.
	 * Ordered in z Order, the last object has the highest z Order.
	 */
	//TODO deep iterator
	getAbstractShapesAtPosition: function() {
		var x, y;
		switch (arguments.length) {
			case 1:
				x = arguments[0].x;
				y = arguments[0].y;
				break;
			case 2:	//two or more arguments
				x = arguments[0];
				y = arguments[1];
				break;
			default:
				throw "getAbstractShapesAtPosition needs 1 or 2 arguments!"
		}

		if(this.isPointIncluded(x, y)) {

			var result = [];
			result.push(this);

			//check, if one child is at that position						
			
			
			var childNodes = this.getChildNodes();
			var childEdges = this.getChildEdges();
			
			[childNodes, childEdges].each(function(ne){
				var nodesAtPosition = new Hash();
				
				ne.each(function(node) {
					if(!node.isVisible){ return }
					var candidates = node.getAbstractShapesAtPosition( x , y );
					if(candidates.length > 0) {
						var nodesInZOrder = $A(node.node.parentNode.childNodes);
						var zOrderIndex = nodesInZOrder.indexOf(node.node);
						nodesAtPosition[zOrderIndex] = candidates;
					}
				});
				
				nodesAtPosition.keys().sort().each(function(key) {
					result = result.concat(nodesAtPosition[key]);
				});
 			});
						
			return result;
			
		} else {
			return [];
		}
	},
	
	/**
	 * 
	 * @param key {String} Must be 'prefix-id' of property
	 * @param value {Object} Can be of type String or Number according to property type.
	 */
	setProperty: function(key, value, force) {
		var oldValue = this.properties[key];
		if(oldValue !== value || force === true) {
			this.properties[key] = value;
			this.propertiesChanged[key] = true;
			this._changed();
			
			// Raise an event, to show that the property has changed
			//window.setTimeout( function(){

			if (!this._isInSetProperty) {
				this._isInSetProperty = true;
				
				this._delegateEvent({
						type	: ORYX.CONFIG.EVENT_PROPERTY_CHANGED, 
						elements : [this],
						name	: key, 
						value	: value,
						oldValue: oldValue
					});
				
				delete this._isInSetProperty;
			}
			//}.bind(this), 10)
		}
	},

	/**
	 * 
	 * @param {String} Must be 'prefix-id' of property
	 * @param {Object} Can be of type String or Number according to property type.
	 */
	setHiddenProperty: function(key, value) {
		// IF undefined, Delete
		if (value === undefined) {
			delete this.hiddenProperties[key];
			return;
		}
		var oldValue = this.hiddenProperties[key];
		if(oldValue !== value) {
			this.hiddenProperties[key] = value;
		}
	},
	/**
	 * Calculate if the point is inside the Shape
	 * @param {Point}
	 */
	isPointIncluded: function(pointX, pointY, absoluteBounds) {
		var absBounds = absoluteBounds ? absoluteBounds : this.absoluteBounds();
		return absBounds.isIncluded(pointX, pointY);
				
	},
	
	/**
	 * Get the serialized object
	 * return Array with hash-entrees (prefix, name, value)
	 * Following values will given:
	 * 		Type
	 * 		Properties
	 */
	serialize: function() {
		var serializedObject = [];
		
		// Add the type
		serializedObject.push({name: 'type', prefix:'oryx', value: this.getStencil().id(), type: 'literal'});	
	
		// Add hidden properties
		this.hiddenProperties.each(function(prop){
			serializedObject.push({name: prop.key.replace("oryx-", ""), prefix: "oryx", value: prop.value, type: 'literal'});
		}.bind(this));
		
		// Add all properties
		this.getStencil().properties().each((function(property){
			
			var prefix = property.prefix();	// Get prefix
			var name = property.id();		// Get name
			
			//if(typeof this.properties[prefix+'-'+name] == 'boolean' || this.properties[prefix+'-'+name] != "")
				serializedObject.push({name: name, prefix: prefix, value: this.properties[prefix+'-'+name], type: 'literal'});

		}).bind(this));
		
		return serializedObject;
	},
		
		
	deserialize: function(serialize){
		// Search in Serialize
		var initializedDocker = 0;
		
		// Sort properties so that the hidden properties are first in the list
		serialize = serialize.sort(function(a,b){ return Number(this.properties.keys().member(a.prefix+"-"+a.name)) > Number(this.properties.keys().member(b.prefix+"-"+b.name)) ? -1 : 0 }.bind(this));
		
		serialize.each((function(obj){
			
			var name 	= obj.name;
			var prefix 	= obj.prefix;
			var value 	= obj.value;
            
            // Complex properties can be real json objects, encode them to a string
            if(Ext.type(value) === "object") value = Ext.encode(value);

			switch(prefix + "-" + name){
				case 'raziel-parent': 
							// Set parent
							if(!this.parent) {break};
							
							// Set outgoing Shape
							var parent = this.getCanvas().getChildShapeByResourceId(value);
							if(parent) {
								parent.add(this);
							}
							
							break;											
				default:
							// Set property
							if(this.properties.keys().member(prefix+"-"+name)) {
								this.setProperty(prefix+"-"+name, value);
							} else if(!(name === "bounds"||name === "parent"||name === "target"||name === "dockers"||name === "docker"||name === "outgoing"||name === "incoming")) {
								this.setHiddenProperty(prefix+"-"+name, value);
							}
					
			}
		}).bind(this));
	},
	
	toString: function() { return "ORYX.Core.AbstractShape " + this.id },
    
    /**
     * Converts the shape to a JSON representation.
     * @return {Object} A JSON object with included ORYX.Core.AbstractShape.JSONHelper and getShape() method.
     */
    toJSON: function(){
        var json = {
            resourceId: this.resourceId,
            properties: Ext.apply({}, this.properties, this.hiddenProperties).inject({}, function(props, prop){
              var key = prop[0];
              var value = prop[1];
                
              //If complex property, value should be a json object
              if(this.getStencil().property(key)
                && this.getStencil().property(key).type() === ORYX.CONFIG.TYPE_COMPLEX 
                && Ext.type(value) === "string"){
                  try {value = Ext.decode(value);} catch(error){}
              }
              
              //Takes "my_property" instead of "oryx-my_property" as key
              key = key.replace(/^[\w_]+-/, "");
              props[key] = value;
              
              return props;
            }.bind(this)),
            stencil: {
                id: this.getStencil().idWithoutNs()
            },
            childShapes: this.getChildShapes().map(function(shape){
                return shape.toJSON()
            })
        };
        
        if(this.getOutgoingShapes){
            json.outgoing = this.getOutgoingShapes().map(function(shape){
                return {
                    resourceId: shape.resourceId
                };
            });
        }
        
        if(this.bounds){
            json.bounds = { 
                lowerRight: this.bounds.lowerRight(), 
                upperLeft: this.bounds.upperLeft() 
            };
        }
        
        if(this.dockers){
            json.dockers = this.dockers.map(function(docker){
                var d = docker.getDockedShape() && docker.referencePoint ? docker.referencePoint : docker.bounds.center();
                d.getDocker = function(){return docker;};
                return d;
            })
        }
        
        Ext.apply(json, ORYX.Core.AbstractShape.JSONHelper);
        
        // do not pollute the json attributes (for serialization), so put the corresponding
        // shape is encapsulated in a method
        json.getShape = function(){
            return this;
        }.bind(this);
        
        return json;
    }
 });
 
/**
 * @namespace Collection of methods which can be used on a shape json object (ORYX.Core.AbstractShape#toJSON()).
 * @example
 * Ext.apply(shapeAsJson, ORYX.Core.AbstractShape.JSONHelper);
 */
ORYX.Core.AbstractShape.JSONHelper = {
     /**
      * Iterates over each child shape.
      * @param {Object} iterator Iterator function getting a child shape and his parent as arguments.
      * @param {boolean} [deep=false] Iterate recursively (childShapes of childShapes)
      * @param {boolean} [modify=false] If true, the result of the iterator function is taken as new shape, return false to delete it. This enables modifying the object while iterating through the child shapes.
      * @example
      * // Increases the lowerRight x value of each direct child shape by one. 
      * myShapeAsJson.eachChild(function(shape, parentShape){
      *     shape.bounds.lowerRight.x = shape.bounds.lowerRight.x + 1;
      *     return shape;
      * }, false, true);
      */
     eachChild: function(iterator, deep, modify){
         if(!this.childShapes) return;
         
         var newChildShapes = []; //needed if modify = true
         
         this.childShapes.each(function(shape){
             var res = iterator(shape, this);
             if(res) newChildShapes.push(res); //if false is returned, and modify = true, current shape is deleted.
             
             if(deep) shape.eachChild(iterator, deep, modify);
         }.bind(this));
         
         if(modify) this.childShapes = newChildShapes;
     },
     
     getChildShapes: function(deep){
         var allShapes = this.childShapes;
         
         if(deep){
             this.eachChild(function(shape){
                 allShapes = allShapes.concat(shape.getChildShapes(deep));
             }, true);
         }
         
         return allShapes;
     },
     
     /**
      * @return {String} Serialized JSON object
      */
     serialize: function(){
         return Ext.encode(this);
     }
 }
/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}/**   @namespace Namespace for the Oryx core elements.   @name ORYX.Core*/if(!ORYX.Core) {ORYX.Core = {};}/** * @class Oryx canvas. * @extends ORYX.Core.AbstractShape * */ORYX.Core.Canvas = ORYX.Core.AbstractShape.extend({    /** @lends ORYX.Core.Canvas.prototype */	/**	 * Defines the current zoom level	 */	zoomLevel:1,	/**	 * Constructor	 */	construct: function(options) {		arguments.callee.$.construct.apply(this, arguments);		if(!(options && options.width && options.height)) {					ORYX.Log.fatal("Canvas is missing mandatory parameters options.width and options.height.");			return;		}					//TODO: set document resource id		this.resourceId = options.id;		this.nodes = [];				this.edges = [];				//init svg document		this.rootNode = ORYX.Editor.graft("http://www.w3.org/2000/svg", options.parentNode,			['svg', {id: this.id, width: options.width, height: options.height},				['defs', {}]			]);					this.rootNode.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink");		this.rootNode.setAttribute("xmlns:svg", "http://www.w3.org/2000/svg");		this._htmlContainer = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", options.parentNode,			['div', {id: "oryx_canvas_htmlContainer", style:"position:absolute; top:5px"}]);				this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.rootNode,			['g', {},				['g', {"class": "stencils"},					['g', {"class": "me"}],					['g', {"class": "children"}],					['g', {"class": "edge"}]				],				['g', {"class":"svgcontainer"}]			]);				/*		var off = 2 * ORYX.CONFIG.GRID_DISTANCE;		var size = 3;		var d = "";		for(var i = 0; i <= options.width; i += off)			for(var j = 0; j <= options.height; j += off)				d = d + "M" + (i - size) + " " + j + " l" + (2*size) + " 0 m" + (-size) + " " + (-size) + " l0 " + (2*size) + " m0" + (-size) + " ";									ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node.firstChild.firstChild,			['path', {d:d , stroke:'#000000', 'stroke-width':'0.15px'},]);		*/				//Global definition of default font for shapes		//Definitions in the SVG definition of a stencil will overwrite these settings for		// that stencil.		/*if(navigator.platform.indexOf("Mac") > -1) {			this.node.setAttributeNS(null, 'stroke', 'black');			this.node.setAttributeNS(null, 'stroke-width', '0.5px');			this.node.setAttributeNS(null, 'font-family', 'Skia');			//this.node.setAttributeNS(null, 'letter-spacing', '2px');			this.node.setAttributeNS(null, 'font-size', ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT);		} else {			this.node.setAttributeNS(null, 'stroke', 'none');			this.node.setAttributeNS(null, 'font-family', 'Verdana');			this.node.setAttributeNS(null, 'font-size', ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT);		}*/				this.node.setAttributeNS(null, 'stroke', 'black');		this.node.setAttributeNS(null, 'font-family', 'Verdana, sans-serif');		this.node.setAttributeNS(null, 'font-size-adjust', 'none');		this.node.setAttributeNS(null, 'font-style', 'normal');		this.node.setAttributeNS(null, 'font-variant', 'normal');		this.node.setAttributeNS(null, 'font-weight', 'normal');		this.node.setAttributeNS(null, 'line-heigth', 'normal');				this.node.setAttributeNS(null, 'font-size', ORYX.CONFIG.LABEL_DEFAULT_LINE_HEIGHT);					this.bounds.set(0,0,options.width, options.height);				this.addEventHandlers(this.rootNode.parentNode);				//disable context menu		this.rootNode.oncontextmenu = function() {return false;};	},		focus: function(){				// Get a href		if (!this.headerA){			this.headerA = Ext.get("oryx_editor_header").child("a").dom		}				// Focus it and blurs it		this.headerA.focus();		this.headerA.blur();	},		update: function() {				this.nodes.each(function(node) {			this._traverseForUpdate(node);		}.bind(this));				// call stencil's layout callback		// (needed for row layouting of xforms)		//this.getStencil().layout(this);				var layoutEvents = this.getStencil().layout();				if(layoutEvents) {			layoutEvents.each(function(event) {						// setup additional attributes				event.shape = this;				event.forceExecution = true;				event.target = this.rootNode;								// do layouting								this._delegateEvent(event);			}.bind(this))		}				this.nodes.invoke("_update");				this.edges.invoke("_update", true);				/*this.children.each(function(child) {			child._update();		});*/	},		_traverseForUpdate: function(shape) {		var childRet = shape.isChanged;		shape.getChildNodes(false, function(child) {			if(this._traverseForUpdate(child)) {				childRet = true;			}		}.bind(this));				if(childRet) {			shape.layout();			return true;		} else {			return false;		}	},		layout: function() {							},		/**	 * 	 * @param {Object} deep	 * @param {Object} iterator	 */	getChildNodes: function(deep, iterator) {		if(!deep && !iterator) {			return this.nodes.clone();		} else {			var result = [];			this.nodes.each(function(uiObject) {				if(iterator) {					iterator(uiObject);				}				result.push(uiObject);								if(deep && uiObject instanceof ORYX.Core.Shape) {					result = result.concat(uiObject.getChildNodes(deep, iterator));				}			});				return result;		}	},		/**	 * buggy crap! use base class impl instead! 	 * @param {Object} iterator	 *//*	getChildEdges: function(iterator) {		if(iterator) {			this.edges.each(function(edge) {				iterator(edge);			});		}				return this.edges.clone();	},*/		/**	 * Overrides the UIObject.add method. Adds uiObject to the correct sub node.	 * @param {UIObject} uiObject	 */	add: function(uiObject) {		//if uiObject is child of another UIObject, remove it.		if(uiObject instanceof ORYX.Core.UIObject) {			if (!(this.children.member(uiObject))) {				//if uiObject is child of another parent, remove it from that parent.				if(uiObject.parent) {					uiObject.parent.remove(uiObject);				}				//add uiObject to the Canvas				this.children.push(uiObject);				//set parent reference				uiObject.parent = this;				//add uiObject.node to this.node depending on the type of uiObject				if(uiObject instanceof ORYX.Core.Shape) {					if(uiObject instanceof ORYX.Core.Edge) {						uiObject.addMarkers(this.rootNode.getElementsByTagNameNS(NAMESPACE_SVG, "defs")[0]);						uiObject.node = this.node.childNodes[0].childNodes[2].appendChild(uiObject.node);						this.edges.push(uiObject);					} else {						uiObject.node = this.node.childNodes[0].childNodes[1].appendChild(uiObject.node);						this.nodes.push(uiObject);					}				} else {	//UIObject					uiObject.node = this.node.appendChild(uiObject.node);				}				uiObject.bounds.registerCallback(this._changedCallback);									if(this.eventHandlerCallback)					this.eventHandlerCallback({type:ORYX.CONFIG.EVENT_SHAPEADDED,shape:uiObject})			} else {								ORYX.Log.warn("add: ORYX.Core.UIObject is already a child of this object.");			}		} else {			ORYX.Log.fatal("add: Parameter is not of type ORYX.Core.UIObject.");		}	},	/**	 * Overrides the UIObject.remove method. Removes uiObject.	 * @param {UIObject} uiObject	 */	remove: function(uiObject) {		//if uiObject is a child of this object, remove it.		if (this.children.member(uiObject)) {			//remove uiObject from children			this.children = this.children.without(uiObject);			//delete parent reference of uiObject			uiObject.parent = undefined;			//delete uiObject.node from this.node			if(uiObject instanceof ORYX.Core.Shape) {				if(uiObject instanceof ORYX.Core.Edge) {					uiObject.removeMarkers();					uiObject.node = this.node.childNodes[0].childNodes[2].removeChild(uiObject.node);					this.edges = this.edges.without(uiObject);				} else {					uiObject.node = this.node.childNodes[0].childNodes[1].removeChild(uiObject.node);					this.nodes = this.nodes.without(uiObject);				}			} else {	//UIObject					uiObject.node = this.node.removeChild(uiObject.node);			}			uiObject.bounds.unregisterCallback(this._changedCallback);		} else {			ORYX.Log.warn("remove: ORYX.Core.UIObject is not a child of this object.");		}	},        /**     * Creates shapes out of the given collection of shape objects and adds them to the canvas.     * @example      * canvas.addShapeObjects({         bounds:{ lowerRight:{ y:510, x:633 }, upperLeft:{ y:146, x:210 } },         resourceId:"oryx_F0715955-50F2-403D-9851-C08CFE70F8BD",         childShapes:[],         properties:{},         stencil:{           id:"Subprocess"         },         outgoing:[{resourceId: 'aShape'}],         target: {resourceId: 'aShape'}       });     * @param {Object} shapeObjects      * @param {Function} [eventHandler] An event handler passed to each newly created shape (as eventHandlerCallback)     * @return {Array} A collection of ORYX.Core.Shape     * @methodOf ORYX.Core.Canvas.prototype     */    addShapeObjects: function(shapeObjects, eventHandler){        if(!shapeObjects) return;                /*FIXME This implementation is very evil! At first, all shapes are created on          canvas. In a second step, the attributes are applied. There must be a distinction          between the configuration phase (where the outgoings, for example, are just named),          and the creation phase (where the outgoings are evaluated). This must be reflected          in code to provide a nicer API/ implementation!!! */                var addShape = function(shape, parent){            // Try to create a new Shape            try {                // Create a new Stencil                var stencil = ORYX.Core.StencilSet.stencil(this.getStencil().namespace() + shape.stencil.id );                    // Create a new Shape                var ShapeClass = (stencil.type() == "node") ? ORYX.Core.Node : ORYX.Core.Edge;                var newShape = new ShapeClass(                  {'eventHandlerCallback': eventHandler},                  stencil);                                // Set the resource id                newShape.resourceId = shape.resourceId;                                // Set parent to json object to be used later                // Due to the nested json structure, normally shape.parent is not set/ must not be set.                 // In special cases, it can be easier to set this directly instead of a nested structure.                shape.parent = "#" + ((shape.parent && shape.parent.resourceId) || parent.resourceId);                                // Add the shape to the canvas                this.add( newShape );                return {                  json: shape,                  object: newShape                };            } catch(e) {                ORYX.Log.warn("LoadingContent: Stencil could not create.");            }        }.bind(this);                /** Builds up recursively a flatted array of shapes, including a javascript object and json representation         * @param {Object} shape Any object that has Object#childShapes         */        var addChildShapesRecursively = function(shape){            var addedShapes = [];                        shape.childShapes.each(function(childShape){  			  /*  			   *  workaround for Chrome, for some reason an undefined shape is given  			   */            	var xy=addShape(childShape, shape);  			  if(!(typeof xy ==="undefined")){  					addedShapes.push(xy);  			  }              addedShapes = addedShapes.concat(addChildShapesRecursively(childShape));            });                        return addedShapes;        }.bind(this);        var shapes = addChildShapesRecursively({            childShapes: shapeObjects,             resourceId: this.resourceId        });                            // prepare deserialisation parameter        shapes.each(            function(shape){            	var properties = [];                for(field in shape.json.properties){                    properties.push({                      prefix: 'oryx',                      name: field,                      value: shape.json.properties[field]                    });                  }                                    // Outgoings                  shape.json.outgoing.each(function(out){                    properties.push({                      prefix: 'raziel',                      name: 'outgoing',                      value: "#"+out.resourceId                    });                  });                                    // Target                   // (because of a bug, the first outgoing is taken when there is no target,                  // can be removed after some time)                  if(shape.object instanceof ORYX.Core.Edge) {	                  var target = shape.json.target || shape.json.outgoing[0];	                  if(target){	                    properties.push({	                      prefix: 'raziel',	                      name: 'target',	                      value: "#"+target.resourceId	                    });	                  }                  }                                    // Bounds                  if (shape.json.bounds) {                      properties.push({                          prefix: 'oryx',                          name: 'bounds',                          value: shape.json.bounds.upperLeft.x + "," + shape.json.bounds.upperLeft.y + "," + shape.json.bounds.lowerRight.x + "," + shape.json.bounds.lowerRight.y                      });                  }                                    //Dockers [{x:40, y:50}, {x:30, y:60}] => "40 50 30 60  #"                  if(shape.json.dockers){                    properties.push({                      prefix: 'oryx',                      name: 'dockers',                      value: shape.json.dockers.inject("", function(dockersStr, docker){                        return dockersStr + docker.x + " " + docker.y + " ";                      }) + " #"                    });                  }                                    //Parent                  properties.push({                    prefix: 'raziel',                    name: 'parent',                    value: shape.json.parent                  });                              shape.__properties = properties;	         }.bind(this)        );          // Deserialize the properties from the shapes        // This can't be done earlier because Shape#deserialize expects that all referenced nodes are already there                // first, deserialize all nodes        shapes.each(function(shape) {        	if(shape.object instanceof ORYX.Core.Node) {        		shape.object.deserialize(shape.__properties);        	}        });                // second, deserialize all edges        shapes.each(function(shape) {        	if(shape.object instanceof ORYX.Core.Edge) {        		shape.object.deserialize(shape.__properties);        	}        });               return shapes.pluck("object");    },        /**     * Updates the size of the canvas, regarding to the containg shapes.     */    updateSize: function(){        // Check the size for the canvas        var maxWidth    = 0;        var maxHeight   = 0;        var offset      = 100;        this.getChildShapes(true, function(shape){            var b = shape.bounds;            maxWidth    = Math.max( maxWidth, b.lowerRight().x + offset)            maxHeight   = Math.max( maxHeight, b.lowerRight().y + offset)        });                 if( this.bounds.width() < maxWidth || this.bounds.height() < maxHeight ){            this.setSize({width: Math.max(this.bounds.width(), maxWidth), height: Math.max(this.bounds.height(), maxHeight)})        }    },	getRootNode: function() {		return this.rootNode;	},		getSvgContainer: function() {		return this.node.childNodes[1];	},		getHTMLContainer: function() {		return this._htmlContainer;	},		/**	 * Return all elements of the same highest level	 * @param {Object} elements	 */	getShapesWithSharedParent: function(elements) {		// If there is no elements, return []		if(!elements || elements.length < 1) { return [] }		// If there is one element, return this element		if(elements.length == 1) { return elements}		return elements.findAll(function(value){			var parentShape = value.parent;			while(parentShape){				if(elements.member(parentShape)) return false;				parentShape = parentShape.parent			}			return true;		});			},	setSize: function(size, dontSetBounds) {		if(!size || !size.width || !size.height){return}				if(this.rootNode.parentNode){			this.rootNode.parentNode.style.width = size.width + 'px';			this.rootNode.parentNode.style.height = size.height + 'px';		}				this.rootNode.setAttributeNS(null, 'width', size.width);		this.rootNode.setAttributeNS(null, 'height', size.height);		//this._htmlContainer.style.top = "-" + (size.height + 4) + 'px';				if( !dontSetBounds ){			this.bounds.set({a:{x:0,y:0},b:{x:size.width/this.zoomLevel,y:size.height/this.zoomLevel}})				}	},		/**	 * Returns an SVG document of the current process.	 * @param {Boolean} escapeText Use true, if you want to parse it with an XmlParser,	 * 					false, if you want to use the SVG document in browser on client side.	 */	getSVGRepresentation: function(escapeText) {		// Get the serialized svg image source        var svgClone = this.getRootNode().cloneNode(true);				this._removeInvisibleElements(svgClone);				var x1, y1, x2, y2;		try {			var bb = this.getRootNode().childNodes[1].getBBox();			x1 = bb.x;			y1 = bb.y;			x2 = bb.x + bb.width;			y2 = bb.y + bb.height;		} catch(e) {			this.getChildShapes(true).each(function(shape) {				var absBounds = shape.absoluteBounds();				var ul = absBounds.upperLeft();				var lr = absBounds.lowerRight();				if(x1 == undefined) {					x1 = ul.x;					y1 = ul.y;					x2 = lr.x;					y2 = lr.y;				} else {					x1 = Math.min(x1, ul.x);					y1 = Math.min(y1, ul.y);					x2 = Math.max(x2, lr.x);					y2 = Math.max(y2, lr.y);				}			});		}				var margin = 50;				var width, height, tx, ty;		if(x1 == undefined) {			width = 0;			height = 0;			tx = 0;			ty = 0;		} else {			width = x2 - x1;			height = y2 - y1;			tx = -x1+margin/2;			ty = -y1+margin/2;		}		 				        // Set the width and height        svgClone.setAttributeNS(null, 'width', width + margin);        svgClone.setAttributeNS(null, 'height', height + margin);				svgClone.childNodes[1].firstChild.setAttributeNS(null, 'transform', 'translate(' + tx + ", " + ty + ')');				//remove scale factor		svgClone.childNodes[1].removeAttributeNS(null, 'transform');				try{			var svgCont = svgClone.childNodes[1].childNodes[1];			svgCont.parentNode.removeChild(svgCont);		} catch(e) {}		if(escapeText) {			$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'tspan')).each(function(elem) {				elem.textContent = elem.textContent.escapeHTML();			});						$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'text')).each(function(elem) {				if(elem.childNodes.length == 0)					elem.textContent = elem.textContent.escapeHTML();			});		}				// generating absolute urls for the pdf-exporter		$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'image')).each(function(elem) {			var href = elem.getAttributeNS("http://www.w3.org/1999/xlink","href");						if(!href.match("^(http|https)://")) {				href = window.location.protocol + "//" + window.location.host + href;				elem.setAttributeNS("http://www.w3.org/1999/xlink", "href", href);			}		});						// escape all links		$A(svgClone.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'a')).each(function(elem) {			elem.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", (elem.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").escapeHTML());		});		        return svgClone;	},		/**   	* Removes all nodes (and its children) that has the	* attribute visibility set to "hidden"	*/	_removeInvisibleElements: function(element) {		var index = 0;		while(index < element.childNodes.length) {			var child = element.childNodes[index];			if(child.getAttributeNS &&				child.getAttributeNS(null, "visibility") === "hidden") {				element.removeChild(child);			} else {				this._removeInvisibleElements(child);				index++; 			}		}			},		/**	 * This method checks all shapes on the canvas and removes all shapes that	 * contain invalid bounds values or dockers values(NaN)	 */	/*cleanUp: function(parent) {		if (!parent) {			parent = this;		}		parent.getChildShapes().each(function(shape){			var a = shape.bounds.a;			var b = shape.bounds.b;			if (isNaN(a.x) || isNaN(a.y) || isNaN(b.x) || isNaN(b.y)) {				parent.remove(shape);			}			else {				shape.getDockers().any(function(docker) {					a = docker.bounds.a;					b = docker.bounds.b;					if (isNaN(a.x) || isNaN(a.y) || isNaN(b.x) || isNaN(b.y)) {						parent.remove(shape);						return true;					}					return false;				});				shape.getMagnets().any(function(magnet) {					a = magnet.bounds.a;					b = magnet.bounds.b;					if (isNaN(a.x) || isNaN(a.y) || isNaN(b.x) || isNaN(b.y)) {						parent.remove(shape);						return true;					}					return false;				});				this.cleanUp(shape);			}		}.bind(this));	},*/	_delegateEvent: function(event) {		if(this.eventHandlerCallback && ( event.target == this.rootNode || event.target == this.rootNode.parentNode )) {			this.eventHandlerCallback(event, this);		}	},		toString: function() { return "Canvas " + this.id },        /**     * Calls {@link ORYX.Core.AbstractShape#toJSON} and adds some stencil set information.     */    toJSON: function() {        var json = arguments.callee.$.toJSON.apply(this, arguments);        //		if(ORYX.CONFIG.STENCILSET_HANDLER.length > 0) {//			json.stencilset = {//				url: this.getStencil().stencilSet().namespace()//	        };//		} else {			json.stencilset = {				url: this.getStencil().stencilSet().source(),				namespace: this.getStencil().stencilSet().namespace()	        };	//		}                        return json;    } });/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/var idCounter = 0;var ID_PREFIX = "resource";/** * Main initialization method. To be called when loading * of the document, including all scripts, is completed. */function init() {	/* When the blank image url is not set programatically to a local	 * representation, a spacer gif on the site of ext is loaded from the	 * internet. This causes problems when internet or the ext site are not	 * available. */	Ext.BLANK_IMAGE_URL = ORYX.PATH + 'lib/ext-2.0.2/resources/images/default/s.gif';			ORYX.Log.debug("Querying editor instances");	// Hack for WebKit to set the SVGElement-Classes	ORYX.Editor.setMissingClasses();        // If someone wants to create the editor instance himself    if (window.onOryxResourcesLoaded) {        window.onOryxResourcesLoaded();    }     // Else if this is a newly created model    else if(window.location.pathname.include(ORYX.CONFIG.ORYX_NEW_URL)){        new ORYX.Editor({            id: 'oryx-canvas123',            fullscreen: true,            stencilset: {                url: ORYX.PATH + ORYX.Utils.getParamFromUrl("stencilset")            }        });    }     // Else fetch the model from server and display editor    else {        //HACK for distinguishing between different backends		// Backend of 2008 uses /self URL ending	    var modelUrl = window.location.href.replace(/#.*/g, "");		if(modelUrl.endsWith("/self")) {			modelUrl = modelUrl.replace("/self","/json");		} else {			modelUrl += "&data";		}        ORYX.Editor.createByUrl(modelUrl, {            id: modelUrl        });    }}/**   @namespace Global Oryx name space   @name ORYX*/if(!ORYX) {var ORYX = {};}/** * The Editor class. * @class ORYX.Editor * @extends Clazz * @param {Object} config An editor object, passed to {@link ORYX.Editor#loadSerialized} * @param {String} config.id Any ID that can be used inside the editor. If fullscreen=false, any HTML node with this id must be present to render the editor to this node. * @param {boolean} [config.fullscreen=true] Render editor in fullscreen mode or not. * @param {String} config.stencilset.url Stencil set URL. * @param {String} [config.stencil.id] Stencil type used for creating the canvas.   * @param {Object} config.properties Any properties applied to the canvas.*/ORYX.Editor = {    /** @lends ORYX.Editor.prototype */	// Defines the global dom event listener 	DOMEventListeners: new Hash(),	// Defines the selection	selection: [],		// Defines the current zoom level	zoomLevel:1.0,	construct: function(config) {		// initialization.		this._eventsQueue 	= [];		this.loadedPlugins 	= [];		this.pluginsData 	= [];						//meta data about the model for the signavio warehouse		//directory, new, name, description, revision, model (the model data)				this.modelMetaData = config;				var model = config;		if(config.model) {			model = config.model;		}				this.id = model.resourceId;        if(!this.id) {        	this.id = model.id;        	if(!this.id) {        		this.id = ORYX.Editor.provideId();        	}        }                // Defines if the editor should be fullscreen or not		this.fullscreen = model.fullscreen || true;				// Initialize the eventlistener		this._initEventListener();		// Load particular stencilset		if(ORYX.CONFIG.BACKEND_SWITCH) {			var ssUrl = (model.stencilset.namespace||model.stencilset.url).replace("#", "%23");        	ORYX.Core.StencilSet.loadStencilSet(ORYX.CONFIG.STENCILSET_HANDLER + ssUrl, this.id);		} else {			var ssUrl = model.stencilset.url;        	ORYX.Core.StencilSet.loadStencilSet(ssUrl, this.id);		}		                //TODO load ealier and asynchronous??        this._loadStencilSetExtensionConfig();                //Load predefined StencilSetExtensions        if(!!ORYX.CONFIG.SSEXTS){        	ORYX.CONFIG.SSEXTS.each(function(ssext){                this.loadSSExtension(ssext.namespace);            }.bind(this));        }		// CREATES the canvas		this._createCanvas(model.stencil ? model.stencil.id : null, model.properties);		// GENERATES the whole EXT.VIEWPORT		this._generateGUI();		// Initializing of a callback to check loading ends		var loadPluginFinished 	= false;		var loadContentFinished = false;		var initFinished = function(){				if( !loadPluginFinished || !loadContentFinished ){ return }			this._finishedLoading();		}.bind(this)				// disable key events when Ext modal window is active		ORYX.Editor.makeExtModalWindowKeysave(this._getPluginFacade());				// LOAD the plugins		window.setTimeout(function(){			this.loadPlugins();			loadPluginFinished = true;			initFinished();		}.bind(this), 100);		// LOAD the content of the current editor instance		window.setTimeout(function(){            this.loadSerialized(model);            this.getCanvas().update();			loadContentFinished = true;			initFinished();		}.bind(this), 200);	},		_finishedLoading: function() {		if(Ext.getCmp('oryx-loading-panel')){			Ext.getCmp('oryx-loading-panel').hide()		}				// Do Layout for viewport		this.layout.doLayout();		// Generate a drop target		new Ext.dd.DropTarget(this.getCanvas().rootNode.parentNode);				// Fixed the problem that the viewport can not 		// start with collapsed panels correctly		if (ORYX.CONFIG.PANEL_RIGHT_COLLAPSED === true){			this.layout_regions.east.collapse();		}		if (ORYX.CONFIG.PANEL_LEFT_COLLAPSED === true){			this.layout_regions.west.collapse();		}				// Raise Loaded Event		this.handleEvents( {type:ORYX.CONFIG.EVENT_LOADED} )			},		_initEventListener: function(){		// Register on Events				document.documentElement.addEventListener(ORYX.CONFIG.EVENT_KEYDOWN, this.catchKeyDownEvents.bind(this), true);		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_KEYUP, this.catchKeyUpEvents.bind(this), true);		// Enable Key up and down Event		this._keydownEnabled = 	true;		this._keyupEnabled =  	true;		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEDOWN] = [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEUP] 	= [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEOVER] = [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEOUT] 	= [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_SELECTION_CHANGED] = [];		this.DOMEventListeners[ORYX.CONFIG.EVENT_MOUSEMOVE] = [];					},		/**	 * Generate the whole viewport of the	 * Editor and initialized the Ext-Framework	 * 	 */	_generateGUI: function() {		//TODO make the height be read from eRDF data from the canvas.		// default, a non-fullscreen editor shall define its height by layout.setHeight(int) 				// Defines the layout hight if it's NOT fullscreen		var layoutHeight 	= 400;			var canvasParent	= this.getCanvas().rootNode.parentNode;		// DEFINITION OF THE VIEWPORT AREAS		this.layout_regions = {								// DEFINES TOP-AREA				north	: new Ext.Panel({ //TOOO make a composite of the oryx header and addable elements (for toolbar), second one should contain margins					region	: 'north',					cls		: 'x-panel-editor-north',					autoEl	: 'div',					border	: false				}),									// DEFINES RIGHT-AREA				east	: new Ext.Panel({					region	: 'east',					layout	: 'fit',					cls		: 'x-panel-editor-east',					/*layout: 'accordion',					layoutConfig: {		               // layout-specific configs go here						titleCollapse: true,						animate: true,						activeOnTop: true	                },*/					autoEl	: 'div',					border	:false,					cmargins: {left:0, right:0},					collapsible	: true,					width	: ORYX.CONFIG.PANEL_RIGHT_WIDTH || 200,					split	: true,					title	: "East"				}),												// DEFINES BOTTOM-AREA				south	: new Ext.Panel({					region	: 'south',					cls		: 'x-panel-editor-south',					autoEl	: 'div',					border	: false				}),												// DEFINES LEFT-AREA				west	: new Ext.Panel({					region	: 'west',					layout	: 'anchor',					autoEl	: 'div',					cls		: 'x-panel-editor-west',					collapsible	: true,					width	: ORYX.CONFIG.PANEL_LEFT_WIDTH || 200,					autoScroll:true,					cmargins: {left:0, right:0},					split	: true,					title	: "West"				}),												// DEFINES CENTER-AREA (FOR THE EDITOR)				center	: new Ext.Panel({					region	: 'center',					cls		: 'x-panel-editor-center',					autoScroll: true,					items	: {						layout	: "fit",						autoHeight: true,						el		: canvasParent					}				})		}				// Hide every region except the center		for (region in this.layout_regions) {			if ( region != "center" ) {				//this.layout_regions[ region ].hide();			}		}				// Config for the Ext.Viewport 		var layout_config = {			layout: 'border',			items: [				this.layout_regions.north,				this.layout_regions.east,				this.layout_regions.south,				this.layout_regions.west,				this.layout_regions.center			]		}		// IF Fullscreen, use a viewport		if (this.fullscreen) {			this.layout = new Ext.Viewport( layout_config )				// IF NOT, use a panel and render it to the given id		} else {			layout_config.renderTo 	= this.id;			layout_config.height 	= layoutHeight;			this.layout = new Ext.Panel( layout_config )		}				//Generates the ORYX-Header		this._generateHeader();						// Set the editor to the center, and refresh the size	 	canvasParent.parentNode.setAttributeNS(null, 'align', 'center');	 	canvasParent.setAttributeNS(null, 'align', 'left');		this.getCanvas().setSize({			width	: ORYX.CONFIG.CANVAS_WIDTH,			height	: ORYX.CONFIG.CANVAS_HEIGHT		});									},		_generateHeader: function(){				var headerPanel = new Ext.Panel({			height		: 30,			autoHeight	: false,			border		: false,			html		: "<div id='oryx_editor_header'><a href=\""+ORYX.CONFIG.WEB_URL+"\" target=\"_blank\"><img src='"+ORYX.PATH+"images/oryx.small.gif' border=\"0\" /></a><div style='clear: both;'></div></div>" 		});		var maActive 	= ORYX.MashupAPI && ORYX.MashupAPI.isUsed;		var maKey		= maActive ? ORYX.MashupAPI.key : "";		var maCanRun	= maActive ? ORYX.MashupAPI.canRun : false;			var maIsRemoteM	= maActive ? ORYX.MashupAPI.isModelRemote : true;					var maModelImage= maIsRemoteM ? "<img src='"+ORYX.PATH+"images/page_white_put.png'/>" : "";		var maModelAuthI= maActive ? "<span class='mashupinfo'><img src='"+ORYX.PATH+"images/" +( maCanRun ? "plugin_error" : "plugin") +".png'/>" + maModelImage + "</span>" : "";						// Callback if the user changes		var fn = function(val){						var publicText = ORYX.I18N.Oryx.notLoggedOn;			var user = val && val.identifier && val.identifier != "public" ? decodeURI(val.identifier.gsub('"', "")).replace(/\+/g," ") : "";						if( user.length <= 0 ){				user 	= 	publicText;			}						var content = 	"<div id='oryx_editor_header'>" +								"<a href=\""+ORYX.CONFIG.WEB_URL+"\" target=\"_blank\">" +									"<img src='"+ORYX.PATH+"images/oryx.small.gif' border=\"0\" />" + 								"</a>" + 								"<span class='openid " + (publicText == user ? "not" : "") + "'>" + 									user + 									maModelAuthI + 								"</span>" + 								"<div style='clear: both;'/>" + 							"</div>";						if( headerPanel.body ){				headerPanel.body.dom.innerHTML = content;			} else {				headerPanel.html = content			}		};					ORYX.Editor.Cookie.onChange(fn);		fn(ORYX.Editor.Cookie.getParams());				// The oryx header		this.addToRegion("north", headerPanel );	},		/**	 * adds a component to the specified region	 * 	 * @param {String} region	 * @param {Ext.Component} component	 * @param {String} title, optional	 * @return {Ext.Component} dom reference to the current region or null if specified region is unknown	 */	addToRegion: function(region, component, title) {				if (region.toLowerCase && this.layout_regions[region.toLowerCase()]) {			var current_region = this.layout_regions[region.toLowerCase()];						current_region.add(component);									ORYX.Log.debug("original dimensions of region %0: %1 x %2", current_region.region, current_region.width, current_region.height)			// update dimensions of region if required.			if  (!current_region.width && component.initialConfig && component.initialConfig.width) {				ORYX.Log.debug("resizing width of region %0: %1", current_region.region, component.initialConfig.width)					current_region.setWidth(component.initialConfig.width)			}			if  (component.initialConfig && component.initialConfig.height) {				ORYX.Log.debug("resizing height of region %0: %1", current_region.region, component.initialConfig.height)				var current_height = current_region.height || 0;				current_region.height = component.initialConfig.height + current_height;				current_region.setHeight(component.initialConfig.height + current_height)			}												// set title if provided as parameter.            if (typeof title == "string") {                    switch(region.toLowerCase()) {                    case "east":                            if (current_region.title != "East"){                                    title = current_region.title + " and " + title;                                    current_region.setTitle(title);                            }                            current_region.setTitle(title);                            break;                    case "west":                            if (current_region.title != "West"){                                    title = current_region.title + " and " + title;                                    current_region.setTitle(title);                            }                            current_region.setTitle(title);                            break;                    default :                            current_region.setTitle(title);                    }            }			            //If we we want to put more than one content pane into the east region            //we have to add a layout that can handle this. 			if (region.toLowerCase() == 'east' && current_region.items.length >= 2 ) {				var layout = new Ext.layout.Accordion( current_region.layoutConfig );            	current_region.setLayout( layout );								var items = current_region.items.clone();						} 						//This renders the layout			current_region.ownerCt.doLayout();			current_region.show();			if(Ext.isMac)				ORYX.Editor.resizeFix();						return current_region;											}				return null;	},		getAvailablePlugins: function(){		var curAvailablePlugins=ORYX.availablePlugins.clone();		curAvailablePlugins.each(function(plugin){			if(this.loadedPlugins.find(function(loadedPlugin){				return loadedPlugin.type==this.name;			}.bind(plugin))){				plugin.engaged=true;			}else{				plugin.engaged=false;			}			}.bind(this));		return curAvailablePlugins;	},	loadScript: function (url, callback){	    var script = document.createElement("script")	    script.type = "text/javascript";	    if (script.readyState){  //IE	        script.onreadystatechange = function(){	            if (script.readyState == "loaded" || script.readyState == "complete"){	                script.onreadystatechange = null;	                callback();	            }        	};    	} else {  //Others	        script.onload = function(){	            callback();	        };		}	    script.src = url;		document.getElementsByTagName("head")[0].appendChild(script);	},	/**	 * activate Plugin	 * 	 * @param {String} name	 * @param {Function} callback	 * 		callback(sucess, [errorCode])	 * 			errorCodes: NOTUSEINSTENCILSET, REQUIRESTENCILSET, NOTFOUND, YETACTIVATED	 */	activatePluginByName: function(name, callback, loadTry){		var match=this.getAvailablePlugins().find(function(value){return value.name==name});		if(match && (!match.engaged || (match.engaged==='false'))){						var loadedStencilSetsNamespaces = this.getStencilSets().keys();				var facade = this._getPluginFacade();				var newPlugin;				var me=this;				ORYX.Log.debug("Initializing plugin '%0'", match.name);									if (!match.requires 	|| !match.requires.namespaces 	|| match.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ){						if(!match.notUsesIn 	|| !match.notUsesIn.namespaces 	|| !match.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 })){						try {												var className 	= eval(match.name);							var newPlugin = new className(facade, match);							newPlugin.type = match.name;														// If there is an GUI-Plugin, they get all Plugins-Offer-Meta-Data							if (newPlugin.registryChanged) 								newPlugin.registryChanged(me.pluginsData);														// If there have an onSelection-Method it will pushed to the Editor Event-Handler							if (newPlugin.onSelectionChanged) 								me.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, newPlugin.onSelectionChanged.bind(newPlugin));							this.loadedPlugins.push(newPlugin);							this.loadedPlugins.each(function(loaded){								if(loaded.registryChanged)									loaded.registryChanged(this.pluginsData);							}.bind(me));							callback(true);											} catch(e) {						ORYX.Log.warn("Plugin %0 is not available", match.name);						if(!!loadTry){							callback(false,"INITFAILED");							return;						}						this.loadScript("plugins/scripts/"+match.source, this.activatePluginByName.bind(this,match.name,callback,true));					}					}else{						callback(false,"NOTUSEINSTENCILSET");						ORYX.Log.info("Plugin need a stencilset which is not loaded'", match.name);					}												} else {					callback(false,"REQUIRESTENCILSET");					ORYX.Log.info("Plugin need a stencilset which is not loaded'", match.name);				}						}else{				callback(false, match?"NOTFOUND":"YETACTIVATED");				//TODO error handling			}	},	/**	 *  Laden der Plugins	 */	loadPlugins: function() {				// if there should be plugins but still are none, try again.		// TODO this should wait for every plugin respectively.		/*if (!ORYX.Plugins && ORYX.availablePlugins.length > 0) {			window.setTimeout(this.loadPlugins.bind(this), 100);			return;		}*/				var me = this;		var newPlugins = [];		var loadedStencilSetsNamespaces = this.getStencilSets().keys();		// Available Plugins will be initalize		var facade = this._getPluginFacade();				// If there is an Array where all plugins are described, than only take those		// (that comes from the usage of oryx with a mashup api)		if( ORYX.MashupAPI && ORYX.MashupAPI.loadablePlugins && ORYX.MashupAPI.loadablePlugins instanceof Array ){					// Get the plugins from the available plugins (those who are in the plugins.xml)			ORYX.availablePlugins = $A(ORYX.availablePlugins).findAll(function(value){										return ORYX.MashupAPI.loadablePlugins.include( value.name )									})						// Add those plugins to the list, which are only in the loadablePlugins list			ORYX.MashupAPI.loadablePlugins.each(function( className ){				if( !(ORYX.availablePlugins.find(function(val){ return val.name == className }))){					ORYX.availablePlugins.push( {name: className } );				}			})		}						ORYX.availablePlugins.each(function(value) {			ORYX.Log.debug("Initializing plugin '%0'", value.name);				if( (!value.requires 	|| !value.requires.namespaces 	|| value.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) ) &&					(!value.notUsesIn 	|| !value.notUsesIn.namespaces 	|| !value.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) )&&					//We assume if there is no engaged attribute in an XML					//node of a plugin the plugin is activated by default.					//If there is an engaged attribute and it is set to true					//the plugin will not be loaded					(!value.engaged || value.engaged=="true" )){				try {					var className 	= eval(value.name);					if( className ){						var plugin		= new className(facade, value);						plugin.type		= value.name;						newPlugins.push( plugin );						plugin.engaged=true;					}				} catch(e) {					ORYX.Log.warn("Plugin %0 is not available", value.name);				}										} else {				ORYX.Log.info("Plugin need a stencilset which is not loaded'", value.name);			}					});		newPlugins.each(function(value) {			// If there is an GUI-Plugin, they get all Plugins-Offer-Meta-Data			if(value.registryChanged)				value.registryChanged(me.pluginsData);			// If there have an onSelection-Method it will pushed to the Editor Event-Handler			if(value.onSelectionChanged)				me.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, value.onSelectionChanged.bind(value));		});		this.loadedPlugins = newPlugins;				// Hack for the Scrollbars		if(Ext.isMac) {			ORYX.Editor.resizeFix();		}				this.registerPluginsOnKeyEvents();				this.setSelection();			},    /**     * Loads the stencil set extension file, defined in ORYX.CONFIG.SS_EXTENSIONS_CONFIG     */    _loadStencilSetExtensionConfig: function(){        // load ss extensions        new Ajax.Request(ORYX.CONFIG.SS_EXTENSIONS_CONFIG, {            method: 'GET',            asynchronous: false,            onSuccess: (function(transport) {                var jsonObject = Ext.decode(transport.responseText);                this.ss_extensions_def = jsonObject;            }).bind(this),            onFailure: (function(transport) {                ORYX.Log.error("Editor._loadStencilSetExtensionConfig: Loading stencil set extension configuration file failed." + transport);            }).bind(this)        });    },	/**	 * Creates the Canvas	 * @param {String} [stencilType] The stencil type used for creating the canvas. If not given, a stencil with myBeRoot = true from current stencil set is taken.	 * @param {Object} [canvasConfig] Any canvas properties (like language).	 */	_createCanvas: function(stencilType, canvasConfig) {        if (stencilType) {            // Add namespace to stencilType            if (stencilType.search(/^http/) === -1) {                stencilType = this.getStencilSets().values()[0].namespace() + stencilType;            }        }        else {            // Get any root stencil type            stencilType = this.getStencilSets().values()[0].findRootStencilName();        }        		// get the stencil associated with the type		var canvasStencil = ORYX.Core.StencilSet.stencil(stencilType);					if (!canvasStencil) 			ORYX.Log.fatal("Initialisation failed, because the stencil with the type %0 is not part of one of the loaded stencil sets.", stencilType);				// create all dom		// TODO fix border, so the visible canvas has a double border and some spacing to the scrollbars		var div = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", null, ['div']);		// set class for custom styling		div.addClassName("ORYX_Editor");								// create the canvas		this._canvas = new ORYX.Core.Canvas({			width					: ORYX.CONFIG.CANVAS_WIDTH,			height					: ORYX.CONFIG.CANVAS_HEIGHT,			'eventHandlerCallback'	: this.handleEvents.bind(this),			id						: this.id,			parentNode				: div		}, canvasStencil);                if (canvasConfig) {          // Migrate canvasConfig to an RDF-like structure          //FIXME this isn't nice at all because we don't want rdf any longer          var properties = [];          for(field in canvasConfig){            properties.push({              prefix: 'oryx',              name: field,              value: canvasConfig[field]            });          }                      this._canvas.deserialize(properties);        }					},	/**	 * Returns a per-editor singleton plugin facade.	 * To be used in plugin initialization.	 */	_getPluginFacade: function() {		// if there is no pluginfacade already created:		if(!(this._pluginFacade))			// create it.			this._pluginFacade = {				activatePluginByName:		this.activatePluginByName.bind(this),				//deactivatePluginByName:		this.deactivatePluginByName.bind(this),				getAvailablePlugins:	this.getAvailablePlugins.bind(this),				offer:					this.offer.bind(this),				getStencilSets:			this.getStencilSets.bind(this),				getRules:				this.getRules.bind(this),				loadStencilSet:			this.loadStencilSet.bind(this),				createShape:			this.createShape.bind(this),				deleteShape:			this.deleteShape.bind(this),				getSelection:			this.getSelection.bind(this),				setSelection:			this.setSelection.bind(this),				updateSelection:		this.updateSelection.bind(this),				getCanvas:				this.getCanvas.bind(this),								importJSON:				this.importJSON.bind(this),				importERDF:				this.importERDF.bind(this),				getERDF:				this.getERDF.bind(this),                getJSON:                this.getJSON.bind(this),                getSerializedJSON:      this.getSerializedJSON.bind(this),								executeCommands:		this.executeCommands.bind(this),								registerOnEvent:		this.registerOnEvent.bind(this),				unregisterOnEvent:		this.unregisterOnEvent.bind(this),				raiseEvent:				this.handleEvents.bind(this),				enableEvent:			this.enableEvent.bind(this),				disableEvent:			this.disableEvent.bind(this),								eventCoordinates:		this.eventCoordinates.bind(this),				addToRegion:			this.addToRegion.bind(this),								getModelMetaData:		this.getModelMetaData.bind(this)			};		// return it.		return this._pluginFacade;	},	/**	 * Implementes the command pattern	 * (The real usage of the command pattern	 * is implemented and shown in the Plugins/undo.js)	 *	 * @param <Oryx.Core.Command>[] Array of commands	 */	executeCommands: function(commands){				// Check if the argument is an array and the elements are from command-class		if ( 	commands instanceof Array 	&& 				commands.length > 0 		&& 				commands.all(function(command){ return command instanceof ORYX.Core.Command }) ) {					// Raise event for executing commands			this.handleEvents({				type		: ORYX.CONFIG.EVENT_EXECUTE_COMMANDS,				commands	: commands			});						// Execute every command			commands.each(function(command){				command.execute();			})					}	},	    /**     * Returns JSON of underlying canvas (calls ORYX.Canvas#toJSON()).     * @return {Object} Returns JSON representation as JSON object.     */    getJSON: function(){        var canvas = this.getCanvas().toJSON();        canvas.ssextensions = this.getStencilSets().values()[0].extensions().keys();        return canvas;    },        /**     * Serializes a call to toJSON().     * @return {String} Returns JSON representation as string.     */    getSerializedJSON: function(){        return Ext.encode(this.getJSON());    },	    /**	 * @return {String} Returns eRDF representation.	 * @deprecated Use ORYX.Editor#getJSON instead, if possible.	 */	getERDF:function(){		// Get the serialized dom        var serializedDOM = DataManager.serializeDOM( this._getPluginFacade() );				// Add xml definition if there is no		serializedDOM = '<?xml version="1.0" encoding="utf-8"?>' +						'<html xmlns="http://www.w3.org/1999/xhtml" ' +						'xmlns:b3mn="http://b3mn.org/2007/b3mn" ' +						'xmlns:ext="http://b3mn.org/2007/ext" ' +						'xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ' +						'xmlns:atom="http://b3mn.org/2007/atom+xhtml">' +						'<head profile="http://purl.org/NET/erdf/profile">' +						'<link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />' +						'<link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " />' +						'<link rel="schema.b3mn" href="http://b3mn.org" />' +						'<link rel="schema.oryx" href="http://oryx-editor.org/" />' +						'<link rel="schema.raziel" href="http://raziel.org/" />' +						'<base href="' +						location.href.split("?")[0] +						'" />' +						'</head><body>' +						serializedDOM +						'</body></html>';				return serializedDOM;					},    	/**	* Imports shapes in JSON as expected by {@link ORYX.Editor#loadSerialized}	* @param {Object|String} jsonObject The (serialized) json object to be imported	* @param {boolean } [noSelectionAfterImport=false] Set to true if no shapes should be selected after import	* @throws {SyntaxError} If the serialized json object contains syntax errors	*/	importJSON: function(jsonObject, noSelectionAfterImport) {		        try {            jsonObject = this.renewResourceIds(jsonObject);        } catch(error){            throw error;        }     		//check, if the imported json model can be loaded in this editor		// (stencil set has to fit)        if (!jsonObject.stencilset) {        	Ext.Msg.alert(ORYX.I18N.JSONImport.title, ORYX.I18N.JSONImport.invalidJSON);        	return null;        }		if(jsonObject.stencilset.namespace && jsonObject.stencilset.namespace !== this.getCanvas().getStencil().stencilSet().namespace()) {			Ext.Msg.alert(ORYX.I18N.JSONImport.title, String.format(ORYX.I18N.JSONImport.wrongSS, jsonObject.stencilset.namespace, this.getCanvas().getStencil().stencilSet().namespace()));			return null;		} else {			var commandClass = ORYX.Core.Command.extend({			construct: function(jsonObject, loadSerializedCB, noSelectionAfterImport, facade){				this.jsonObject = jsonObject;				this.noSelection = noSelectionAfterImport;				this.facade = facade;				this.shapes;				this.connections = [];				this.parents = new Hash();				this.selection = this.facade.getSelection();				this.loadSerialized = loadSerializedCB;			},						execute: function(){								if (!this.shapes) {					// Import the shapes out of the serialization							this.shapes	= this.loadSerialized( this.jsonObject );												//store all connections					this.shapes.each(function(shape) {												if (shape.getDockers) {							var dockers = shape.getDockers();							if (dockers) {								if (dockers.length > 0) {									this.connections.push([dockers.first(), dockers.first().getDockedShape(), dockers.first().referencePoint]);								}								if (dockers.length > 1) {									this.connections.push([dockers.last(), dockers.last().getDockedShape(), dockers.last().referencePoint]);								}							}						}												//store parents						this.parents[shape.id] = shape.parent;					}.bind(this));				} else {					this.shapes.each(function(shape) {						this.parents[shape.id].add(shape);					}.bind(this));										this.connections.each(function(con) {						con[0].setDockedShape(con[1]);						con[0].setReferencePoint(con[2]);						//con[0].update();					});				}								//this.parents.values().uniq().invoke("update");				this.facade.getCanvas().update();									if(!this.noSelection)					this.facade.setSelection(this.shapes);				else					this.facade.updateSelection();				},				rollback: function(){					var selection = this.facade.getSelection();										this.shapes.each(function(shape) {						selection = selection.without(shape);						this.facade.deleteShape(shape);					}.bind(this));										/*this.parents.values().uniq().each(function(parent) {						if(!this.shapes.member(parent))							parent.update();					}.bind(this));*/										this.facade.getCanvas().update();										this.facade.setSelection(selection);				}			})						var command = new commandClass(jsonObject, 											this.loadSerialized.bind(this),											noSelectionAfterImport,											this._getPluginFacade());						this.executeCommands([command]);							return command.shapes.clone();		}	},        /**     * This method renew all resource Ids and according references.     * Warning: The implementation performs a substitution on the serialized object for     * easier implementation. This results in a low performance which is acceptable if this     * is only used when importing models.     * @param {Object|String} jsonObject     * @throws {SyntaxError} If the serialized json object contains syntax errors.     * @return {Object} The jsonObject with renewed ids.     * @private     */    renewResourceIds: function(jsonObject){        // For renewing resource ids, a serialized and object version is needed        if(Ext.type(jsonObject) === "string"){            try {                var serJsonObject = jsonObject;                jsonObject = Ext.decode(jsonObject);            } catch(error){                throw new SyntaxError(error.message);            }        } else {            var serJsonObject = Ext.encode(jsonObject);        }                        // collect all resourceIds recursively        var collectResourceIds = function(shapes){            if(!shapes) return [];                        return shapes.map(function(shape){                return collectResourceIds(shape.childShapes).concat(shape.resourceId);            }).flatten();        }        var resourceIds = collectResourceIds(jsonObject.childShapes);                // Replace each resource id by a new one        resourceIds.each(function(oldResourceId){            var newResourceId = ORYX.Editor.provideId();            serJsonObject = serJsonObject.gsub('"'+oldResourceId+'"', '"'+newResourceId+'"')        });                return Ext.decode(serJsonObject);    },		/**	 * Import erdf structure to the editor	 *	 */	importERDF: function( erdfDOM ){		var serialized = this.parseToSerializeObjects( erdfDOM );					if(serialized)			return this.importJSON(serialized, true);	},	/**	 * Parses one model (eRDF) to the serialized form (JSON)	 * 	 * @param {Object} oneProcessData	 * @return {Object} The JSON form of given eRDF model, or null if it couldn't be extracted 	 */	parseToSerializeObjects: function( oneProcessData ){				// Firefox splits a long text node into chunks of 4096 characters.		// To prevent truncation of long property values the normalize method must be called		if(oneProcessData.normalize) oneProcessData.normalize();		try {			var xsl = "";			var source=ORYX.PATH + "lib/extract-rdf.xsl";			new Ajax.Request(source, {				asynchronous: false,				method: 'get',				onSuccess: function(transport){					xsl = transport.responseText				}.bind(this),				onFailure: (function(transport){					ORYX.Log.error("XSL load failed" + transport);				}).bind(this)			});			var domParser = new DOMParser();			var xmlObject = oneProcessData;			var xslObject = domParser.parseFromString(xsl, "text/xml");        	var xsltProcessor = new XSLTProcessor();        	var xslRef = document.implementation.createDocument("", "", null);        	xsltProcessor.importStylesheet(xslObject);                    var new_rdf = xsltProcessor.transformToFragment(xmlObject, document);            var serialized_rdf = (new XMLSerializer()).serializeToString(new_rdf);			}catch(e){			Ext.Msg.alert("Oryx", error);			var serialized_rdf = "";		}                        // Firefox 2 to 3 problem?!            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;        var req = new Ajax.Request(ORYX.CONFIG.ROOT_PATH+"rdf2json", {          method: 'POST',          asynchronous: false,          onSuccess: function(transport) {              Ext.decode(transport.responseText);          },          parameters: {              rdf: serialized_rdf          }        });                return Ext.decode(req.transport.responseText);	},    /**     * Loads serialized model to the oryx.     * @example     * editor.loadSerialized({     *    resourceId: "mymodel1",     *    childShapes: [     *       {     *          stencil:{ id:"Subprocess" },     *          outgoing:[{resourceId: 'aShape'}],     *          target: {resourceId: 'aShape'},     *          bounds:{ lowerRight:{ y:510, x:633 }, upperLeft:{ y:146, x:210 } },     *          resourceId: "myshape1",     *          childShapes:[],     *          properties:{},     *       }     *    ],     *    properties:{     *       language: "English"     *    },     *    stencilset:{     *       url:ORYX.PATH + "/stencilsets/bpmn1.1/bpmn1.1.json"     *    },     *    stencil:{     *       id:"BPMNDiagram"     *    }     * });     * @param {Object} model Description of the model to load.     * @param {Array} [model.ssextensions] List of stenctil set extensions.     * @param {String} model.stencilset.url     * @param {String} model.stencil.id      * @param {Array} model.childShapes     * @param {Array} [model.properties]     * @param {String} model.resourceId     * @return {ORYX.Core.Shape[]} List of created shapes     * @methodOf ORYX.Editor.prototype     */    loadSerialized: function( model ){        var canvas  = this.getCanvas();              // Bugfix (cf. http://code.google.com/p/oryx-editor/issues/detail?id=240)        // Deserialize the canvas' stencil set extensions properties first!        this.loadSSExtensions(model.ssextensions);        var shapes = this.getCanvas().addShapeObjects(model.childShapes, this.handleEvents.bind(this));                if(model.properties) {        	for(key in model.properties) {        		var prop = model.properties[key];        		if (!(typeof prop === "string")) {        			prop = Ext.encode(prop);        		}            	this.getCanvas().setProperty("oryx-" + key, prop);            }        }                        this.getCanvas().updateSize();        return shapes;    },        /**     * Calls ORYX.Editor.prototype.ss_extension_namespace for each element     * @param {Array} ss_extension_namespaces An array of stencil set extension namespaces.     */    loadSSExtensions: function(ss_extension_namespaces){        if(!ss_extension_namespaces) return;        ss_extension_namespaces.each(function(ss_extension_namespace){            this.loadSSExtension(ss_extension_namespace);        }.bind(this));    },		/**	* Loads a stencil set extension.	* The stencil set extensions definiton file must already	* be loaded when the editor is initialized.	*/	loadSSExtension: function(ss_extension_namespace) {								if (this.ss_extensions_def) {			var extension = this.ss_extensions_def.extensions.find(function(ex){				return (ex.namespace == ss_extension_namespace);			});						if (!extension) {				return;			}						var stencilset = this.getStencilSets()[extension["extends"]];						if (!stencilset) {				return;			}						stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension["definition"])			//stencilset.addExtension("/oryx/build/stencilsets/extensions/" + extension["definition"])			this.getRules().initializeRules(stencilset);						this._getPluginFacade().raiseEvent({				type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED			});		}			},	disableEvent: function(eventType){		if(eventType == ORYX.CONFIG.EVENT_KEYDOWN) {			this._keydownEnabled = false;		}		if(eventType == ORYX.CONFIG.EVENT_KEYUP) {			this._keyupEnabled = false;		}		if(this.DOMEventListeners.keys().member(eventType)) {			var value = this.DOMEventListeners.remove(eventType);			this.DOMEventListeners['disable_' + eventType] = value;		}	},	enableEvent: function(eventType){		if(eventType == ORYX.CONFIG.EVENT_KEYDOWN) {			this._keydownEnabled = true;		}				if(eventType == ORYX.CONFIG.EVENT_KEYUP) {			this._keyupEnabled = true;		}				if(this.DOMEventListeners.keys().member("disable_" + eventType)) {			var value = this.DOMEventListeners.remove("disable_" + eventType);			this.DOMEventListeners[eventType] = value;		}	},	/**	 *  Methods for the PluginFacade	 */	registerOnEvent: function(eventType, callback) {		if(!(this.DOMEventListeners.keys().member(eventType))) {			this.DOMEventListeners[eventType] = [];		}		this.DOMEventListeners[eventType].push(callback);	},	unregisterOnEvent: function(eventType, callback) {		if(this.DOMEventListeners.keys().member(eventType)) {			this.DOMEventListeners[eventType] = this.DOMEventListeners[eventType].without(callback);		} else {			// Event is not supported			// TODO: Error Handling		}	},	getSelection: function() {		return this.selection;	},	getStencilSets: function() { 		return ORYX.Core.StencilSet.stencilSets(this.id); 	},		getRules: function() {		return ORYX.Core.StencilSet.rules(this.id);	},		loadStencilSet: function(source) {		try {			ORYX.Core.StencilSet.loadStencilSet(source, this.id);			this.handleEvents({type:ORYX.CONFIG.EVENT_STENCIL_SET_LOADED});		} catch (e) {			ORYX.Log.warn("Requesting stencil set file failed. (" + e + ")");		}	},	offer: function(pluginData) {		if(!this.pluginsData.member(pluginData)){			this.pluginsData.push(pluginData);		}	},		/**	 * It creates an new event or adds the callback, if already existing,	 * for the key combination that the plugin passes in keyCodes attribute	 * of the offer method.	 * 	 * The new key down event fits the schema:	 * 		key.event[.metactrl][.alt][.shift].'thekeyCode'	 */	registerPluginsOnKeyEvents: function() {		this.pluginsData.each(function(pluginData) {						if(pluginData.keyCodes) {								pluginData.keyCodes.each(function(keyComb) {					var eventName = "key.event";										/* Include key action */					eventName += '.' + keyComb.keyAction;										if(keyComb.metaKeys) {						/* Register on ctrl or apple meta key as meta key */						if(keyComb.metaKeys.							indexOf(ORYX.CONFIG.META_KEY_META_CTRL) > -1) {								eventName += "." + ORYX.CONFIG.META_KEY_META_CTRL;						}													/* Register on alt key as meta key */						if(keyComb.metaKeys.							indexOf(ORYX.CONFIG.META_KEY_ALT) > -1) {								eventName += '.' + ORYX.CONFIG.META_KEY_ALT;						}												/* Register on shift key as meta key */						if(keyComb.metaKeys.							indexOf(ORYX.CONFIG.META_KEY_SHIFT) > -1) {								eventName += '.' + ORYX.CONFIG.META_KEY_SHIFT;						}							}										/* Register on the actual key */					if(keyComb.keyCode)	{						eventName += '.' + keyComb.keyCode;					}										/* Register the event */					ORYX.Log.debug("Register Plugin on Key Event: %0", eventName);					this.registerOnEvent(eventName,pluginData.functionality);								}.bind(this));			}		}.bind(this));	},	setSelection: function(elements, subSelectionElement, force) {				if (!elements) { elements = [] }				elements = elements.compact().findAll(function(n){ return n instanceof ORYX.Core.Shape });				if (elements.first() instanceof ORYX.Core.Canvas) {			elements = [];		}				if (!force && elements.length === this.selection.length && this.selection.all(function(r){ return elements.include(r) })){			return;		}				this.selection = elements;		this._subSelection = subSelectionElement;				this.handleEvents({type:ORYX.CONFIG.EVENT_SELECTION_CHANGED, elements:elements, subSelection: subSelectionElement})	},		updateSelection: function() {		this.setSelection(this.selection, this._subSelection, true);		/*var s = this.selection;		this.setSelection();		this.setSelection(s);*/	},	getCanvas: function() {		return this._canvas;	},		/**	*	option = {	*		type: string,	*		position: {x:int, y:int},	*		connectingType:	uiObj-Class	*		connectedShape: uiObj	*		draggin: bool	*		namespace: url	*       parent: ORYX.Core.AbstractShape	*		template: a template shape that the newly created inherits properties from.	*		}	*/	createShape: function(option) {		if(option && option.serialize && option.serialize instanceof Array){					var type = option.serialize.find(function(obj){return (obj.prefix+"-"+obj.name) == "oryx-type"});			var stencil = ORYX.Core.StencilSet.stencil(type.value);					if(stencil.type() == 'node'){				var newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);				} else {				var newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, stencil);				}					this.getCanvas().add(newShapeObject);			newShapeObject.deserialize(option.serialize);					return newShapeObject;		}		// If there is no argument, throw an exception		if(!option || !option.type || !option.namespace) { throw "To create a new shape you have to give an argument with type and namespace";}				var canvas = this.getCanvas();		var newShapeObject;		// Get the shape type		var shapetype = option.type;		// Get the stencil set		var sset = ORYX.Core.StencilSet.stencilSet(option.namespace);		// Create an New Shape, dependents on an Edge or a Node		if(sset.stencil(shapetype).type() == "node") {			newShapeObject = new ORYX.Core.Node({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))		} else {			newShapeObject = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(shapetype))		}				// when there is a template, inherit the properties.		if(option.template) {			newShapeObject._jsonStencil.properties = option.template._jsonStencil.properties;			newShapeObject.postProcessProperties();		}		// Add to the canvas		if(option.parent && newShapeObject instanceof ORYX.Core.Node) {			option.parent.add(newShapeObject);		} else {			canvas.add(newShapeObject);		}						// Set the position		var point = option.position ? option.position : {x:100, y:200};					var con;		// If there is create a shape and in the argument there is given an ConnectingType and is instance of an edge		if(option.connectingType && option.connectedShape && !(newShapeObject instanceof ORYX.Core.Edge)) {			// there will be create a new Edge			con = new ORYX.Core.Edge({'eventHandlerCallback':this.handleEvents.bind(this)}, sset.stencil(option.connectingType));						// And both endings dockers will be referenced to the both shapes			con.dockers.first().setDockedShape(option.connectedShape);						var magnet = option.connectedShape.getDefaultMagnet()			var cPoint = magnet ? magnet.bounds.center() : option.connectedShape.bounds.midPoint();			con.dockers.first().setReferencePoint( cPoint );			con.dockers.last().setDockedShape(newShapeObject);			con.dockers.last().setReferencePoint(newShapeObject.getDefaultMagnet().bounds.center());								// The Edge will be added to the canvas and be updated			canvas.add(con);				//con.update();					} 				// Move the new Shape to the position		if(newShapeObject instanceof ORYX.Core.Edge && option.connectedShape) {			newShapeObject.dockers.first().setDockedShape(option.connectedShape);						if( option.connectedShape instanceof ORYX.Core.Node ){				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.getDefaultMagnet().bounds.center());									newShapeObject.dockers.last().bounds.centerMoveTo(point);						} else {				newShapeObject.dockers.first().setReferencePoint(option.connectedShape.bounds.midPoint());											}		} else {						var b = newShapeObject.bounds			if( newShapeObject instanceof ORYX.Core.Node && newShapeObject.dockers.length == 1){				b = newShapeObject.dockers.first().bounds			}						b.centerMoveTo(point);						var upL = b.upperLeft();			b.moveBy( -Math.min(upL.x, 0) , -Math.min(upL.y, 0) )						var lwR = b.lowerRight();			b.moveBy( -Math.max(lwR.x-canvas.bounds.width(), 0) , -Math.max(lwR.y-canvas.bounds.height(), 0) )					}				// Update the shape		if (newShapeObject instanceof ORYX.Core.Edge) {			newShapeObject._update(false);		}				// And refresh the selection		if(!(newShapeObject instanceof ORYX.Core.Edge)) {			this.setSelection([newShapeObject]);		}				if(con && con.alignDockers) {			con.alignDockers();		} 		if(newShapeObject.alignDockers) {			newShapeObject.alignDockers();		}		return newShapeObject;	},		deleteShape: function(shape) {				if (!shape || !shape.parent){ return }				//remove shape from parent		// this also removes it from DOM		shape.parent.remove(shape);				//delete references to outgoing edges		shape.getOutgoingShapes().each(function(os) {			var docker = os.getDockers().first();			if(docker && docker.getDockedShape() == shape) {				docker.setDockedShape(undefined);			}		});				//delete references to incoming edges		shape.getIncomingShapes().each(function(is) {			var docker = is.getDockers().last();			if(docker && docker.getDockedShape() == shape) {				docker.setDockedShape(undefined);			}		});				//delete references of the shape's dockers		shape.getDockers().each(function(docker) {			docker.setDockedShape(undefined);		});	},		/**	 * Returns an object with meta data about the model.	 * Like name, description, ...	 * 	 * Empty object with the current backend.	 * 	 * @return {Object} Meta data about the model	 */	getModelMetaData: function() {		return this.modelMetaData;	},	/* Event-Handler Methods */		/**	* Helper method to execute an event immediately. The event is not	* scheduled in the _eventsQueue. Needed to handle Layout-Callbacks.	*/	_executeEventImmediately: function(eventObj) {		if(this.DOMEventListeners.keys().member(eventObj.event.type)) {			this.DOMEventListeners[eventObj.event.type].each((function(value) {				value(eventObj.event, eventObj.arg);					}).bind(this));		}	},	_executeEvents: function() {		this._queueRunning = true;		while(this._eventsQueue.length > 0) {			var val = this._eventsQueue.shift();			this._executeEventImmediately(val);		}		this._queueRunning = false;	},		/**	 * Leitet die Events an die Editor-Spezifischen Event-Methoden weiter	 * @param {Object} event Event , welches gefeuert wurde	 * @param {Object} uiObj Target-UiObj	 */	handleEvents: function(event, uiObj) {				ORYX.Log.trace("Dispatching event type %0 on %1", event.type, uiObj);		switch(event.type) {			case ORYX.CONFIG.EVENT_MOUSEDOWN:				this._handleMouseDown(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEMOVE:				this._handleMouseMove(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEUP:				this._handleMouseUp(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEOVER:				this._handleMouseHover(event, uiObj);				break;			case ORYX.CONFIG.EVENT_MOUSEOUT:				this._handleMouseOut(event, uiObj);				break;		}		/* Force execution if necessary. Used while handle Layout-Callbacks. */		if(event.forceExecution) {			this._executeEventImmediately({event: event, arg: uiObj});		} else {			this._eventsQueue.push({event: event, arg: uiObj});		}				if(!this._queueRunning) {			this._executeEvents();		}				// TODO: Make this return whether no listener returned false.		// So that, when one considers bubbling undesireable, it won't happen.		return false;	},	catchKeyUpEvents: function(event) {		if(!this._keyupEnabled) {			return;		}		/* assure we have the current event. */        if (!event)             event = window.event;        		// Checks if the event comes from some input field		if ( ["INPUT", "TEXTAREA"].include(event.target.tagName.toUpperCase()) ){			return;		}				/* Create key up event type */		var keyUpEvent = this.createKeyCombEvent(event,	ORYX.CONFIG.KEY_ACTION_UP);				ORYX.Log.debug("Key Event to handle: %0", keyUpEvent);		/* forward to dispatching. */		this.handleEvents({type: keyUpEvent, event:event});	},		/**	 * Catches all key down events and forward the appropriated event to 	 * dispatching concerning to the pressed keys.	 * 	 * @param {Event} 	 * 		The key down event to handle	 */	catchKeyDownEvents: function(event) {		if(!this._keydownEnabled) {			return;		}		/* Assure we have the current event. */        if (!event)             event = window.event;        		/* Fixed in FF3 */		// This is a mac-specific fix. The mozilla event object has no knowledge		// of meta key modifier on osx, however, it is needed for certain		// shortcuts. This fix adds the metaKey field to the event object, so		// that all listeners that registered per Oryx plugin facade profit from		// this. The original bug is filed in		// https://bugzilla.mozilla.org/show_bug.cgi?id=418334		//if (this.__currentKey == ORYX.CONFIG.KEY_CODE_META) {		//	event.appleMetaKey = true;		//}		//this.__currentKey = pressedKey;				// Checks if the event comes from some input field		if ( ["INPUT", "TEXTAREA"].include(event.target.tagName.toUpperCase()) ){			return;		}				/* Create key up event type */		var keyDownEvent = this.createKeyCombEvent(event, ORYX.CONFIG.KEY_ACTION_DOWN);				ORYX.Log.debug("Key Event to handle: %0", keyDownEvent);				/* Forward to dispatching. */		this.handleEvents({type: keyDownEvent,event: event});	},		/**	 * Creates the event type name concerning to the pressed keys.	 * 	 * @param {Event} keyDownEvent	 * 		The source keyDownEvent to build up the event name	 */	createKeyCombEvent: function(keyEvent, keyAction) {		/* Get the currently pressed key code. */        var pressedKey = keyEvent.which || keyEvent.keyCode;		//this.__currentKey = pressedKey;				/* Event name */		var eventName = "key.event";				/* Key action */		if(keyAction) {			eventName += "." + keyAction;		}				/* Ctrl or apple meta key is pressed */		if(keyEvent.ctrlKey || keyEvent.metaKey) {			eventName += "." + ORYX.CONFIG.META_KEY_META_CTRL;		}				/* Alt key is pressed */		if(keyEvent.altKey) {			eventName += "." + ORYX.CONFIG.META_KEY_ALT;		}				/* Alt key is pressed */		if(keyEvent.shiftKey) {			eventName += "." + ORYX.CONFIG.META_KEY_SHIFT;		}				/* Return the composed event name */		return  eventName + "." + pressedKey;	},	_handleMouseDown: function(event, uiObj) {				// get canvas.		var canvas = this.getCanvas();		// Try to get the focus		canvas.focus()			// find the shape that is responsible for this element's id.		var element = event.currentTarget;		var elementController = uiObj;		// gather information on selection.		var currentIsSelectable = (elementController !== null) &&			(elementController !== undefined) && (elementController.isSelectable);		var currentIsMovable = (elementController !== null) &&			(elementController !== undefined) && (elementController.isMovable);		var modifierKeyPressed = event.shiftKey || event.ctrlKey;		var noObjectsSelected = this.selection.length === 0;		var currentIsSelected = this.selection.member(elementController);		// Rule #1: When there is nothing selected, select the clicked object.		if(currentIsSelectable && noObjectsSelected) {			this.setSelection([elementController]);			ORYX.Log.trace("Rule #1 applied for mouse down on %0", element.id);		// Rule #3: When at least one element is selected, and there is no		// control key pressed, and the clicked object is not selected, select		// the clicked object.		} else if(currentIsSelectable && !noObjectsSelected &&			!modifierKeyPressed && !currentIsSelected) {			this.setSelection([elementController]);			//var objectType = elementController.readAttributes();			//alert(objectType[0] + ": " + objectType[1]);			ORYX.Log.trace("Rule #3 applied for mouse down on %0", element.id);		// Rule #4: When the control key is pressed, and the current object is		// not selected, add it to the selection.		} else if(currentIsSelectable && modifierKeyPressed			&& !currentIsSelected) {							var newSelection = this.selection.clone();			newSelection.push(elementController)			this.setSelection(newSelection)			ORYX.Log.trace("Rule #4 applied for mouse down on %0", element.id);		// Rule #6		} else if(currentIsSelectable && currentIsSelected &&			modifierKeyPressed) {			var newSelection = this.selection.clone();			this.setSelection(newSelection.without(elementController))			ORYX.Log.trace("Rule #6 applied for mouse down on %0", elementController.id);		// Rule #5: When there is at least one object selected and no control		// key pressed, we're dragging.		/*} else if(currentIsSelectable && !noObjectsSelected			&& !modifierKeyPressed) {			if(this.log.isTraceEnabled())				this.log.trace("Rule #5 applied for mouse down on "+element.id);*/		// Rule #2: When clicked on something that is neither		// selectable nor movable, clear the selection, and return.		} else if (!currentIsSelectable && !currentIsMovable) {						this.setSelection([]);						ORYX.Log.trace("Rule #2 applied for mouse down on %0", element.id);			return;		// Rule #7: When the current object is not selectable but movable,		// it is probably a control. Leave the selection unchanged but set		// the movedObject to the current one and enable Drag. Dockers will		// be processed in the dragDocker plugin.		} else if(!currentIsSelectable && currentIsMovable && !(elementController instanceof ORYX.Core.Controls.Docker)) {						// TODO: If there is any moveable elements, do this in a plugin			//ORYX.Core.UIEnableDrag(event, elementController);			ORYX.Log.trace("Rule #7 applied for mouse down on %0", element.id);				// Rule #8: When the element is selectable and is currently selected and no 		// modifier key is pressed		} else if(currentIsSelectable && currentIsSelected &&			!modifierKeyPressed) {						this._subSelection = this._subSelection != elementController ? elementController : undefined;									this.setSelection(this.selection, this._subSelection);						ORYX.Log.trace("Rule #8 applied for mouse down on %0", element.id);		}						// prevent event from bubbling, return.		//Event.stop(event);		return;	},	_handleMouseMove: function(event, uiObj) {		return;	},	_handleMouseUp: function(event, uiObj) {		// get canvas.		var canvas = this.getCanvas();		// find the shape that is responsible for this elemement's id.		var elementController = uiObj;		//get event position		var evPos = this.eventCoordinates(event);		//Event.stop(event);	},	_handleMouseHover: function(event, uiObj) {		return;	},	_handleMouseOut: function(event, uiObj) {		return;	},	/**	 * Calculates the event coordinates to SVG document coordinates.	 * @param {Event} event	 * @return {SVGPoint} The event coordinates in the SVG document	 */	eventCoordinates: function(event) {		var canvas = this.getCanvas();		var svgPoint = canvas.node.ownerSVGElement.createSVGPoint();		svgPoint.x = event.clientX;		svgPoint.y = event.clientY;		var matrix = canvas.node.getScreenCTM();		return svgPoint.matrixTransform(matrix.inverse());	}};ORYX.Editor = Clazz.extend(ORYX.Editor);/** * Creates a new ORYX.Editor instance by fetching a model from given url and passing it to the constructur * @param {String} modelUrl The JSON URL of a model. * @param {Object} config Editor config passed to the constructur, merged with the response of the request to modelUrl */ORYX.Editor.createByUrl = function(modelUrl, config){    if(!config) config = {};        new Ajax.Request(modelUrl, {      method: 'GET',      onSuccess: function(transport) {        var editorConfig = Ext.decode(transport.responseText);        editorConfig = Ext.applyIf(editorConfig, config);        new ORYX.Editor(editorConfig);              if ("function" == typeof(config.onSuccess)) {		  	config.onSuccess(transport);	    }      }.bind(this),      onFailure: function(transport) {    	if ("function" == typeof(config.onFailure)) {    	  config.onFailure(transport);    	}      }.bind(this)    });}// TODO Implement namespace awareness on attribute level./** * graft() function * Originally by Sean M. Burke from interglacial.com, altered for usage with * SVG and namespace (xmlns) support. Be sure you understand xmlns before * using this funtion, as it creates all grafted elements in the xmlns * provided by you and all element's attribures in default xmlns. If you * need to graft elements in a certain xmlns and wish to assign attributes * in both that and another xmlns, you will need to do stepwise grafting, * adding non-default attributes yourself or you'll have to enhance this * function. Latter, I would appreciate: martin�apfelfabrik.de * @param {Object} namespace The namespace in which * 					elements should be grafted. * @param {Object} parent The element that should contain the grafted * 					structure after the function returned. * @param {Object} t the crafting structure. * @param {Object} doc the document in which grafting is performed. */ORYX.Editor.graft = function(namespace, parent, t, doc) {    doc = (doc || (parent && parent.ownerDocument) || document);    var e;    if(t === undefined) {        throw "Can't graft an undefined value";    } else if(t.constructor == String) {        e = doc.createTextNode( t );    } else {        for(var i = 0; i < t.length; i++) {            if( i === 0 && t[i].constructor == String ) {                var snared;                snared = t[i].match( /^([a-z][a-z0-9]*)\.([^\s\.]+)$/i );                if( snared ) {                    e = doc.createElementNS(namespace, snared[1] );                    e.setAttributeNS(null, 'class', snared[2] );                    continue;                }                snared = t[i].match( /^([a-z][a-z0-9]*)$/i );                if( snared ) {                    e = doc.createElementNS(namespace, snared[1] );  // but no class                    continue;                }                // Otherwise:                e = doc.createElementNS(namespace, "span" );                e.setAttribute(null, "class", "namelessFromLOL" );            }            if( t[i] === undefined ) {                throw "Can't graft an undefined value in a list!";            } else if( t[i].constructor == String || t[i].constructor == Array ) {                this.graft(namespace, e, t[i], doc );            } else if(  t[i].constructor == Number ) {                this.graft(namespace, e, t[i].toString(), doc );            } else if(  t[i].constructor == Object ) {                // hash's properties => element's attributes                for(var k in t[i]) { e.setAttributeNS(null, k, t[i][k] ); }            } else {			}        }    }	if(parent) {	    parent.appendChild( e );	} else {	}    return e; // return the topmost created node};ORYX.Editor.provideId = function() {	var res = [], hex = '0123456789ABCDEF';	for (var i = 0; i < 36; i++) res[i] = Math.floor(Math.random()*0x10);	res[14] = 4;	res[19] = (res[19] & 0x3) | 0x8;	for (var i = 0; i < 36; i++) res[i] = hex[res[i]];	res[8] = res[13] = res[18] = res[23] = '-';	return "oryx_" + res.join('');};/** * When working with Ext, conditionally the window needs to be resized. To do * so, use this class method. Resize is deferred until 100ms, and all subsequent * resizeBugFix calls are ignored until the initially requested resize is * performed. */ORYX.Editor.resizeFix = function() {	if (!ORYX.Editor._resizeFixTimeout) {		ORYX.Editor._resizeFixTimeout = window.setTimeout(function() {			window.resizeBy(1,1);			window.resizeBy(-1,-1);			ORYX.Editor._resizefixTimeout = null;		}, 100); 	}};ORYX.Editor.Cookie = {		callbacks:[],			onChange: function( callback, interval ){			this.callbacks.push(callback);		this.start( interval )		},		start: function( interval ){				if( this.pe ){			return;		}				var currentString = document.cookie;				this.pe = new PeriodicalExecuter( function(){						if( currentString != document.cookie ){				currentString = document.cookie;				this.callbacks.each(function(callback){ callback(this.getParams()) }.bind(this));			}					}.bind(this), ( interval || 10000 ) / 1000);		},		stop: function(){		if( this.pe ){			this.pe.stop();			this.pe = null;		}	},			getParams: function(){		var res = {};				var p = document.cookie;		p.split("; ").each(function(param){ res[param.split("=")[0]] = param.split("=")[1];});				return res;	},			toString: function(){		return document.cookie;	}};/** * Workaround for SAFARI/Webkit, because * when trying to check SVGSVGElement of instanceof there is  * raising an error *  */ORYX.Editor.SVGClassElementsAreAvailable = true;ORYX.Editor.setMissingClasses = function() {		try {		SVGElement;	} catch(e) {		ORYX.Editor.SVGClassElementsAreAvailable = false;		SVGSVGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'svg').toString();		SVGGElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'g').toString();		SVGPathElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'path').toString();		SVGTextElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'text').toString();		//SVGMarkerElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'marker').toString();		SVGRectElement 		= document.createElementNS('http://www.w3.org/2000/svg', 'rect').toString();		SVGImageElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'image').toString();		SVGCircleElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'circle').toString();		SVGEllipseElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'ellipse').toString();		SVGLineElement	 	= document.createElementNS('http://www.w3.org/2000/svg', 'line').toString();		SVGPolylineElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polyline').toString();		SVGPolygonElement 	= document.createElementNS('http://www.w3.org/2000/svg', 'polygon').toString();			}	}ORYX.Editor.checkClassType = function( classInst, classType ) {		if( ORYX.Editor.SVGClassElementsAreAvailable ){		return classInst instanceof classType	} else {		return classInst == classType	}};ORYX.Editor.makeExtModalWindowKeysave = function(facade) {	Ext.override(Ext.Window,{		beforeShow : function(){			delete this.el.lastXY;			delete this.el.lastLT;			if(this.x === undefined || this.y === undefined){				var xy = this.el.getAlignToXY(this.container, 'c-c');				var pos = this.el.translatePoints(xy[0], xy[1]);				this.x = this.x === undefined? pos.left : this.x;				this.y = this.y === undefined? pos.top : this.y;			}			this.el.setLeftTop(this.x, this.y);				if(this.expandOnShow){				this.expand(false);			}				if(this.modal){				facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);				Ext.getBody().addClass("x-body-masked");				this.mask.setSize(Ext.lib.Dom.getViewWidth(true), Ext.lib.Dom.getViewHeight(true));				this.mask.show();			}		},		afterHide : function(){	        this.proxy.hide();	        if(this.monitorResize || this.modal || this.constrain || this.constrainHeader){	            Ext.EventManager.removeResizeListener(this.onWindowResize, this);	        }	        if(this.modal){	            this.mask.hide();	            facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);	            Ext.getBody().removeClass("x-body-masked");	        }	        if(this.keyMap){	            this.keyMap.disable();	        }	        this.fireEvent("hide", this);	    },	    beforeDestroy : function(){	    	if(this.modal)	    		facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);	        Ext.destroy(	            this.resizer,	            this.dd,	            this.proxy,	            this.mask	        );	        Ext.Window.superclass.beforeDestroy.call(this);	    }	});}/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}ORYX.Core.UIEnableDrag = function(event, uiObj, option) {	this.uiObj = uiObj;	var upL = uiObj.bounds.upperLeft();	var a = uiObj.node.getScreenCTM();	this.faktorXY= {x: a.a, y: a.d};		this.scrollNode = uiObj.node.ownerSVGElement.parentNode.parentNode;		this.offSetPosition =  {		x: Event.pointerX(event) - (upL.x * this.faktorXY.x),		y: Event.pointerY(event) - (upL.y * this.faktorXY.y)};	this.offsetScroll	= {x:this.scrollNode.scrollLeft,y:this.scrollNode.scrollTop};			this.dragCallback = ORYX.Core.UIDragCallback.bind(this);	this.disableCallback = ORYX.Core.UIDisableDrag.bind(this);	this.movedCallback = option ? option.movedCallback : undefined;	this.upCallback = option ? option.upCallback : undefined;		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);	document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, 	this.dragCallback , false);};ORYX.Core.UIDragCallback = function(event) {	var position = {		x: Event.pointerX(event) - this.offSetPosition.x,		y: Event.pointerY(event) - this.offSetPosition.y}	position.x 	-= this.offsetScroll.x - this.scrollNode.scrollLeft; 	position.y 	-= this.offsetScroll.y - this.scrollNode.scrollTop;	position.x /= this.faktorXY.x;	position.y /= this.faktorXY.y;	this.uiObj.bounds.moveTo(position);	//this.uiObj.update();	if(this.movedCallback)		this.movedCallback(event);		Event.stop(event);};ORYX.Core.UIDisableDrag = function(event) {	document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.dragCallback, false);	document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.disableCallback, true);		if(this.upCallback)		this.upCallback(event);			this.upCallback = undefined;	this.movedCallback = undefined;				Event.stop(event);	};/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}/** * @classDescription Base class for Shapes. * @extends ORYX.Core.AbstractShape */ORYX.Core.Shape = {	/**	 * Constructor	 */	construct: function(options, stencil) {		// call base class constructor		arguments.callee.$.construct.apply(this, arguments);				this.dockers = [];		this.magnets = [];				this._defaultMagnet;				this.incoming = [];		this.outgoing = [];				this.nodes = [];				this._dockerChangedCallback = this._dockerChanged.bind(this);				//Hash map for all labels. Labels are not treated as children of shapes.		this._labels = new Hash();				// create SVG node		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg",			null,			['g', {id:this.id},				['g', {"class": "stencils"},					['g', {"class": "me"}],					['g', {"class": "children", style:"overflow:hidden"}],					['g', {"class": "edge"}]				],				['g', {"class": "controls"},					['g', {"class": "dockers"}],					['g', {"class": "magnets"}]								]			]);	},	/**	 * If changed flag is set, refresh method is called.	 */	update: function() {		//if(this.isChanged) {			//this.layout();
		//}	},		/**	 * !!!Not called from any sub class!!!	 */	_update: function() {	},		/**	 * Calls the super class refresh method	 *  and updates the svg elements that are referenced by a property.	 */	refresh: function() {		//call base class refresh method		arguments.callee.$.refresh.apply(this, arguments);				if(this.node.ownerDocument) {			//adjust SVG to properties' values			var me = this;			this.propertiesChanged.each((function(propChanged) {				if(propChanged.value) {					var prop = this.properties[propChanged.key];					var property = this.getStencil().property(propChanged.key);					this.propertiesChanged[propChanged.key] = false;					//handle choice properties					if(property.type() == ORYX.CONFIG.TYPE_CHOICE) {						//iterate all references to SVG elements						property.refToView().each((function(ref) {							//if property is referencing a label, update the label							if(ref !== "") {								var label = this._labels[this.id + ref];								if (label) {									// if a choice is not valid anymore (due to changed stencil set), choose the default value									if ("undefined" == typeof(property.item(prop)) || !property.item(prop)) {										label.text(property.value()); // standard value of the stencil set									}									else {										label.text(property.item(prop).value());									}								}							}						}).bind(this));													//if the choice's items are referencing SVG elements						// show the selected and hide all other referenced SVG						// elements						var refreshedSvgElements = new Hash();						property.items().each((function(item) {							item.refToView().each((function(itemRef) {								if(itemRef == "") { this.propertiesChanged[propChanged.key] = true; return; }																var svgElem = this.node.ownerDocument.getElementById(this.id + itemRef);									if(!svgElem) { this.propertiesChanged[propChanged.key] = true; return; }																								/* Do not refresh the same svg element multiple times */								if(!refreshedSvgElements[svgElem.id] || prop == item.value()) {									svgElem.setAttributeNS(null, 'display', ((prop == item.value()) ? 'inherit' : 'none'));									refreshedSvgElements[svgElem.id] = svgElem;								}																// Reload the href if there is an image-tag								if(ORYX.Editor.checkClassType(svgElem, SVGImageElement)) {									svgElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', svgElem.getAttributeNS('http://www.w3.org/1999/xlink', 'href'));								}							}).bind(this));						}).bind(this));											} else { //handle properties that are not of type choice						//iterate all references to SVG elements						property.refToView().each((function(ref) {							//if the property does not reference an SVG element,							// do nothing							if(ref === "") { this.propertiesChanged[propChanged.key] = true; return; }									var refId = this.id + ref;							//get the SVG element							var svgElem = this.node.ownerDocument.getElementById(refId);							//if the SVG element can not be found							if(!svgElem || !(svgElem.ownerSVGElement)) { 								//if the referenced SVG element is a SVGAElement, it cannot								// be found with getElementById (Firefox bug).								// this is a work around								if(property.type() === ORYX.CONFIG.TYPE_URL || property.type() === ORYX.CONFIG.TYPE_DIAGRAM_LINK) {									var svgElems = this.node.ownerDocument.getElementsByTagNameNS('http://www.w3.org/2000/svg', 'a');																		svgElem = $A(svgElems).find(function(elem) {										return elem.getAttributeNS(null, 'id') === refId;									});																		if(!svgElem) { this.propertiesChanged[propChanged.key] = true; return; } 								} else {									this.propertiesChanged[propChanged.key] = true;									return;								}												}														if (property.complexAttributeToView()) {								var label = this._labels[refId];								if (label) {									try {								    	propJson = prop.evalJSON();								    	var value = propJson[property.complexAttributeToView()]								    	label.text(value ? value : prop);								    } catch (e) {								    	label.text(prop);								    }								}															} else {								switch (property.type()) {									case ORYX.CONFIG.TYPE_BOOLEAN:																					if (typeof prop == "string")											prop = prop === "true"											svgElem.setAttributeNS(null, 'display', (!(prop === property.inverseBoolean())) ? 'inherit' : 'none');																				break;									case ORYX.CONFIG.TYPE_COLOR:										if(property.fill()) {											if (svgElem.tagName.toLowerCase() === "stop"){												svgElem.setAttributeNS(null, "stop-color", prop);																								// Adjust stop color of the others												if (svgElem.parentNode.tagName.toLowerCase() === "radialgradient"){													ORYX.Utils.adjustGradient(svgElem.parentNode, svgElem);												}											} else {												svgElem.setAttributeNS(null, 'fill', prop);											}										}										if(property.stroke()) {											svgElem.setAttributeNS(null, 'stroke', prop);										}										break;									case ORYX.CONFIG.TYPE_STRING:										var label = this._labels[refId];										if (label) {											label.text(prop);										}										break;									case ORYX.CONFIG.TYPE_INTEGER:										var label = this._labels[refId];										if (label) {											label.text(prop);										}										break;									case ORYX.CONFIG.TYPE_FLOAT:										if(property.fillOpacity()) {											svgElem.setAttributeNS(null, 'fill-opacity', prop);										} 										if(property.strokeOpacity()) {											svgElem.setAttributeNS(null, 'stroke-opacity', prop);										}										if(!property.fillOpacity() && !property.strokeOpacity()) {											var label = this._labels[refId];											if (label) {												label.text(prop);											}										}										break;									case ORYX.CONFIG.TYPE_URL:									case ORYX.CONFIG.TYPE_DIAGRAM_LINK:										//TODO what is the dafault path?										var hrefAttr = svgElem.getAttributeNodeNS('http://www.w3.org/1999/xlink', 'xlink:href');										if(hrefAttr) {											hrefAttr.textContent = prop;										} else {											svgElem.setAttributeNS('http://www.w3.org/1999/xlink', 'xlink:href', prop);										}											break;								}							}						}).bind(this));																	}									}			}).bind(this));						//update labels			this._labels.values().each(function(label) {				label.update();			});		}	},		layout: function() {		//this.getStencil().layout(this)		var layoutEvents = this.getStencil().layout()		if(this instanceof ORYX.Core.Node && layoutEvents) {			layoutEvents.each(function(event) {								// setup additional attributes				event.shape = this;				event.forceExecution = true;								// do layouting				this._delegateEvent(event);			}.bind(this))					}	},		/**	 * Returns an array of Label objects.	 */	getLabels: function() {		return this._labels.values();	},	/**	 * Returns an array of dockers of this object.	 */	getDockers: function() {		return this.dockers;	},		getMagnets: function() {		return this.magnets;	},		getDefaultMagnet: function() {		if(this._defaultMagnet) {			return this._defaultMagnet;		} else if (this.magnets.length > 0) {			return this.magnets[0];		} else {			return undefined;		}	},	getParentShape: function() {		return this.parent;	},		getIncomingShapes: function(iterator) {		if(iterator) {			this.incoming.each(iterator);		}		return this.incoming;	},		getIncomingNodes: function(iterator) {        return this.incoming.select(function(incoming){            var isNode = (incoming instanceof ORYX.Core.Node);            if(isNode && iterator) iterator(incoming);            return isNode;        });    },			getOutgoingShapes: function(iterator) {		if(iterator) {			this.outgoing.each(iterator);		}		return this.outgoing;	},        getOutgoingNodes: function(iterator) {        return this.outgoing.select(function(out){            var isNode = (out instanceof ORYX.Core.Node);            if(isNode && iterator) iterator(out);            return isNode;        });    },		getAllDockedShapes: function(iterator) {		var result = this.incoming.concat(this.outgoing);		if(iterator) {			result.each(iterator);		}		return result	},	getCanvas: function() {		if(this.parent instanceof ORYX.Core.Canvas) {			return this.parent;		} else if(this.parent instanceof ORYX.Core.Shape) {			return this.parent.getCanvas();		} else {			return undefined;		}	},		/**	 * 	 * @param {Object} deep	 * @param {Object} iterator	 */	getChildNodes: function(deep, iterator) {		if(!deep && !iterator) {			return this.nodes.clone();		} else {			var result = [];			this.nodes.each(function(uiObject) {				if(!uiObject.isVisible){return}				if(iterator) {					iterator(uiObject);				}				result.push(uiObject);								if(deep && uiObject instanceof ORYX.Core.Shape) {					result = result.concat(uiObject.getChildNodes(deep, iterator));				}			});				return result;		}	},		/**	 * Overrides the UIObject.add method. Adds uiObject to the correct sub node.	 * @param {UIObject} uiObject	 * @param {Number} index	 */	add: function(uiObject, index) {		//parameter has to be an UIObject, but		// must not be an Edge.		if(uiObject instanceof ORYX.Core.UIObject 			&& !(uiObject instanceof ORYX.Core.Edge)) {						if (!(this.children.member(uiObject))) {				//if uiObject is child of another parent, remove it from that parent.				if(uiObject.parent) {					uiObject.parent.remove(uiObject);				}				//add uiObject to this Shape				if(index != undefined)					this.children.splice(index, 0, uiObject);				else					this.children.push(uiObject);				//set parent reference				uiObject.parent = this;				//add uiObject.node to this.node depending on the type of uiObject				var parent;				if(uiObject instanceof ORYX.Core.Node) {					parent = this.node.childNodes[0].childNodes[1];					this.nodes.push(uiObject);				} else if(uiObject instanceof ORYX.Core.Controls.Control) {					var ctrls = this.node.childNodes[1];					if(uiObject instanceof ORYX.Core.Controls.Docker) {						parent = ctrls.childNodes[0];						if (this.dockers.length >= 2){							this.dockers.splice(index!==undefined?Math.min(index, this.dockers.length-1):this.dockers.length-1, 0, uiObject);						} else {							this.dockers.push(uiObject);						}					} else if(uiObject instanceof ORYX.Core.Controls.Magnet) {						parent = ctrls.childNodes[1];						this.magnets.push(uiObject);					} else {						parent = ctrls;					}				} else {	//UIObject					parent = this.node;				}				if(index != undefined && index < parent.childNodes.length)					uiObject.node = parent.insertBefore(uiObject.node, parent.childNodes[index]);				else					uiObject.node = parent.appendChild(uiObject.node);									this._changed();				//uiObject.bounds.registerCallback(this._changedCallback);												if(this.eventHandlerCallback)					this.eventHandlerCallback({type:ORYX.CONFIG.EVENT_SHAPEADDED,shape:uiObject})								} else {				ORYX.Log.warn("add: ORYX.Core.UIObject is already a child of this object.");			}		} else {			ORYX.Log.warn("add: Parameter is not of type ORYX.Core.UIObject.");		}	},	/**	 * Overrides the UIObject.remove method. Removes uiObject.	 * @param {UIObject} uiObject	 */	remove: function(uiObject) {		//if uiObject is a child of this object, remove it.		if (this.children.member(uiObject)) {			//remove uiObject from children			this.children = this.children.without(uiObject);			//delete parent reference of uiObject			uiObject.parent = undefined;			//delete uiObject.node from this.node			if(uiObject instanceof ORYX.Core.Shape) {				if(uiObject instanceof ORYX.Core.Edge) {					uiObject.removeMarkers();					uiObject.node = this.node.childNodes[0].childNodes[2].removeChild(uiObject.node);				} else {					uiObject.node = this.node.childNodes[0].childNodes[1].removeChild(uiObject.node);					this.nodes = this.nodes.without(uiObject);				}			} else if(uiObject instanceof ORYX.Core.Controls.Control) {				if (uiObject instanceof ORYX.Core.Controls.Docker) {					uiObject.node = this.node.childNodes[1].childNodes[0].removeChild(uiObject.node);					this.dockers = this.dockers.without(uiObject);				} else if (uiObject instanceof ORYX.Core.Controls.Magnet) {					uiObject.node = this.node.childNodes[1].childNodes[1].removeChild(uiObject.node);					this.magnets = this.magnets.without(uiObject);				} else {					uiObject.node = this.node.childNodes[1].removeChild(uiObject.node);				}			}			this._changed();			//uiObject.bounds.unregisterCallback(this._changedCallback);		} else {			ORYX.Log.warn("remove: ORYX.Core.UIObject is not a child of this object.");		}	},		/**	 * Calculate the Border Intersection Point between two points	 * @param {PointA}	 * @param {PointB}	 */	getIntersectionPoint: function() {					var pointAX, pointAY, pointBX, pointBY;				// Get the the two Points			switch(arguments.length) {			case 2:				pointAX = arguments[0].x;				pointAY = arguments[0].y;				pointBX = arguments[1].x;				pointBY = arguments[1].y;				break;			case 4:				pointAX = arguments[0];				pointAY = arguments[1];				pointBX = arguments[2];				pointBY = arguments[3];				break;			default:				throw "getIntersectionPoints needs two or four arguments";		}								// Defined an include and exclude point		var includePointX, includePointY, excludePointX, excludePointY;		var bounds = this.absoluteBounds();				if(this.isPointIncluded(pointAX, pointAY, bounds)){			includePointX = pointAX;			includePointY = pointAY;		} else {			excludePointX = pointAX;			excludePointY = pointAY;		}		if(this.isPointIncluded(pointBX, pointBY, bounds)){			includePointX = pointBX;			includePointY = pointBY;		} else {			excludePointX = pointBX;			excludePointY = pointBY;		}						// If there is no inclue or exclude Shape, than return		if(!includePointX || !includePointY || !excludePointX || !excludePointY) {			return undefined;		}		var midPointX = 0;		var midPointY = 0;						var refPointX, refPointY;				var minDifferent = 1;		// Get the UpperLeft and LowerRight		//var ul = bounds.upperLeft();		//var lr = bounds.lowerRight();				var i = 0;				while(true) {			// Calculate the midpoint of the current to points				var midPointX = Math.min(includePointX, excludePointX) + ((Math.max(includePointX, excludePointX) - Math.min(includePointX, excludePointX)) / 2.0);			var midPointY = Math.min(includePointY, excludePointY) + ((Math.max(includePointY, excludePointY) - Math.min(includePointY, excludePointY)) / 2.0);									// Set the new midpoint by the means of the include of the bounds			if(this.isPointIncluded(midPointX, midPointY, bounds)){				includePointX = midPointX;				includePointY = midPointY;			} else {				excludePointX = midPointX;				excludePointY = midPointY;			}									// Calc the length of the line			var length = Math.sqrt(Math.pow(includePointX - excludePointX, 2) + Math.pow(includePointY - excludePointY, 2))			// Calc a point one step from the include point			refPointX = includePointX + ((excludePointX - includePointX) / length),			refPointY = includePointY + ((excludePointY - includePointY) / length)											// If the reference point not in the bounds, break			if(!this.isPointIncluded(refPointX, refPointY, bounds)) {				break			}												}		// Return the last includepoint		return {x:refPointX , y:refPointY};	},           /**     * Calculate if the point is inside the Shape     * @param {PointX}     * @param {PointY}      */    isPointIncluded: function(){		return  false	},        /**     * Calculate if the point is over an special offset area     * @param {Point}     */    isPointOverOffset: function(){		return  this.isPointIncluded.apply( this , arguments )	},			_dockerChanged: function() {	},			/**	 * Create a Docker for this Edge	 *	 */	createDocker: function(index, position) {		var docker = new ORYX.Core.Controls.Docker({eventHandlerCallback: this.eventHandlerCallback});		docker.bounds.registerCallback(this._dockerChangedCallback);		if(position) {			docker.bounds.centerMoveTo(position);		}		this.add(docker, index);				return docker	},	/**	 * Get the serialized object	 * return Array with hash-entrees (prefix, name, value)	 * Following values will given:	 * 		Bounds	 * 		Outgoing Shapes	 * 		Parent	 */	serialize: function() {		var serializedObject = arguments.callee.$.serialize.apply(this);		// Add the bounds		serializedObject.push({name: 'bounds', prefix:'oryx', value: this.bounds.serializeForERDF(), type: 'literal'});		// Add the outgoing shapes		this.getOutgoingShapes().each((function(followingShape){			serializedObject.push({name: 'outgoing', prefix:'raziel', value: '#'+ERDF.__stripHashes(followingShape.resourceId), type: 'resource'});					}).bind(this));		// Add the parent shape, if the parent not the canvas		//if(this.parent instanceof ORYX.Core.Shape){			serializedObject.push({name: 'parent', prefix:'raziel', value: '#'+ERDF.__stripHashes(this.parent.resourceId), type: 'resource'});			//}							return serializedObject;	},					deserialize: function(serialze){		arguments.callee.$.deserialize.apply(this, arguments);				// Set the Bounds		var bounds = serialze.find(function(ser){ return (ser.prefix+"-"+ser.name) == 'oryx-bounds'});		if(bounds) {			var b = bounds.value.replace(/,/g, " ").split(" ").without("");			if(this instanceof ORYX.Core.Edge){				this.dockers.first().bounds.centerMoveTo(parseFloat(b[0]), parseFloat(b[1]));				this.dockers.last().bounds.centerMoveTo(parseFloat(b[2]), parseFloat(b[3]));			} else {				this.bounds.set(parseFloat(b[0]), parseFloat(b[1]), parseFloat(b[2]), parseFloat(b[3]));			}					}	},			/**	 * Private methods.	 */	/**	 * Child classes have to overwrite this method for initializing a loaded	 * SVG representation.	 * @param {SVGDocument} svgDocument	 */	_init: function(svgDocument) {		//adjust ids		this._adjustIds(svgDocument, 0);	},	_adjustIds: function(element, idIndex) {		if(element instanceof Element) {			var eid = element.getAttributeNS(null, 'id');			if(eid && eid !== "") {				element.setAttributeNS(null, 'id', this.id + eid);			} else {				element.setAttributeNS(null, 'id', this.id + "_" + this.id + "_" + idIndex);				idIndex++;			}						// Replace URL in fill attribute			var fill = element.getAttributeNS(null, 'fill');			if (fill&&fill.include("url(#")){				fill = fill.replace(/url\(#/g, 'url(#'+this.id);				element.setAttributeNS(null, 'fill', fill);			}						if(element.hasChildNodes()) {				for(var i = 0; i < element.childNodes.length; i++) {					idIndex = this._adjustIds(element.childNodes[i], idIndex);				}			}		}		return idIndex;	},	toString: function() { return "ORYX.Core.Shape " + this.getId() }};ORYX.Core.Shape = ORYX.Core.AbstractShape.extend(ORYX.Core.Shape);/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}
if(!ORYX.Core.Controls) {ORYX.Core.Controls = {};}


/**
 * @classDescription Abstract base class for all Controls.
 */
ORYX.Core.Controls.Control = ORYX.Core.UIObject.extend({
	
	toString: function() { return "Control " + this.id; }
 });/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}if(!ORYX.Core.Controls) {ORYX.Core.Controls = {};}/** * @classDescription Represents a movable docker that can be bound to a shape. Dockers are used * for positioning shape objects. * @extends {Control} *  * TODO absoluteXY und absoluteCenterXY von einem Docker liefern falsche Werte!!! */ORYX.Core.Controls.Docker = ORYX.Core.Controls.Control.extend({	/**	 * Constructor	 */	construct: function() {		arguments.callee.$.construct.apply(this, arguments);				this.isMovable = true;				// Enables movability		this.bounds.set(0, 0, 16, 16);		// Set the bounds		this.referencePoint = undefined;		// Refrenzpoint 		this._dockedShapeBounds = undefined;				this._dockedShape = undefined;		this._oldRefPoint1 = undefined;		this._oldRefPoint2 = undefined;				//this.anchors = [];		this.anchorLeft;		this.anchorRight;		this.anchorTop;		this.anchorBottom;		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg",			null,			['g']);		// The DockerNode reprasentation		this._dockerNode = ORYX.Editor.graft("http://www.w3.org/2000/svg",			this.node,			['g', {"pointer-events":"all"},					['circle', {cx:"8", cy:"8", r:"8", stroke:"none", fill:"none"}],					['circle', {cx:"8", cy:"8", r:"3", stroke:"black", fill:"red", "stroke-width":"1"}]				]);					// The ReferenzNode reprasentation			this._referencePointNode = ORYX.Editor.graft("http://www.w3.org/2000/svg",			this.node,				['g', {"pointer-events":"none"},				['circle', {cx: this.bounds.upperLeft().x, cy: this.bounds.upperLeft().y, r: 3, fill:"red", "fill-opacity":0.4}]]);		// Hide the Docker		this.hide();				//Add to the EventHandler		this.addEventHandlers(this.node);		// Buffer the Update Callback for un-/register on Event-Handler 		this._updateCallback = this._changed.bind(this);	},		update: function() {		// If there have an DockedShape			if(this._dockedShape) {			if(this._dockedShapeBounds && this._dockedShape instanceof ORYX.Core.Node) {				// Calc the delta of width and height of the lastBounds and the current Bounds				var dswidth = this._dockedShapeBounds.width();				var dsheight = this._dockedShapeBounds.height();				if(!dswidth)					dswidth = 1;				if(!dsheight)					dsheight = 1;					var widthDelta = 	this._dockedShape.bounds.width() 	/ dswidth;				var heightDelta = 	this._dockedShape.bounds.height() 	/ dsheight;								// If there is an different				if(widthDelta !== 1.0 || heightDelta !== 1.0) {					// Set the delta					this.referencePoint.x *= widthDelta;					this.referencePoint.y *= heightDelta;				}					// Clone these bounds				this._dockedShapeBounds = this._dockedShape.bounds.clone();							}						// Get the first and the last Docker of the parent Shape			var dockerIndex = this.parent.dockers.indexOf(this)			var dock1 = this;			var dock2 = this.parent.dockers.length > 1 ? 							(dockerIndex === 0?							// If there is the first element							 	this.parent.dockers[dockerIndex + 1]:	// then take the next docker								this.parent.dockers[dockerIndex - 1]):  // if not, then take the docker before							undefined;						// Calculate the first absolute Refenzpoint 			var absoluteReferenzPoint1 = dock1.getDockedShape() ? 				dock1.getAbsoluteReferencePoint() : 				dock1.bounds.center();			// Calculate the last absolute Refenzpoint 			var absoluteReferenzPoint2 = dock2 && dock2.getDockedShape() ? 				dock2.getAbsoluteReferencePoint() : 				dock2 ? 					dock2.bounds.center() :					undefined;			// If there is no last absolute Referenzpoint					if(!absoluteReferenzPoint2) {				// Calculate from the middle of the DockedShape				var center = this._dockedShape.absoluteCenterXY();				var minDimension = this._dockedShape.bounds.width() * this._dockedShape.bounds.height(); 				absoluteReferenzPoint2 = {					x: absoluteReferenzPoint1.x + (center.x - absoluteReferenzPoint1.x) * -minDimension,					y: absoluteReferenzPoint1.y + (center.y - absoluteReferenzPoint1.y) * -minDimension				}			}						var newPoint = undefined;						/*if (!this._oldRefPoint1 || !this._oldRefPoint2 ||				absoluteReferenzPoint1.x !== this._oldRefPoint1.x ||				absoluteReferenzPoint1.y !== this._oldRefPoint1.y ||				absoluteReferenzPoint2.x !== this._oldRefPoint2.x ||				absoluteReferenzPoint2.y !== this._oldRefPoint2.y) {*/								// Get the new point for the Docker, calucalted by the intersection point of the Shape and the two points				newPoint = this._dockedShape.getIntersectionPoint(absoluteReferenzPoint1, absoluteReferenzPoint2);								// If there is new point, take the referencepoint as the new point				if(!newPoint) {					newPoint = this.getAbsoluteReferencePoint();				}								if(this.parent && this.parent.parent) {					var grandParentPos = this.parent.parent.absoluteXY();					newPoint.x -= grandParentPos.x;					newPoint.y -= grandParentPos.y;				}								// Set the bounds to the new point				this.bounds.centerMoveTo(newPoint)							this._oldRefPoint1 = absoluteReferenzPoint1;				this._oldRefPoint2 = absoluteReferenzPoint2;			} 			/*else {				newPoint = this.bounds.center();			}*/							//	}				// Call the super class		arguments.callee.$.update.apply(this, arguments);	},	/**	 * Calls the super class refresh method and updates the view of the docker.	 */	refresh: function() {		arguments.callee.$.refresh.apply(this, arguments);				// Refresh the dockers node		var p = this.bounds.upperLeft();		this._dockerNode.setAttributeNS(null, 'transform','translate(' + p.x + ', ' + p.y + ')');				// Refresh the referencepoints node		p = Object.clone(this.referencePoint);				if(p && this._dockedShape){			var upL 			if(this.parent instanceof ORYX.Core.Edge) {				upL = this._dockedShape.absoluteXY();			} else {				upL = this._dockedShape.bounds.upperLeft();
			}			p.x += upL.x;			p.y += upL.y;		} else {			p = this.bounds.center();		}					this._referencePointNode.setAttributeNS(null, 'transform','translate(' + p.x + ', ' + p.y + ')');	},	/**	 * Set the reference point	 * @param {Object} point	 */		setReferencePoint: function(point) {		// Set the referencepoint		if(this.referencePoint !== point &&			(!this.referencePoint || 			!point ||			this.referencePoint.x !== point.x || 			this.referencePoint.y !== point.y)) {							this.referencePoint = point;			this._changed();					}				// Update directly, because the referencepoint has no influence of the bounds		//this.refresh();	},		/**	 * Get the absolute referencepoint	 */	getAbsoluteReferencePoint: function() {		if(!this.referencePoint || !this._dockedShape) {			return undefined;		} else {			var absUL = this._dockedShape.absoluteXY();			return {							x: this.referencePoint.x + absUL.x,						y: this.referencePoint.y + absUL.y					}		}	},			/**	 * Set the docked Shape from the docker	 * @param {Object} shape	 */	setDockedShape: function(shape) {		// If there is an old docked Shape		if(this._dockedShape) {			this._dockedShape.bounds.unregisterCallback(this._updateCallback)						// Delete the Shapes from the incoming and outgoing array			// If this Docker the incoming of the Shape			if(this === this.parent.dockers.first()) {								this.parent.incoming = this.parent.incoming.without(this._dockedShape);				this._dockedShape.outgoing = this._dockedShape.outgoing.without(this.parent);						// If this Docker the outgoing of the Shape				} else if (this === this.parent.dockers.last()){					this.parent.outgoing = this.parent.outgoing.without(this._dockedShape);				this._dockedShape.incoming = this._dockedShape.incoming.without(this.parent);										}					}				// Set the new Shape		this._dockedShape = shape;		this._dockedShapeBounds = undefined;		var referencePoint = undefined;				// If there is an Shape, register the updateCallback if there are changes in the shape bounds		if(this._dockedShape) {						// Add the Shapes to the incoming and outgoing array			// If this Docker the incoming of the Shape			if(this === this.parent.dockers.first()) {								this.parent.incoming.push(shape);				shape.outgoing.push(this.parent);						// If this Docker the outgoing of the Shape				} else if (this === this.parent.dockers.last()){					this.parent.outgoing.push(shape);				shape.incoming.push(this.parent);										}						// Get the bounds and set the new referencepoint			var bounds = this.bounds;			var absUL = shape.absoluteXY();						/*if(shape.parent){				var b = shape.parent.bounds.upperLeft();				absUL.x -= b.x;				absUL.y -= b.y;
			}*/						referencePoint = {				x: bounds.center().x - absUL.x,				y: bounds.center().y - absUL.y			}										this._dockedShapeBounds = this._dockedShape.bounds.clone();						this._dockedShape.bounds.registerCallback(this._updateCallback);						// Set the color of the docker as docked			this.setDockerColor(ORYX.CONFIG.DOCKER_DOCKED_COLOR);						} else {			// Set the color of the docker as undocked			this.setDockerColor(ORYX.CONFIG.DOCKER_UNDOCKED_COLOR);		}		// Set the referencepoint		this.setReferencePoint(referencePoint);		this._changed();		//this.update();	},		/**	 * Get the docked Shape	 */	getDockedShape: function() {		return this._dockedShape;	},	/**	 * Returns TRUE if the docker has a docked shape	 */	isDocked: function() {		return !!this._dockedShape;	},			/**	 * Set the Color of the Docker	 * @param {Object} color	 */	setDockerColor: function(color) {		this._dockerNode.lastChild.setAttributeNS(null, "fill", color);	},		/**	 * Hides this UIObject and all its children.	 */	hide: function() {		this.node.setAttributeNS(null, 'visibility', 'hidden');				this.children.each(function(uiObj) {			uiObj.hide();			});					},		/**	 * Enables visibility of this UIObject and all its children.	 */	show: function() {		this.node.setAttributeNS(null, 'visibility', 'visible');				this.children.each(function(uiObj) {			uiObj.show();			});			},		toString: function() { return "Docker " + this.id }});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if(!ORYX) {var ORYX = {};}if(!ORYX.Core) {ORYX.Core = {};}if(!ORYX.Core.Controls) {ORYX.Core.Controls = {};}/** * @classDescription Represents a magnet that is part of another shape and can * be attached to dockers. Magnets are used for linking edge objects * to other Shape objects. * @extends {Control} */ORYX.Core.Controls.Magnet = ORYX.Core.Controls.Control.extend({			/**	 * Constructor	 */	construct: function() {		arguments.callee.$.construct.apply(this, arguments);				//this.anchors = [];		this.anchorLeft;		this.anchorRight;		this.anchorTop;		this.anchorBottom;				this.bounds.set(0, 0, 16, 16);				//graft magnet's root node into owner's control group.		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg",			null,			['g', {"pointer-events":"all"},					['circle', {cx:"8", cy:"8", r:"4", stroke:"none", fill:"red", "fill-opacity":"0.3"}],				]);					this.hide();	},		update: function() {		arguments.callee.$.update.apply(this, arguments);				//this.isChanged = true;	},		_update: function() {				arguments.callee.$.update.apply(this, arguments);				//this.isChanged = true;	},		refresh: function() {		arguments.callee.$.refresh.apply(this, arguments);		var p = this.bounds.upperLeft();		/*if(this.parent) {			var parentPos = this.parent.bounds.upperLeft();			p.x += parentPos.x;			p.y += parentPos.y;		}*/				this.node.setAttributeNS(null, 'transform','translate(' + p.x + ', ' + p.y + ')');	},		show: function() {		//this.refresh();		arguments.callee.$.show.apply(this, arguments);	},		toString: function() {		return "Magnet " + this.id;	}});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * Init namespaces */if (!ORYX) {    var ORYX = {};}if (!ORYX.Core) {    ORYX.Core = {};}/** * @classDescription Abstract base class for all Nodes. * @extends ORYX.Core.Shape */ORYX.Core.Node = {    /**     * Constructor     * @param options {Object} A container for arguments.     * @param stencil {Stencil}     */    construct: function(options, stencil){        arguments.callee.$.construct.apply(this, arguments);                this.isSelectable = true;        this.isMovable = true;		this._dockerUpdated = false;                this._oldBounds = new ORYX.Core.Bounds(); //init bounds with undefined values        this._svgShapes = []; //array of all SVGShape objects of        // SVG representation                //TODO vielleicht in shape verschieben?        this.minimumSize = undefined; // {width:..., height:...}        this.maximumSize = undefined;                //TODO vielleicht in shape oder uiobject verschieben?        // vielleicht sogar isResizable ersetzen?        this.isHorizontallyResizable = false;        this.isVerticallyResizable = false;                this.dataId = undefined;                this._init(this._stencil.view());    },            /**     * This method checks whether the shape is resized correctly and calls the     * super class update method.     */    _update: function(){				this.dockers.invoke("update");		if (this.isChanged) {			var bounds = this.bounds;            var oldBounds = this._oldBounds;									if (this.isResized) {							var widthDelta = bounds.width() / oldBounds.width();				var heightDelta = bounds.height() / oldBounds.height();								//iterate over all relevant svg elements and resize them				this._svgShapes.each(function(svgShape){					//adjust width					if (svgShape.isHorizontallyResizable) {						svgShape.width = svgShape.oldWidth * widthDelta;					}					//adjust height					if (svgShape.isVerticallyResizable) {						svgShape.height = svgShape.oldHeight * heightDelta;					}										//check, if anchors are set					var anchorOffset;					var leftIncluded = svgShape.anchorLeft;					var rightIncluded = svgShape.anchorRight;										if (rightIncluded) {						anchorOffset = oldBounds.width() - (svgShape.oldX + svgShape.oldWidth);						if (leftIncluded) {							svgShape.width = bounds.width() - svgShape.x - anchorOffset;						}						else {							svgShape.x = bounds.width() - (anchorOffset + svgShape.width);						}					}					else 						if (!leftIncluded) {							svgShape.x = widthDelta * svgShape.oldX;							if (!svgShape.isHorizontallyResizable) {								svgShape.x = svgShape.x + svgShape.width * widthDelta / 2 - svgShape.width / 2;							}						}										var topIncluded = svgShape.anchorTop;					var bottomIncluded = svgShape.anchorBottom;										if (bottomIncluded) {						anchorOffset = oldBounds.height() - (svgShape.oldY + svgShape.oldHeight);						if (topIncluded) {							svgShape.height = bounds.height() - svgShape.y - anchorOffset;						}						else {							// Hack for choreography task layouting							if (!svgShape._isYLocked) {								svgShape.y = bounds.height() - (anchorOffset + svgShape.height);							}						}					}					else 						if (!topIncluded) {							svgShape.y = heightDelta * svgShape.oldY;							if (!svgShape.isVerticallyResizable) {								svgShape.y = svgShape.y + svgShape.height * heightDelta / 2 - svgShape.height / 2;							}						}				});								//check, if the current bounds is unallowed horizontally or vertically resized				var p = {					x: 0,					y: 0				};				if (!this.isHorizontallyResizable && bounds.width() !== oldBounds.width()) {					p.x = oldBounds.width() - bounds.width();				}				if (!this.isVerticallyResizable && bounds.height() !== oldBounds.height()) {					p.y = oldBounds.height() - bounds.height();				}				if (p.x !== 0 || p.y !== 0) {					bounds.extend(p);				}								//check, if the current bounds are between maximum and minimum bounds				p = {					x: 0,					y: 0				};				var widthDifference, heightDifference;				if (this.minimumSize) {									ORYX.Log.debug("Shape (%0)'s min size: (%1x%2)", this, this.minimumSize.width, this.minimumSize.height);					widthDifference = this.minimumSize.width - bounds.width();					if (widthDifference > 0) {						p.x += widthDifference;					}					heightDifference = this.minimumSize.height - bounds.height();					if (heightDifference > 0) {						p.y += heightDifference;					}				}				if (this.maximumSize) {									ORYX.Log.debug("Shape (%0)'s max size: (%1x%2)", this, this.maximumSize.width, this.maximumSize.height);					widthDifference = bounds.width() - this.maximumSize.width;					if (widthDifference > 0) {						p.x -= widthDifference;					}					heightDifference = bounds.height() - this.maximumSize.height;					if (heightDifference > 0) {						p.y -= heightDifference;					}				}				if (p.x !== 0 || p.y !== 0) {					bounds.extend(p);				}								//update magnets								var widthDelta = bounds.width() / oldBounds.width();				var heightDelta = bounds.height() / oldBounds.height();								var leftIncluded, rightIncluded, topIncluded, bottomIncluded, center, newX, newY;								this.magnets.each(function(magnet){					leftIncluded = magnet.anchorLeft;					rightIncluded = magnet.anchorRight;					topIncluded = magnet.anchorTop;					bottomIncluded = magnet.anchorBottom;										center = magnet.bounds.center();										if (leftIncluded) {						newX = center.x;					}					else 						if (rightIncluded) {							newX = bounds.width() - (oldBounds.width() - center.x)						}						else {							newX = center.x * widthDelta;						}										if (topIncluded) {						newY = center.y;					}					else 						if (bottomIncluded) {							newY = bounds.height() - (oldBounds.height() - center.y);						}						else {							newY = center.y * heightDelta;						}										if (center.x !== newX || center.y !== newY) {						magnet.bounds.centerMoveTo(newX, newY);					}				});								//set new position of labels				this.getLabels().each(function(label){					leftIncluded = label.anchorLeft;					rightIncluded = label.anchorRight;					topIncluded = label.anchorTop;					bottomIncluded = label.anchorBottom;															if (leftIncluded) {										}					else 						if (rightIncluded) {							label.x = bounds.width() - (oldBounds.width() - label.oldX)						}						else {							label.x *= widthDelta;						}										if (topIncluded) {										}					else 						if (bottomIncluded) {							label.y = bounds.height() - (oldBounds.height() - label.oldY);						}						else {							label.y *= heightDelta;						}				});								//update docker				var docker = this.dockers[0];				if (docker) {					docker.bounds.unregisterCallback(this._dockerChangedCallback);					if (!this._dockerUpdated) {						docker.bounds.centerMoveTo(this.bounds.center());						this._dockerUpdated = false;					}										docker.update();					docker.bounds.registerCallback(this._dockerChangedCallback);				}				this.isResized = false;			}                        this.refresh();						this.isChanged = false;						this._oldBounds = this.bounds.clone();        }				this.children.each(function(value) {			if(!(value instanceof ORYX.Core.Controls.Docker)) {				value._update();			}		});				if (this.dockers.length > 0&&!this.dockers.first().getDockedShape()) {			this.dockers.each(function(docker){				docker.bounds.centerMoveTo(this.bounds.center())			}.bind(this))		}				/*this.incoming.each((function(edge) {			if(!(this.dockers[0] && this.dockers[0].getDockedShape() instanceof ORYX.Core.Node))				edge._update(true);		}).bind(this));				this.outgoing.each((function(edge) {			if(!(this.dockers[0] && this.dockers[0].getDockedShape() instanceof ORYX.Core.Node))				edge._update(true);		}).bind(this)); */    },        /**     * This method repositions and resizes the SVG representation     * of the shape.     */    refresh: function(){        arguments.callee.$.refresh.apply(this, arguments);                /** Movement */        var x = this.bounds.upperLeft().x;        var y = this.bounds.upperLeft().y;                //set translation in transform attribute        /*var attributeTransform = document.createAttributeNS(ORYX.CONFIG.NAMESPACE_SVG, "transform");        attributeTransform.nodeValue = "translate(" + x + ", " + y + ")";        this.node.firstChild.setAttributeNode(attributeTransform);*/		// Move owner element		this.node.firstChild.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")");		// Move magnets		this.node.childNodes[1].childNodes[1].setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")");                /** Resize */                //iterate over all relevant svg elements and update them        this._svgShapes.each(function(svgShape){            svgShape.update();        });    },        _dockerChanged: function(){		var docker = this.dockers[0];                //set the bounds of the the association        this.bounds.centerMoveTo(docker.bounds.center());        		this._dockerUpdated = true;        //this._update(true);    },        /**     * This method traverses a tree of SVGElements and returns     * all SVGShape objects. For each basic shape or path element     * a SVGShape object is initialized.     *     * @param svgNode {SVGElement}     * @return {Array} Array of SVGShape objects     */    _initSVGShapes: function(svgNode){        var svgShapes = [];        try {            var svgShape = new ORYX.Core.SVG.SVGShape(svgNode);            svgShapes.push(svgShape);        }         catch (e) {            //do nothing        }                if (svgNode.hasChildNodes()) {            for (var i = 0; i < svgNode.childNodes.length; i++) {                svgShapes = svgShapes.concat(this._initSVGShapes(svgNode.childNodes[i]));            }        }                return svgShapes;    },        /**     * Calculate if the point is inside the Shape     * @param {PointX}     * @param {PointY}      * @param {absoluteBounds} optional: for performance     */    isPointIncluded: function(pointX, pointY, absoluteBounds){        // If there is an arguments with the absoluteBounds        var absBounds = absoluteBounds && absoluteBounds instanceof ORYX.Core.Bounds ? absoluteBounds : this.absoluteBounds();                if (!absBounds.isIncluded(pointX, pointY)) {			return false;		} else {					}			                //point = Object.clone(point);        var ul = absBounds.upperLeft();        var x = pointX - ul.x;        var y = pointY - ul.y;					var i=0;		do {			var isPointIncluded = this._svgShapes[i++].isPointIncluded( x, y );		} while( !isPointIncluded && i < this._svgShapes.length)				return isPointIncluded;        /*return this._svgShapes.any(function(svgShape){            return svgShape.isPointIncluded(point);        });*/    },         /**     * Calculate if the point is over an special offset area     * @param {Point}     */    isPointOverOffset: function( pointX, pointY ){       		var isOverEl = arguments.callee.$.isPointOverOffset.apply( this , arguments );				if (isOverEl) {							        // If there is an arguments with the absoluteBounds	        var absBounds = this.absoluteBounds();	        absBounds.widen( - ORYX.CONFIG.BORDER_OFFSET );				        if ( !absBounds.isIncluded( pointX, pointY )) {	            return true;	        }				}				return false;			},	       serialize: function(){        var result = arguments.callee.$.serialize.apply(this);                // Add the docker's bounds        // nodes only have at most one docker!        this.dockers.each((function(docker){			if (docker.getDockedShape()) {				var center = docker.referencePoint;				center = center ? center : docker.bounds.center();				result.push({					name: 'docker',					prefix: 'oryx',					value: $H(center).values().join(','),					type: 'literal'				});			}        }).bind(this));                // Get the spezific serialized object from the stencil        try {            //result = this.getStencil().serialize(this, result);			var serializeEvent = this.getStencil().serialize();						/*			 * call serialize callback by reference, result should be found			 * in serializeEvent.result			 */			if(serializeEvent.type) {				serializeEvent.shape = this;				serializeEvent.data = result;				serializeEvent.result = undefined;				serializeEvent.forceExecution = true;								this._delegateEvent(serializeEvent);								if(serializeEvent.result) {					result = serializeEvent.result;				}			}        }         catch (e) {        }        return result;    },        deserialize: function(data){    	arguments.callee.$.deserialize.apply(this, [data]);			    try {            //data = this.getStencil().deserialize(this, data);			var deserializeEvent = this.getStencil().deserialize();						/*			 * call serialize callback by reference, result should be found			 * in serializeEventInfo.result			 */			if(deserializeEvent.type) {				deserializeEvent.shape = this;				deserializeEvent.data = data;				deserializeEvent.result = undefined;				deserializeEvent.forceExecution = true;								this._delegateEvent(deserializeEvent);				if(deserializeEvent.result) {					data = deserializeEvent.result;				}			}        }         catch (e) {        }				// Set the outgoing shapes		var outgoing = data.findAll(function(ser){ return (ser.prefix+"-"+ser.name) == 'raziel-outgoing'});		outgoing.each((function(obj){			// TODO: Look at Canvas			if(!this.parent) {return};											// Set outgoing Shape			var next = this.getCanvas().getChildShapeByResourceId(obj.value);																				if(next){				if(next instanceof ORYX.Core.Edge) {					//Set the first docker of the next shape					next.dockers.first().setDockedShape(this);					next.dockers.first().setReferencePoint(next.dockers.first().bounds.center());				} else if(next.dockers.length > 0) { //next is a node and next has a docker					next.dockers.first().setDockedShape(this);					//next.dockers.first().setReferencePoint({x: this.bounds.width() / 2.0, y: this.bounds.height() / 2.0});				}			}						}).bind(this));                if (this.dockers.length === 1) {            var dockerPos;            dockerPos = data.find(function(entry){                return (entry.prefix + "-" + entry.name === "oryx-dockers");            });                        if (dockerPos) {                var points = dockerPos.value.replace(/,/g, " ").split(" ").without("").without("#");				if (points.length === 2 && this.dockers[0].getDockedShape()) {                    this.dockers[0].setReferencePoint({                        x: parseFloat(points[0]),                        y: parseFloat(points[1])                    });                }                else {                    this.dockers[0].bounds.centerMoveTo(parseFloat(points[0]), parseFloat(points[1]));                }            }        }    },        /**     * This method excepts the SVGDoucment that is the SVG representation     * of this shape.     * The bounds of the shape are calculated, the SVG representation's upper left point     * is moved to 0,0 and it the method sets if this shape is resizable.     *     * @param {SVGDocument} svgDocument     */    _init: function(svgDocument){        arguments.callee.$._init.apply(this, arguments);		        var svgNode = svgDocument.getElementsByTagName("g")[0]; //outer most g node        // set all required attributes        var attributeTitle = svgDocument.ownerDocument.createAttributeNS(null, "title");        attributeTitle.nodeValue = this.getStencil().title();        svgNode.setAttributeNode(attributeTitle);                var attributeId = svgDocument.ownerDocument.createAttributeNS(null, "id");        attributeId.nodeValue = this.id;        svgNode.setAttributeNode(attributeId);                //         var stencilTargetNode = this.node.childNodes[0].childNodes[0]; //<g class=me>"        svgNode = stencilTargetNode.appendChild(svgNode);                // Add to the EventHandler        this.addEventHandlers(svgNode);                /**set minimum and maximum size*/        var minSizeAttr = svgNode.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "minimumSize");        if (minSizeAttr) {            minSizeAttr = minSizeAttr.replace("/,/g", " ");            var minSizeValues = minSizeAttr.split(" ");            minSizeValues = minSizeValues.without("");                        if (minSizeValues.length > 1) {                this.minimumSize = {                    width: parseFloat(minSizeValues[0]),                    height: parseFloat(minSizeValues[1])                };            }            else {                //set minimumSize to (1,1), so that width and height of the stencil can never be (0,0)                this.minimumSize = {                    width: 1,                    height: 1                };            }        }                var maxSizeAttr = svgNode.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "maximumSize");        if (maxSizeAttr) {            maxSizeAttr = maxSizeAttr.replace("/,/g", " ");            var maxSizeValues = maxSizeAttr.split(" ");            maxSizeValues = maxSizeValues.without("");                        if (maxSizeValues.length > 1) {                this.maximumSize = {                    width: parseFloat(maxSizeValues[0]),                    height: parseFloat(maxSizeValues[1])                };            }        }                if (this.minimumSize && this.maximumSize &&        (this.minimumSize.width > this.maximumSize.width ||        this.minimumSize.height > this.maximumSize.height)) {                    //TODO wird verschluckt!!!            throw this + ": Minimum Size must be greater than maxiumSize.";        }                /**get current bounds and adjust it to upperLeft == (0,0)*/        //initialize all SVGShape objects        this._svgShapes = this._initSVGShapes(svgNode);                //get upperLeft and lowerRight of stencil        var upperLeft = {            x: undefined,            y: undefined        };        var lowerRight = {            x: undefined,            y: undefined        };        var me = this;        this._svgShapes.each(function(svgShape){            upperLeft.x = (upperLeft.x !== undefined) ? Math.min(upperLeft.x, svgShape.x) : svgShape.x;            upperLeft.y = (upperLeft.y !== undefined) ? Math.min(upperLeft.y, svgShape.y) : svgShape.y;            lowerRight.x = (lowerRight.x !== undefined) ? Math.max(lowerRight.x, svgShape.x + svgShape.width) : svgShape.x + svgShape.width;            lowerRight.y = (lowerRight.y !== undefined) ? Math.max(lowerRight.y, svgShape.y + svgShape.height) : svgShape.y + svgShape.height;                        /** set if resizing is enabled */            //TODO isResizable durch die beiden anderen booleans ersetzen?            if (svgShape.isHorizontallyResizable) {                me.isHorizontallyResizable = true;                me.isResizable = true;            }            if (svgShape.isVerticallyResizable) {                me.isVerticallyResizable = true;                me.isResizable = true;            }            if (svgShape.anchorTop && svgShape.anchorBottom) {                me.isVerticallyResizable = true;                me.isResizable = true;            }            if (svgShape.anchorLeft && svgShape.anchorRight) {                me.isHorizontallyResizable = true;                me.isResizable = true;            }        });                //move all SVGShapes by -upperLeft        this._svgShapes.each(function(svgShape){            svgShape.x -= upperLeft.x;            svgShape.y -= upperLeft.y;            svgShape.update();        });                //set bounds of shape        //the offsets are also needed for positioning the magnets and the docker        var offsetX = upperLeft.x;        var offsetY = upperLeft.y;                lowerRight.x -= offsetX;        lowerRight.y -= offsetY;        upperLeft.x = 0;        upperLeft.y = 0;                //prevent that width or height of initial bounds is 0        if (lowerRight.x === 0) {            lowerRight.x = 1;        }        if (lowerRight.y === 0) {            lowerRight.y = 1;        }                this._oldBounds.set(upperLeft, lowerRight);        this.bounds.set(upperLeft, lowerRight);                /**initialize magnets */                var magnets = svgDocument.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_ORYX, "magnets");                if (magnets && magnets.length > 0) {                    magnets = $A(magnets[0].getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_ORYX, "magnet"));                        var me = this;            magnets.each(function(magnetElem){                var magnet = new ORYX.Core.Controls.Magnet({                    eventHandlerCallback: me.eventHandlerCallback                });                var cx = parseFloat(magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cx"));                var cy = parseFloat(magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cy"));                magnet.bounds.centerMoveTo({                    x: cx - offsetX,                    y: cy - offsetY                });                                //get anchors                var anchors = magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "anchors");                if (anchors) {                    anchors = anchors.replace("/,/g", " ");                    anchors = anchors.split(" ").without("");                    for(var i = 0; i < anchors.length; i++) {						switch(anchors[i].toLowerCase()) {							case "left":								magnet.anchorLeft = true;								break;							case "right":								magnet.anchorRight = true;								break;							case "top":								magnet.anchorTop = true;								break;							case "bottom":								magnet.anchorBottom = true;								break;						}					}                }                                me.add(magnet);                                //check, if magnet is default magnet                if (!this._defaultMagnet) {                    var defaultAttr = magnetElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "default");                    if (defaultAttr && defaultAttr.toLowerCase() === "yes") {                        me._defaultMagnet = magnet;                    }                }            });        }        else {            // Add a Magnet in the Center of Shape			            var magnet = new ORYX.Core.Controls.Magnet();            magnet.bounds.centerMoveTo(this.bounds.width() / 2, this.bounds.height() / 2);            this.add(magnet);        }                /**initialize docker */        var dockerElem = svgDocument.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_ORYX, "docker");                if (dockerElem && dockerElem.length > 0) {            dockerElem = dockerElem[0];            var docker = this.createDocker();            var cx = parseFloat(dockerElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cx"));            var cy = parseFloat(dockerElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "cy"));            docker.bounds.centerMoveTo({                x: cx - offsetX,                y: cy - offsetY            });                        //get anchors            var anchors = dockerElem.getAttributeNS(ORYX.CONFIG.NAMESPACE_ORYX, "anchors");            if (anchors) {                anchors = anchors.replace("/,/g", " ");                anchors = anchors.split(" ").without("");                				for(var i = 0; i < anchors.length; i++) {					switch(anchors[i].toLowerCase()) {						case "left":							docker.anchorLeft = true;							break;						case "right":							docker.anchorRight = true;							break;						case "top":							docker.anchorTop = true;							break;						case "bottom":							docker.anchorBottom = true;							break;					}				}            }        }                /**initialize labels*/        var textElems = svgNode.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'text');        $A(textElems).each((function(textElem){            var label = new ORYX.Core.SVG.Label({                textElement: textElem,				shapeId: this.id            });            label.x -= offsetX;            label.y -= offsetY;            this._labels[label.id] = label;        }).bind(this));    },		/**	 * Override the Method, that a docker is not shown	 *	 */	createDocker: function() {		var docker = new ORYX.Core.Controls.Docker({eventHandlerCallback: this.eventHandlerCallback});		docker.bounds.registerCallback(this._dockerChangedCallback);				this.dockers.push( docker );		docker.parent = this;		docker.bounds.registerCallback(this._changedCallback);						return docker			},	        toString: function(){        return this._stencil.title() + " " + this.id    }};ORYX.Core.Node = ORYX.Core.Shape.extend(ORYX.Core.Node);/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/NAMESPACE_SVG = "http://www.w3.org/2000/svg";NAMESPACE_ORYX = "http://www.b3mn.org/oryx";/** * Init namespaces */if (!ORYX) {    var ORYX = {};}if (!ORYX.Core) {    ORYX.Core = {};}/** * @classDescription Abstract base class for all connections. * @extends {ORYX.Core.Shape} * @param options {Object} * * TODO da die verschiebung der Edge nicht ueber eine *  translation gemacht wird, die sich auch auf alle kind UIObjects auswirkt, *  muessen die kinder hier beim verschieben speziell betrachtet werden. *  Das sollte ueberarbeitet werden. * */ORYX.Core.Edge = {    /**     * Constructor     * @param {Object} options     * @param {Stencil} stencil     */    construct: function(options, stencil){        arguments.callee.$.construct.apply(this, arguments);                this.isMovable = true;        this.isSelectable = true;        this._dockerUpdated = false;                this._markers = new Hash(); //a hash map of SVGMarker objects where keys are the marker ids        this._paths = [];        this._interactionPaths = [];        this._dockersByPath = new Hash();        this._markersByPath = new Hash();				/* Data structures to store positioning information of attached child nodes */ 		this.attachedNodePositionData = new Hash();                //TODO was muss hier initial erzeugt werden?        var stencilNode = this.node.childNodes[0].childNodes[0];        stencilNode = ORYX.Editor.graft("http://www.w3.org/2000/svg", stencilNode, ['g', {            "pointer-events": "painted"        }]);                //Add to the EventHandler        this.addEventHandlers(stencilNode);                        this._oldBounds = this.bounds.clone();                //load stencil        this._init(this._stencil.view());                if (stencil instanceof Array) {            this.deserialize(stencil);        }            },        _update: function(force){		if(this._dockerUpdated || this.isChanged || force) {						this.dockers.invoke("update");				        if (this.bounds.width() === 0 || this.bounds.height() === 0) {	        	            this.bounds.moveBy({	                x: this.bounds.width() === 0 ? -1 : 0,	                y: this.bounds.height() === 0 ? -1 : 0	            });	            	            this.bounds.extend({	                x: this.bounds.width() === 0 ? 2 : 0,	                y: this.bounds.height() === 0 ? 2 : 0	            });	            	        }	        	        // TODO: Bounds muss abhaengig des Eltern-Shapes gesetzt werden	        var upL = this.bounds.upperLeft();	        var oldUpL = this._oldBounds.upperLeft();	        var oldWidth = this._oldBounds.width() === 0 ? this.bounds.width() : this._oldBounds.width();	        var oldHeight = this._oldBounds.height() === 0 ? this.bounds.height() : this._oldBounds.height();	        var diffX = upL.x - oldUpL.x;	        var diffY = upL.y - oldUpL.y;	        var diffWidth = this.bounds.width() / oldWidth;	        var diffHeight = this.bounds.height() / oldHeight;	        	        this.dockers.each((function(docker){	            // Unregister on BoundsChangedCallback	            docker.bounds.unregisterCallback(this._dockerChangedCallback);	            	            // If there is any changes at the edge and is there is not an DockersUpdate	            // set the new bounds to the docker	            if (!this._dockerUpdated) {	                docker.bounds.moveBy(diffX, diffY);	                	                if (diffWidth !== 1 || diffHeight !== 1) {	                    var relX = docker.bounds.upperLeft().x - upL.x;	                    var relY = docker.bounds.upperLeft().y - upL.y;	                    	                    docker.bounds.moveTo(upL.x + relX * diffWidth, upL.y + relY * diffHeight);	                }	            }	            // Do Docker update and register on DockersBoundChange	            docker.update();	            docker.bounds.registerCallback(this._dockerChangedCallback);	            	        }).bind(this));	        	        if (this._dockerUpdated) {	            var a = this.dockers.first().bounds.center();	            var b = this.dockers.first().bounds.center();	            	            this.dockers.each((function(docker){	                var center = docker.bounds.center();	                a.x = Math.min(a.x, center.x);	                a.y = Math.min(a.y, center.y);	                b.x = Math.max(b.x, center.x);	                b.y = Math.max(b.y, center.y);	            }).bind(this));	            	            //set the bounds of the the association	            this.bounds.set(Object.clone(a), Object.clone(b));	        }						//reposition labels			this.getLabels().each(function(label) {				switch (label.edgePosition) {					case "freeMoved" :			        	label.x=label.x;			        	label.y=label.y;				        	break;					case "starttop":						var angle = this._getAngle(this.dockers[0], this.dockers[1]);						var pos = this.dockers.first().bounds.center();												if (angle <= 90 || angle > 270) {							label.horizontalAlign("left");							label.verticalAlign("bottom");							label.x = pos.x + label.getOffsetTop();							label.y = pos.y - label.getOffsetTop();							label.rotate(360 - angle, pos);						} else {							label.horizontalAlign("right");							label.verticalAlign("bottom");							label.x = pos.x - label.getOffsetTop();							label.y = pos.y - label.getOffsetTop();							label.rotate(180 - angle, pos);						}												break;					case "startbottom":						var angle = this._getAngle(this.dockers[0], this.dockers[1]);						var pos = this.dockers.first().bounds.center();												if (angle <= 90 || angle > 270) {							label.horizontalAlign("left");							label.verticalAlign("top");							label.x = pos.x + label.getOffsetBottom();							label.y = pos.y + label.getOffsetBottom();							label.rotate(360 - angle, pos);						} else {							label.horizontalAlign("right");							label.verticalAlign("top");							label.x = pos.x - label.getOffsetBottom();							label.y = pos.y + label.getOffsetBottom();							label.rotate(180 - angle, pos);						}												break;					case "midtop":						var numOfDockers = this.dockers.length;						if(numOfDockers%2 == 0) {							var angle = this._getAngle(this.dockers[numOfDockers/2-1], this.dockers[numOfDockers/2])							var pos1 = this.dockers[numOfDockers/2-1].bounds.center();							var pos2 = this.dockers[numOfDockers/2].bounds.center();							var pos = {x:(pos1.x + pos2.x)/2.0, y:(pos1.y+pos2.y)/2.0};														label.horizontalAlign("center");							label.verticalAlign("bottom");							label.x = pos.x;							label.y = pos.y - label.getOffsetTop();															if (angle <= 90 || angle > 270) {								label.rotate(360 - angle, pos);							} else {								label.rotate(180 - angle, pos);							}						} else {							var index = parseInt(numOfDockers/2);							var angle = this._getAngle(this.dockers[index], this.dockers[index+1])							var pos = this.dockers[index].bounds.center();														if (angle <= 90 || angle > 270) {								label.horizontalAlign("left");								label.verticalAlign("bottom");								label.x = pos.x + label.getOffsetTop();								label.y = pos.y - label.getOffsetTop();								label.rotate(360 - angle, pos);							} else {								label.horizontalAlign("right");								label.verticalAlign("bottom");								label.x = pos.x - label.getOffsetTop();								label.y = pos.y - label.getOffsetTop();								label.rotate(180 - angle, pos);							}						}												break;					case "midbottom":						var numOfDockers = this.dockers.length;						if(numOfDockers%2 == 0) {							var angle = this._getAngle(this.dockers[numOfDockers/2-1], this.dockers[numOfDockers/2])							var pos1 = this.dockers[numOfDockers/2-1].bounds.center();							var pos2 = this.dockers[numOfDockers/2].bounds.center();							var pos = {x:(pos1.x + pos2.x)/2.0, y:(pos1.y+pos2.y)/2.0};														label.horizontalAlign("center");							label.verticalAlign("top");							label.x = pos.x;							label.y = pos.y + label.getOffsetTop();														if (angle <= 90 || angle > 270) {								label.rotate(360 - angle, pos);							} else {								label.rotate(180 - angle, pos);							}						} else {							var index = parseInt(numOfDockers/2);							var angle = this._getAngle(this.dockers[index], this.dockers[index+1])							var pos = this.dockers[index].bounds.center();														if (angle <= 90 || angle > 270) {								label.horizontalAlign("left");								label.verticalAlign("top");								label.x = pos.x + label.getOffsetBottom();								label.y = pos.y + label.getOffsetBottom();								label.rotate(360 - angle, pos);							} else {								label.horizontalAlign("right");								label.verticalAlign("top");								label.x = pos.x - label.getOffsetBottom();								label.y = pos.y + label.getOffsetBottom();								label.rotate(180 - angle, pos);							}						}												break;					case "endtop":						var length = this.dockers.length;						var angle = this._getAngle(this.dockers[length-2], this.dockers[length-1]);						var pos = this.dockers.last().bounds.center();												if (angle <= 90 || angle > 270) {							label.horizontalAlign("right");							label.verticalAlign("bottom");							label.x = pos.x - label.getOffsetTop();							label.y = pos.y - label.getOffsetTop();							label.rotate(360 - angle, pos);						} else {							label.horizontalAlign("left");							label.verticalAlign("bottom");							label.x = pos.x + label.getOffsetTop();							label.y = pos.y - label.getOffsetTop();							label.rotate(180 - angle, pos);						}												break;					case "endbottom":						var length = this.dockers.length;						var angle = this._getAngle(this.dockers[length-2], this.dockers[length-1]);						var pos = this.dockers.last().bounds.center();												if (angle <= 90 || angle > 270) {							label.horizontalAlign("right");							label.verticalAlign("top");							label.x = pos.x - label.getOffsetBottom();							label.y = pos.y + label.getOffsetBottom();							label.rotate(360 - angle, pos);						} else {							label.horizontalAlign("left");							label.verticalAlign("top");							label.x = pos.x + label.getOffsetBottom();							label.y = pos.y + label.getOffsetBottom();							label.rotate(180 - angle, pos);						}												break;			}			}.bind(this));			this.children.each(function(value) {				if(value instanceof ORYX.Core.Node) {					this.calculatePositionOfAttachedChildNode.call(this, value);				}			}.bind(this));						this.refreshAttachedNodes();			this.refresh();						this.isChanged = false;			this._dockerUpdated = false;						this._oldBounds = this.bounds.clone();        }		    },		/**	 *  Moves a point to the upperLeft of a node's bounds.	 *  	 *  @param {point} point	 *  	The point to move	 *  @param {ORYX.Core.Bounds} bounds	 *  	The Bounds of the related noe	 */	movePointToUpperLeftOfNode: function(point, bounds) {		point.x -= bounds.width()/2;		point.y -= bounds.height()/2;	},		/**	 * Refreshes the visual representation of edge's attached nodes.	 */		refreshAttachedNodes: function() {		this.attachedNodePositionData.values().each(function(nodeData) {			var startPoint = nodeData.segment.docker1.bounds.center();			var endPoint = nodeData.segment.docker2.bounds.center();			this.relativizePoint(startPoint);			this.relativizePoint(endPoint);						var newNodePosition = new Object();						/* Calculate new x-coordinate */			newNodePosition.x = startPoint.x 								+ nodeData.relativDistanceFromDocker1									* (endPoint.x - startPoint.x);						/* Calculate new y-coordinate */			newNodePosition.y = startPoint.y 								+ nodeData.relativDistanceFromDocker1									* (endPoint.y - startPoint.y);						/* Convert new position to the upper left of the node */			this.movePointToUpperLeftOfNode(newNodePosition, nodeData.node.bounds);						/* Move node to its new position */			nodeData.node.bounds.moveTo(newNodePosition);			nodeData.node._update();										}.bind(this));	},		/**	 * Calculates the position of an edge's child node. The node is placed on 	 * the path of the edge.	 * 	 * @param {node}	 * 		The node to calculate the new position	 * @return {Point}	 * 		The calculated upper left point of the node's shape.	 */	calculatePositionOfAttachedChildNode: function(node) {		/* Initialize position */		var position = new Object();		position.x = 0;		position.y = 0;				/* Case: Node was just added */		if(!this.attachedNodePositionData[node.getId()]) {			this.attachedNodePositionData[node.getId()] = new Object();			this.attachedNodePositionData[node.getId()]					.relativDistanceFromDocker1 = 0;			this.attachedNodePositionData[node.getId()].node = node;			this.attachedNodePositionData[node.getId()].segment = new Object();			this.findEdgeSegmentForNode(node);		}else if(node.isChanged) {			this.findEdgeSegmentForNode(node);		}							},		/**	 * Finds the appropriate edge segement for a node.	 * The segment is choosen, which has the smallest distance to the node.	 * 	 * @param {ORYX.Core.Node} node	 * 		The concerning node	 */	findEdgeSegmentForNode: function(node) {		var length = this.dockers.length;		var smallestDistance = undefined;				for(i=1;i<length;i++) {			var lineP1 = this.dockers[i-1].bounds.center();			var lineP2 = this.dockers[i].bounds.center();			this.relativizePoint(lineP1);			this.relativizePoint(lineP2);			//position übergeben hier			var nodeCenterPoint = node.bounds.center();			var distance = ORYX.Core.Math.distancePointLinie(															lineP1,															lineP2, 															nodeCenterPoint, 															true);						if((distance || distance == 0) && ((!smallestDistance && smallestDistance != 0) 						|| distance < smallestDistance)) {								smallestDistance = distance;								this.attachedNodePositionData[node.getId()].segment.docker1 = 													this.dockers[i-1];				this.attachedNodePositionData[node.getId()].segment.docker2 = 													this.dockers[i];				}						/* Either the distance does not match the segment or the distance			 * between docker1 and docker2 is 0			 * 			 * In this case choose the nearest docker as attaching point.			 * 			 */			if(!distance && !smallestDistance && smallestDistance != 0) {				(ORYX.Core.Math.getDistancePointToPoint(nodeCenterPoint, lineP1)					< ORYX.Core.Math.getDistancePointToPoint(nodeCenterPoint, lineP2)) ?					this.attachedNodePositionData[node.getId()].relativDistanceFromDocker1 = 0 :					this.attachedNodePositionData[node.getId()].relativDistanceFromDocker1 = 1;				this.attachedNodePositionData[node.getId()].segment.docker1 = 													this.dockers[i-1];				this.attachedNodePositionData[node.getId()].segment.docker2 = 													this.dockers[i];			}		}				/* Calculate position on edge segment for the node */		if(smallestDistance || smallestDistance == 0) {			this.attachedNodePositionData[node.getId()].relativDistanceFromDocker1 =			this.getLineParameterForPosition(					this.attachedNodePositionData[node.getId()].segment.docker1,					this.attachedNodePositionData[node.getId()].segment.docker2,					node);		}	},		/**	 * Returns the value of the scalar to determine the position of the node on 	 * line defined by docker1 and docker2.	 * 	 * @param {point} docker1	 * 		The docker that defines the start of the line segment	 * @param {point} docker2	 * 		The docker that defines the end of the line segment	 * @param {ORYX.Core.Node} node	 * 		The concerning node	 * 	 * @return {float} positionParameter	 * 		The scalar value to determine the position on the line	 */	getLineParameterForPosition: function(docker1, docker2, node) {		var dockerPoint1 = docker1.bounds.center();		var dockerPoint2 = docker2.bounds.center();		this.relativizePoint(dockerPoint1);		this.relativizePoint(dockerPoint2);				var intersectionPoint = ORYX.Core.Math.getPointOfIntersectionPointLine(									dockerPoint1,									dockerPoint2,									node.bounds.center(), true);		if(!intersectionPoint) {			return 0;		}				var relativeDistance = 			ORYX.Core.Math.getDistancePointToPoint(intersectionPoint, dockerPoint1) /			ORYX.Core.Math.getDistancePointToPoint(dockerPoint1, dockerPoint2);				return relativeDistance;	},	/**	 * Makes point relative to the upper left of the edge's bound.	 * 	 * @param {point} point	 * 		The point to relativize	 */	relativizePoint: function(point) {		point.x -= this.bounds.upperLeft().x;		point.y -= this.bounds.upperLeft().y;			},        refresh: function(){        //call base class refresh method        arguments.callee.$.refresh.apply(this, arguments);                //TODO consider points for marker mids        var lastPoint;        this._paths.each((function(path, index){            var dockers = this._dockersByPath[path.id];            var c = undefined;			var d = undefined;            if (lastPoint) {                d = "M" + lastPoint.x + " " + lastPoint.y;            }            else {                c = dockers[0].bounds.center();                lastPoint = c;                                d = "M" + c.x + " " + c.y;            }                        for (var i = 1; i < dockers.length; i++) {                // for each docker, draw a line to the center                c = dockers[i].bounds.center();                d = d + "L" + c.x + " " + c.y + " ";                lastPoint = c;            }                        path.setAttributeNS(null, "d", d);            this._interactionPaths[index].setAttributeNS(null, "d", d);                    }).bind(this));						/* move child shapes of an edge */		if(this.getChildNodes().length > 0) {	        var x = this.bounds.upperLeft().x;	        var y = this.bounds.upperLeft().y;	        			this.node.firstChild.childNodes[1].setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")");		}		    },        /**     * Calculate the Border Intersection Point between two points     * @param {PointA}     * @param {PointB}     */    getIntersectionPoint: function(){            var length = Math.floor(this.dockers.length / 2)                return ORYX.Core.Math.midPoint(this.dockers[length - 1].bounds.center(), this.dockers[length].bounds.center())    },            /**     * Calculate if the point is inside the Shape     * @param {PointX}     * @param {PointY}      */    isPointIncluded: function(pointX, pointY){            var isbetweenAB = this.absoluteBounds().isIncluded(pointX, pointY, 												ORYX.CONFIG.OFFSET_EDGE_BOUNDS);        		var isPointIncluded = undefined;		        if (isbetweenAB && this.dockers.length > 0) {					var i = 0;			var point1, point2;									do {							point1 = this.dockers[i].bounds.center();				point2 = this.dockers[++i].bounds.center();								isPointIncluded = ORYX.Core.Math.isPointInLine(pointX, pointY, 											point1.x, point1.y, 											point2.x, point2.y, 											ORYX.CONFIG.OFFSET_EDGE_BOUNDS);							} while (!isPointIncluded && i < this.dockers.length - 1)					}				return isPointIncluded;    },          /**     * Calculate if the point is over an special offset area     * @param {Point}     */    isPointOverOffset: function(){		return  false	},		/**	* Returns the angle of the line between two dockers	* (0 - 359.99999999)	*/	_getAngle: function(docker1, docker2) {		var p1 = docker1.absoluteCenterXY();		var p2 = docker2.absoluteCenterXY();				if(p1.x == p2.x && p1.y == p2.y)			return 0;		var angle = Math.asin(Math.sqrt(Math.pow(p1.y-p2.y, 2))					/(Math.sqrt(Math.pow(p2.x-p1.x, 2)+Math.pow(p1.y-p2.y, 2))))					*180/Math.PI;				if(p2.x >= p1.x && p2.y <= p1.y)			return angle;		else if(p2.x < p1.x && p2.y <= p1.y)			return 180 - angle;		else if(p2.x < p1.x && p2.y > p1.y)			return 180 + angle;		else			return 360 - angle;	},	        alignDockers: function(){        this._update(true);                var firstPoint = this.dockers.first().bounds.center();        var lastPoint = this.dockers.last().bounds.center();                var deltaX = lastPoint.x - firstPoint.x;        var deltaY = lastPoint.y - firstPoint.y;                var numOfDockers = this.dockers.length - 1;                this.dockers.each((function(docker, index){            var part = index / numOfDockers;            docker.bounds.unregisterCallback(this._dockerChangedCallback);            docker.bounds.moveTo(firstPoint.x + part * deltaX, firstPoint.y + part * deltaY);            docker.bounds.registerCallback(this._dockerChangedCallback);        }).bind(this));                this._dockerChanged();    },    	add: function(shape){        arguments.callee.$.add.apply(this, arguments);				// If the new shape is a Docker which is not contained		if (shape instanceof ORYX.Core.Controls.Docker && this.dockers.include(shape)){			// Add it to the dockers list ordered by paths					var pathArray = this._dockersByPath.values()[0];			if (pathArray) {				pathArray.splice(this.dockers.indexOf(shape), 0, shape);			}						/* Perform nessary adjustments on the edge's child shapes */			this.handleChildShapesAfterAddDocker(shape);		}	},		/**	 * Performs nessary adjustments on the edge's child shapes.	 * 	 * @param {ORYX.Core.Controls.Docker} docker	 * 		The added docker	 */	handleChildShapesAfterAddDocker: function(docker) {		/* Ensure type of Docker */		if(!docker instanceof ORYX.Core.Controls.Docker) {return undefined;}				var index = this.dockers.indexOf(docker);		if(!(0 < index && index < this.dockers.length - 1)) {		/* Exception: Expect added docker between first and last node of the edge */			return undefined;		} 					/* Get child nodes concerning the segment of the new docker */		var startDocker = this.dockers[index-1];		var endDocker = this.dockers[index+1];				/* Adjust the position of edge's child nodes */		var segmentElements = 			this.getAttachedNodePositionDataForSegment(startDocker, endDocker);				var lengthSegmentPart1 = ORYX.Core.Math.getDistancePointToPoint(										startDocker.bounds.center(),										docker.bounds.center());		var lengthSegmentPart2 = ORYX.Core.Math.getDistancePointToPoint(										endDocker.bounds.center(),										docker.bounds.center());												if(!(lengthSegmentPart1 + lengthSegmentPart2)) {return;}				var relativDockerPosition = lengthSegmentPart1 / (lengthSegmentPart1 + lengthSegmentPart2);					segmentElements.each(function(nodePositionData) {			/* Assign child node to the new segment */			if(nodePositionData.value.relativDistanceFromDocker1 < relativDockerPosition) {				/* Case: before added Docker */				nodePositionData.value.segment.docker2 = docker;				nodePositionData.value.relativDistanceFromDocker1 = 					nodePositionData.value.relativDistanceFromDocker1 / relativDockerPosition;			} else {				/* Case: after added Docker */				nodePositionData.value.segment.docker1 = docker;				var newFullDistance = 1 - relativDockerPosition;				var relativPartOfSegment = 							nodePositionData.value.relativDistanceFromDocker1							- relativDockerPosition;								nodePositionData.value.relativDistanceFromDocker1 = 										relativPartOfSegment / newFullDistance;							}		})				/* Update attached nodes visual representation */		this.refreshAttachedNodes();	},		/**	 *	Returns elements from {@link attachedNodePositiondata} that match the	 *  segement defined by startDocker and endDocker.	 *  	 *  @param {ORYX.Core.Controls.Docker} startDocker	 *  	The docker defining the begin of the segment.	 *  @param {ORYX.Core.Controls.Docker} endDocker	 *  	The docker defining the begin of the segment.	 *  	 *  @return {Hash} attachedNodePositionData	 *  	Child elements matching the segment	 */	getAttachedNodePositionDataForSegment: function(startDocker, endDocker) {		/* Ensure that the segment is defined correctly */		if(!((startDocker instanceof ORYX.Core.Controls.Docker) 			&& (endDocker instanceof ORYX.Core.Controls.Docker))) {				return [];			}					/* Get elements of the segment */		var elementsOfSegment = 			this.attachedNodePositionData.findAll(function(nodePositionData) {				return nodePositionData.value.segment.docker1 === startDocker &&						nodePositionData.value.segment.docker2 === endDocker;			});				/* Return a Hash in each case */		if(!elementsOfSegment) {return [];}				return elementsOfSegment;	},		/**	 * Removes an edge's child shape	 */	remove: function(shape) {		arguments.callee.$.remove.apply(this, arguments);				if(this.attachedNodePositionData[shape.getId()]) {			delete this.attachedNodePositionData[shape.getId()];		}				/* Adjust child shapes if neccessary */		if(shape instanceof ORYX.Core.Controls.Docker) {			this.handleChildShapesAfterRemoveDocker(shape);		}	},		/**	 * 	Adjusts the child shapes of an edges after a docker was removed.	 * 		 *  @param{ORYX.Core.Controls.Docker} docker	 *  	The removed docker.	 */	handleChildShapesAfterRemoveDocker: function(docker) {		/* Ensure docker type */		if(!(docker instanceof ORYX.Core.Controls.Docker)) {return;}				this.attachedNodePositionData.each(function(nodePositionData) {			if(nodePositionData.value.segment.docker1 === docker) {				/* The new start of the segment is the predecessor of docker2. */				var index = this.dockers.indexOf(nodePositionData.value.segment.docker2);				if(index == -1) {return;}				nodePositionData.value.segment.docker1 = this.dockers[index - 1];			} 			else if(nodePositionData.value.segment.docker2 === docker) {				/* The new end of the segment is the successor of docker1. */				var index = this.dockers.indexOf(nodePositionData.value.segment.docker1);				if(index == -1) {return;}				nodePositionData.value.segment.docker2 = this.dockers[index + 1];			}		}.bind(this));				/* Update attached nodes visual representation */		this.refreshAttachedNodes();	},		/**     *@deprecated Use the .createDocker() Method and set the point via the bounds     */    addDocker: function(position, exDocker){        var lastDocker;		var result;        this._dockersByPath.any((function(pair){            return pair.value.any((function(docker, index){                if (!lastDocker) {                    lastDocker = docker;                    return false;                }                else {                    var point1 = lastDocker.bounds.center();                    var point2 = docker.bounds.center();                                        if (ORYX.Core.Math.isPointInLine(position.x, position.y, point1.x, point1.y, point2.x, point2.y, 10)) {                        var path = this._paths.find(function(path){                            return path.id === pair.key;                        });                        if (path) {                            var allowAttr = path.getAttributeNS(NAMESPACE_ORYX, 'allowDockers');                            if (allowAttr && allowAttr.toLowerCase() === "no") {                                return true;                            }                        }                        var newDocker = (exDocker) ? exDocker : this.createDocker(this.dockers.indexOf(lastDocker) + 1, position);						newDocker.bounds.centerMoveTo(position);                        if(exDocker)							this.add(newDocker, this.dockers.indexOf(lastDocker) + 1);                        // Remove new Docker from 'to add' dockers						//pair.value = pair.value.without(newDocker);						//pair.value.splice(this.dockers.indexOf(lastDocker) + 1, 0, newDocker);						// Remove the Docker from the Docker list and add the Docker to the new position                        //this.dockers = this.dockers.without(newDocker);                        //this.dockers.splice(this.dockers.indexOf(lastDocker) + 1, 0, newDocker);                        //this._update(true);						result = newDocker;                        return true;                    }                    else {                        lastDocker = docker;                        return false;                    }                }            }).bind(this));        }).bind(this));		return result;    },        removeDocker: function(docker){        if (this.dockers.length > 2 && !(this.dockers.first() === docker)) {            this._dockersByPath.any((function(pair){                if (pair.value.member(docker)) {                    if (docker === pair.value.last()) {                        return true;                    }                    else {                        this.remove(docker);                        this._dockersByPath[pair.key] = pair.value.without(docker);                        this.isChanged = true;                        this._dockerChanged();                        return true;                    }                }                return false;            }).bind(this));        }    },		/**	 * Removes all dockers from the edge which are on 	 * the line between two dockers	 * @return {Object} Removed dockers in an indicied array 	 * (key is the removed position of the docker, value is docker themselve)	 */	removeUnusedDockers:function(){		var marked = $H({});				this.dockers.each(function(docker, i){			if (i==0||i==this.dockers.length-1){ return }			var previous = this.dockers[i-1];						/* Do not consider already removed dockers */			if(marked.values().indexOf(previous) != -1 && this.dockers[i-2]) {				previous = this.dockers[i-2];			}			var next = this.dockers[i+1];						var cp = previous.getDockedShape() && previous.referencePoint ? previous.getAbsoluteReferencePoint() : previous.bounds.center();			var cn = next.getDockedShape() && next.referencePoint ? next.getAbsoluteReferencePoint() : next.bounds.center();			var cd = docker.bounds.center();						if (ORYX.Core.Math.isPointInLine(cd.x, cd.y, cp.x, cp.y, cn.x, cn.y, 1)){				marked[i] = docker;			}		}.bind(this))				marked.each(function(docker){			this.removeDocker(docker.value);		}.bind(this))				if (marked.values().length > 0){			this._update(true);		}				return marked;	},        /**     * Initializes the Edge after loading the SVG representation of the edge.     * @param {SVGDocument} svgDocument     */    _init: function(svgDocument){        arguments.callee.$._init.apply(this, arguments);                var minPointX, minPointY, maxPointX, maxPointY;                //init markers        var defs = svgDocument.getElementsByTagNameNS(NAMESPACE_SVG, "defs");        if (defs.length > 0) {            defs = defs[0];            var markerElements = $A(defs.getElementsByTagNameNS(NAMESPACE_SVG, "marker"));            var marker;            var me = this;            markerElements.each(function(markerElement){                try {                    marker = new ORYX.Core.SVG.SVGMarker(markerElement.cloneNode(true));                    me._markers[marker.id] = marker;                    var textElements = $A(marker.element.getElementsByTagNameNS(NAMESPACE_SVG, "text"));                    var label;                    textElements.each(function(textElement){                        label = new ORYX.Core.SVG.Label({                            textElement: textElement,							shapeId: this.id                        });                        me._labels[label.id] = label;                    });                }                 catch (e) {                }            });        }                        var gs = svgDocument.getElementsByTagNameNS(NAMESPACE_SVG, "g");        if (gs.length <= 0) {            throw "Edge: No g element found.";        }        var g = gs[0];                        g.setAttributeNS(null, "id", null);                var isFirst = true;                $A(g.childNodes).each((function(path, index){            if (ORYX.Editor.checkClassType(path, SVGPathElement)) {                path = path.cloneNode(false);                                var pathId = this.id + "_" + index;                path.setAttributeNS(null, "id", pathId);                this._paths.push(path);                                //check, if markers are set and update the id                var markersByThisPath = [];                var markerUrl = path.getAttributeNS(null, "marker-start");                                if (markerUrl && markerUrl !== "") {                    markerUrl = markerUrl.strip();                    markerUrl = markerUrl.replace(/^url\(#/, '');                    var markerStartId = this.id.concat(markerUrl.replace(/\)$/, ''));                    path.setAttributeNS(null, "marker-start", "url(#" + markerStartId + ")");                                        markersByThisPath.push(this._markers[markerStartId]);                }                                markerUrl = path.getAttributeNS(null, "marker-mid");                                if (markerUrl && markerUrl !== "") {                    markerUrl = markerUrl.strip();                    markerUrl = markerUrl.replace(/^url\(#/, '');                    var markerMidId = this.id.concat(markerUrl.replace(/\)$/, ''));                    path.setAttributeNS(null, "marker-mid", "url(#" + markerMidId + ")");                                        markersByThisPath.push(this._markers[markerMidId]);                }                                markerUrl = path.getAttributeNS(null, "marker-end");                                if (markerUrl && markerUrl !== "") {                    markerUrl = markerUrl.strip();                    markerUrl = markerUrl.replace(/^url\(#/, '');                    var markerEndId = this.id.concat(markerUrl.replace(/\)$/, ''));                    path.setAttributeNS(null, "marker-end", "url(#" + markerEndId + ")");                                        markersByThisPath.push(this._markers[markerEndId]);                }                                this._markersByPath[pathId] = markersByThisPath;                                //init dockers                var parser = new PathParser();                var handler = new ORYX.Core.SVG.PointsPathHandler();                parser.setHandler(handler);                parser.parsePath(path);                                if (handler.points.length < 4) {                    throw "Edge: Path has to have two or more points specified.";                }                                this._dockersByPath[pathId] = [];                				for (var i = 0; i < handler.points.length; i += 2) {					//handler.points.each((function(point, pIndex){					var x = handler.points[i];					var y = handler.points[i+1];					if (isFirst || i > 0) {						var docker = new ORYX.Core.Controls.Docker({							eventHandlerCallback: this.eventHandlerCallback						});						docker.bounds.centerMoveTo(x,y);						docker.bounds.registerCallback(this._dockerChangedCallback);						this.add(docker, this.dockers.length);												//this._dockersByPath[pathId].push(docker);												//calculate minPoint and maxPoint						if (minPointX) {							minPointX = Math.min(x, minPointX);							minPointY = Math.min(y, minPointY);						}						else {							minPointX = x;							minPointY = y;						}												if (maxPointX) {							maxPointX = Math.max(x, maxPointX);							maxPointY = Math.max(y, maxPointY);						}						else {							maxPointX = x;							maxPointY = y;						}					}					//}).bind(this));				}                isFirst = false;            }        }).bind(this));                this.bounds.set(minPointX, minPointY, maxPointX, maxPointY);                if (this.bounds.width() === 0 || this.bounds.height() === 0) {            this.bounds.extend({                x: this.bounds.width() === 0 ? 2 : 0,                y: this.bounds.height() === 0 ? 2 : 0            });                        this.bounds.moveBy({                x: this.bounds.width() === 0 ? -1 : 0,                y: this.bounds.height() === 0 ? -1 : 0            });                    }                this._oldBounds = this.bounds.clone();                //add paths to this.node        this._paths.reverse();        var paths = [];        this._paths.each((function(path){            paths.push(this.node.childNodes[0].childNodes[0].childNodes[0].appendChild(path));        }).bind(this));                this._paths = paths;                //init interaction path        this._paths.each((function(path){            var iPath = path.cloneNode(false);			iPath.setAttributeNS(null, "id", undefined);            iPath.setAttributeNS(null, "stroke-width", 10);            iPath.setAttributeNS(null, "visibility", "hidden");            iPath.setAttributeNS(null, "stroke-dasharray", null);            iPath.setAttributeNS(null, "stroke", "black");            iPath.setAttributeNS(null, "fill", "none");            this._interactionPaths.push(this.node.childNodes[0].childNodes[0].childNodes[0].appendChild(iPath));        }).bind(this));                this._paths.reverse();        this._interactionPaths.reverse();				/**initialize labels*/        var textElems = svgDocument.getElementsByTagNameNS(ORYX.CONFIG.NAMESPACE_SVG, 'text');        		$A(textElems).each((function(textElem){            var label = new ORYX.Core.SVG.Label({                textElement: textElem,				shapeId: this.id            });            this.node.childNodes[0].childNodes[0].appendChild(label.node);            this._labels[label.id] = label;        }).bind(this)); 		        //set title        this.node.childNodes[0].childNodes[0].setAttributeNS(null, "title", this.getStencil().title());                this.propertiesChanged.each(function(pair){            pair.value = true;        });		        //this._update(true);    },        /**     * Adds all necessary markers of this Edge to the SVG document.     * Has to be called, while this.node is part of DOM.     */    addMarkers: function(defs){        this._markers.each(function(marker){            if (!defs.ownerDocument.getElementById(marker.value.id)) {                marker.value.element = defs.appendChild(marker.value.element);            }        });    },        /**     * Removes all necessary markers of this Edge from the SVG document.     * Has to be called, while this.node is part of DOM.     */    removeMarkers: function(){        var svgElement = this.node.ownerSVGElement;        if (svgElement) {            var defs = svgElement.getElementsByTagNameNS(NAMESPACE_SVG, "defs");            if (defs.length > 0) {                defs = defs[0];                this._markers.each(function(marker){                    var foundMarker = defs.ownerDocument.getElementById(marker.value.id);                    if (foundMarker) {                        marker.value.element = defs.removeChild(marker.value.element);                    }                });            }        }    },        /**     * Calls when a docker has changed     */    _dockerChanged: function(){            //this._update(true);		this._dockerUpdated = true;            },        serialize: function(){        var result = arguments.callee.$.serialize.apply(this);                //add dockers triple        var value = "";        this._dockersByPath.each((function(pair){            pair.value.each(function(docker){                var position = docker.getDockedShape() && docker.referencePoint ? docker.referencePoint : docker.bounds.center();                value = value.concat(position.x + " " + position.y + " ");            });                        value += " # ";        }).bind(this));        result.push({            name: 'dockers',            prefix: 'oryx',            value: value,            type: 'literal'        });                //add parent triple dependant on the dockedShapes        //TODO change this when canvas becomes a resource/*        var source = this.dockers.first().getDockedShape();        var target = this.dockers.last().getDockedShape();        var sharedParent;        if (source && target) {            //get shared parent            while (source.parent) {                source = source.parent;                if (source instanceof ORYX.Core.Canvas) {                    sharedParent = source;                    break;                }                else {                    var targetParent = target.parent;                    var found;                    while (targetParent) {                        if (source === targetParent) {                            sharedParent = source;                            found = true;                            break;                        }                        else {                            targetParent = targetParent.parent;                        }                    }                    if (found) {                        break;                    }                }            }        }        else             if (source) {                sharedParent = source.parent;            }            else                 if (target) {                    sharedParent = target.parent;                }*/                //if (sharedParent) {/*            result.push({                name: 'parent',                prefix: 'raziel',                //value: '#' + ERDF.__stripHashes(sharedParent.resourceId),                value: '#' + ERDF.__stripHashes(this.getCanvas().resourceId),                type: 'resource'            });*/        //}				//serialize target and source		var lastDocker = this.dockers.last();				var target = lastDocker.getDockedShape();				if(target) {			result.push({				name: 'target',				prefix: 'raziel',				value: '#' + ERDF.__stripHashes(target.resourceId),				type: 'resource'			});		}                try {            //result = this.getStencil().serialize(this, result);			var serializeEvent = this.getStencil().serialize();						/*			 * call serialize callback by reference, result should be found			 * in serializeEvent.result			 */			if(serializeEvent.type) {				serializeEvent.shape = this;				serializeEvent.data = result;				serializeEvent.result = undefined;				serializeEvent.forceExecution = true;								this._delegateEvent(serializeEvent);								if(serializeEvent.result) {					result = serializeEvent.result;				}			}        }         catch (e) {        }        return result;    },        deserialize: function(data){        try {            //data = this.getStencil().deserialize(this, data);						var deserializeEvent = this.getStencil().deserialize();						/*			 * call serialize callback by reference, result should be found			 * in serializeEventInfo.result			 */			if(deserializeEvent.type) {				deserializeEvent.shape = this;				deserializeEvent.data = data;				deserializeEvent.result = undefined;				deserializeEvent.forceExecution = true;								this._delegateEvent(deserializeEvent);				if(deserializeEvent.result) {					data = deserializeEvent.result;				}			}        }         catch (e) {        }        		// Set the outgoing shapes		var target = data.find(function(ser) {return (ser.prefix+"-"+ser.name) == 'raziel-target'});		var targetShape;		if(target) {			targetShape = this.getCanvas().getChildShapeByResourceId(target.value);		}				var outgoing = data.findAll(function(ser){ return (ser.prefix+"-"+ser.name) == 'raziel-outgoing'});		outgoing.each((function(obj){			// TODO: Look at Canvas			if(!this.parent) {return};											// Set outgoing Shape			var next = this.getCanvas().getChildShapeByResourceId(obj.value);																		if(next){				if(next == targetShape) {					// If this is an edge, set the last docker to the next shape					this.dockers.last().setDockedShape(next);					this.dockers.last().setReferencePoint({x: next.bounds.width() / 2.0, y: next.bounds.height() / 2.0});				} else if(next instanceof ORYX.Core.Edge) {					//Set the first docker of the next shape					next.dockers.first().setDockedShape(this);					//next.dockers.first().setReferencePoint({x: this.bounds.width() / 2.0, y: this.bounds.height() / 2.0});				} /*else if(next.dockers.length > 0) { //next is a node and next has a docker					next.dockers.first().setDockedShape(this);					next.dockers.first().setReferencePoint({x: this.bounds.width() / 2.0, y: this.bounds.height() / 2.0});				}*/			}						}).bind(this));		        arguments.callee.$.deserialize.apply(this, [data]);                var oryxDockers = data.find(function(obj){            return (obj.prefix === "oryx" &&            obj.name === "dockers");        });		        if (oryxDockers) {            var dataByPath = oryxDockers.value.split("#").without("").without(" ");                        dataByPath.each((function(data, index){                var values = data.replace(/,/g, " ").split(" ").without("");                                //for each docker two values must be defined                if (values.length % 2 === 0) {                    var path = this._paths[index];                                        if (path) {                        if (index === 0) {                            while (this._dockersByPath[path.id].length > 2) {                                this.removeDocker(this._dockersByPath[path.id][1]);                            }                        }                        else {                            while (this._dockersByPath[path.id].length > 1) {                                this.removeDocker(this._dockersByPath[path.id][0]);                            }                        }                                                var dockersByPath = this._dockersByPath[path.id];                                                if (index === 0) {                            //set position of first docker                            var x = parseFloat(values.shift());                            var y = parseFloat(values.shift());                                                        if (dockersByPath.first().getDockedShape()) {                                dockersByPath.first().setReferencePoint({                                    x: x,                                    y: y                                });                            }                            else {                                dockersByPath.first().bounds.centerMoveTo(x, y);                            }                        }                                                //set position of last docker                        y = parseFloat(values.pop());                        x = parseFloat(values.pop());                                                if (dockersByPath.last().getDockedShape()) {                            dockersByPath.last().setReferencePoint({                                x: x,                                y: y                            });                        }                        else {                            dockersByPath.last().bounds.centerMoveTo(x, y);                        }                                                //add additional dockers                        for (var i = 0; i < values.length; i++) {                            x = parseFloat(values[i]);                            y = parseFloat(values[++i]);                                                        var newDocker = this.createDocker();                            newDocker.bounds.centerMoveTo(x, y);                                                        //this.dockers = this.dockers.without(newDocker);                            //this.dockers.splice(this.dockers.indexOf(dockersByPath.last()), 0, newDocker);                            //dockersByPath.splice(this.dockers.indexOf(dockersByPath.last()), 0, newDocker);						}                    }                }            }).bind(this));        }        else {            this.alignDockers();        }		this._changed();    },        toString: function(){        return this.getStencil().title() + " " + this.id;    },        /**     * @return {ORYX.Core.Shape} Returns last docked shape or null.     */    getTarget: function(){        return this.dockers.last() ? this.dockers.last().getDockedShape() : null;    },		/**	 * @return {ORYX.Core.Shape} Returns the first docked shape or null	 */	getSource: function() {		return this.dockers.first() ? this.dockers.first().getDockedShape() : null;	},		/**	 * Checks whether the edge is at least docked to one shape.	 * 	 * @return {boolean} True if edge is docked	 */	isDocked: function() {		var isDocked = false;		this.dockers.each(function(docker) {			if(docker.isDocked()) {				isDocked = true;				throw $break;			}		});		return isDocked;	},        /**     * Calls {@link ORYX.Core.AbstractShape#toJSON} and add a some stencil set information.     */    toJSON: function() {        var json = arguments.callee.$.toJSON.apply(this, arguments);                if(this.getTarget()) {            json.target = {                resourceId: this.getTarget().resourceId            };        }                return json;    }};ORYX.Core.Edge = ORYX.Core.Shape.extend(ORYX.Core.Edge);/**
 * Copyright (c) 2006
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * Init namespaces
 */
if(!ORYX) {var ORYX = {};}
if(!ORYX.Core) {ORYX.Core = {};}


/**
 * @classDescription With Bounds you can set and get position and size of UIObjects.
 */
ORYX.Core.Command = Clazz.extend({

	/**
	 * Constructor
	 */
	construct: function() {

	},
	
	execute: function(){
		throw "Command.execute() has to be implemented!"
	},
	
	rollback: function(){
		throw "Command.rollback() has to be implemented!"
	}
	
	
 });/**
 * Copyright (c) 2008
 * Willi Tscheschner
 * 
 **/

if(!ORYX){ var ORYX = {} }
if(!ORYX.Plugins){ ORYX.Plugins = {} }

/**
   This abstract plugin class can be used to build plugins on.
   It provides some more basic functionality like registering events (on*-handlers)...
   @example
    ORYX.Plugins.MyPlugin = ORYX.Plugins.AbstractPlugin.extend({
        construct: function() {
            // Call super class constructor
            arguments.callee.$.construct.apply(this, arguments);
            
            [...]
        },
        [...]
    });
   
   @class ORYX.Plugins.AbstractPlugin
   @constructor Creates a new instance
   @author Willi Tscheschner
*/
ORYX.Plugins.AbstractPlugin = Clazz.extend({
    /** 
     * The facade which offer editor-specific functionality
     * @type Facade
     * @memberOf ORYX.Plugins.AbstractPlugin.prototype
     */
	facade: null,
	
	construct: function( facade ){
		this.facade = facade;
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.onLoaded.bind(this));
	},
        
    /**
       Overwrite to handle load event. TODO: Document params!!!
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
    */
	onLoaded: function(){},
	
    /**
       Overwrite to handle selection changed event. TODO: Document params!!!
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
    */
	onSelectionChanged: function(){},
	
    /**
       Show overlay on given shape.
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
       @example
       showOverlay(
           myShape,
           { stroke: "green" },
           ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
               "title": "Click the element to execute it!",
               "stroke-width": 2.0,
               "stroke": "black",
               "d": "M0,-5 L5,0 L0,5 Z",
               "line-captions": "round"
           }])
       )
       @param {Oryx.XXX.Shape[]} shapes One shape or array of shapes the overlay should be put on
       @param {Oryx.XXX.Attributes} attributes some attributes...
       @param {Oryx.svg.node} svgNode The svg node which should be used as overlay
       @param {String} [svgNode="NW"] The svg node position where the overlay should be placed
    */
	showOverlay: function(shapes, attributes, svgNode, svgNodePosition ){
		
		if( !(shapes instanceof Array) ){
			shapes = [shapes]
		}
		
		// Define Shapes
		shapes = shapes.map(function(shape){
			var el = shape;
			if( typeof shape == "string" ){
				el = this.facade.getCanvas().getChildShapeByResourceId( shape );
				el = el || this.facade.getCanvas().getChildById( shape, true );
			}
			return el;
		}.bind(this)).compact();
		
		// Define unified id
		if( !this.overlayID ){
			this.overlayID = this.type + ORYX.Editor.provideId();
		}
		
		this.facade.raiseEvent({
			type		: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
			id			: this.overlayID,
			shapes		: shapes,
			attributes 	: attributes,
			node		: svgNode,
			nodePosition: svgNodePosition || "NW"
		});
		
	},
	
    /**
       Hide current overlay.
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
    */
	hideOverlay: function(){
		this.facade.raiseEvent({
			type	: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
			id		: this.overlayID
		});		
	},
	
    /**
       Does a transformation with the given xslt stylesheet.
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
       @param {String} data The data (e.g. eRDF) which should be transformed
       @param {String} stylesheet URL of a stylesheet which should be used for transforming data.
    */
	doTransform: function( data, stylesheet ) {		
		
		if( !stylesheet || !data ){
			return ""
		}

        var parser 		= new DOMParser();
        var parsedData 	= parser.parseFromString(data, "text/xml");
		source=stylesheet;
		new Ajax.Request(source, {
			asynchronous: false,
			method: 'get',
			onSuccess: function(transport){
				xsl = transport.responseText
			}.bind(this),
			onFailure: (function(transport){
				ORYX.Log.error("XSL load failed" + transport);
			}).bind(this)
		});
        var xsltProcessor = new XSLTProcessor();
		var domParser = new DOMParser();
		var xslObject = domParser.parseFromString(xsl, "text/xml");
        xsltProcessor.importStylesheet(xslObject);
        
        try {
        	
            var newData 		= xsltProcessor.transformToFragment(parsedData, document);
            var serializedData 	= (new XMLSerializer()).serializeToString(newData);
            
           	/* Firefox 2 to 3 problem?! */
            serializedData = !serializedData.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serializedData : serializedData;
            
            return serializedData;
            
        }catch (error) {
            return -1;
        }
        
	},
	
	/**
	 * Opens a new window that shows the given XML content.
	 * @methodOf ORYX.Plugins.AbstractPlugin.prototype
	 * @param {Object} content The XML content to be shown.
	 * @example
	 * openDownloadWindow( "my.xml", "<exampleXML />" );
	 */
	openXMLWindow: function(content) {
		var win = window.open(
		   'data:application/xml,' + encodeURIComponent(
		     content
		   ),
		   '_blank', "resizable=yes,width=600,height=600,toolbar=0,scrollbars=yes"
		);
	},
	
    /**
     * Opens a download window for downloading the given content.
     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
     * @param {String} filename The content's file name
     * @param {String} content The content to download
     */
	openDownloadWindow: function(filename, content) {
		var win = window.open("");
		if (win != null) {
			win.document.open();
			win.document.write("<html><body>");
			var submitForm = win.document.createElement("form");
			win.document.body.appendChild(submitForm);
			
			var createHiddenElement = function(name, value) {
				var newElement = document.createElement("input");
				newElement.name=name;
				newElement.type="hidden";
				newElement.value = value;
				return newElement
			}
			
			submitForm.appendChild( createHiddenElement("download", content) );
			submitForm.appendChild( createHiddenElement("file", filename) );
			
			
			submitForm.method = "POST";
			win.document.write("</body></html>");
			win.document.close();
			submitForm.action= ORYX.PATH + "/download";
			submitForm.submit();
		}		
	},
    
    /**
     * Serializes DOM.
     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
     * @type {String} Serialized DOM
     */
    getSerializedDOM: function(){
        // Force to set all resource IDs
        var serializedDOM = DataManager.serializeDOM( this.facade );

        //add namespaces
        serializedDOM = '<?xml version="1.0" encoding="utf-8"?>' +
        '<html xmlns="http://www.w3.org/1999/xhtml" ' +
        'xmlns:b3mn="http://b3mn.org/2007/b3mn" ' +
        'xmlns:ext="http://b3mn.org/2007/ext" ' +
        'xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ' +
        'xmlns:atom="http://b3mn.org/2007/atom+xhtml">' +
        '<head profile="http://purl.org/NET/erdf/profile">' +
        '<link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />' +
        '<link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " />' +
        '<link rel="schema.b3mn" href="http://b3mn.org" />' +
        '<link rel="schema.oryx" href="http://oryx-editor.org/" />' +
        '<link rel="schema.raziel" href="http://raziel.org/" />' +
        '<base href="' +
        location.href.split("?")[0] +
        '" />' +
        '</head><body>' +
        serializedDOM +
        '</body></html>';
        
        return serializedDOM;
    },
    
    /**
     * Sets the editor in read only mode: Edges/ dockers cannot be moved anymore,
     * shapes cannot be selected anymore.
     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
     */
    enableReadOnlyMode: function(){
        //Edges cannot be moved anymore
        this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
        
        // Stop the user from editing the diagram while the plugin is active
        this._stopSelectionChange = function(){
            if(this.facade.getSelection().length > 0) {
                this.facade.setSelection([]);
            }
        };
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this._stopSelectionChange.bind(this));
    },
    /**
     * Disables read only mode, see @see
     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
     * @see ORYX.Plugins.AbstractPlugin.prototype.enableReadOnlyMode
     */
    disableReadOnlyMode: function(){
        // Edges can be moved now again
        this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);
        
        if (this._stopSelectionChange) {
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this._stopSelectionChange.bind(this));
            this._stopSelectionChange = undefined;
        }
    },
    
    /**
     * Extracts RDF from DOM.
     * @methodOf ORYX.Plugins.AbstractPlugin.prototype
     * @type {String} Extracted RFD. Null if there are transformation errors.
     */
    getRDFFromDOM: function(){
        //convert to RDF
		try {
			var xsl = "";
			source=ORYX.PATH + "lib/extract-rdf.xsl";
			new Ajax.Request(source, {
				asynchronous: false,
				method: 'get',
				onSuccess: function(transport){
					xsl = transport.responseText
				}.bind(this),
				onFailure: (function(transport){
					ORYX.Log.error("XSL load failed" + transport);
				}).bind(this)
			});
			/*
			 var parser = new DOMParser();
			 var parsedDOM = parser.parseFromString(this.getSerializedDOM(), "text/xml");
			 var xsltPath = ORYX.PATH + "lib/extract-rdf.xsl";
			 var xsltProcessor = new XSLTProcessor();
			 var xslRef = document.implementation.createDocument("", "", null);
			 xslRef.async = false;
			 xslRef.load(xsltPath);
			 xsltProcessor.importStylesheet(xslRef);
			 try {
			 var rdf = xsltProcessor.transformToDocument(parsedDOM);
			 return (new XMLSerializer()).serializeToString(rdf);
			 } catch (error) {
			 Ext.Msg.alert("Oryx", error);
			 return null;
			 }*/
			var domParser = new DOMParser();
			var xmlObject = domParser.parseFromString(this.getSerializedDOM(), "text/xml");
			var xslObject = domParser.parseFromString(xsl, "text/xml");
			var xsltProcessor = new XSLTProcessor();
			xsltProcessor.importStylesheet(xslObject);
			var result = xsltProcessor.transformToFragment(xmlObject, document);
			
			var serializer = new XMLSerializer();
			
			return serializer.serializeToString(result);
		}catch(e){
			Ext.Msg.alert("Oryx", error);
			return "";
		}

		
    },
    
    /**
	 * Checks if a certain stencil set is loaded right now.
	 * 
	 */
	isStencilSetExtensionLoaded: function(stencilSetExtensionNamespace) {
		return this.facade.getStencilSets().values().any(
			function(ss){ 
				return ss.extensions().keys().any(
					function(extensionKey) {
						return extensionKey == stencilSetExtensionNamespace;
					}.bind(this)
				);
			}.bind(this)
		);
	},
	
	/**
	 * Raises an event so that registered layouters does
	 * have the posiblility to layout the given shapes 
	 * For further reading, have a look into the AbstractLayouter
	 * class
	 * @param {Object} shapes
	 */
	doLayout: function(shapes){
		// Raises a do layout event
		this.facade.raiseEvent({
			type		: ORYX.CONFIG.EVENT_LAYOUT,
			shapes		: shapes
		});
	},
	
	
	/**
	 * Does a primitive layouting with the incoming/outgoing 
	 * edges (set the dockers to the right position) and if 
	 * necessary, it will be called the real layouting 
	 * @param {ORYX.Core.Node} node
	 * @param {Array} edges
	 */
	layoutEdges : function(node, allEdges, offset){		
		
		// Find all edges, which are related to the node and
		// have more than two dockers
		var edges = allEdges
			// Find all edges with more than two dockers
			.findAll(function(r){ return r.dockers.length > 2 }.bind(this))
			
		if (edges.length > 0) {
										
			// Get the new absolute center
			var center = node.absoluteXY();
			
			var ulo = {x: center.x - offset.x, y:center.y - offset.y}			
			
			center.x += node.bounds.width()/2;
			center.y += node.bounds.height()/2;
			
			// Get the old absolute center
			oldCenter = Object.clone(center);
			oldCenter.x -= offset ? offset.x : 0;
			oldCenter.y -= offset ? offset.y : 0;
			
			var ul = {x: center.x - (node.bounds.width() / 2), y: center.y - (node.bounds.height() / 2)}
			var lr = {x: center.x + (node.bounds.width() / 2), y: center.y + (node.bounds.height() / 2)}
			
			
			/**
			 * Align the bounds if the center is 
			 * the same than the old center
			 * @params {Object} bounds
			 * @params {Object} bounds2
			 */
			var align = function(bounds, bounds2){
				var xdif = bounds.center().x-bounds2.center().x;
				var ydif = bounds.center().y-bounds2.center().y;
				if (Math.abs(xdif) < 3){
					bounds.moveBy({x:(offset.xs?(((offset.xs*(bounds.center().x-ulo.x))+offset.x+ulo.x)-bounds.center().x):offset.x)-xdif, y:0});		
				} else if (Math.abs(ydif) < 3){
					bounds.moveBy({x:0, y:(offset.ys?(((offset.ys*(bounds.center().y-ulo.y))+offset.y+ulo.y)-bounds.center().y):offset.y)-ydif});		
				}
			};
									
			/**						
			 * Returns a TRUE if there are bend point which overlay the shape
			 */
			var isBendPointIncluded = function(edge){
				// Get absolute bounds
				var ab = edge.dockers.first().getDockedShape();
				var bb = edge.dockers.last().getDockedShape();
				
				if (ab) {
					ab = ab.absoluteBounds();
					ab.widen(5);
				}
				
				if (bb) {
					bb = bb.absoluteBounds();
					bb.widen(20); // Wide with 20 because of the arrow from the edge
				}
				
				return edge.dockers
						.any(function(docker, i){ 
							var c = docker.bounds.center();
									// Dont count first and last
							return 	i != 0 && i != edge.dockers.length-1 && 
									// Check if the point is included to the absolute bounds
									((ab && ab.isIncluded(c)) || (bb && bb.isIncluded(c)))
						})
			}
			// For every edge, check second and one before last docker
			// if there are horizontal/vertical on the same level
			// and if so, align the the bounds 
			edges.each(function(edge){
				if (edge.dockers.first().getDockedShape() === node){
					var second = edge.dockers[1];
					if (align(second.bounds, edge.dockers.first().bounds)){ second.update(); }
				} else if (edge.dockers.last().getDockedShape() === node) {
					var beforeLast = edge.dockers[edge.dockers.length-2];
					if (align(beforeLast.bounds, edge.dockers.last().bounds)){ beforeLast.update(); }									
				}
				edge._update(true);
				edge.removeUnusedDockers();
				if (isBendPointIncluded(edge)){
					this.doLayout(edge);
					return;
				}
			}.bind(this))
		}	

		// Find all edges, which have only to dockers 
		// and is located horizontal/vertical.
		// Do layout with those edges
		allEdges.each(function(edge){
				// Find all edges with two dockers
				if (edge.dockers.length == 2){
					var p1 = edge.dockers.first().bounds.center();
					var p2 = edge.dockers.last().bounds.center();
					// Find all horizontal/vertical edges
					if (Math.abs(p1.x - p2.x) < 2 || Math.abs(p1.y - p2.y) < 2){
						edge.dockers.first().update();
						edge.dockers.last().update();
						this.doLayout(edge);
					}
				}
			}.bind(this));
	}
});/**
 * Copyright (c) 2009
 * Willi Tscheschner
 * 
 **/

if(!ORYX){ var ORYX = {} }
if(!ORYX.Plugins){ ORYX.Plugins = {} }

/**
   This abstract plugin implements the core behaviour of layout
   
   @class ORYX.Plugins.AbstractLayouter
   @constructor Creates a new instance
   @author Willi Tscheschner
*/
ORYX.Plugins.AbstractLayouter = ORYX.Plugins.AbstractPlugin.extend({
	
	/**
	 * 'layouted' defined all types of shapes which will be layouted. 
	 * It can be one value or an array of values. The value
	 * can be a Stencil ID (as String) or an class type of either 
	 * a ORYX.Core.Node or ORYX.Core.Edge
     * @type Array|String|Object
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	layouted : [],
	
	/**
	 * Constructor
	 * @param {Object} facade
	 * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	construct: function( facade ){
		arguments.callee.$.construct.apply(this, arguments);
			
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT, this._initLayout.bind(this));
	},
	
	/**
	 * Proofs if this shape should be layouted or not
	 * @param {Object} shape
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	isIncludedInLayout: function(shape){
		if (!(this.layouted instanceof Array)){
			this.layouted = [this.layouted].compact();
		}
		
		// If there are no elements
		if (this.layouted.length <= 0) {
			// Return TRUE
			return true;
		}
		
		// Return TRUE if there is any correlation between 
		// the 'layouted' attribute and the shape themselve.
		return this.layouted.any(function(s){
			if (typeof s == "string") {
				return shape.getStencil().id().include(s);
			} else {
				return shape instanceof s;
			}
		})
	},
	
	/**
	 * Callback to start the layouting
	 * @param {Object} event Layout event
	 * @param {Object} shapes Given shapes
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	_initLayout: function(event){
		
		// Get the shapes
		var shapes = [event.shapes].flatten().compact();
		
		// Find all shapes which should be layouted
		var toLayout = shapes.findAll(function(shape){
			return this.isIncludedInLayout(shape) 
		}.bind(this))
		
		// If there are shapes left 
		if (toLayout.length > 0){
			// Do layout
			this.layout(toLayout);
		}
	},
	
	/**
	 * Implementation of layouting a set on shapes
	 * @param {Object} shapes Given shapes
     * @memberOf ORYX.Plugins.AbstractLayouter.prototype
	 */
	layout: function(shapes){
		throw new Error("Layouter has to implement the layout function.")
	}
});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins) {	ORYX.Plugins = new Object();}ORYX.Plugins.Toolbar = Clazz.extend({	facade: undefined,	plugs:	[],	construct: function(facade, ownPluginData) {		this.facade = facade;				this.groupIndex = new Hash();		ownPluginData.properties.each((function(value){			if(value.group && value.index != undefined) {				this.groupIndex[value.group] = value.index			}		}).bind(this));				Ext.QuickTips.init();		this.buttons = [];        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_BUTTON_UPDATE, this.onButtonUpdate.bind(this));        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, this.onSelectionChanged.bind(this));        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_WINDOW_FOCUS, this.onSelectionChanged.bind(this));        Event.observe(window, "focus", function(event) {       		this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_WINDOW_FOCUS}, null);        }.bind(this));	},        /**     * Can be used to manipulate the state of a button.     * @example     * this.facade.raiseEvent({     *   type: ORYX.CONFIG.EVENT_BUTTON_UPDATE,     *   id: this.buttonId, // have to be generated before and set in the offer method     *   pressed: true     * });     * @param {Object} event     */    onButtonUpdate: function(event){        var button = this.buttons.find(function(button){            return button.id === event.id;        });                if(event.pressed !== undefined){            button.buttonInstance.toggle(event.pressed);        }    },	registryChanged: function(pluginsData) {        // Sort plugins by group and index		var newPlugs =  pluginsData.sortBy((function(value) {			return ((this.groupIndex[value.group] != undefined ? this.groupIndex[value.group] : "" ) + value.group + "" + value.index).toLowerCase();		}).bind(this));		var plugs = $A(newPlugs).findAll(function(value){										return !this.plugs.include( value )									}.bind(this));		if(plugs.length<1)			return;		this.buttons = [];		ORYX.Log.trace("Creating a toolbar.")		if(!this.toolbar){			this.toolbar = new Ext.ux.SlicedToolbar({			height: 24		});				var region = this.facade.addToRegion("north", this.toolbar, "Toolbar");		}						var currentGroupsName = this.plugs.last()?this.plugs.last().group:plugs[0].group;                // Map used to store all drop down buttons of current group        var currentGroupsDropDownButton = {};				plugs.each((function(value) {			if(!value.name) {return}			this.plugs.push(value);            // Add seperator if new group begins			if(currentGroupsName != value.group) {			    this.toolbar.add('-');				currentGroupsName = value.group;                currentGroupsDropDownButton = {};			}			//add eventtracking			var tmp = value.functionality;			value.functionality = function(){				 if ("undefined" != typeof(pageTracker) && "function" == typeof(pageTracker._trackEvent) )				 {					pageTracker._trackEvent("ToolbarButton",value.name)				}				return tmp.apply(this, arguments);			}            // If an drop down group icon is provided, a split button should be used            if(value.dropDownGroupIcon){                var splitButton = currentGroupsDropDownButton[value.dropDownGroupIcon];                                // Create a new split button if this is the first plugin using it                 if(splitButton === undefined){                    splitButton = currentGroupsDropDownButton[value.dropDownGroupIcon] = new Ext.Toolbar.SplitButton({                        cls: "x-btn-icon", //show icon only                        icon: value.dropDownGroupIcon,                        menu: new Ext.menu.Menu({                            items: [] // items are added later on                        }),                        listeners: {                          click: function(button, event){                            // The "normal" button should behave like the arrow button                            if(!button.menu.isVisible() && !button.ignoreNextClick){                                button.showMenu();                            } else {                                button.hideMenu();                            }                          }                         }                    });                                        this.toolbar.add(splitButton);                }                                // General config button which will be used either to create a normal button                // or a check button (if toggling is enabled)                var buttonCfg = {                    icon: value.icon,                    text: value.name,                    itemId: value.id,                    handler: value.toggle ? undefined : value.functionality,                    checkHandler: value.toggle ? value.functionality : undefined,                    listeners: {                        render: function(item){                            // After rendering, a tool tip should be added to component                            if (value.description) {                                new Ext.ToolTip({                                    target: item.getEl(),                                    title: value.description                                })                            }                        }                    }                }                                // Create buttons depending on toggle                if(value.toggle) {                    var button = new Ext.menu.CheckItem(buttonCfg);                } else {                    var button = new Ext.menu.Item(buttonCfg);                }                                splitButton.menu.add(button);                            } else { // create normal, simple button                var button = new Ext.Toolbar.Button({                    icon:           value.icon,         // icons can also be specified inline                    cls:            'x-btn-icon',       // Class who shows only the icon                    itemId:         value.id,					tooltip:        value.description,  // Set the tooltip                    tooltipType:    'title',            // Tooltip will be shown as in the html-title attribute                    handler:        value.toggle ? null : value.functionality,  // Handler for mouse click                    enableToggle:   value.toggle, // Option for enabling toggling                    toggleHandler:  value.toggle ? value.functionality : null // Handler for toggle (Parameters: button, active)                });                                 this.toolbar.add(button);                button.getEl().onclick = function() {this.blur()}            }			     			value['buttonInstance'] = button;			this.buttons.push(value);					}).bind(this));		this.enableButtons([]);        this.toolbar.calcSlices();		window.addEventListener("resize", function(event){this.toolbar.calcSlices()}.bind(this), false);		window.addEventListener("onresize", function(event){this.toolbar.calcSlices()}.bind(this), false);	},		onSelectionChanged: function(event) {		if(!event.elements){			this.enableButtons([]);		}else{			this.enableButtons(event.elements);		}	},	enableButtons: function(elements) {		// Show the Buttons		this.buttons.each((function(value){			value.buttonInstance.enable();									// If there is less elements than minShapes			if(value.minShape && value.minShape > elements.length)				value.buttonInstance.disable();			// If there is more elements than minShapes			if(value.maxShape && value.maxShape < elements.length)				value.buttonInstance.disable();				// If the plugin is not enabled				if(value.isEnabled && !value.isEnabled())				value.buttonInstance.disable();					}).bind(this));			}});Ext.ns("Ext.ux");Ext.ux.SlicedToolbar = Ext.extend(Ext.Toolbar, {    currentSlice: 0,    iconStandardWidth: 22, //22 px     seperatorStandardWidth: 2, //2px, minwidth for Ext.Toolbar.Fill    toolbarStandardPadding: 2,        initComponent: function(){        Ext.apply(this, {        });        Ext.ux.SlicedToolbar.superclass.initComponent.apply(this, arguments);    },        onRender: function(){        Ext.ux.SlicedToolbar.superclass.onRender.apply(this, arguments);    },        onResize: function(){        Ext.ux.SlicedToolbar.superclass.onResize.apply(this, arguments);    },        calcSlices: function(){        var slice = 0;        this.sliceMap = {};        var sliceWidth = 0;        var toolbarWidth = this.getEl().getWidth();        this.items.getRange().each(function(item, index){            //Remove all next and prev buttons            if (item.helperItem) {                item.destroy();                return;            }                        var itemWidth = item.getEl().getWidth();                        if(sliceWidth + itemWidth + 5 * this.iconStandardWidth > toolbarWidth){                var itemIndex = this.items.indexOf(item);                                this.insertSlicingButton("next", slice, itemIndex);                                if (slice !== 0) {                    this.insertSlicingButton("prev", slice, itemIndex);                }                                this.insertSlicingSeperator(slice, itemIndex);                slice += 1;                sliceWidth = 0;            }                        this.sliceMap[item.id] = slice;            sliceWidth += itemWidth;        }.bind(this));                // Add prev button at the end        if(slice > 0){            this.insertSlicingSeperator(slice, this.items.getCount()+1);            this.insertSlicingButton("prev", slice, this.items.getCount()+1);            var spacer = new Ext.Toolbar.Spacer();            this.insertSlicedHelperButton(spacer, slice, this.items.getCount()+1);            Ext.get(spacer.id).setWidth(this.iconStandardWidth);        }                this.maxSlice = slice;                // Update view        this.setCurrentSlice(this.currentSlice);    },        insertSlicedButton: function(button, slice, index){        this.insertButton(index, button);        this.sliceMap[button.id] = slice;    },        insertSlicedHelperButton: function(button, slice, index){        button.helperItem = true;        this.insertSlicedButton(button, slice, index);    },        insertSlicingSeperator: function(slice, index){        // Align right        this.insertSlicedHelperButton(new Ext.Toolbar.Fill(), slice, index);    },        // type => next or prev    insertSlicingButton: function(type, slice, index){        var nextHandler = function(){this.setCurrentSlice(this.currentSlice+1)}.bind(this);        var prevHandler = function(){this.setCurrentSlice(this.currentSlice-1)}.bind(this);                var button = new Ext.Toolbar.Button({            cls: "x-btn-icon",            icon: ORYX.CONFIG.ROOT_PATH + "images/toolbar_"+type+".png",            handler: (type === "next") ? nextHandler : prevHandler        });                this.insertSlicedHelperButton(button, slice, index);    },        setCurrentSlice: function(slice){        if(slice > this.maxSlice || slice < 0) return;                this.currentSlice = slice;        this.items.getRange().each(function(item){            item.setVisible(slice === this.sliceMap[item.id]);        }.bind(this));    }});/** * Copyright (c) 2009 * Jan-Felix Schwarz, Willi Tscheschner, Nicolas Peters, Martin Czuchra, Daniel Polak * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins) {	ORYX.Plugins = new Object();}ORYX.Plugins.ShapeMenuPlugin = {	construct: function(facade) {		this.facade = facade;				this.alignGroups = new Hash();		var containerNode = this.facade.getCanvas().getHTMLContainer();		this.shapeMenu = new ORYX.Plugins.ShapeMenu(containerNode);		this.currentShapes = [];		// Register on dragging and resizing events for show/hide of ShapeMenu		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_START, this.hideShapeMenu.bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_END,  this.showShapeMenu.bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_RESIZE_START,  (function(){			this.hideShapeMenu();			this.hideMorphMenu();		}).bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_RESIZE_END,  this.showShapeMenu.bind(this));				// Enable DragZone		var DragZone = new Ext.dd.DragZone(containerNode.parentNode, {shadow: !Ext.isMac});		DragZone.afterDragDrop = this.afterDragging.bind(this, DragZone);		DragZone.beforeDragOver = this.beforeDragOver.bind(this, DragZone);				// Memory of created Buttons		this.createdButtons = {};				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, (function(){ this.registryChanged() }).bind(this));		this.timer = null;				this.resetElements = true;	},	hideShapeMenu: function(event) {		window.clearTimeout(this.timer);		this.timer = null;		this.shapeMenu.hide();	},	showShapeMenu: function( dontGenerateNew ) {			if( !dontGenerateNew || this.resetElements ){						window.clearTimeout(this.timer);			this.timer = window.setTimeout(function(){									// Close all Buttons				this.shapeMenu.closeAllButtons();						// Show the Morph Button				this.showMorphButton(this.currentShapes);								// Show the Stencil Buttons				this.showStencilButtons(this.currentShapes);									// Show the ShapeMenu				this.shapeMenu.show(this.currentShapes);								this.resetElements = false;			}.bind(this), 300)					} else {						window.clearTimeout(this.timer);			this.timer = null;						// Show the ShapeMenu			this.shapeMenu.show(this.currentShapes);					}	},	registryChanged: function(pluginsData) {				if(pluginsData) {			pluginsData = pluginsData.each(function(value) {value.group = value.group ? value.group : 'unknown'});			this.pluginsData = pluginsData.sortBy( function(value) {				return (value.group + "" + value.index);			});					}						this.shapeMenu.removeAllButtons();		this.shapeMenu.setNumberOfButtonsPerLevel(ORYX.CONFIG.SHAPEMENU_RIGHT, 2);		this.createdButtons = {};				this.createMorphMenu();				if( !this.pluginsData ){			this.pluginsData = [];		}		this.baseMorphStencils = this.facade.getRules().baseMorphs();				// Checks if the stencil set has morphing attributes		var isMorphing = this.facade.getRules().containsMorphingRules();				// Create Buttons for all Stencils of all loaded stencilsets		var stencilsets = this.facade.getStencilSets();		stencilsets.values().each((function(stencilSet){						var nodes = stencilSet.nodes();			nodes.each((function(stencil) {												// Create a button for each node				var option = {type: stencil.id(), namespace: stencil.namespace(), connectingType: true};				var button = new ORYX.Plugins.ShapeMenuButton({					callback: 	this.newShape.bind(this, option),					icon: 		stencil.icon(),					align: 		ORYX.CONFIG.SHAPEMENU_RIGHT,					group:		0,					//dragcallback: this.hideShapeMenu.bind(this),					msg:		stencil.title() + " - " + ORYX.I18N.ShapeMenuPlugin.clickDrag					});								// Add button to shape menu				this.shapeMenu.addButton(button); 								// Add to the created Button Array				this.createdButtons[stencil.namespace() + stencil.type() + stencil.id()] = button;								// Drag'n'Drop will enable				Ext.dd.Registry.register(button.node.lastChild, option);							}).bind(this));					var edges = stencilSet.edges();			edges.each((function(stencil) {				// Create a button for each edge				var option = {type: stencil.id(), namespace: stencil.namespace()};				var button = new ORYX.Plugins.ShapeMenuButton({					callback: 	this.newShape.bind(this, option),					// icon: 		isMorphing ? ORYX.PATH + "images/edges.png" : stencil.icon(),					icon: 		stencil.icon(),					align: 		ORYX.CONFIG.SHAPEMENU_RIGHT,					group:		1,					//dragcallback: this.hideShapeMenu.bind(this),					msg:		(isMorphing ? ORYX.I18N.Edge : stencil.title()) + " - " + ORYX.I18N.ShapeMenuPlugin.drag				});								// Add button to shape menu				this.shapeMenu.addButton(button); 								// Add to the created Button Array				this.createdButtons[stencil.namespace() + stencil.type() + stencil.id()] = button;								// Drag'n'Drop will enable				Ext.dd.Registry.register(button.node.lastChild, option);							}).bind(this));				}).bind(this));										},		createMorphMenu: function() {				this.morphMenu = new Ext.menu.Menu({			id: 'Oryx_morph_menu',			items: []		});				this.morphMenu.on("mouseover", function() {			this.morphMenuHovered = true;		}, this);		this.morphMenu.on("mouseout", function() {			this.morphMenuHovered = false;		}, this);						// Create the button to show the morph menu		var button = new ORYX.Plugins.ShapeMenuButton({			hovercallback: 	(ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER ? this.showMorphMenu.bind(this) : undefined), 			resetcallback: 	(ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER ? this.hideMorphMenu.bind(this) : undefined), 			callback:		(ORYX.CONFIG.ENABLE_MORPHMENU_BY_HOVER ? undefined : this.toggleMorphMenu.bind(this)), 			icon: 			ORYX.PATH + 'images/wrench_orange.png',			align: 			ORYX.CONFIG.SHAPEMENU_BOTTOM,			group:			0,			msg:			ORYX.I18N.ShapeMenuPlugin.morphMsg		});								this.shapeMenu.setNumberOfButtonsPerLevel(ORYX.CONFIG.SHAPEMENU_BOTTOM, 1)		this.shapeMenu.addButton(button);		this.morphMenu.getEl().appendTo(button.node);		this.morphButton = button;	},		showMorphMenu: function() {		this.morphMenu.show(this.morphButton.node);		this._morphMenuShown = true;	},		hideMorphMenu: function() {		this.morphMenu.hide();		this._morphMenuShown = false;	},		toggleMorphMenu: function() {		if(this._morphMenuShown)			this.hideMorphMenu();		else			this.showMorphMenu();	},		onSelectionChanged: function(event) {		var elements = event.elements;		this.hideShapeMenu();		this.hideMorphMenu();						if( this.currentShapes.inspect() !== elements.inspect() ){			this.currentShapes = elements;			this.resetElements = true;						this.showShapeMenu();		} else {			this.showShapeMenu(true)		}			},		/**	 * Show button for morphing the selected shape into another stencil	 */	showMorphButton: function(elements) {				if(elements.length != 1) return;				var possibleMorphs = this.facade.getRules().morphStencils({ stencil: elements[0].getStencil() });		possibleMorphs = possibleMorphs.select(function(morph) {			if(elements[0].getStencil().type() === "node") {				//check containment rules				return this.facade.getRules().canContain({containingShape:elements[0].parent, containedStencil:morph});			} else { 				//check connect rules				return this.facade.getRules().canConnect({											sourceShape:	elements[0].dockers.first().getDockedShape(), 											edgeStencil:	morph, 											targetShape:	elements[0].dockers.last().getDockedShape()											});				}		}.bind(this));		if(possibleMorphs.size()<=1) return; // if morphing to other stencils is not possible, don't show button				this.morphMenu.removeAll();				// populate morph menu with the possible morph stencils ordered by their position		possibleMorphs = possibleMorphs.sortBy(function(stencil) { return stencil.position(); });		possibleMorphs.each((function(morph) {			var menuItem = new Ext.menu.Item({ 				text: morph.title(), 				icon: morph.icon(), 				disabled: morph.id()==elements[0].getStencil().id(),				disabledClass: ORYX.CONFIG.MORPHITEM_DISABLED,				handler: (function() { this.morphShape(elements[0], morph); }).bind(this) 			});			this.morphMenu.add(menuItem);		}).bind(this));				this.morphButton.prepareToShow();			},	/**	 * Show buttons for creating following shapes	 */	showStencilButtons: function(elements) {		if(elements.length != 1) return;		//TODO temporaere nutzung des stencilsets		var sset = this.facade.getStencilSets()[elements[0].getStencil().namespace()];		// Get all available edges		var edges = this.facade.getRules().outgoingEdgeStencils({canvas:this.facade.getCanvas(), sourceShape:elements[0]});				// And find all targets for each Edge		var targets = new Array();		var addedEdges = new Array();				var isMorphing = this.facade.getRules().containsMorphingRules();				edges.each((function(edge) {						if (isMorphing){				if(this.baseMorphStencils.include(edge)) {					var shallAppear = true;				} else {										// if edge is member of a morph groups where none of the base morphs is in the outgoing edges					// we want to display the button (but only for the first one)										var possibleMorphs = this.facade.getRules().morphStencils({ stencil: edge });										var shallAppear = !possibleMorphs.any((function(morphStencil) {						if(this.baseMorphStencils.include(morphStencil) && edges.include(morphStencil)) return true;						return addedEdges.include(morphStencil);					}).bind(this));									}			}			if(shallAppear || !isMorphing) {				if(this.createdButtons[edge.namespace() + edge.type() + edge.id()]) 					this.createdButtons[edge.namespace() + edge.type() + edge.id()].prepareToShow();				addedEdges.push(edge);			}						// get all targets for this edge			targets = targets.concat(this.facade.getRules().targetStencils(					{canvas:this.facade.getCanvas(), sourceShape:elements[0], edgeStencil:edge}));		}).bind(this));				targets.uniq();				var addedTargets = new Array();		// Iterate all possible target 		targets.each((function(target) {						if (isMorphing){								// continue with next target stencil				if (target.type()==="edge") return; 								// continue when stencil should not shown in the shape menu				if (!this.facade.getRules().showInShapeMenu(target)) return 								// if target is not a base morph 				if(!this.baseMorphStencils.include(target)) {										// if target is member of a morph groups where none of the base morphs is in the targets					// we want to display the button (but only for the first one)										var possibleMorphs = this.facade.getRules().morphStencils({ stencil: target });					if(possibleMorphs.size()==0) return; // continue with next target						var baseMorphInTargets = possibleMorphs.any((function(morphStencil) {						if(this.baseMorphStencils.include(morphStencil) && targets.include(morphStencil)) return true;						return addedTargets.include(morphStencil);					}).bind(this));										if(baseMorphInTargets) return; // continue with next target				}			}						// if this is reached the button shall appear in the shape menu:			if(this.createdButtons[target.namespace() + target.type() + target.id()]) 				this.createdButtons[target.namespace() + target.type() + target.id()].prepareToShow();			addedTargets.push(target);					}).bind(this));			},		beforeDragOver: function(dragZone, target, event){		if (this.shapeMenu.isVisible){			this.hideShapeMenu();		}		var coord = this.facade.eventCoordinates(event.browserEvent);		var aShapes = this.facade.getCanvas().getAbstractShapesAtPosition(coord);		if(aShapes.length <= 0) {return false;}					var el = aShapes.last();				if(this._lastOverElement == el) {						return false;					} else {			// check containment rules			var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);						// revert to original options if these were modified			if(option.backupOptions) {				for(key in option.backupOptions) {					option[key] = option.backupOptions[key];				}				delete option.backupOptions;			}			var stencilSet = this.facade.getStencilSets()[option.namespace];			var stencil = stencilSet.stencil(option.type);			var candidate = aShapes.last();			if(stencil.type() === "node") {				//check containment rules				var canContain = this.facade.getRules().canContain({containingShape:candidate, containedStencil:stencil});													// if not canContain, try to find a morph which can be contained				if(!canContain) {					var possibleMorphs = this.facade.getRules().morphStencils({stencil: stencil});					for(var i=0; i<possibleMorphs.size(); i++) {						canContain = this.facade.getRules().canContain({							containingShape:candidate, 							containedStencil:possibleMorphs[i]						});						if(canContain) {							option.backupOptions = Object.clone(option);							option.type = possibleMorphs[i].id();							option.namespace = possibleMorphs[i].namespace();							break;						}					}				}									this._currentReference = canContain ? candidate : undefined;									} else { //Edge							var curCan = candidate, orgCan = candidate;				var canConnect = false;				while(!canConnect && curCan && !(curCan instanceof ORYX.Core.Canvas)){					candidate = curCan;					//check connection rules					canConnect = this.facade.getRules().canConnect({											sourceShape: this.currentShapes.first(), 											edgeStencil: stencil, 											targetShape: curCan											});						curCan = curCan.parent;				}			 	// if not canConnect, try to find a morph which can be connected				if(!canConnect) {										candidate = orgCan;					var possibleMorphs = this.facade.getRules().morphStencils({stencil: stencil});					for(var i=0; i<possibleMorphs.size(); i++) {						var curCan = candidate;						var canConnect = false;						while(!canConnect && curCan && !(curCan instanceof ORYX.Core.Canvas)){							candidate = curCan;							//check connection rules							canConnect = this.facade.getRules().canConnect({														sourceShape:	this.currentShapes.first(), 														edgeStencil:	possibleMorphs[i], 														targetShape:	curCan													});								curCan = curCan.parent;						}						if(canConnect) {							option.backupOptions = Object.clone(option);							option.type = possibleMorphs[i].id();							option.namespace = possibleMorphs[i].namespace();							break;						} else {							candidate = orgCan;						}					}				}														this._currentReference = canConnect ? candidate : undefined;									}				this.facade.raiseEvent({											type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 											highlightId:'shapeMenu',											elements:	[candidate],											color:		this._currentReference ? ORYX.CONFIG.SELECTION_VALID_COLOR : ORYX.CONFIG.SELECTION_INVALID_COLOR										});															var pr = dragZone.getProxy();			pr.setStatus(this._currentReference ? pr.dropAllowed : pr.dropNotAllowed );			pr.sync();												}				this._lastOverElement = el;				return false;	},		afterDragging: function(dragZone, target, event) {				if (!(this.currentShapes instanceof Array)||this.currentShapes.length<=0) {			return;		}		var sourceShape = this.currentShapes;				this._lastOverElement = undefined;				// Hide the highlighting		this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'shapeMenu'});				// Check if drop is allowed		var proxy = dragZone.getProxy()		if(proxy.dropStatus == proxy.dropNotAllowed) { return this.facade.updateSelection();}						// Check if there is a current Parent		if(!this._currentReference) { return }						var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);		option['parent'] = this._currentReference;		var xy = event.getXY();		var pos = {x: xy[0], y: xy[1]};		var a = this.facade.getCanvas().node.getScreenCTM();		// Correcting the UpperLeft-Offset		pos.x -= a.e; pos.y -= a.f;		// Correcting the Zoom-Faktor		pos.x /= a.a; pos.y /= a.d;		// Correcting the ScrollOffset		pos.x -= document.documentElement.scrollLeft;		pos.y -= document.documentElement.scrollTop;		var parentAbs = this._currentReference.absoluteXY();		pos.x -= parentAbs.x;		pos.y -= parentAbs.y;				// If the ctrl key is not pressed, 		// snapp the new shape to the center 		// if it is near to the center of the other shape		if (!event.ctrlKey){			// Get the center of the shape			var cShape = this.currentShapes[0].bounds.center();			// Snapp +-20 Pixel horizontal to the center 			if (20 > Math.abs(cShape.x - pos.x)){				pos.x = cShape.x;			}			// Snapp +-20 Pixel vertical to the center 			if (20 > Math.abs(cShape.y - pos.y)){				pos.y = cShape.y;			}		}						option['position'] = pos;		option['connectedShape'] = this.currentShapes[0];		if(option['connectingType']) {			var stencilset = this.facade.getStencilSets()[option.namespace];			var containedStencil = stencilset.stencil(option.type);			var args = { sourceShape: this.currentShapes[0], targetStencil: containedStencil };			option['connectingType'] = this.facade.getRules().connectMorph(args).id();		}				if (ORYX.CONFIG.SHAPEMENU_DISABLE_CONNECTED_EDGE===true) {			delete option['connectingType'];		}					var command = new ORYX.Plugins.ShapeMenuPlugin.CreateCommand(Object.clone(option), this._currentReference, pos, this);				this.facade.executeCommands([command]);				// Inform about completed Drag 		this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_SHAPE_MENU_CLOSE, source:sourceShape, destination:this.currentShapes});				// revert to original options if these were modified		if(option.backupOptions) {			for(key in option.backupOptions) {				option[key] = option.backupOptions[key];			}			delete option.backupOptions;		}					this._currentReference = undefined;			},	newShape: function(option, event) {		var stencilset = this.facade.getStencilSets()[option.namespace];		var containedStencil = stencilset.stencil(option.type);		if(this.facade.getRules().canContain({			containingShape:this.currentShapes.first().parent,			"containedStencil":containedStencil
		})) {			option['connectedShape'] = this.currentShapes[0];			option['parent'] = this.currentShapes.first().parent;			option['containedStencil'] = containedStencil;					var args = { sourceShape: this.currentShapes[0], targetStencil: containedStencil };			var targetStencil = this.facade.getRules().connectMorph(args);			if (!targetStencil){ return }// Check if there can be a target shape			option['connectingType'] = targetStencil.id();			if (ORYX.CONFIG.SHAPEMENU_DISABLE_CONNECTED_EDGE===true) {				delete option['connectingType'];			}						var command = new ORYX.Plugins.ShapeMenuPlugin.CreateCommand(option, undefined, undefined, this);					this.facade.executeCommands([command]);		}	},		/**	 * Morph a shape to a new stencil	 * {Command implemented}	 * @param {Shape} shape	 * @param {Stencil} stencil	 */	morphShape: function(shape, stencil) {				var MorphTo = ORYX.Core.Command.extend({			construct: function(shape, stencil, facade){				this.shape = shape;				this.stencil = stencil;				this.facade = facade;			},			execute: function(){								var shape = this.shape;				var stencil = this.stencil;				var resourceId = shape.resourceId;								// Serialize all attributes				var serialized = shape.serialize();				stencil.properties().each((function(prop) {					if(prop.readonly()) {						serialized = serialized.reject(function(serProp) {							return serProp.name==prop.id();						});					}				}).bind(this));						// Get shape if already created, otherwise create a new shape				if (this.newShape){					newShape = this.newShape;					this.facade.getCanvas().add(newShape);				} else {					newShape = this.facade.createShape({									type: stencil.id(),									namespace: stencil.namespace(),									resourceId: resourceId								});				}								// calculate new bounds using old shape's upperLeft and new shape's width/height				var boundsObj = serialized.find(function(serProp){					return (serProp.prefix === "oryx" && serProp.name === "bounds");				});								var changedBounds = null;								if(!this.facade.getRules().preserveBounds(shape.getStencil())) {										var bounds = boundsObj.value.split(",");					if (parseInt(bounds[0], 10) > parseInt(bounds[2], 10)) { // if lowerRight comes first, swap array items						var tmp = bounds[0];						bounds[0] = bounds[2];						bounds[2] = tmp;						tmp = bounds[1];						bounds[1] = bounds[3];						bounds[3] = tmp;					}					bounds[2] = parseInt(bounds[0], 10) + newShape.bounds.width();					bounds[3] = parseInt(bounds[1], 10) + newShape.bounds.height();					boundsObj.value = bounds.join(",");									}  else {										var height = shape.bounds.height();					var width  = shape.bounds.width();										// consider the minimum and maximum size of					// the new shape										if (newShape.minimumSize) {						if (shape.bounds.height() < newShape.minimumSize.height) {							height = newShape.minimumSize.height;						}																		if (shape.bounds.width() < newShape.minimumSize.width) {							width = newShape.minimumSize.width;						}					}										if(newShape.maximumSize) {						if(shape.bounds.height() > newShape.maximumSize.height) {							height = newShape.maximumSize.height;						}													if(shape.bounds.width() > newShape.maximumSize.width) {							width = newShape.maximumSize.width;						}					}										changedBounds = {						a : {							x: shape.bounds.a.x,							y: shape.bounds.a.y						},						b : {							x: shape.bounds.a.x + width,							y: shape.bounds.a.y + height						}											};									}								var oPos = shape.bounds.center();				if(changedBounds !== null) {					newShape.bounds.set(changedBounds);				}								// Set all related dockers				this.setRelatedDockers(shape, newShape);								// store DOM position of old shape				var parentNode = shape.node.parentNode;				var nextSibling = shape.node.nextSibling;								// Delete the old shape				this.facade.deleteShape(shape);								// Deserialize the new shape - Set all attributes				newShape.deserialize(serialized);				/*				 * Change color to default if unchanged				 * 23.04.2010				 */				if(shape.getStencil().property("oryx-bgcolor") 						&& shape.properties["oryx-bgcolor"]						&& shape.getStencil().property("oryx-bgcolor").value().toUpperCase()== shape.properties["oryx-bgcolor"].toUpperCase()){						if(newShape.getStencil().property("oryx-bgcolor")){							newShape.setProperty("oryx-bgcolor", newShape.getStencil().property("oryx-bgcolor").value());						}				}					if(changedBounds !== null) {					newShape.bounds.set(changedBounds);				}								if(newShape.getStencil().type()==="edge" || (newShape.dockers.length==0 || !newShape.dockers[0].getDockedShape())) {					newShape.bounds.centerMoveTo(oPos);				} 								if(newShape.getStencil().type()==="node" && (newShape.dockers.length==0 || !newShape.dockers[0].getDockedShape())) {					this.setRelatedDockers(newShape, newShape);									}								// place at the DOM position of the old shape				if(nextSibling) parentNode.insertBefore(newShape.node, nextSibling);				else parentNode.appendChild(newShape.node);								// Set selection				this.facade.setSelection([newShape]);				this.facade.getCanvas().update();				this.facade.updateSelection();				this.newShape = newShape;								this.facade.raiseEvent({					type: ORYX.CONFIG.EVENT_SHAPE_MORPHED,					shape: newShape				});							},			rollback: function(){								if (!this.shape || !this.newShape || !this.newShape.parent) {return}								// Append shape to the parent				this.newShape.parent.add(this.shape);				// Set dockers				this.setRelatedDockers(this.newShape, this.shape);				// Delete new shape				this.facade.deleteShape(this.newShape);				// Set selection				this.facade.setSelection([this.shape]);				// Update				this.facade.getCanvas().update();				this.facade.updateSelection();			},						/**			 * Set all incoming and outgoing edges from the shape to the new shape			 * @param {Shape} shape			 * @param {Shape} newShape			 */			setRelatedDockers: function(shape, newShape){								if(shape.getStencil().type()==="node") {										(shape.incoming||[]).concat(shape.outgoing||[])						.each(function(i) { 							i.dockers.each(function(docker) {								if (docker.getDockedShape() == shape) {									var rPoint = Object.clone(docker.referencePoint);									// Move reference point per percent									var rPointNew = {										x: rPoint.x*newShape.bounds.width()/shape.bounds.width(),										y: rPoint.y*newShape.bounds.height()/shape.bounds.height()									};									docker.setDockedShape(newShape);									// Set reference point and center to new position									docker.setReferencePoint(rPointNew);									if(i instanceof ORYX.Core.Edge) {										docker.bounds.centerMoveTo(rPointNew);									} else {										var absXY = shape.absoluteXY();										docker.bounds.centerMoveTo({x:rPointNew.x+absXY.x, y:rPointNew.y+absXY.y});										//docker.bounds.moveBy({x:rPointNew.x-rPoint.x, y:rPointNew.y-rPoint.y});									}								}							});							});										// for attached events					if(shape.dockers.length>0&&shape.dockers.first().getDockedShape()) {						newShape.dockers.first().setDockedShape(shape.dockers.first().getDockedShape());						newShape.dockers.first().setReferencePoint(Object.clone(shape.dockers.first().referencePoint));					}								} else { // is edge					newShape.dockers.first().setDockedShape(shape.dockers.first().getDockedShape());					newShape.dockers.first().setReferencePoint(shape.dockers.first().referencePoint);					newShape.dockers.last().setDockedShape(shape.dockers.last().getDockedShape());					newShape.dockers.last().setReferencePoint(shape.dockers.last().referencePoint);				}			}		});				// Create and execute command (for undo/redo)					var command = new MorphTo(shape, stencil, this.facade);		this.facade.executeCommands([command]);	}}ORYX.Plugins.ShapeMenuPlugin = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.ShapeMenuPlugin);ORYX.Plugins.ShapeMenu = {	/***	 * Constructor.	 */	construct: function(parentNode) {		this.bounds = undefined;		this.shapes = undefined;		this.buttons = [];		this.isVisible = false;		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", $(parentNode),			['div', {id: ORYX.Editor.provideId(), 'class':'Oryx_ShapeMenu'}]);				this.alignContainers = new Hash();		this.numberOfButtonsPerLevel = new Hash();	},	addButton: function(button) {		this.buttons.push(button);		// lazy grafting of the align containers		if(!this.alignContainers[button.align]) {			this.alignContainers[button.align] = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.node,					['div', {'class':button.align}]);			this.node.appendChild(this.alignContainers[button.align]);						// add event listeners for hover effect			var onBubble = false;			this.alignContainers[button.align].addEventListener(ORYX.CONFIG.EVENT_MOUSEOVER, this.hoverAlignContainer.bind(this, button.align), onBubble);			this.alignContainers[button.align].addEventListener(ORYX.CONFIG.EVENT_MOUSEOUT, this.resetAlignContainer.bind(this, button.align), onBubble);			this.alignContainers[button.align].addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.hoverAlignContainer.bind(this, button.align), onBubble);		}		this.alignContainers[button.align].appendChild(button.node);	},	deleteButton: function(button) {		this.buttons = this.buttons.without(button);		this.node.removeChild(button.node);	},	removeAllButtons: function() {		var me = this;		this.buttons.each(function(value){			if (value.node&&value.node.parentNode)				value.node.parentNode.removeChild(value.node);		});		this.buttons = [];	},	closeAllButtons: function() {		this.buttons.each(function(value){ value.prepareToHide() });		this.isVisible = false;	},		/**	 * Show the shape menu	 */	show: function(shapes) {		//shapes = (shapes||[]).findAll(function(r){ return r && r.node && r.node.parent });		if(shapes.length <= 0 )			return		this.shapes = shapes;		var newBounds = undefined;		var tmpBounds = undefined;		this.shapes.each(function(value) {			var a = value.node.getScreenCTM();			var upL = value.absoluteXY();			a.e = a.a*upL.x;			a.f = a.d*upL.y;			tmpBounds = new ORYX.Core.Bounds(a.e, a.f, a.e+a.a*value.bounds.width(), a.f+a.d*value.bounds.height());			/*if(value instanceof ORYX.Core.Edge) {				tmpBounds.moveBy(value.bounds.upperLeft())			}*/			if(!newBounds)				newBounds = tmpBounds			else				newBounds.include(tmpBounds);		});		this.bounds = newBounds;		//this.bounds.moveBy({x:document.documentElement.scrollLeft, y:document.documentElement.scrollTop});		var bounds = this.bounds;		var a = this.bounds.upperLeft();		var left = 0,			leftButtonGroup = 0;		var top = 0,			topButtonGroup = 0;		var bottom = 0,			bottomButtonGroup;		var right = 0			rightButtonGroup = 0;		var size = 22;				this.getWillShowButtons().sortBy(function(button) {			return button.group;		});				this.getWillShowButtons().each(function(button){						var numOfButtonsPerLevel = this.getNumberOfButtonsPerLevel(button.align);			if (button.align == ORYX.CONFIG.SHAPEMENU_LEFT) {				// vertical levels				if(button.group!=leftButtonGroup) {					left = 0;					leftButtonGroup = button.group;				}				var x = Math.floor(left / numOfButtonsPerLevel)				var y = left % numOfButtonsPerLevel;								button.setLevel(x);								button.setPosition(a.x-5 - (x+1)*size, 						a.y+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + y*size);								//button.setPosition(a.x-22, a.y+left*size);				left++; 			} else if (button.align == ORYX.CONFIG.SHAPEMENU_TOP) { 				// horizontal levels 				if(button.group!=topButtonGroup) {					top = 0;					topButtonGroup = button.group;				} 				var x = top % numOfButtonsPerLevel; 				var y = Math.floor(top / numOfButtonsPerLevel); 				 				button.setLevel(y); 				 				button.setPosition(a.x+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + x*size, 						a.y-5 - (y+1)*size);				top++; 			} else if (button.align == ORYX.CONFIG.SHAPEMENU_BOTTOM) { 				// horizontal levels 				if(button.group!=bottomButtonGroup) {					bottom = 0;					bottomButtonGroup = button.group;				} 				var x = bottom % numOfButtonsPerLevel; 				var y = Math.floor(bottom / numOfButtonsPerLevel); 				 				button.setLevel(y); 				 				button.setPosition(a.x+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + x*size, 						a.y+bounds.height() + 5 + y*size);				bottom++;			} else {				// vertical levels				if(button.group!=rightButtonGroup) {					right = 0;					rightButtonGroup = button.group;				}				var x = Math.floor(right / numOfButtonsPerLevel)				var y = right % numOfButtonsPerLevel;								button.setLevel(x);								button.setPosition(a.x+bounds.width() + 5 + x*size, 						a.y+numOfButtonsPerLevel*button.group*size + button.group*0.3*size + y*size - 5);				right++;			}			button.show();		}.bind(this));		this.isVisible = true;	},	/**	 * Hide the shape menu	 */	hide: function() {		this.buttons.each(function(button){			button.hide();		});		this.isVisible = false;		//this.bounds = undefined;		//this.shape = undefined;	},	hoverAlignContainer: function(align, evt) {		this.buttons.each(function(button){			if(button.align == align) button.showOpaque();		});	},		resetAlignContainer: function(align, evt) {		this.buttons.each(function(button){			if(button.align == align) button.showTransparent();		});	},		isHover: function() {		return 	this.buttons.any(function(value){					return value.isHover();				});	},		getWillShowButtons: function() {		return this.buttons.findAll(function(value){return value.willShow});	},		/**	 * Returns a set on buttons for that align value	 * @params {String} align	 * @params {String} group	 */	getButtons: function(align, group){		return this.getWillShowButtons().findAll(function(b){ return b.align == align && (group === undefined || b.group == group)})	},		/**	 * Set the number of buttons to display on each level of the shape menu in the specified align group.	 * Example: setNumberOfButtonsPerLevel(ORYX.CONFIG.SHAPEMENU_RIGHT, 2) causes that the buttons of the right align group 	 * will be rendered in 2 rows.	 */	setNumberOfButtonsPerLevel: function(align, number) {		this.numberOfButtonsPerLevel[align] = number;	},		/**	 * Returns the number of buttons to display on each level of the shape menu in the specified align group.	 * Default value is 1	 */	getNumberOfButtonsPerLevel: function(align) {		if(this.numberOfButtonsPerLevel[align])			return Math.min(this.getButtons(align,0).length, this.numberOfButtonsPerLevel[align]);		else			return 1;	}}ORYX.Plugins.ShapeMenu = Clazz.extend(ORYX.Plugins.ShapeMenu);ORYX.Plugins.ShapeMenuButton = {		/**	 * Constructor	 * @param option A key map specifying the configuration options:	 * 					id: 	(String) The id of the parent DOM element for the new button	 * 					icon: 	(String) The url to the icon of the button	 * 					msg:	(String) A tooltip message	 * 					caption:(String) The caption of the button (attention: button width > 22, only set for single column button layouts)	 * 					align:	(String) The direction in which the button is aligned	 * 					group: 	(Integer) The button group in the specified alignment 	 * 							(buttons in the same group will be aligned side by side)	 * 					callback:		(Function) A callback that is executed when the button is clicked	 * 					dragcallback:	(Function) A callback that is executed when the button is dragged	 * 					hovercallback:	(Function) A callback that is executed when the button is hovered	 * 					resetcallback:	(Function) A callback that is executed when the button is reset	 * 					arguments:		(Array) An argument array to pass to the callback functions	 */	construct: function(option) {		if(option) {			this.option = option;			if(!this.option.arguments)				this.option.arguments = [];		} else {			//TODO error		}		this.parentId = this.option.id ? this.option.id : null;		// graft the button.		var buttonClassName = this.option.caption ? "Oryx_button_with_caption" : "Oryx_button";		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", $(this.parentId),			['div', {'class':buttonClassName}]);		var imgOptions = {src:this.option.icon};		if(this.option.msg){			imgOptions.title = this.option.msg;		}				// graft and update icon (not in grafting for ns reasons).		//TODO Enrich graft()-function to do this in one of the above steps.		if(this.option.icon)			ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.node,				['img', imgOptions]);				if(this.option.caption) {			var captionNode = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.node, ['span']);			ORYX.Editor.graft("http://www.w3.org/1999/xhtml", captionNode, this.option.caption);		}		var onBubble = false;		this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOVER, this.hover.bind(this), onBubble);		this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEOUT, this.reset.bind(this), onBubble);		this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEDOWN, this.activate.bind(this), onBubble);		this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.hover.bind(this), onBubble);		this.node.addEventListener('click', this.trigger.bind(this), onBubble);		this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.move.bind(this), onBubble);		this.align = this.option.align ? this.option.align : ORYX.CONFIG.SHAPEMENU_RIGHT;		this.group = this.option.group ? this.option.group : 0;		this.hide();		this.dragStart 	= false;		this.isVisible 	= false;		this.willShow 	= false;		this.resetTimer;	},		hide: function() {		this.node.style.display = "none";		this.isVisible = false;	},	show: function() {		this.node.style.display = "";		this.node.style.opacity = this.opacity;		this.isVisible = true;	},		showOpaque: function() {		this.node.style.opacity = 1.0;	},		showTransparent: function() {		this.node.style.opacity = this.opacity;	},		prepareToShow: function() {		this.willShow = true;	},	prepareToHide: function() {		this.willShow = false;		this.hide();	},	setPosition: function(x, y) {		this.node.style.left = x + "px";		this.node.style.top = y + "px";	},		setLevel: function(level) {		if(level==0) this.opacity = 0.5;		else if(level==1) this.opacity = 0.2;		//else if(level==2) this.opacity = 0.1;		else this.opacity = 0.0;	},		setChildWidth: function(width) {		this.childNode.style.width = width + "px";	},	reset: function(evt) {		// Delete the timeout for hiding		window.clearTimeout( this.resetTimer )		this.resetTimer = window.setTimeout( this.doReset.bind(this), 100)				if(this.option.resetcallback) {			this.option.arguments.push(evt);			var state = this.option.resetcallback.apply(this, this.option.arguments);			this.option.arguments.remove(evt);		}	},		doReset: function() {				if(this.node.hasClassName('Oryx_down'))			this.node.removeClassName('Oryx_down');		if(this.node.hasClassName('Oryx_hover'))			this.node.removeClassName('Oryx_hover');	},	activate: function(evt) {		this.node.addClassName('Oryx_down');		//Event.stop(evt);		this.dragStart = true;	},	isHover: function() {		return this.node.hasClassName('Oryx_hover') ? true: false;	},	hover: function(evt) {		// Delete the timeout for hiding		window.clearTimeout( this.resetTimer )		this.resetTimer = null;				this.node.addClassName('Oryx_hover');		this.dragStart = false;				if(this.option.hovercallback) {			this.option.arguments.push(evt);			var state = this.option.hovercallback.apply(this, this.option.arguments);			this.option.arguments.remove(evt);		}	},	move: function(evt) {		if(this.dragStart && this.option.dragcallback) {			this.option.arguments.push(evt);			var state = this.option.dragcallback.apply(this, this.option.arguments);			this.option.arguments.remove(evt);		}	},	trigger: function(evt) {		if(this.option.callback) {			//Event.stop(evt);			this.option.arguments.push(evt);			var state = this.option.callback.apply(this, this.option.arguments);			this.option.arguments.remove(evt);		}		this.dragStart = false;	},	toString: function() {		return "HTML-Button " + this.id;	}}ORYX.Plugins.ShapeMenuButton = Clazz.extend(ORYX.Plugins.ShapeMenuButton);//create command for undo/redoORYX.Plugins.ShapeMenuPlugin.CreateCommand = ORYX.Core.Command.extend({	construct: function(option, currentReference, position, plugin){		this.option = option;		this.currentReference = currentReference;		this.position = position;		this.plugin = plugin;		this.shape;		this.edge;		this.targetRefPos;		this.sourceRefPos;		/*		 * clone options parameters		 */        this.connectedShape = option.connectedShape;        this.connectingType = option.connectingType;        this.namespace = option.namespace;        this.type = option.type;        this.containedStencil = option.containedStencil;        this.parent = option.parent;        this.currentReference = currentReference;        this.shapeOptions = option.shapeOptions;	},				execute: function(){				var resume = false;				if (this.shape) {			if (this.shape instanceof ORYX.Core.Node) {				this.parent.add(this.shape);				if (this.edge) {					this.plugin.facade.getCanvas().add(this.edge);					this.edge.dockers.first().setDockedShape(this.connectedShape);					this.edge.dockers.first().setReferencePoint(this.sourceRefPos);					this.edge.dockers.last().setDockedShape(this.shape);					this.edge.dockers.last().setReferencePoint(this.targetRefPos);				}								this.plugin.facade.setSelection([this.shape]);							} else if (this.shape instanceof ORYX.Core.Edge) {				this.plugin.facade.getCanvas().add(this.shape);				this.shape.dockers.first().setDockedShape(this.connectedShape);				this.shape.dockers.first().setReferencePoint(this.sourceRefPos);			}			resume = true;		}		else {			this.shape = this.plugin.facade.createShape(this.option);			this.edge = (!(this.shape instanceof ORYX.Core.Edge)) ? this.shape.getIncomingShapes().first() : undefined;		}				if (this.currentReference && this.position) {						if (this.shape instanceof ORYX.Core.Edge) {							if (!(this.currentReference instanceof ORYX.Core.Canvas)) {					this.shape.dockers.last().setDockedShape(this.currentReference);										// @deprecated It now uses simply the midpoint					var upL = this.currentReference.absoluteXY();					var refPos = {						x: this.position.x - upL.x,						y: this.position.y - upL.y					};										this.shape.dockers.last().setReferencePoint(this.currentReference.bounds.midPoint());				}				else {					this.shape.dockers.last().bounds.centerMoveTo(this.position);					//this.shape.dockers.last().update();				}				this.sourceRefPos = this.shape.dockers.first().referencePoint;				this.targetRefPos = this.shape.dockers.last().referencePoint;							} else if (this.edge){				this.sourceRefPos = this.edge.dockers.first().referencePoint;				this.targetRefPos = this.edge.dockers.last().referencePoint;			}		} else {			var containedStencil = this.containedStencil;			var connectedShape = this.connectedShape;			var bc = connectedShape.bounds;			var bs = this.shape.bounds;						var pos = bc.center();			if(containedStencil.defaultAlign()==="north") {				pos.y -= (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.height()/2);			} else if(containedStencil.defaultAlign()==="northeast") {				pos.x += (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);				pos.y -= (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);			} else if(containedStencil.defaultAlign()==="southeast") {				pos.x += (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);				pos.y += (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);			} else if(containedStencil.defaultAlign()==="south") {				pos.y += (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.height()/2);			} else if(containedStencil.defaultAlign()==="southwest") {				pos.x -= (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);				pos.y += (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);			} else if(containedStencil.defaultAlign()==="west") {				pos.x -= (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.width()/2);			} else if(containedStencil.defaultAlign()==="northwest") {				pos.x -= (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.width()/2);				pos.y -= (bc.height() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET_CORNER + (bs.height()/2);			} else {				pos.x += (bc.width() / 2) + ORYX.CONFIG.SHAPEMENU_CREATE_OFFSET + (bs.width()/2);			}						// Move shape to the new position			this.shape.bounds.centerMoveTo(pos);						// Move all dockers of a node to the position			if (this.shape instanceof ORYX.Core.Node){				(this.shape.dockers||[]).each(function(docker){					docker.bounds.centerMoveTo(pos);				})			}						//this.shape.update();			this.position = pos;						if (this.edge){				this.sourceRefPos = this.edge.dockers.first().referencePoint;				this.targetRefPos = this.edge.dockers.last().referencePoint;			}		}				this.plugin.facade.getCanvas().update();		this.plugin.facade.updateSelection();				if (!resume) {			// If there is a connected shape			if (this.edge){				// Try to layout it				this.plugin.doLayout(this.edge);			} else if (this.shape instanceof ORYX.Core.Edge){				// Try to layout it				this.plugin.doLayout(this.shape);			}		}	},	rollback: function(){		this.plugin.facade.deleteShape(this.shape);		if(this.edge) {			this.plugin.facade.deleteShape(this.edge);		}		//this.currentParent.update();		this.plugin.facade.setSelection(this.plugin.facade.getSelection().without(this.shape, this.edge));	}});/** * Copyright (c) 2009 * Jan-Felix Schwarz * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins) {	ORYX.Plugins = new Object();}ORYX.Plugins.SelectStencilSetPerspective = {	facade: undefined,		extensions : undefined,		perspectives: undefined,	construct: function(facade) {		this.facade = facade;		var panel = new Ext.Panel({			cls:'selectssperspective',			border: false,			autoScroll:true		});		var region = this.facade.addToRegion("west", panel);		var url = ORYX.CONFIG.SS_EXTENSIONS_CONFIG;				new Ajax.Request(url, {			method: 'GET',			asynchronous: false,			onSuccess: (function(transport) {				try {					eval("var jsonObject = " + transport.responseText);										/* Determine available extensions */					this.extensions = {};					jsonObject.extensions.each(function(ext) {						this.extensions[ext.namespace] = ext;					}.bind(this));										this.perspectives = {};					jsonObject.perspectives.each(function(per) {						this.perspectives[per.namespace] = per;					}.bind(this));					this.facade.getStencilSets().values().each((function(sset) {						var validPerspectives = jsonObject.perspectives.findAll(function(perspective){							if(perspective.stencilset == sset.namespace()) return true;							else return false;						}); 						if(validPerspectives.size()>0)							this.createPerspectivesCombobox(panel, sset, validPerspectives);					}).bind(this));									} catch (e) {					ORYX.Log.debug(ORYX.I18N.SSExtensionLoader.failed1);					Ext.Msg.alert("Oryx", ORYX.I18N.SSExtensionLoader.failed1);				}			}).bind(this),			onFailure: (function(transport){				Ext.Msg.alert("Oryx", ORYX.I18N.SSExtensionLoader.failed2);			}).bind(this)		});  	},	createPerspectivesCombobox: function(panel, stencilset, perspectives) {			var data = new Array();		perspectives.each(function(perspective) {			data.push([perspective.namespace, perspective.title, perspective.description]);		});			var store = new Ext.data.SimpleStore({			fields: ['namespace', 'title', 'tooltip'],			data: data		});			var combobox = new Ext.form.ComboBox({			store: store,			displayField:'title',			forceSelection: true,			typeAhead: true,			mode: 'local',			width: 168,			triggerAction: 'all',			emptyText:'Select a perspective...',			selectOnFocus:true,			tpl: '<tpl for="."><div ext:qtip="{tooltip}" class="x-combo-list-item">{title}</div></tpl>'		});				combobox.on('select', this.onSelect ,this)			panel.add(combobox);		panel.doLayout();	},		onSelect: function(combobox, record) {		var ns = record.json[0];				/* Get loaded stencil set extensions */		var stencilSets = this.facade.getStencilSets();		var loadedExtensions = new Object();				stencilSets.values().each(function(ss) { 	    	ss.extensions().values().each(function(extension) {				if(this.extensions[extension.namespace])					loadedExtensions[extension.namespace] = extension;			}.bind(this));		}.bind(this));				/* Determine extensions that are required for this perspective */		var addExtensions = new Array();		if(this.perspectives[ns].addExtensions) {			this.perspectives[ns].addExtensions.each(function(ext){				if(!ext.ifIsLoaded) {					addExtensions.push(this.extensions[ext]);					return;				}								if(loadedExtensions[ext.ifIsLoaded] && this.extensions[ext.add]) {					addExtensions.push(this.extensions[ext.add]);				} else {					if(ext["default"] && this.extensions[ext["default"]]) {						addExtensions.push(this.extensions[ext["default"]]);					}				}			}.bind(this));		}				/* Determine extension that are not allowed in this perspective */				/* Check if flag to remove all other extension is set */		if(this.perspectives[ns].removeAllExtensions) {			this._loadExtensions(addExtensions, undefined, true);				return;				}				/* Check on specific extensions */		var removeExtensions = new Array();		if(this.perspectives[ns].removeExtensions) {			this.perspectives[ns].removeExtensions.each(function(ns){				removeExtensions.push(this.extensions[ns]);			}.bind(this));		}				this._loadExtensions(addExtensions, removeExtensions, false);	},		/*	 * Load all stencil set extensions specified in param extensions (key map: String -> Object)	 * Unload all other extensions (method copied from addssextension plugin)	 */	_loadExtensions: function(addExtensions, removeExtensions, removeAll) {		var stencilsets = this.facade.getStencilSets();				var atLeastOne = false;				// unload unselected extensions		stencilsets.values().each(function(stencilset) {			var unselected = stencilset.extensions().values().select(function(ext) { return addExtensions[ext.namespace] == undefined }); 			if(removeAll) {				unselected.each(function(ext) {					stencilset.removeExtension(ext.namespace);					atLeastOne = true;				});			} else {				unselected.each(function(ext) {					var remove = removeExtensions.find(function(remExt) {						return ext.namespace === remExt.namespace;					});										if(remove) {						stencilset.removeExtension(ext.namespace);						atLeastOne = true;					}				});			}		});				// load selected extensions		addExtensions.each(function(extension) {						var stencilset = stencilsets[extension["extends"]];						if(stencilset) {				stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension.definition);				atLeastOne = true;			}		}.bind(this));				if (atLeastOne) {			stencilsets.values().each(function(stencilset) {				this.facade.getRules().initializeRules(stencilset);			}.bind(this));			this.facade.raiseEvent({				type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED			});			var selection = this.facade.getSelection();			this.facade.setSelection();			this.facade.setSelection(selection);		}	}}ORYX.Plugins.SelectStencilSetPerspective = Clazz.extend(ORYX.Plugins.SelectStencilSetPerspective);/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins) {	ORYX.Plugins = new Object();}ORYX.Plugins.ShapeRepository = {	facade: undefined,	construct: function(facade) {		this.facade = facade;		this._currentParent;		this._canContain = undefined;		this._canAttach  = undefined;		this.shapeList = new Ext.tree.TreeNode({					})		var panel = new Ext.tree.TreePanel({            cls:'shaperepository',			loader: new Ext.tree.TreeLoader(),			root: this.shapeList,			autoScroll:true,			rootVisible: false,			lines: false,			anchors: '0, -30'		})		var region = this.facade.addToRegion("west", panel, ORYX.I18N.ShapeRepository.title);					// Create a Drag-Zone for Drag'n'Drop		var DragZone = new Ext.dd.DragZone(this.shapeList.getUI().getEl(), {shadow: !Ext.isMac});		DragZone.afterDragDrop = this.drop.bind(this, DragZone);		DragZone.beforeDragOver = this.beforeDragOver.bind(this, DragZone);		DragZone.beforeDragEnter = function(){this._lastOverElement = false; return true}.bind(this);				// Load all Stencilssets		this.setStencilSets();				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, this.setStencilSets.bind(this));	},			/**	 * Load all stencilsets in the shaperepository	 */	setStencilSets: function() {		// Remove all childs		var child = this.shapeList.firstChild;		while(child) {			this.shapeList.removeChild(child);			child = this.shapeList.firstChild;		}		// Go thru all Stencilsets and stencils		this.facade.getStencilSets().values().each((function(sset) {						// For each Stencilset create and add a new Tree-Node			var stencilSetNode						var typeTitle = sset.title();			var extensions = sset.extensions();			if (extensions && extensions.size() > 0) {				typeTitle += " / " + ORYX.Core.StencilSet.getTranslation(extensions.values()[0], "title");			} 						this.shapeList.appendChild(stencilSetNode = new Ext.tree.TreeNode({				text:typeTitle, 			// Stencilset Name				allowDrag:false,        		allowDrop:false,           				iconCls:'headerShapeRepImg',	            cls:'headerShapeRep',				singleClickExpand:true}));						stencilSetNode.render();			stencilSetNode.expand();							// Get Stencils from Stencilset			var stencils = sset.stencils(this.facade.getCanvas().getStencil(),										 this.facade.getRules());				var treeGroups = new Hash();						// Sort the stencils according to their position and add them to the repository			stencils = stencils.sortBy(function(value) { return value.position(); } );			stencils.each((function(value) {								// Show stencils in no group if there is less than 10 shapes				if(stencils.length <= ORYX.CONFIG.MAX_NUM_SHAPES_NO_GROUP) {					this.createStencilTreeNode(stencilSetNode, value);						return;									}								// Get the groups name				var groups = value.groups();								// For each Group-Entree				groups.each((function(group) {										// If there is a new group					if(!treeGroups[group]) {						// Create a new group						treeGroups[group] = new Ext.tree.TreeNode({							text:group,					// Group-Name							allowDrag:false,        					allowDrop:false,            							iconCls:'headerShapeRepImg', // Css-Class for Icon				            cls:'headerShapeRepChild',  // CSS-Class for Stencil-Group							singleClickExpand:true});												// Add the Group to the ShapeRepository						stencilSetNode.appendChild(treeGroups[group]);						treeGroups[group].render();						}										// Create the Stencil-Tree-Node					this.createStencilTreeNode(treeGroups[group], value);										}).bind(this));												// If there is no group				if(groups.length == 0) {					// Create the Stencil-Tree-Node					this.createStencilTreeNode(stencilSetNode, value);										}				}).bind(this));		}).bind(this));					if (this.shapeList.firstChild.firstChild) {			this.shapeList.firstChild.firstChild.expand(false, true);		}		},	createStencilTreeNode: function(parentTreeNode, stencil) {		// Create and add the Stencil to the Group		var newElement = new Ext.tree.TreeNode({				text:		stencil.title(), 		// Text of the stencil				icon:		stencil.icon(),			// Icon of the stencil				allowDrag:	false,					// Don't use the Drag and Drop of Ext-Tree				allowDrop:	false,				iconCls:	'ShapeRepEntreeImg', 	// CSS-Class for Icon				cls:		'ShapeRepEntree'		// CSS-Class for the Tree-Entree				});		parentTreeNode.appendChild(newElement);				newElement.render();							var ui = newElement.getUI();				// Set the tooltip		ui.elNode.setAttributeNS(null, "title", stencil.description());				// Register the Stencil on Drag and Drop		Ext.dd.Registry.register(ui.elNode, {				node: 		ui.node,		        handles: 	[ui.elNode, ui.textNode].concat($A(ui.elNode.childNodes)), // Set the Handles		        isHandle: 	false,				type:		stencil.id(),			// Set Type of stencil 				namespace:	stencil.namespace()		// Set Namespace of stencil				});									},		drop: function(dragZone, target, event) {				this._lastOverElement = undefined;				// Hide the highlighting		this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'shapeRepo.added'});		this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'shapeRepo.attached'});				// Check if drop is allowed		var proxy = dragZone.getProxy()		if(proxy.dropStatus == proxy.dropNotAllowed) { return }				// Check if there is a current Parent		if(!this._currentParent) { return }				var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);				var xy = event.getXY();		var pos = {x: xy[0], y: xy[1]};		var a = this.facade.getCanvas().node.getScreenCTM();		// Correcting the UpperLeft-Offset		pos.x -= a.e; pos.y -= a.f;		// Correcting the Zoom-Faktor		pos.x /= a.a; pos.y /= a.d;		// Correting the ScrollOffset		pos.x -= document.documentElement.scrollLeft;		pos.y -= document.documentElement.scrollTop;		// Correct position of parent		var parentAbs = this._currentParent.absoluteXY();		pos.x -= parentAbs.x;		pos.y -= parentAbs.y;		// Set position		option['position'] = pos				// Set parent		if( this._canAttach &&  this._currentParent instanceof ORYX.Core.Node ){			option['parent'] = undefined;			} else {			option['parent'] = this._currentParent;		}						var commandClass = ORYX.Core.Command.extend({			construct: function(option, currentParent, canAttach, position, facade){				this.option = option;				this.currentParent = currentParent;				this.canAttach = canAttach;				this.position = position;				this.facade = facade;				this.selection = this.facade.getSelection();				this.shape;				this.parent;			},						execute: function(){				if (!this.shape) {					this.shape 	= this.facade.createShape(option);					this.parent = this.shape.parent;				} else {					this.parent.add(this.shape);				}																	if( this.canAttach &&  this.currentParent instanceof ORYX.Core.Node && this.shape.dockers.length > 0){										var docker = this.shape.dockers[0];							if( this.currentParent.parent instanceof ORYX.Core.Node ) {						this.currentParent.parent.add( docker.parent );					}																	docker.bounds.centerMoveTo( this.position );					docker.setDockedShape( this.currentParent );					//docker.update();					}						//this.currentParent.update();				//this.shape.update();				this.facade.setSelection([this.shape]);				this.facade.getCanvas().update();				this.facade.updateSelection();							},			rollback: function(){				this.facade.deleteShape(this.shape);								//this.currentParent.update();				this.facade.setSelection(this.selection.without(this.shape));				this.facade.getCanvas().update();				this.facade.updateSelection();							}		});									var position = this.facade.eventCoordinates( event.browserEvent );								var command = new commandClass(option, this._currentParent, this._canAttach, position, this.facade);				this.facade.executeCommands([command]);				this._currentParent = undefined;	},	beforeDragOver: function(dragZone, target, event){		var coord = this.facade.eventCoordinates(event.browserEvent);		var aShapes = this.facade.getCanvas().getAbstractShapesAtPosition( coord );		if(aShapes.length <= 0) {							var pr = dragZone.getProxy();				pr.setStatus(pr.dropNotAllowed);				pr.sync();								return false;		}					var el = aShapes.last();					if(aShapes.lenght == 1 && aShapes[0] instanceof ORYX.Core.Canvas) {						return false;					} else {			// check containment rules			var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);			var stencilSet = this.facade.getStencilSets()[option.namespace];			var stencil = stencilSet.stencil(option.type);			if(stencil.type() === "node") {								var parentCandidate = aShapes.reverse().find(function(candidate) {					return (candidate instanceof ORYX.Core.Canvas 							|| candidate instanceof ORYX.Core.Node							|| candidate instanceof ORYX.Core.Edge);				});								if(  parentCandidate !== this._lastOverElement){										this._canAttach  = undefined;					this._canContain = undefined;									}								if( parentCandidate ) {					//check containment rule																if (!(parentCandidate instanceof ORYX.Core.Canvas) && parentCandidate.isPointOverOffset(coord.x, coord.y) && this._canAttach == undefined) {											this._canAttach = this.facade.getRules().canConnect({												sourceShape: parentCandidate,												edgeStencil: stencil,												targetStencil: stencil											});												if( this._canAttach ){							// Show Highlight							this.facade.raiseEvent({								type: ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,								highlightId: "shapeRepo.attached",								elements: [parentCandidate],								style: ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,								color: ORYX.CONFIG.SELECTION_VALID_COLOR							});														this.facade.raiseEvent({								type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,								highlightId: "shapeRepo.added"							});														this._canContain	= undefined;						} 																}										if(!(parentCandidate instanceof ORYX.Core.Canvas) && !parentCandidate.isPointOverOffset(coord.x, coord.y)){						this._canAttach 	= this._canAttach == false ? this._canAttach : undefined;											}										if( this._canContain == undefined && !this._canAttach) {																	this._canContain = this.facade.getRules().canContain({															containingShape:parentCandidate, 															containedStencil:stencil															});																					// Show Highlight						this.facade.raiseEvent({															type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 															highlightId:'shapeRepo.added',															elements:	[parentCandidate],															color:		this._canContain ? ORYX.CONFIG.SELECTION_VALID_COLOR : ORYX.CONFIG.SELECTION_INVALID_COLOR														});							this.facade.raiseEvent({															type: 		ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,															highlightId:"shapeRepo.attached"														});											}																				this._currentParent = this._canContain || this._canAttach ? parentCandidate : undefined;					this._lastOverElement = parentCandidate;					var pr = dragZone.getProxy();					pr.setStatus(this._currentParent ? pr.dropAllowed : pr.dropNotAllowed );					pr.sync();					} 			} else { //Edge				this._currentParent = this.facade.getCanvas();				var pr = dragZone.getProxy();				pr.setStatus(pr.dropAllowed);				pr.sync();			}				}						return false	}	}ORYX.Plugins.ShapeRepository = Clazz.extend(ORYX.Plugins.ShapeRepository);

/**
 * Copyright (c) 2010
 * Daniel Schleicher
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


if(!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}

ORYX.Plugins.FragmentRepository = Clazz.extend({

				
	facade: undefined,

	construct: function(facade) {
		this.facade = facade;
		this._currentParent;
		this._canContain = undefined;
		this._canAttach  = undefined;

		this.shapeList = new Ext.tree.TreeNode({
			
		})

		var panel = new Ext.tree.TreePanel({
            cls:'shaperepository',
			loader: new Ext.tree.TreeLoader(),
			root: this.shapeList,
			autoScroll:true,
			rootVisible: false,
			lines: false,
			autoHeight: true,
			anchors: '0, -30'
		})
		var region = this.facade.addToRegion("east", panel, ORYX.I18N.ShapeRepository.title);
	
		
		// Create a Drag-Zone for Drag'n'Drop
		var DragZone = new Ext.dd.DragZone(this.shapeList.getUI().getEl(), {shadow: !Ext.isMac});
		DragZone.afterDragDrop = this.drop.bind(this, DragZone);
		//DragZone.beforeDragOver = this.beforeDragOver.bind(this, DragZone);
		DragZone.beforeDragEnter = function(){this._lastOverElement = false; return true}.bind(this);
		
		// Load all Stencilssets
		this.setStencilSets();
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, this.setStencilSets.bind(this));

		},

		/**
		 * Load all stencilsets in the shaperepository
		 */
		setStencilSets: function() {
			// Remove all childs
			var child = this.shapeList.firstChild;
			while(child) {
				this.shapeList.removeChild(child);
				child = this.shapeList.firstChild;
			}

/*			// Go thru all Stencilsets and stencils
			this.facade.getStencilSets().values().each((function(sset) {
*/				
				// For each Stencilset create and add a new Tree-Node
				var stencilSetNode
				
				var typeTitle = "Fragment Repository";
	/*			var extensions = sset.extensions();
				if (extensions && extensions.size() > 0) {
					typeTitle += " / " + ORYX.Core.StencilSet.getTranslation(extensions.values()[0], "title");
				} 
	*/			
				this.shapeList.appendChild(stencilSetNode = new Ext.tree.TreeNode({
					text:typeTitle, 			// Stencilset Name
					allowDrag:false,
	        		allowDrop:false,           
					iconCls:'headerShapeRepImg',
		            cls:'headerShapeRep',
					singleClickExpand:true}));
				
				stencilSetNode.render();
				stencilSetNode.expand();	
				
				this.createStencilTreeNode(stencilSetNode, "description");	
				// Get Stencils from Stencilset
/*				var stencils = sset.stencils(this.facade.getCanvas().getStencil(),
											 this.facade.getRules());	
				var treeGroups = new Hash();
				
				// Sort the stencils according to their position and add them to the repository
				stencils = stencils.sortBy(function(value) { return value.position(); } );
				stencils.each((function(value) {
					
					// Show stencils in no group if there is less than 10 shapes
					if(stencils.length <= ORYX.CONFIG.MAX_NUM_SHAPES_NO_GROUP) {
						this.createStencilTreeNode(stencilSetNode, value);	
						return;					
					}
					
					// Get the groups name
					var groups = value.groups();
					
					// For each Group-Entree
					groups.each((function(group) {
						
						// If there is a new group
						if(!treeGroups[group]) {
							// Create a new group
							treeGroups[group] = new Ext.tree.TreeNode({
								text:group,					// Group-Name
								allowDrag:false,
	        					allowDrop:false,            
								iconCls:'headerShapeRepImg', // Css-Class for Icon
					            cls:'headerShapeRepChild',  // CSS-Class for Stencil-Group
								singleClickExpand:true});
							
							// Add the Group to the ShapeRepository
							stencilSetNode.appendChild(treeGroups[group]);
							treeGroups[group].render();	
						}
						
						// Create the Stencil-Tree-Node
						this.createStencilTreeNode(treeGroups[group], value);	
						
					}).bind(this));
					
					
					// If there is no group
					if(groups.length == 0) {
						// Create the Stencil-Tree-Node
						this.createStencilTreeNode(stencilSetNode, value);						
					}
		
				}).bind(this));
*/			//}).bind(this));
				
			if (this.shapeList.firstChild.firstChild) {
				this.shapeList.firstChild.firstChild.expand(false, true);
			}	
		},

		createStencilTreeNode: function(parentTreeNode, stencil) {

			// Create and add the Stencil to the Group
			var newElement = new Ext.tree.TreeNode({
					text:		"Task", 		// Text of the stencil
					icon:		ORYX.PATH + "/stencilsets/bpmn2.0/icons/activity/task.png",			// Icon of the stencil
					allowDrag:	false,					// Don't use the Drag and Drop of Ext-Tree
					allowDrop:	false,
					iconCls:	'ShapeRepEntreeImg', 	// CSS-Class for Icon
					cls:		'ShapeRepEntree'		// CSS-Class for the Tree-Entree
					});

			parentTreeNode.appendChild(newElement);		
			newElement.render();	
					
			var ui = newElement.getUI();
			
			// Set the tooltip
			ui.elNode.setAttributeNS(null, "title", stencil);
			
			// Register the Stencil on Drag and Drop
			Ext.dd.Registry.register(ui.elNode, {
					node: 		ui.node,
			        handles: 	[ui.elNode, ui.textNode].concat($A(ui.elNode.childNodes)), // Set the Handles
			        isHandle: 	false,
					type:		"http://b3mn.org/stencilset/bpmn2.0#Task",			// Set Type of stencil 
					namespace:	"http://b3mn.org/stencilset/bpmn2.0#"	// Set Namespace of stencil
					});
									
		},
		
		drop: function(dragZone, target, event) {
			
			this._lastOverElement = undefined;
			
			// Hide the highlighting
			this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'shapeRepo.added'});
			this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'shapeRepo.attached'});
			
			// Check if drop is allowed
			var proxy = dragZone.getProxy()
			if(proxy.dropStatus == proxy.dropNotAllowed) { return }
			
			// Check if there is a current Parent
/*			if(!this._currentParent) { return }
			
			var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);
			
			var xy = event.getXY();
			var pos = {x: xy[0], y: xy[1]};

			var a = this.facade.getCanvas().node.getScreenCTM();

			// Correcting the UpperLeft-Offset
			pos.x -= a.e; pos.y -= a.f;		// Correcting the Zoom-Faktor
			pos.x /= a.a; pos.y /= a.d;
			// Correting the ScrollOffset
			pos.x -= document.documentElement.scrollLeft;
			pos.y -= document.documentElement.scrollTop;
			// Correct position of parent
			var parentAbs = this._currentParent.absoluteXY();
			pos.x -= parentAbs.x;
			pos.y -= parentAbs.y;

			// Set position
			option['position'] = pos
			
			// Set parent
			if( this._canAttach &&  this._currentParent instanceof ORYX.Core.Node ){
				option['parent'] = undefined;	
			} else {
				option['parent'] = this._currentParent;
			}
			
			
			var commandClass = ORYX.Core.Command.extend({
				construct: function(option, currentParent, canAttach, position, facade){
					this.option = option;
					this.currentParent = currentParent;
					this.canAttach = canAttach;
					this.position = position;
					this.facade = facade;
					this.selection = this.facade.getSelection();
					this.shape;
					this.parent;
				},			
				execute: function(){
					if (!this.shape) {
						this.shape 	= this.facade.createShape(option);
						this.parent = this.shape.parent;
					} else {
						this.parent.add(this.shape);
					}
						
					
					
					if( this.canAttach &&  this.currentParent instanceof ORYX.Core.Node && this.shape.dockers.length > 0){
						
						var docker = this.shape.dockers[0];
			
						if( this.currentParent.parent instanceof ORYX.Core.Node ) {
							this.currentParent.parent.add( docker.parent );
						}
													
						docker.bounds.centerMoveTo( this.position );
						docker.setDockedShape( this.currentParent );
						//docker.update();	
					}
			
					//this.currentParent.update();
					//this.shape.update();

					this.facade.setSelection([this.shape]);
					this.facade.getCanvas().update();
					this.facade.updateSelection();
					
				},
				rollback: function(){
					this.facade.deleteShape(this.shape);
					
					//this.currentParent.update();

					this.facade.setSelection(this.selection.without(this.shape));
					this.facade.getCanvas().update();
					this.facade.updateSelection();
					
				}
			});
								
			var position = this.facade.eventCoordinates( event.browserEvent );	
						
			var command = new commandClass(option, this._currentParent, this._canAttach, position, this.facade);
			
			this.facade.executeCommands([command]);
			
			this._currentParent = undefined;*/
			
			var fragmentToBeImported = {
					   "resourceId":"oryx-canvas123",
					   "properties":{
					      "id":"",
					      "name":"",
					      "documentation":"",
					      "auditing":"",
					      "monitoring":"",
					      "version":"",
					      "author":"",
					      "language":"English",
					      "namespaces":"",
					      "targetnamespace":"http://www.omg.org/bpmn20",
					      "expressionlanguage":"http://www.w3.org/1999/XPath",
					      "typelanguage":"http://www.w3.org/2001/XMLSchema",
					      "creationdate":"",
					      "modificationdate":""
					   },
					   "stencil":{
					      "id":"BPMNDiagram"
					   },
					   "childShapes":[
					      {
					         "resourceId":"oryx_C2AE5B00-4718-4FD3-A60B-8B0C300223F2",
					         "properties":{
					            "id":"",
					            "name":"",
					            "documentation":"",
					            "auditing":"",
					            "monitoring":"",
					            "categories":"",
					            "startquantity":1,
					            "completionquantity":1,
					            "status":"None",
					            "performers":"",
					            "properties":"",
					            "inputsets":"",
					            "inputs":"",
					            "outputsets":"",
					            "outputs":"",
					            "iorules":"",
					            "testtime":"After",
					            "mi_condition":"",
					            "mi_flowcondition":"All",
					            "isforcompensation":"",
					            "assignments":"",
					            "pool":"",
					            "lanes":"",
					            "looptype":"None",
					            "loopcondition":"",
					            "loopcounter":1,
					            "loopmaximum":1,
					            "callacitivity":"",
					            "activitytype":"Task",
					            "tasktype":"Send",
					            "inmessage":"",
					            "outmessage":"",
					            "implementation":"webService",
					            "resources":"",
					            "complexmi_condition":"",
					            "messageref":"",
					            "operationref":"",
					            "taskref":"",
					            "instantiate":"",
					            "script":"",
					            "script_language":"",
					            "bgcolor":"#ffffcc"
					         },
					         "stencil":{
					            "id":"Task"
					         },
					         "childShapes":[

					         ],
					         "outgoing":[

					         ],
					         "bounds":{
					            "lowerRight":{
					               "x":251,
					               "y":180
					            },
					            "upperLeft":{
					               "x":151,
					               "y":100
					            }
					         },
					         "dockers":[

					         ]
					      }
					   ],
					   "bounds":{
					      "lowerRight":{
					         "x":1485,
					         "y":1050
					      },
					      "upperLeft":{
					         "x":0,
					         "y":0
					      }
					   },
					   "stencilset":{
					      "url":ORYX.PATH + "/stencilsets/bpmn2.0/bpmn2.0.json",
					      "namespace":"http://b3mn.org/stencilset/bpmn2.0#"
					   },
					   "ssextensions":[
					      "http://oryx-editor.org/stencilsets/extensions/bpmnComplianceTemplate#"
					   ]
					}
;
		
		//We have to put the fragment on the same 
		//position where the mouse-up event occured. 
		var positionOfFragment = fragmentToBeImported.childShapes[0].bounds.upperLeft.x;
		var eventCoordinates = event.getXY();	
		
		var matrix = this.facade.getCanvas().node.getScreenCTM();

		// Correcting the UpperLeft-Offset
		eventCoordinates[0] -= matrix.e; 
		eventCoordinates[1] -= matrix.f;		// Correcting the Zoom-Faktor
		
		eventCoordinates[0] /= matrix.a; 
		eventCoordinates[1] /= matrix.d; // Correting the ScrollOffset
		eventCoordinates[0] -= document.documentElement.scrollLeft;
		eventCoordinates[1] -= document.documentElement.scrollTop;
		// Correct position of parent
/*		var parentAbs = this._currentParent.absoluteXY();
		eventCoordinates[0] -= parentAbs.x;
		eventCoordinates[1] -= parentAbs.y;
*/		
		fragmentToBeImported.childShapes[0].bounds.upperLeft.x = eventCoordinates[0];
		fragmentToBeImported.childShapes[0].bounds.upperLeft.y = eventCoordinates[1];
		
		fragmentToBeImported.childShapes[0].bounds.lowerRight.x = eventCoordinates[0] + 100;
		fragmentToBeImported.childShapes[0].bounds.lowerRight.y = eventCoordinates[1] + 80;
		
		
		this.facade.importJSON(fragmentToBeImported, true);
		
		},

		beforeDragOver: function(dragZone, target, event){

			var coord = this.facade.eventCoordinates(event.browserEvent);
			var aShapes = this.facade.getCanvas().getAbstractShapesAtPosition( coord );

			if(aShapes.length <= 0) {
				
					var pr = dragZone.getProxy();
					pr.setStatus(pr.dropNotAllowed);
					pr.sync();
					
					return false;
			}	
			
			var el = aShapes.last();
		
			
			if(aShapes.lenght == 1 && aShapes[0] instanceof ORYX.Core.Canvas) {
				
				return false;
				
			} else {
				// check containment rules
				var option = Ext.dd.Registry.getHandle(target.DDM.currentTarget);

				var stencilSet = this.facade.getStencilSets()[option.namespace];

				var stencil = stencilSet.stencil(option.type);

				if(stencil.type() === "node") {
					
					var parentCandidate = aShapes.reverse().find(function(candidate) {
						return (candidate instanceof ORYX.Core.Canvas 
								|| candidate instanceof ORYX.Core.Node
								|| candidate instanceof ORYX.Core.Edge);
					});
					
					if(  parentCandidate !== this._lastOverElement){
						
						this._canAttach  = undefined;
						this._canContain = undefined;
						
					}
					
					if( parentCandidate ) {
						//check containment rule					
							
						if (!(parentCandidate instanceof ORYX.Core.Canvas) && parentCandidate.isPointOverOffset(coord.x, coord.y) && this._canAttach == undefined) {
						
							this._canAttach = this.facade.getRules().canConnect({
													sourceShape: parentCandidate,
													edgeStencil: stencil,
													targetStencil: stencil
												});
							
							if( this._canAttach ){
								// Show Highlight
								this.facade.raiseEvent({
									type: ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,
									highlightId: "shapeRepo.attached",
									elements: [parentCandidate],
									style: ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,
									color: ORYX.CONFIG.SELECTION_VALID_COLOR
								});
								
								this.facade.raiseEvent({
									type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
									highlightId: "shapeRepo.added"
								});
								
								this._canContain	= undefined;
							} 					
							
						}
						
						if(!(parentCandidate instanceof ORYX.Core.Canvas) && !parentCandidate.isPointOverOffset(coord.x, coord.y)){
							this._canAttach 	= this._canAttach == false ? this._canAttach : undefined;						
						}
						
						if( this._canContain == undefined && !this._canAttach) {
												
							this._canContain = this.facade.getRules().canContain({
																containingShape:parentCandidate, 
																containedStencil:stencil
																});
																
							// Show Highlight
							this.facade.raiseEvent({
																type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
																highlightId:'shapeRepo.added',
																elements:	[parentCandidate],
																color:		this._canContain ? ORYX.CONFIG.SELECTION_VALID_COLOR : ORYX.CONFIG.SELECTION_INVALID_COLOR
															});	
							this.facade.raiseEvent({
																type: 		ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
																highlightId:"shapeRepo.attached"
															});						
						}
							
					
						
						this._currentParent = this._canContain || this._canAttach ? parentCandidate : undefined;
						this._lastOverElement = parentCandidate;
						var pr = dragZone.getProxy();
						pr.setStatus(this._currentParent ? pr.dropAllowed : pr.dropNotAllowed );
						pr.sync();
		
					} 
				} else { //Edge
					this._currentParent = this.facade.getCanvas();
					var pr = dragZone.getProxy();
					pr.setStatus(pr.dropAllowed);
					pr.sync();
				}		
			}
			
			
			return false
		}	
});
/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


if(!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}

ORYX.Plugins.PropertyWindow = {

	facade: undefined,

	construct: function(facade) {
		// Reference to the Editor-Interface
		this.facade = facade;

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHOW_PROPERTYWINDOW, this.init.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.selectDiagram.bind(this));
		this.init();
	},
	
	init: function(){

		// The parent div-node of the grid
		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml",
			null,
			['div']);

		// If the current property in focus is of type 'Date', the date format
		// is stored here.
		this.currentDateFormat;

		// the properties array
		this.popularProperties = [];
		this.properties = [];
		
		/* The currently selected shapes whos properties will shown */
		this.shapeSelection = new Hash();
		this.shapeSelection.shapes = new Array();
		this.shapeSelection.commonProperties = new Array();
		this.shapeSelection.commonPropertiesValues = new Hash();
		
		this.updaterFlag = false;

		// creating the column model of the grid.
		this.columnModel = new Ext.grid.ColumnModel([
			{
				//id: 'name',
				header: ORYX.I18N.PropertyWindow.name,
				dataIndex: 'name',
				width: 90,
				sortable: true,
				renderer: this.tooltipRenderer.bind(this)
			}, {
				//id: 'value',
				header: ORYX.I18N.PropertyWindow.value,
				dataIndex: 'value',
				id: 'propertywindow_column_value',
				width: 110,
				editor: new Ext.form.TextField({
					allowBlank: false
				}),
				renderer: this.renderer.bind(this)
			},
			{
				header: "Pop",
				dataIndex: 'popular',
				hidden: true,
				sortable: true
			}
		]);

		// creating the store for the model.
        this.dataSource = new Ext.data.GroupingStore({
			proxy: new Ext.data.MemoryProxy(this.properties),
			reader: new Ext.data.ArrayReader({}, [
				{name: 'popular'},
				{name: 'name'},
				{name: 'value'},
				{name: 'icons'},
				{name: 'gridProperties'}
			]),
			sortInfo: {field: 'popular', direction: "ASC"},
			sortData : function(f, direction){
		        direction = direction || 'ASC';
		        var st = this.fields.get(f).sortType;
		        var fn = function(r1, r2){
		            var v1 = st(r1.data[f]), v2 = st(r2.data[f]);
					var p1 = r1.data['popular'], p2  = r2.data['popular'];
		            return p1 && !p2 ? -1 : (!p1 && p2 ? 1 : (v1 > v2 ? 1 : (v1 < v2 ? -1 : 0)));
		        };
		        this.data.sort(direction, fn);
		        if(this.snapshot && this.snapshot != this.data){
		            this.snapshot.sort(direction, fn);
				}
		    },
			groupField: 'popular'
        });
		this.dataSource.load();
		
		this.grid = new Ext.grid.EditorGridPanel({
			clicksToEdit: 1,
			stripeRows: true,
			autoExpandColumn: "propertywindow_column_value",
			width:'auto',
			// the column model
			colModel: this.columnModel,
			enableHdMenu: false,
			view: new Ext.grid.GroupingView({
				forceFit: true,
				groupTextTpl: '{[values.rs.first().data.popular ? ORYX.I18N.PropertyWindow.oftenUsed : ORYX.I18N.PropertyWindow.moreProps]}'
			}),
			
			// the data store
			store: this.dataSource
			
		});

		region = this.facade.addToRegion('east', new Ext.Panel({
			width: 220,
			layout: "fit",
			border: false,
			title: 'Properties',
			items: [
				this.grid 
			]
		}), ORYX.I18N.PropertyWindow.title)

		// Register on Events
		this.grid.on('beforeedit', this.beforeEdit, this, true);
		this.grid.on('afteredit', this.afterEdit, this, true);
		this.grid.view.on('refresh', this.hideMoreAttrs, this, true);
		
		//this.grid.on(ORYX.CONFIG.EVENT_KEYDOWN, this.keyDown, this, true);
		
		// Renderer the Grid
		this.grid.enableColumnMove = false;
		//this.grid.render();

		// Sort as Default the first column
		//this.dataSource.sort('name');

	},
	
	// Select the Canvas when the editor is ready
	selectDiagram: function() {
		this.shapeSelection.shapes = [this.facade.getCanvas()];
		
		this.setPropertyWindowTitle();
		this.identifyCommonProperties();
		this.createProperties();
	},

	specialKeyDown: function(field, event) {
		// If there is a TextArea and the Key is an Enter
		if(field instanceof Ext.form.TextArea && event.button == ORYX.CONFIG.KEY_Code_enter) {
			// Abort the Event
			return false
		}
	},
	tooltipRenderer: function(value, p, record) {
		/* Prepare tooltip */
		p.cellAttr = 'title="' + record.data.gridProperties.tooltip + '"';
		return value;
	},
	
	renderer: function(value, p, record) {
		
		this.tooltipRenderer(value, p, record);
				
		if(value instanceof Date) {
			// TODO: Date-Schema is not generic
			value = value.dateFormat(ORYX.I18N.PropertyWindow.dateFormat);
		} else if(String(value).search("<a href='") < 0) {
			// Shows the Value in the Grid in each Line
			value = String(value).gsub("<", "&lt;");
			value = String(value).gsub(">", "&gt;");
			value = String(value).gsub("%", "&#37;");
			value = String(value).gsub("&", "&amp;");

			if(record.data.gridProperties.type == ORYX.CONFIG.TYPE_COLOR) {
				value = "<div class='prop-background-color' style='background-color:" + value + "' />";
			}			

			record.data.icons.each(function(each) {
				if(each.name == value) {
					if(each.icon) {
						value = "<img src='" + each.icon + "' /> " + value;
					}
				}
			});
		}

		return value;
	},

	beforeEdit: function(option) {

		var editorGrid 		= this.dataSource.getAt(option.row).data.gridProperties.editor;
		var editorRenderer 	= this.dataSource.getAt(option.row).data.gridProperties.renderer;

		if(editorGrid) {
			// Disable KeyDown
			this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);

			option.grid.getColumnModel().setEditor(1, editorGrid);
			
			editorGrid.field.row = option.row;
			// Render the editor to the grid, therefore the editor is also available 
			// for the first and last row
			editorGrid.render(this.grid);
			
			//option.grid.getColumnModel().setRenderer(1, editorRenderer);
			editorGrid.setSize(option.grid.getColumnModel().getColumnWidth(1), editorGrid.height);
		} else {
			return false;
		}
		
		var key = this.dataSource.getAt(option.row).data.gridProperties.propId;
		
		this.oldValues = new Hash();
		this.shapeSelection.shapes.each(function(shape){
			this.oldValues[shape.getId()] = shape.properties[key];
		}.bind(this)); 
	},

	afterEdit: function(option) {
		//Ext1.0: option.grid.getDataSource().commitChanges();
		option.grid.getStore().commitChanges();

		var key 			 = option.record.data.gridProperties.propId;
		var selectedElements = this.shapeSelection.shapes;
		
		var oldValues 	= this.oldValues;	
		
		var newValue	= option.value;
		var facade		= this.facade;
		

		// Implement the specific command for property change
		var commandClass = ORYX.Core.Command.extend({
			construct: function(){
				this.key 		= key;
				this.selectedElements = selectedElements;
				this.oldValues = oldValues;
				this.newValue 	= newValue;
				this.facade		= facade;
			},			
			execute: function(){
				this.selectedElements.each(function(shape){
					if(!shape.getStencil().property(this.key).readonly()) {
						shape.setProperty(this.key, this.newValue);
					}
				}.bind(this));
				this.facade.setSelection(this.selectedElements);
				this.facade.getCanvas().update();
				this.facade.updateSelection();
			},
			rollback: function(){
				this.selectedElements.each(function(shape){
					shape.setProperty(this.key, this.oldValues[shape.getId()]);
				}.bind(this));
				this.facade.setSelection(this.selectedElements);
				this.facade.getCanvas().update();
				this.facade.updateSelection();
			}
		})		
		// Instanciated the class
		var command = new commandClass();
		
		// Execute the command
		this.facade.executeCommands([command]);


		// extended by Kerstin (start)
//
		this.facade.raiseEvent({
			type 		: ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, 
			elements	: selectedElements,
			key			: key,
			value		: option.value
		});
		// extended by Kerstin (end)
	},
	
	// Cahnges made in the property window will be shown directly
	editDirectly:function(key, value){
		
		this.shapeSelection.shapes.each(function(shape){
			if(!shape.getStencil().property(key).readonly()) {
				shape.setProperty(key, value);
				//shape.update();
			}
		}.bind(this));
		
		/* Propagate changed properties */
		var selectedElements = this.shapeSelection.shapes;
		
		this.facade.raiseEvent({
			type 		: ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, 
			elements	: selectedElements,
			key			: key,
			value		: value
		});

		this.facade.getCanvas().update();
		
	},
	
	// if a field becomes invalid after editing the shape must be restored to the old value
	updateAfterInvalid : function(key) {
		this.shapeSelection.shapes.each(function(shape) {
			if(!shape.getStencil().property(key).readonly()) {
				shape.setProperty(key, this.oldValues[shape.getId()]);
				shape.update();
			}
		}.bind(this));
		
		this.facade.getCanvas().update();
	},

	// extended by Kerstin (start)	
	dialogClosed: function(data) {
		var row = this.field ? this.field.row : this.row 
		this.scope.afterEdit({
			grid:this.scope.grid, 
			record:this.scope.grid.getStore().getAt(row), 
			//value:this.scope.grid.getStore().getAt(this.row).get("value")
			value: data
		})
		// reopen the text field of the complex list field again
		this.scope.grid.startEditing(row, this.col);
	},
	// extended by Kerstin (end)
	
	/**
	 * Changes the title of the property window panel according to the selected shapes.
	 */
	setPropertyWindowTitle: function() {
		if(this.shapeSelection.shapes.length == 1) {
			// add the name of the stencil of the selected shape to the title
				region.setTitle(ORYX.I18N.PropertyWindow.title +' ('+this.shapeSelection.shapes.first().getStencil().title()+')' );
		} else {
			region.setTitle(ORYX.I18N.PropertyWindow.title +' ('
							+ this.shapeSelection.shapes.length
							+ ' '
							+ ORYX.I18N.PropertyWindow.selected 
							+')');
		}
	},
	/**
	 * Sets this.shapeSelection.commonPropertiesValues.
	 * If the value for a common property is not equal for each shape the value
	 * is left empty in the property window.
	 */
	setCommonPropertiesValues: function() {
		this.shapeSelection.commonPropertiesValues = new Hash();
		this.shapeSelection.commonProperties.each(function(property){
			var key = property.prefix() + "-" + property.id();
			var emptyValue = false;
			var firstShape = this.shapeSelection.shapes.first();
			
			this.shapeSelection.shapes.each(function(shape){
				if(firstShape.properties[key] != shape.properties[key]) {
					emptyValue = true;
				}
			}.bind(this));
			
			/* Set property value */
			if(!emptyValue) {
				this.shapeSelection.commonPropertiesValues[key]
					= firstShape.properties[key];
			}
		}.bind(this));
	},
	
	/**
	 * Returns the set of stencils used by the passed shapes.
	 */
	getStencilSetOfSelection: function() {
		var stencils = new Hash();
		
		this.shapeSelection.shapes.each(function(shape) {
			stencils[shape.getStencil().id()] = shape.getStencil();
		})
		return stencils;
	},
	
	/**
	 * Identifies the common Properties of the selected shapes.
	 */
	identifyCommonProperties: function() {
		this.shapeSelection.commonProperties.clear();
		
		/* 
		 * A common property is a property, that is part of 
		 * the stencil definition of the first and all other stencils.
		 */
		var stencils = this.getStencilSetOfSelection();
		var firstStencil = stencils.values().first();
		var comparingStencils = stencils.values().without(firstStencil);
		
		
		if(comparingStencils.length == 0) {
			this.shapeSelection.commonProperties = firstStencil.properties();
		} else {
			var properties = new Hash();
			
			/* put all properties of on stencil in a Hash */
			firstStencil.properties().each(function(property){
				properties[property.namespace() + '-' + property.id() 
							+ '-' + property.type()] = property;
			});
			
			/* Calculate intersection of properties. */
			
			comparingStencils.each(function(stencil){
				var intersection = new Hash();
				stencil.properties().each(function(property){
					if(properties[property.namespace() + '-' + property.id()
									+ '-' + property.type()]){
						intersection[property.namespace() + '-' + property.id()
										+ '-' + property.type()] = property;
					}
				});
				properties = intersection;	
			});
			
			this.shapeSelection.commonProperties = properties.values();
		}
	},
	
	onSelectionChanged: function(event) {
		/* Event to call afterEdit method */
		this.grid.stopEditing();
		
		/* Selected shapes */
		this.shapeSelection.shapes = event.elements;
		
		/* Case: nothing selected */
		if(event.elements.length == 0) {
			this.shapeSelection.shapes = [this.facade.getCanvas()];
		}
		
		/* subselection available */
		if(event.subSelection){
			this.shapeSelection.shapes = [event.subSelection];
		}
		
		this.setPropertyWindowTitle();
		this.identifyCommonProperties();
		this.setCommonPropertiesValues();
		
		// Create the Properties
		
		this.createProperties();
	},
	
	/**
	 * Creates the properties for the ExtJS-Grid from the properties of the
	 * selected shapes.
	 */
	createProperties: function() {
		this.properties = [];
		this.popularProperties = [];

		if(this.shapeSelection.commonProperties) {
			
			// add new property lines
			this.shapeSelection.commonProperties.each((function(pair, index) {

				var key = pair.prefix() + "-" + pair.id();
				
				// Get the property pair
				var name		= pair.title();
				var icons		= [];
				var attribute	= this.shapeSelection.commonPropertiesValues[key];
				
				var editorGrid = undefined;
				var editorRenderer = null;
				
				var refToViewFlag = false;

				if(!pair.readonly()){
					switch(pair.type()) {
						case ORYX.CONFIG.TYPE_STRING:
							// If the Text is MultiLine
							if(pair.wrapLines()) {
								// Set the Editor as TextArea
								var editorTextArea = new Ext.form.TextArea({alignment: "tl-tl", allowBlank: pair.optional(),  msgTarget:'title', maxLength:pair.length()});
								editorTextArea.on('keyup', function(textArea, event) {
									this.editDirectly(key, textArea.getValue());
								}.bind(this));								
								
								editorGrid = new Ext.Editor(editorTextArea);
							} else {
								// If not, set the Editor as InputField
								var editorInput = new Ext.form.TextField({allowBlank: pair.optional(),  msgTarget:'title', maxLength:pair.length()});
								editorInput.on('keyup', function(input, event) {
									this.editDirectly(key, input.getValue());
								}.bind(this));
								
								// reverts the shape if the editor field is invalid
								editorInput.on('blur', function(input) {
									if(!input.isValid(false))
										this.updateAfterInvalid(key);
								}.bind(this));
								
								editorInput.on("specialkey", function(input, e) {
									if(!input.isValid(false))
										this.updateAfterInvalid(key);
								}.bind(this));
								
								editorGrid = new Ext.Editor(editorInput);
							}
							break;
						case ORYX.CONFIG.TYPE_BOOLEAN:
							// Set the Editor as a CheckBox
							var editorCheckbox = new Ext.form.Checkbox();
							editorCheckbox.on('check', function(c,checked) {
								this.editDirectly(key, checked);
							}.bind(this));
							
							editorGrid = new Ext.Editor(editorCheckbox);
							break;
						case ORYX.CONFIG.TYPE_INTEGER:
							// Set as an Editor for Integers
							var numberField = new Ext.form.NumberField({allowBlank: pair.optional(), allowDecimals:false, msgTarget:'title', minValue: pair.min(), maxValue: pair.max()});
							numberField.on('keyup', function(input, event) {
								this.editDirectly(key, input.getValue());
							}.bind(this));							
							
							editorGrid = new Ext.Editor(numberField);
							break;
						case ORYX.CONFIG.TYPE_FLOAT:
							// Set as an Editor for Float
							var numberField = new Ext.form.NumberField({ allowBlank: pair.optional(), allowDecimals:true, msgTarget:'title', minValue: pair.min(), maxValue: pair.max()});
							numberField.on('keyup', function(input, event) {
								this.editDirectly(key, input.getValue());
							}.bind(this));
							
							editorGrid = new Ext.Editor(numberField);

							break;
						case ORYX.CONFIG.TYPE_COLOR:
							// Set as a ColorPicker
							// Ext1.0 editorGrid = new gEdit(new form.ColorField({ allowBlank: pair.optional(),  msgTarget:'title' }));

							var editorPicker = new Ext.ux.ColorField({ allowBlank: pair.optional(),  msgTarget:'title', facade: this.facade });
							
							/*this.facade.registerOnEvent(ORYX.CONFIG.EVENT_COLOR_CHANGE, function(option) {
								this.editDirectly(key, option.value);
							}.bind(this));*/
							
							editorGrid = new Ext.Editor(editorPicker);

							break;
						case ORYX.CONFIG.TYPE_CHOICE:
							var items = pair.items();
													
							var options = [];
							items.each(function(value) {
								if(value.value() == attribute)
									attribute = value.title();
									
								if(value.refToView()[0])
									refToViewFlag = true;
																
								options.push([value.icon(), value.title(), value.value()]);
															
								icons.push({
									name: value.title(),
									icon: value.icon()
								});
							});
							
							var store = new Ext.data.SimpleStore({
						        fields: [{name: 'icon'},
									{name: 'title'},
									{name: 'value'}	],
						        data : options // from states.js
						    });
							
							// Set the grid Editor

						    var editorCombo = new Ext.form.ComboBox({
								tpl: '<tpl for="."><div class="x-combo-list-item">{[(values.icon) ? "<img src=\'" + values.icon + "\' />" : ""]} {title}</div></tpl>',
						        store: store,
						        displayField:'title',
								valueField: 'value',
						        typeAhead: true,
						        mode: 'local',
						        triggerAction: 'all',
						        selectOnFocus:true
						    });
								
							editorCombo.on('select', function(combo, record, index) {
								this.editDirectly(key, combo.getValue());
							}.bind(this))
							
							editorGrid = new Ext.Editor(editorCombo);

							break;
						case ORYX.CONFIG.TYPE_DATE:
							var currFormat = ORYX.I18N.PropertyWindow.dateFormat
							if(!(attribute instanceof Date))
								attribute = Date.parseDate(attribute, currFormat)
							editorGrid = new Ext.Editor(new Ext.form.DateField({ allowBlank: pair.optional(), format:currFormat,  msgTarget:'title'}));
							break;

						case ORYX.CONFIG.TYPE_TEXT:
							
							var cf = new Ext.form.ComplexTextField({
								allowBlank: pair.optional(),
								dataSource:this.dataSource,
								grid:this.grid,
								row:index,
								facade:this.facade
							});
							cf.on('dialogClosed', this.dialogClosed, {scope:this, row:index, col:1,field:cf});							
							editorGrid = new Ext.Editor(cf);
							break;
							
						// extended by Kerstin (start)
						case ORYX.CONFIG.TYPE_COMPLEX:
							
							var cf = new Ext.form.ComplexListField({ allowBlank: pair.optional()}, pair.complexItems(), key, this.facade);
							cf.on('dialogClosed', this.dialogClosed, {scope:this, row:index, col:1,field:cf});							
							editorGrid = new Ext.Editor(cf);
							break;
						// extended by Kerstin (end)
						
						// extended by Gerardo (Start)
						case "CPNString":
							var editorInput = new Ext.form.TextField(
									{
										allowBlank: pair.optional(),
										msgTarget:'title', 
										maxLength:pair.length(), 
										enableKeyEvents: true
									});
							
							editorInput.on('keyup', function(input, event) {
								this.editDirectly(key, input.getValue());
								console.log(input.getValue());
								alert("huhu");
							}.bind(this));
							
							editorGrid = new Ext.Editor(editorInput);							
							break;
						// extended by Gerardo (End)
						
						default:
							var editorInput = new Ext.form.TextField({ allowBlank: pair.optional(),  msgTarget:'title', maxLength:pair.length(), enableKeyEvents: true});
							editorInput.on('keyup', function(input, event) {
								this.editDirectly(key, input.getValue());
							}.bind(this));
							
							editorGrid = new Ext.Editor(editorInput);
					}


					// Register Event to enable KeyDown
					editorGrid.on('beforehide', this.facade.enableEvent.bind(this, ORYX.CONFIG.EVENT_KEYDOWN));
					editorGrid.on('specialkey', this.specialKeyDown.bind(this));

				} else if(pair.type() === ORYX.CONFIG.TYPE_URL || pair.type() === ORYX.CONFIG.TYPE_DIAGRAM_LINK){
					attribute = String(attribute).search("http") !== 0 ? ("http://" + attribute) : attribute;
					attribute = "<a href='" + attribute + "' target='_blank'>" + attribute.split("://")[1] + "</a>"
				}
				
				// Push to the properties-array
				if(pair.visible()) {
					// Popular Properties are those with a refToView set or those which are set to be popular
					if (pair.refToView()[0] || refToViewFlag || pair.popular()) {
						pair.setPopular();
					} 
					
					if(pair.popular()) {
						this.popularProperties.push([pair.popular(), name, attribute, icons, {
							editor: editorGrid,
							propId: key,
							type: pair.type(),
							tooltip: pair.description(),
							renderer: editorRenderer
						}]);
					}
					else {					
						this.properties.push([pair.popular(), name, attribute, icons, {
							editor: editorGrid,
							propId: key,
							type: pair.type(),
							tooltip: pair.description(),
							renderer: editorRenderer
						}]);
					}
				}

			}).bind(this));
		}

		this.setProperties();
	},
	
	hideMoreAttrs: function(panel) {
		// TODO: Implement the case that the canvas has no attributes
		if (this.properties.length <= 0){ return }
		
		// collapse the "more attr" group
		this.grid.view.toggleGroup(this.grid.view.getGroupId(this.properties[0][0]), false);
		
		// prevent the more attributes pane from closing after a attribute has been edited
		this.grid.view.un("refresh", this.hideMoreAttrs, this);
	},

	setProperties: function() {
		var props = this.popularProperties.concat(this.properties);
		
		this.dataSource.loadData(props);
	}
}
ORYX.Plugins.PropertyWindow = Clazz.extend(ORYX.Plugins.PropertyWindow);



/**
 * Editor for complex type
 * 
 * When starting to edit the editor, it creates a new dialog where new attributes
 * can be specified which generates json out of this and put this 
 * back to the input field.
 * 
 * This is implemented from Kerstin Pfitzner
 * 
 * @param {Object} config
 * @param {Object} items
 * @param {Object} key
 * @param {Object} facade
 */


Ext.form.ComplexListField = function(config, items, key, facade){
    Ext.form.ComplexListField.superclass.constructor.call(this, config);
	this.items 	= items;
	this.key 	= key;
	this.facade = facade;
};

/**
 * This is a special trigger field used for complex properties.
 * The trigger field opens a dialog that shows a list of properties.
 * The entered values will be stored as trigger field value in the JSON format.
 */
Ext.extend(Ext.form.ComplexListField, Ext.form.TriggerField,  {
	/**
     * @cfg {String} triggerClass
     * An additional CSS class used to style the trigger button.  The trigger will always get the
     * class 'x-form-trigger' and triggerClass will be <b>appended</b> if specified.
     */
    triggerClass:	'x-form-complex-trigger',
	readOnly:		true,
	emptyText: 		ORYX.I18N.PropertyWindow.clickIcon,
		
	/**
	 * Builds the JSON value from the data source of the grid in the dialog.
	 */
	buildValue: function() {
		var ds = this.grid.getStore();
		ds.commitChanges();
		
		if (ds.getCount() == 0) {
			return "";
		}
		
		var jsonString = "[";
		for (var i = 0; i < ds.getCount(); i++) {
			var data = ds.getAt(i);		
			jsonString += "{";	
			for (var j = 0; j < this.items.length; j++) {
				var key = this.items[j].id();
				jsonString += key + ':' + ("" + data.get(key)).toJSON();
				if (j < (this.items.length - 1)) {
					jsonString += ", ";
				}
			}
			jsonString += "}";
			if (i < (ds.getCount() - 1)) {
				jsonString += ", ";
			}
		}
		jsonString += "]";
		
		jsonString = "{'totalCount':" + ds.getCount().toJSON() + 
			", 'items':" + jsonString + "}";
		return Object.toJSON(jsonString.evalJSON());
	},
	
	/**
	 * Returns the field key.
	 */
	getFieldKey: function() {
		return this.key;
	},
	
	/**
	 * Returns the actual value of the trigger field.
	 * If the table does not contain any values the empty
	 * string will be returned.
	 */
    getValue : function(){
		// return actual value if grid is active
		if (this.grid) {
			return this.buildValue();			
		} else if (this.data == undefined) {
			return "";
		} else {
			return this.data;
		}
    },
	
	/**
	 * Sets the value of the trigger field.
	 * In this case this sets the data that will be shown in
	 * the grid of the dialog.
	 * 
	 * @param {Object} value The value to be set (JSON format or empty string)
	 */
	setValue: function(value) {	
		if (value.length > 0) {
			// set only if this.data not set yet
			// only to initialize the grid
			if (this.data == undefined) {
				this.data = value;
			}
		}
	},
	
	/**
	 * Returns false. In this way key events will not be propagated
	 * to other elements.
	 * 
	 * @param {Object} event The keydown event.
	 */
	keydownHandler: function(event) {
		return false;
	},
	
	/**
	 * The listeners of the dialog. 
	 * 
	 * If the dialog is hidded, a dialogClosed event will be fired.
	 * This has to be used by the parent element of the trigger field
	 * to reenable the trigger field (focus gets lost when entering values
	 * in the dialog).
	 */
    dialogListeners : {
        show : function(){ // retain focus styling
            this.onFocus();	
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keydownHandler.bind(this));
			this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
			return;
        },
        hide : function(){

            var dl = this.dialogListeners;
            this.dialog.un("show", dl.show,  this);
            this.dialog.un("hide", dl.hide,  this);
			
			this.dialog.destroy(true);
			this.grid.destroy(true);
			delete this.grid;
			delete this.dialog;
			
			this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keydownHandler.bind(this));
			this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
			
			// store data and notify parent about the closed dialog
			// parent has to handel this event and start editing the text field again
			this.fireEvent('dialogClosed', this.data);
			
			Ext.form.ComplexListField.superclass.setValue.call(this, this.data);
        }
    },	
	
	/**
	 * Builds up the initial values of the grid.
	 * 
	 * @param {Object} recordType The record type of the grid.
	 * @param {Object} items      The initial items of the grid (columns)
	 */
	buildInitial: function(recordType, items) {
		var initial = new Hash();
		
		for (var i = 0; i < items.length; i++) {
			var id = items[i].id();
			initial[id] = items[i].value();
		}
		
		var RecordTemplate = Ext.data.Record.create(recordType);
		return new RecordTemplate(initial);
	},
	
	/**
	 * Builds up the column model of the grid. The parent element of the
	 * grid.
	 * 
	 * Sets up the editors for the grid columns depending on the 
	 * type of the items.
	 * 
	 * @param {Object} parent The 
	 */
	buildColumnModel: function(parent) {
		var cols = [];
		for (var i = 0; i < this.items.length; i++) {
			var id 		= this.items[i].id();
			var header 	= this.items[i].name();
			var width 	= this.items[i].width();
			var type 	= this.items[i].type();
			var editor;
			
			if (type == ORYX.CONFIG.TYPE_STRING) {
				editor = new Ext.form.TextField({ allowBlank : this.items[i].optional(), width : width});
			} else if (type == ORYX.CONFIG.TYPE_CHOICE) {				
				var items = this.items[i].items();
				var select = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", parent, ['select', {style:'display:none'}]);
				var optionTmpl = new Ext.Template('<option value="{value}">{value}</option>');
				items.each(function(value){ 
					optionTmpl.append(select, {value:value.value()}); 
				});				
				
				editor = new Ext.form.ComboBox(
					{ typeAhead: true, triggerAction: 'all', transform:select, lazyRender:true,  msgTarget:'title', width : width});			
			} else if (type == ORYX.CONFIG.TYPE_BOOLEAN) {
				editor = new Ext.form.Checkbox( { width : width } );
			}
					
			cols.push({
				id: 		id,
				header: 	header,
				dataIndex: 	id,
				resizable: 	true,
				editor: 	editor,
				width:		width
	        });
			
		}
		return new Ext.grid.ColumnModel(cols);
	},
	
	/**
	 * After a cell was edited the changes will be commited.
	 * 
	 * @param {Object} option The option that was edited.
	 */
	afterEdit: function(option) {
		option.grid.getStore().commitChanges();
	},
		
	/**
	 * Before a cell is edited it has to be checked if this 
	 * cell is disabled by another cell value. If so, the cell editor will
	 * be disabled.
	 * 
	 * @param {Object} option The option to be edited.
	 */
	beforeEdit: function(option) {

		var state = this.grid.getView().getScrollState();
		
		var col = option.column;
		var row = option.row;
		var editId = this.grid.getColumnModel().config[col].id;
		// check if there is an item in the row, that disables this cell
		for (var i = 0; i < this.items.length; i++) {
			// check each item that defines a "disable" property
			var item = this.items[i];
			var disables = item.disable();
			if (disables != undefined) {
				
				// check if the value of the column of this item in this row is equal to a disabling value
				var value = this.grid.getStore().getAt(row).get(item.id());
				for (var j = 0; j < disables.length; j++) {
					var disable = disables[j];
					if (disable.value == value) {
						
						for (var k = 0; k < disable.items.length; k++) {
							// check if this value disables the cell to select 
							// (id is equals to the id of the column to edit)
							var disItem = disable.items[k];
							if (disItem == editId) {
								this.grid.getColumnModel().getCellEditor(col, row).disable();
								return;
							}
						}
					}
				}		
			}
		}
		this.grid.getColumnModel().getCellEditor(col, row).enable();
		//this.grid.getView().restoreScroll(state);
	},
	
    /**
     * If the trigger was clicked a dialog has to be opened
     * to enter the values for the complex property.
     */
    onTriggerClick : function(){
        if(this.disabled){
            return;
        }	
		
		//if(!this.dialog) { 
		
			var dialogWidth = 0;
			var recordType 	= [];
			
			for (var i = 0; i < this.items.length; i++) {
				var id 		= this.items[i].id();
				var width 	= this.items[i].width();
				var type 	= this.items[i].type();	
					
				if (type == ORYX.CONFIG.TYPE_CHOICE) {
					type = ORYX.CONFIG.TYPE_STRING;
				}
						
				dialogWidth += width;
				recordType[i] = {name:id, type:type};
			}			
			
			if (dialogWidth > 800) {
				dialogWidth = 800;
			}
			dialogWidth += 22;
			
			var data = this.data;
			if (data == "") {
				// empty string can not be parsed
				data = "{}";
			}
			
			
			var ds = new Ext.data.Store({
		        proxy: new Ext.data.MemoryProxy(eval("(" + data + ")")),				
				reader: new Ext.data.JsonReader({
		            root: 'items',
		            totalProperty: 'totalCount'
		        	}, recordType)
	        });
			ds.load();
					
				
			var cm = this.buildColumnModel();
			
			this.grid = new Ext.grid.EditorGridPanel({
				store:		ds,
		        cm:			cm,
				stripeRows: true,
				clicksToEdit : 1,
				autoHeight:true,
		        selModel: 	new Ext.grid.CellSelectionModel()
		    });	
			
									
			//var gridHead = this.grid.getView().getHeaderPanel(true);
			var toolbar = new Ext.Toolbar(
			[{
				text: ORYX.I18N.PropertyWindow.add,
				handler: function(){
					var ds = this.grid.getStore();
					var index = ds.getCount();
					this.grid.stopEditing();
					var p = this.buildInitial(recordType, this.items);
					ds.insert(index, p);
					ds.commitChanges();
					this.grid.startEditing(index, 0);
				}.bind(this)
			},{
				text: ORYX.I18N.PropertyWindow.rem,
		        handler : function(){
					var ds = this.grid.getStore();
					var selection = this.grid.getSelectionModel().getSelectedCell();
					if (selection == undefined) {
						return;
					}
					this.grid.getSelectionModel().clearSelections();
		            this.grid.stopEditing();					
					var record = ds.getAt(selection[0]);
					ds.remove(record);
					ds.commitChanges();           
				}.bind(this)
			}]);			
		
			// Basic Dialog
			this.dialog = new Ext.Window({ 
				autoScroll: true,
				autoCreate: true, 
				title: ORYX.I18N.PropertyWindow.complex, 
				height: 350, 
				width: dialogWidth, 
				modal:true,
				collapsible:false,
				fixedcenter: true, 
				shadow:true, 
				proxyDrag: true,
				keys:[{
					key: 27,
					fn: function(){
						this.dialog.hide
					}.bind(this)
				}],
				items:[toolbar, this.grid],
				bodyStyle:"background-color:#FFFFFF",
				buttons: [{
	                text: ORYX.I18N.PropertyWindow.ok,
	                handler: function(){
	                    this.grid.stopEditing();	
						// store dialog input
						this.data = this.buildValue();
						this.dialog.hide()
	                }.bind(this)
	            }, {
	                text: ORYX.I18N.PropertyWindow.cancel,
	                handler: function(){
	                	this.dialog.hide()
	                }.bind(this)
	            }]
			});		
				
			this.dialog.on(Ext.apply({}, this.dialogListeners, {
	       		scope:this
	        }));
		
			this.dialog.show();	
		
	
			this.grid.on('beforeedit', 	this.beforeEdit, 	this, true);
			this.grid.on('afteredit', 	this.afterEdit, 	this, true);
			
			this.grid.render();			
	    
		/*} else {
			this.dialog.show();		
		}*/
		
	}
});





Ext.form.ComplexTextField = Ext.extend(Ext.form.TriggerField,  {

	defaultAutoCreate : {tag: "textarea", rows:1, style:"height:16px;overflow:hidden;" },

    /**
     * If the trigger was clicked a dialog has to be opened
     * to enter the values for the complex property.
     */
    onTriggerClick : function(){
		
        if(this.disabled){
            return;
        }	
		        
		var grid = new Ext.form.TextArea({
	        anchor		: '100% 100%',
			value		: this.value,
			listeners	: {
				focus: function(){
					this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);
				}.bind(this)
			}
		})
		
		
		// Basic Dialog
		var dialog = new Ext.Window({ 
			layout		: 'anchor',
			autoCreate	: true, 
			title		: ORYX.I18N.PropertyWindow.text, 
			height		: 500, 
			width		: 500, 
			modal		: true,
			collapsible	: false,
			fixedcenter	: true, 
			shadow		: true, 
			proxyDrag	: true,
			keys:[{
				key	: 27,
				fn	: function(){
						dialog.hide()
				}.bind(this)
			}],
			items		:[grid],
			listeners	:{
				hide: function(){
					this.fireEvent('dialogClosed', this.value);
					//this.focus.defer(10, this);
					dialog.destroy();
				}.bind(this)				
			},
			buttons		: [{
                text: ORYX.I18N.PropertyWindow.ok,
                handler: function(){	 
					// store dialog input
					var value = grid.getValue();
					this.setValue(value);
					
					this.dataSource.getAt(this.row).set('value', value)
					this.dataSource.commitChanges()

					dialog.hide()
                }.bind(this)
            }, {
                text: ORYX.I18N.PropertyWindow.cancel,
                handler: function(){
					this.setValue(this.value);
                	dialog.hide()
                }.bind(this)
            }]
		});		
				
		dialog.show();		
		grid.render();

		this.grid.stopEditing();
		grid.focus( false, 100 );
		
	}
});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins) {    ORYX.Plugins = new Object();}/** * This plugin is responsible for displaying loading indicators and to prevent * the user from accidently unloading the page by, e.g., pressing the backspace * button and returning to the previous site in history. * @param {Object} facade The editor plugin facade to register enhancements with. */ORYX.Plugins.Loading = {    construct: function(facade){            this.facade = facade;                // The parent Node        this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.facade.getCanvas().getHTMLContainer().parentNode, ['div', {            'class': 'LoadingIndicator'        }, '']);                this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_ENABLE, this.enableLoading.bind(this));        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_DISABLE, this.disableLoading.bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADING_STATUS, this.showStatus.bind(this));                this.disableLoading();    },        enableLoading: function(options){		if(options.text) 			this.node.innerHTML = options.text + "...";		else			this.node.innerHTML = ORYX.I18N.Loading.waiting;		this.node.removeClassName('StatusIndicator');		this.node.addClassName('LoadingIndicator');        this.node.style.display = "block";				var pos = this.facade.getCanvas().rootNode.parentNode.parentNode.parentNode.parentNode;		this.node.style.top 		= pos.offsetTop + 'px';		this.node.style.left 		= pos.offsetLeft +'px';					    },        disableLoading: function(){        this.node.style.display = "none";    },		showStatus: function(options) {		if(options.text) {			this.node.innerHTML = options.text;			this.node.addClassName('StatusIndicator');			this.node.removeClassName('LoadingIndicator');			this.node.style.display = 'block';			var pos = this.facade.getCanvas().rootNode.parentNode.parentNode.parentNode.parentNode;			this.node.style.top 	= pos.offsetTop + 'px';			this.node.style.left 	= pos.offsetLeft +'px';															var tout = options.timeout ? options.timeout : 2000;						window.setTimeout((function(){                            this.disableLoading();                            }).bind(this), tout);		}		
	}}ORYX.Plugins.Loading = Clazz.extend(ORYX.Plugins.Loading);/** * Copyright (c) 2008 * Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins) {    ORYX.Plugins = new Object();}/** * This plugin is responsible for resizing the canvas. * @param {Object} facade The editor plugin facade to register enhancements with. */ORYX.Plugins.CanvasResize = Clazz.extend({    construct: function(facade){		        this.facade = facade;		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "N", this.resize.bind(this));		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "W", this.resize.bind(this));		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "E", this.resize.bind(this));		new ORYX.Plugins.CanvasResizeButton( this.facade.getCanvas(), "S", this.resize.bind(this));    },        resize: function( position, shrink ){    	    	resizeCanvas = function(position, extentionSize, facade) {        	var canvas 		= facade.getCanvas();    		var b 			= canvas.bounds;    		var scrollNode 	= facade.getCanvas().getHTMLContainer().parentNode.parentNode;    		    		if( position == "E" || position == "W"){    			canvas.setSize({width: (b.width() + extentionSize)*canvas.zoomLevel, height: (b.height())*canvas.zoomLevel})    		} else if( position == "S" || position == "N"){    			canvas.setSize({width: (b.width())*canvas.zoomLevel, height: (b.height() + extentionSize)*canvas.zoomLevel})    		}    		if( position == "N" || position == "W"){    			    			var move = position == "N" ? {x: 0, y: extentionSize}: {x: extentionSize, y: 0 };    			// Move all children    			canvas.getChildNodes(false, function(shape){ shape.bounds.moveBy(move) })    			// Move all dockers, when the edge has at least one docked shape    			var edges = canvas.getChildEdges().findAll(function(edge){ return edge.getAllDockedShapes().length > 0})    			var dockers = edges.collect(function(edge){ return edge.dockers.findAll(function(docker){ return !docker.getDockedShape() })}).flatten();    			dockers.each(function(docker){ docker.bounds.moveBy(move)})    		} else if( position == "S" ){    			scrollNode.scrollTop += extentionSize;    		} else if( position == "E" ){    			scrollNode.scrollLeft += extentionSize;    		}    		    		canvas.update();    		facade.updateSelection();        }				var commandClass = ORYX.Core.Command.extend({			construct: function(position, extentionSize, facade){				this.position = position;				this.extentionSize = extentionSize;				this.facade = facade;			},						execute: function(){				resizeCanvas(this.position, this.extentionSize, this.facade);			},			rollback: function(){				resizeCanvas(this.position, -this.extentionSize, this.facade);			},			update:function(){			}		});				var extentionSize = ORYX.CONFIG.CANVAS_RESIZE_INTERVAL;		if(shrink) extentionSize = -extentionSize;		var command = new commandClass(position, extentionSize, this.facade);				this.facade.executeCommands([command]);			    }    });ORYX.Plugins.CanvasResizeButton = Clazz.extend({		construct: function(canvas, position, callback){		this.canvas = canvas;		var parentNode = canvas.getHTMLContainer().parentNode.parentNode.parentNode;				window.myParent=parentNode		var scrollNode 	= parentNode.firstChild;		var svgRootNode = scrollNode.firstChild.firstChild;		// The buttons		var buttonGrow 	= ORYX.Editor.graft("http://www.w3.org/1999/xhtml", parentNode, ['div', { 'class': 'canvas_resize_indicator canvas_resize_indicator_grow' + ' ' + position ,'title':ORYX.I18N.RESIZE.tipGrow+ORYX.I18N.RESIZE[position]}]);		var buttonShrink 	= ORYX.Editor.graft("http://www.w3.org/1999/xhtml", parentNode, ['div', { 'class': 'canvas_resize_indicator canvas_resize_indicator_shrink' + ' ' + position ,'title':ORYX.I18N.RESIZE.tipShrink+ORYX.I18N.RESIZE[position]}]);				// Defines a callback which gives back		// a boolean if the current mouse event 		// is over the particular button area		var offSetWidth = 60;		var isOverOffset = function(event){						if(event.target!=parentNode && event.target!=scrollNode&& event.target!=scrollNode.firstChild&& event.target!=svgRootNode&& event.target!=scrollNode)				return false;						//if(inCanvas){offSetWidth=30}else{offSetWidth=30*2}			//Safari work around			var X=event.layerX			var Y=event.layerY			if((X - scrollNode.scrollLeft)<0 ||Ext.isSafari){	X+=scrollNode.scrollLeft;}			if((Y - scrollNode.scrollTop )<0 ||Ext.isSafari){ Y+=scrollNode.scrollTop ;}			if(position == "N"){				return  Y < offSetWidth+scrollNode.firstChild.offsetTop;			} else if(position == "W"){				return X < offSetWidth + scrollNode.firstChild.offsetLeft;			} else if(position == "E"){				//other offset				var offsetRight=(scrollNode.offsetWidth-(scrollNode.firstChild.offsetLeft + scrollNode.firstChild.offsetWidth));				if(offsetRight<0)offsetRight=0;				return X > scrollNode.scrollWidth-offsetRight-offSetWidth;			} else if(position == "S"){				//other offset				var offsetDown=(scrollNode.offsetHeight-(scrollNode.firstChild.offsetTop  + scrollNode.firstChild.offsetHeight));				if(offsetDown<0)offsetDown=0;				return Y > scrollNode.scrollHeight -offsetDown- offSetWidth;			}						return false;		}				var showButtons = (function() {			buttonGrow.show(); 						var x1, y1, x2, y2;			try {				var bb = this.canvas.getRootNode().childNodes[1].getBBox();				x1 = bb.x;				y1 = bb.y;				x2 = bb.x + bb.width;				y2 = bb.y + bb.height;			} catch(e) {				this.canvas.getChildShapes(true).each(function(shape) {					var absBounds = shape.absoluteBounds();					var ul = absBounds.upperLeft();					var lr = absBounds.lowerRight();					if(x1 == undefined) {						x1 = ul.x;						y1 = ul.y;						x2 = lr.x;						y2 = lr.y;					} else {						x1 = Math.min(x1, ul.x);						y1 = Math.min(y1, ul.y);						x2 = Math.max(x2, lr.x);						y2 = Math.max(y2, lr.y);					}				});			}						var w = canvas.bounds.width();			var h = canvas.bounds.height();						var isEmpty = canvas.getChildNodes().size()==0;					if(position=="N" && (y1>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL || (isEmpty && h>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL))) buttonShrink.show();			else if(position=="E" && (w-x2)>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL) buttonShrink.show();			else if(position=="S" && (h-y2)>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL) buttonShrink.show();			else if(position=="W" && (x1>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL || (isEmpty && w>ORYX.CONFIG.CANVAS_RESIZE_INTERVAL))) buttonShrink.show();			else buttonShrink.hide();		}).bind(this);				var hideButtons = function() {			buttonGrow.hide(); 			buttonShrink.hide();		}					// If the mouse move is over the button area, show the button		scrollNode.addEventListener(	ORYX.CONFIG.EVENT_MOUSEMOVE, 	function(event){ if( isOverOffset(event) ){showButtons();} else {hideButtons()}} , false );		// If the mouse is over the button, show them		buttonGrow.addEventListener(		ORYX.CONFIG.EVENT_MOUSEOVER, 	function(event){showButtons();}, true );		buttonShrink.addEventListener(		ORYX.CONFIG.EVENT_MOUSEOVER, 	function(event){showButtons();}, true );		// If the mouse is out, hide the button		//scrollNode.addEventListener(		ORYX.CONFIG.EVENT_MOUSEOUT, 	function(event){button.hide()}, true )		parentNode.addEventListener(	ORYX.CONFIG.EVENT_MOUSEOUT, 	function(event){hideButtons()} , true );		//svgRootNode.addEventListener(	ORYX.CONFIG.EVENT_MOUSEOUT, 	function(event){ inCanvas = false } , true );				// Hide the button initialy		hideButtons();				// Add the callbacks		buttonGrow.addEventListener('click', function(){callback( position ); showButtons();}, true);		buttonShrink.addEventListener('click', function(){callback( position, true ); showButtons();}, true);	}	});/** * Copyright (c) 2008 * Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.RenameShapes = Clazz.extend({    facade: undefined,        construct: function(facade){            this.facade = facade;		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DBLCLICK, this.actOnDBLClick.bind(this));        this.facade.offer({		 keyCodes: [{				keyCode: 113, // F2-Key				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.renamePerF2.bind(this)         });						document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEDOWN, this.hide.bind(this), true );				// Added in 2011 by Matthias Kunze and Tobias Pfeiffer		// Register on the event for the template plugins (see the method registerTemplate for more information)		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_REGISTER_LABEL_TEMPLATE, this.registerTemplate.bind(this));		// raise the event once so we have the initialized property this.label_templates		this.facade.raiseEvent({			type: ORYX.CONFIG.EVENT_REGISTER_LABEL_TEMPLATE,			empty: true // enforces basic template (unity)		});		    },        /**     * Handle the registration of a plugin for templatization.     * This is part of a change made by Matthias Kunze and Tobias Pfeiffer in 2011      * The options are 2 functions (edit_template and render_template) that handle the templatization.     *      * edit_template is called with the oldValue of a property to be edited and changes it's appearance a bit     * so the user sees something slightly different in his editwindow, for details refer to the UMLState plugin.     *      * render_template is called with the result of the editing by the user, the template connected things are removed     * from it so it gets saved in its pure form. Again for more info please refer to the UMLState plugin.     *      * multiple templating methods are saved and are executed one after another, as one may want to use many of them.     *      * @param options, the options of the template function. It should be the edit_template and the render_template functions.     */    registerTemplate: function(options) {        // initialization        this.label_templates = this.label_templates || [];             // push the new template onto our list so it gets executed in the next renaming process        this.label_templates.push({            edit: "function" == typeof(options.edit_template) ? options.edit_template : function(a){return a;},            render: "function" == typeof(options.render_template) ? options.render_template : function(a){return a;}        });     },    	/**	 * This method handles the "F2" key down event. The selected shape are looked	 * up and the editing of title/name of it gets started.	 */	renamePerF2 : function renamePerF2() {		var selectedShapes = this.facade.getSelection();		this.actOnDBLClick(undefined, selectedShapes.first());	},		getEditableProperties: function getEditableProperties(shape) {	    // Get all properties which where at least one ref to view is set		var props = shape.getStencil().properties().findAll(function(item){ 			return (item.refToView() 					&&  item.refToView().length > 0					&&	item.directlyEditable()); 		});				// from these, get all properties where write access are and the type is String	    return props.findAll(function(item){ return !item.readonly() &&  item.type() == ORYX.CONFIG.TYPE_STRING });	},		getPropertyForLabel: function getPropertyForLabel(properties, shape, label) {	    return properties.find(function(item){ return item.refToView().any(function(toView){ return label.id == shape.id + toView })});	},		actOnDBLClick: function actOnDBLClick(evt, shape){		if( !(shape instanceof ORYX.Core.Shape) ){ return }				// Destroys the old input, if there is one		this.destroy();		var props = this.getEditableProperties(shape);				// Get all ref ids		var allRefToViews	= props.collect(function(prop){ return prop.refToView() }).flatten().compact();		// Get all labels from the shape with the ref ids		var labels			= shape.getLabels().findAll(function(label){ return allRefToViews.any(function(toView){ return label.id.endsWith(toView) }); })				// If there are no referenced labels --> return		if( labels.length == 0 ){ return } 				// Define the nearest label		var nearestLabel 	= labels.length == 1 ? labels[0] : null;			if( !nearestLabel ){		    nearestLabel = labels.find(function(label){ return label.node == evt.target || label.node == evt.target.parentNode })	        if( !nearestLabel ){		        var evtCoord 	= this.facade.eventCoordinates(evt);		        var trans		= this.facade.getCanvas().rootNode.lastChild.getScreenCTM();		        evtCoord.x		*= trans.a;		        evtCoord.y		*= trans.d;			    if (!shape instanceof ORYX.Core.Node) {			        var diff = labels.collect(function(label){						        var center 	= this.getCenterPosition( label.node ); 						        var len 	= Math.sqrt( Math.pow(center.x - evtCoord.x, 2) + Math.pow(center.y - evtCoord.y, 2));						        return {diff: len, label: label} 					        }.bind(this));						        diff.sort(function(a, b){ return a.diff > b.diff })							        nearestLabel = 	diff[0].label;                } else {			        var diff = labels.collect(function(label){						        var center 	= this.getDifferenceCenterForNode( label.node ); 						        var len 	= Math.sqrt( Math.pow(center.x - evtCoord.x, 2) + Math.pow(center.y - evtCoord.y, 2));						        return {diff: len, label: label} 					        }.bind(this));						        diff.sort(function(a, b){ return a.diff > b.diff })							        nearestLabel = 	diff[0].label;                }            }		}		// Get the particular property for the label		var prop = this.getPropertyForLabel(props, shape, nearestLabel);        this.showTextField(shape, prop, nearestLabel);	},		showTextField: function showTextField(shape, prop, label) {		// Set all particular config values		var htmlCont 	= this.facade.getCanvas().getHTMLContainer().id;	    	    // Get the center position from the nearest label		var width;		if(!(shape instanceof ORYX.Core.Node)) {		    var bounds = label.node.getBoundingClientRect();			width = Math.max(150, bounds.width);		} else {			width = shape.bounds.width();		}		if (!shape instanceof ORYX.Core.Node) {		    var center 		= this.getCenterPosition( label.node );		    center.x		-= (width/2);        } else {            var center = shape.absoluteBounds().center();		    center.x		-= (width/2);        }		var propId		= prop.prefix() + "-" + prop.id();		// Set the config values for the TextField/Area		var config 		= 	{								renderTo	: htmlCont,								// Part of the change by Matthias Kunze and Tobias Pfeiffer in order for templates to work								// give the value to each registered templating function and let the function modify it, then return it								value		: (function(value, propId, shape){									this.label_templates.forEach(function(tpl){										// Make sure bad templating functions don't break everything										try {											value = tpl.edit(value, propId, shape);										} catch(err) {											ORYX.Log.error("Unable to render label template", err, tpl.edit);										}									});									return value;								}.bind(this))(shape.properties[propId], propId, shape),								x			: (center.x < 10) ? 10 : center.x,								y			: center.y,								width		: Math.max(100, width),								style		: 'position:absolute', 								allowBlank	: prop.optional(), 								maxLength	: prop.length(),								emptyText	: prop.title(),								cls			: 'x_form_text_set_absolute',                                listeners   : {specialkey: this._specialKeyPressed.bind(this)}							};				// Depending on the property, generate 		// either an TextArea or TextField		if(prop.wrapLines()) {			config.y 		-= 30;			config['grow']	= true;			this.shownTextField = new Ext.form.TextArea(config);		} else {			config.y -= 16;						this.shownTextField = new Ext.form.TextField(config);		}				//focus		this.shownTextField.focus();				// Define event handler		//	Blur 	-> Destroy		//	Change 	-> Set new values							this.shownTextField.on( 'blur', 	this.destroy.bind(this) )		this.shownTextField.on( 'change', 	function(node, value){			var currentEl 	= shape;			var oldValue	= currentEl.properties[propId]; 			// Part of the change by Matthias Kunze and Tobias Pfeiffer in order for templates to work			// give the value to each registered templating function and modify it, then return it			var newValue	= (function(value, propId, shape){				this.label_templates.forEach(function(tpl){					// Make sure bad templating functions don't break everything					try {						value = tpl.render(value, propId, shape);					} catch(err) {						ORYX.Log.error("Unable to render label template", err, tpl.render);					}				})				return value;			}.bind(this))(value, propId, shape);			var facade		= this.facade;						if (oldValue != newValue) {				// Implement the specific command for property change				var commandClass = ORYX.Core.Command.extend({					construct: function(){						this.el = currentEl;						this.propId = propId;						this.oldValue = oldValue;						this.newValue = newValue;						this.facade = facade;					},					execute: function(){						this.el.setProperty(this.propId, this.newValue);						//this.el.update();						this.facade.setSelection([this.el]);						this.facade.getCanvas().update();						this.facade.updateSelection();					},					rollback: function(){						this.el.setProperty(this.propId, this.oldValue);						//this.el.update();						this.facade.setSelection([this.el]);						this.facade.getCanvas().update();						this.facade.updateSelection();					}				})				// Instanciated the class				var command = new commandClass();								// Execute the command				this.facade.executeCommands([command]);			}		}.bind(this) )		// Diable the keydown in the editor (that when hitting the delete button, the shapes not get deleted)		this.facade.disableEvent(ORYX.CONFIG.EVENT_KEYDOWN);	},        _specialKeyPressed: function _specialKeyPressed(field, e) {        // Enter or Ctrl+Enter pressed        var keyCode = e.getKey();        if (keyCode == 13  && (e.shiftKey || !field.initialConfig.grow)) {            field.fireEvent("change", null, field.getValue());            field.fireEvent("blur");        } else if (keyCode == e.ESC) {            field.fireEvent("blur");        }    },		getCenterPosition: function(svgNode){				var center 		= {x: 0, y:0 };		// transformation to the coordinate origin of the canvas		var trans 		= svgNode.getTransformToElement(this.facade.getCanvas().rootNode.lastChild);		var scale 		= this.facade.getCanvas().rootNode.lastChild.getScreenCTM();		var transLocal 	= svgNode.getTransformToElement(svgNode.parentNode);		var bounds = undefined;				center.x 	= trans.e - transLocal.e;		center.y 	= trans.f - transLocal.f;						try {			bounds = svgNode.getBBox();		} catch (e) {}		// Firefox often fails to calculate the correct bounding box		// in this case we fall back to the upper left corner of the shape		if (bounds === null || typeof bounds === "undefined" || bounds.width == 0 || bounds.height == 0) {			bounds = {				x: Number(svgNode.getAttribute('x')),				y: Number(svgNode.getAttribute('y')),				width: 0,				height: 0			};		}				center.x += bounds.x;		center.y += bounds.y;				center.x += bounds.width/2;		center.y += bounds.height/2;				center.x *= scale.a;		center.y *= scale.d;				return center;			},	getDifferenceCenterForNode: function getDifferenceCenterForNode(svgNode){        //for shapes that do not have multiple lables on the x-line, only the vertical difference matters        var center  = this.getCenterPosition(svgNode);        center.x = 0;        center.y = center.y + 10;        return center;    },		hide: function(e){		if (this.shownTextField && (!e || !this.shownTextField.el || e.target !== this.shownTextField.el.dom)) {			this.shownTextField.onBlur();		}	},		destroy: function(e){		if( this.shownTextField ){			this.shownTextField.destroy(); 			delete this.shownTextField; 						this.facade.enableEvent(ORYX.CONFIG.EVENT_KEYDOWN);		}	}});/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Supports EPCs by offering a syntax check and export and import ability..
 * 
 * 
 */
ORYX.Plugins.ERDFSupport = Clazz.extend({

	facade: undefined,
	
	ERDFServletURL: '/erdfsupport',

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {
		
		this.facade = facade;
			
			
		this.facade.offer({
			'name':				ORYX.I18N.ERDFSupport.exp,
			'functionality': 	this.exportERDF.bind(this),
			'group': 			'Export',
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': 			ORYX.PATH + "images/erdf_export_icon.png",
			'description': 		ORYX.I18N.ERDFSupport.expDesc,
			'index': 			0,
			'minShape': 		0,
			'maxShape': 		0
		});
					
		this.facade.offer({
			'name':				ORYX.I18N.ERDFSupport.imp,
			'functionality': 	this.importERDF.bind(this),
			'group': 			'Export',
            dropDownGroupIcon: ORYX.PATH + "images/import.png",
			'icon': 			ORYX.PATH + "images/erdf_import_icon.png",
			'description': 		ORYX.I18N.ERDFSupport.impDesc,
			'index': 			1,
			'minShape': 		0,
			'maxShape': 		0
		});

	},

	
	/**
	 * Imports an AML description
	 * 
	 */
	importERDF: function(){
		this._showImportDialog();
	},		

	
	/**
	 * Imports an AML description
	 * 
	 */
	exportERDF: function(){
        // Show deprecation message
        Ext.Msg.show({
           title:ORYX.I18N.ERDFSupport.deprTitle,
           msg: ORYX.I18N.ERDFSupport.deprText,
           buttons: Ext.Msg.YESNO,
           fn: function(buttonId){
               if(buttonId === 'yes'){
                    var s   = this.facade.getERDF();
                    
                    //this.openXMLWindow( s );
                    this.openDownloadWindow(window.document.title + ".xml", s);
               }
           }.bind(this),
           icon: Ext.MessageBox.WARNING 
        });
	},
	
	/**
	 * 
	 * 
	 * @param {Object} url
	 * @param {Object} params
	 * @param {Object} successcallback
	 */
	sendRequest: function( url, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
            method			: 'POST',
            asynchronous	: false,
            parameters		: params,
			onSuccess		: function(transport) {
				
				suc = true;
				
				if(successcallback){
					successcallback( transport.result )	
				}
				
			}.bind(this),
			
			onFailure		: function(transport) {

				if(failedcallback){
					
					failedcallback();
					
				} else {
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.ERDFSupport.impFailed);
					ORYX.log.warn("Import ERDF failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		
		return suc;
							
	},


	loadERDF: function( erdfString, success, failed ){
		
		var s 	= erdfString;
		s 		= s.startsWith('<?xml') ? s : '<?xml version="1.0" encoding="utf-8"?>'+s+'';	
						
		var parser	= new DOMParser();			
		var doc 	=  parser.parseFromString( s ,"text/xml");
							
		if( doc.firstChild.tagName == "parsererror" ){

			Ext.MessageBox.show({
					title: 		ORYX.I18N.ERDFSupport.error,
 					msg: 		ORYX.I18N.ERDFSupport.impFailed2 + doc.firstChild.textContent.escapeHTML(),
					buttons: 	Ext.MessageBox.OK,
					icon: 		Ext.MessageBox.ERROR
				});
																
			if(failed)
				failed();
				
		} else if( !this.hasStencilSet(doc) ){
			
			if(failed)
				failed();		
		
		} else {
			
			this.facade.importERDF( doc );
			
			if(success)
				success();
		
		}
	},

	hasStencilSet: function( doc ){
		
		var getElementsByClassNameFromDiv 	= function(doc, id){ return $A(doc.getElementsByTagName('div')).findAll(function(el){ return $A(el.attributes).any(function(attr){ return attr.nodeName == 'class' && attr.nodeValue == id }) })	}

		// Get Canvas Node
		var editorNode 		= getElementsByClassNameFromDiv( doc, '-oryx-canvas')[0];
		
		if( !editorNode ){
			this.throwWarning(ORYX.I18N.ERDFSupport.noCanvas);
			return false
		}
		
		var stencilSetNode 	= $A(editorNode.getElementsByTagName('a')).find(function(node){ return node.getAttribute('rel') == 'oryx-stencilset'});

		if( !stencilSetNode ){
			this.throwWarning(ORYX.I18N.ERDFSupport.noSS);
			return false
		}
		
		var stencilSetUrl	= stencilSetNode.getAttribute('href').split("/")
		stencilSetUrl		= stencilSetUrl[stencilSetUrl.length-2] + "/" + stencilSetUrl[stencilSetUrl.length-1];
		
//		var isLoaded = this.facade.getStencilSets().values().any(function(ss){ return ss.source().endsWith( stencilSetUrl ) })
//		if( !isLoaded ){
//			this.throwWarning(ORYX.I18N.ERDFSupport.wrongSS);
//			return false
//		}
				
		return true;
	},
	
	throwWarning: function( text ){
		Ext.MessageBox.show({
					title: 		ORYX.I18N.Oryx.title,
 					msg: 		text,
					buttons: 	Ext.MessageBox.OK,
					icon: 		Ext.MessageBox.WARNING
				});
	},
	
	/**
	 * Opens a new window that shows the given XML content.
	 * 
	 * @param {Object} content The XML content to be shown.
	 */
	openXMLWindow: function(content) {
		var win = window.open(
		   'data:application/xml,' + encodeURIComponent(
		     content
		   ),
		   '_blank', "resizable=yes,width=600,height=600,toolbar=0,scrollbars=yes"
		);
	},
	
	/**
	 * Opens a download window for downloading the given content.
	 * 
	 */
	openDownloadWindow: function(file, content) {
		var win = window.open("");
		if (win != null) {
			win.document.open();
			win.document.write("<html><body>");
			var submitForm = win.document.createElement("form");
			win.document.body.appendChild(submitForm);
			
			submitForm.appendChild( this.createHiddenElement("download", content));
			submitForm.appendChild( this.createHiddenElement("file", file));
			
			
			submitForm.method = "POST";
			win.document.write("</body></html>");
			win.document.close();
			submitForm.action= ORYX.PATH + "/download";
			submitForm.submit();
		}		
	},
	
	/**
	 * Creates a hidden form element to communicate parameter values.
	 * 
	 * @param {Object} name  The name of the hidden field
	 * @param {Object} value The value of the hidden field
	 */
	createHiddenElement: function(name, value) {
		var newElement = document.createElement("input");
		newElement.name=name;
		newElement.type="hidden";
		newElement.value = value;
		return newElement
	},

	/**
	 * Opens a upload dialog.
	 * 
	 */
	_showImportDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.ERDFSupport.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            fieldLabel: ORYX.I18N.ERDFSupport.file,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	        }, {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	        }]
	    });



		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.ERDFSupport.impERDF, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.ERDFSupport.impBtn,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.ERDFSupport.impProgress});
						loadMask.show();
						
						window.setTimeout(function(){
					
							
							var erdfString =  form.items.items[2].getValue();
							this.loadERDF(erdfString, function(){loadMask.hide();dialog.hide()}.bind(this), function(){loadMask.hide();}.bind(this))
														
														
							
						}.bind(this), 100);
			
					}.bind(this)
				},{
					text:ORYX.I18N.ERDFSupport.close,
					handler:function(){
						
						dialog.hide();
					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt){
				var text = evt.target.files[0].getAsText('UTF-8');
				form.items.items[2].setValue( text );
			}, true)

	}
	
});
/**
 * Copyright (c) 2009
 * Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
 * Enables exporting and importing current model in JSON.
 */
ORYX.Plugins.JSONSupport = ORYX.Plugins.AbstractPlugin.extend({

    construct: function(){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        
        this.facade.offer({
            'name': ORYX.I18N.JSONSupport.exp.name,
            'functionality': this.exportJSON.bind(this),
            'group': ORYX.I18N.JSONSupport.exp.group,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': ORYX.PATH + "images/page_white_javascript.png",
            'description': ORYX.I18N.JSONSupport.exp.desc,
            'index': 0,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.offer({
            'name': ORYX.I18N.JSONSupport.imp.name,
            'functionality': this.showImportDialog.bind(this),
            'group': ORYX.I18N.JSONSupport.imp.group,
            dropDownGroupIcon: ORYX.PATH + "images/import.png",
			'icon': ORYX.PATH + "images/page_white_javascript.png",
            'description': ORYX.I18N.JSONSupport.imp.desc,
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    exportJSON: function(){
        var json = this.facade.getSerializedJSON();
        this.openDownloadWindow(window.document.title + ".json", json);
    },
    
    /**
     * Opens a upload dialog.
     *
     */
    showImportDialog: function(successCallback){
    
        var form = new Ext.form.FormPanel({
            baseCls: 'x-plain',
            labelWidth: 50,
            defaultType: 'textfield',
            items: [{
                text: ORYX.I18N.JSONSupport.imp.selectFile,
                style: 'font-size:12px;margin-bottom:10px;display:block;',
                anchor: '100%',
                xtype: 'label'
            }, {
                fieldLabel: ORYX.I18N.JSONSupport.imp.file,
                name: 'subject',
                inputType: 'file',
                style: 'margin-bottom:10px;display:block;',
                itemCls: 'ext_specific_window_overflow'
            }, {
                xtype: 'textarea',
                hideLabel: true,
                name: 'msg',
                anchor: '100% -63'
            }]
        });
        
        // Create the panel
        var dialog = new Ext.Window({
            autoCreate: true,
            layout: 'fit',
            plain: true,
            bodyStyle: 'padding:5px;',
            title: ORYX.I18N.JSONSupport.imp.name,
            height: 350,
            width: 500,
            modal: true,
            fixedcenter: true,
            shadow: true,
            proxyDrag: true,
            resizable: true,
            items: [form],
            buttons: [{
                text: ORYX.I18N.JSONSupport.imp.btnImp,
                handler: function(){
                
                    var loadMask = new Ext.LoadMask(Ext.getBody(), {
                        msg: ORYX.I18N.JSONSupport.imp.progress
                    });
                    loadMask.show();
                    
                    window.setTimeout(function(){
                        var json = form.items.items[2].getValue();
                        try {
                            this.facade.importJSON(json, true);
                            dialog.close();
                        } 
                        catch (error) {
                            Ext.Msg.alert(ORYX.I18N.JSONSupport.imp.syntaxError, error.message);
                        }
                        finally {
                            loadMask.hide();
                        }
                    }.bind(this), 100);
                    
                }.bind(this)
            }, {
                text: ORYX.I18N.JSONSupport.imp.btnClose,
                handler: function(){
                    dialog.close();
                }.bind(this)
            }]
        });
        
        // Show the panel
        dialog.show();
        
        // Adds the change event handler to 
        form.items.items[1].getEl().dom.addEventListener('change', function(evt){
            var text = evt.target.files[0].getAsText('UTF-8');
            form.items.items[2].setValue(text);
        }, true)
        
    }
    
});
/** * Copyright (c) 2009 * Falko Menge * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Transforms a BPMNplus diagram to its XPDL4Chor representation and * calls a transformation web service to generate BPEL4Chor from the XPDL4Chor * representation. */ORYX.Plugins.RDFExport = ORYX.Plugins.AbstractPlugin.extend({		construct: function() {		arguments.callee.$.construct.apply(this, arguments);			this.facade.offer({			'name'				: ORYX.I18N.RDFExport.rdfExport,			'functionality'		: this.exportRDF.bind(this),			'group'				: ORYX.I18N.RDFExport.group,            dropDownGroupIcon   : ORYX.PATH + "images/export2.png",			'icon'				: ORYX.PATH + "images/page_white_code.png",			'description'		: ORYX.I18N.RDFExport.rdfExportDescription,			'index'				: 0,			'minShape'			: 0,			'maxShape'			: 0		});			},	exportRDF: function() {				this.openDownloadWindow( window.document.title + ".rdf", this.getRDFFromDOM() );			}	});/** * Copyright (c) 2008 * Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * This plugin offer the functionality of undo/redo * Therewith the command pattern is used. *  * A Plugin which want that the changes could get undo/redo has  * to implement a command-class (which implements the method .execute(), .rollback()). * Those instance of class must be execute thru the facade.executeCommands(). If so, * those command get stored here in the undo/redo stack and can get reset/restore. * **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.Undo = Clazz.extend({		// Defines the facade    facade		: undefined,    	// Defines the undo/redo Stack	undoStack	: [],	redoStack	: [],		// Constructor     construct: function(facade){            this.facade = facade;     				// Offers the functionality of undo                        this.facade.offer({			name			: ORYX.I18N.Undo.undo,			description		: ORYX.I18N.Undo.undoDesc,			icon			: ORYX.PATH + "images/arrow_undo.png",			keyCodes: [{					metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],					keyCode: 90,					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN				}		 	],			functionality	: this.doUndo.bind(this),			group			: ORYX.I18N.Undo.group,			isEnabled		: function(){ return this.undoStack.length > 0 }.bind(this),			index			: 0		}); 		// Offers the functionality of redo        this.facade.offer({			name			: ORYX.I18N.Undo.redo,			description		: ORYX.I18N.Undo.redoDesc,			icon			: ORYX.PATH + "images/arrow_redo.png",			keyCodes: [{					metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],					keyCode: 89,					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN				}		 	],			functionality	: this.doRedo.bind(this),			group			: ORYX.I18N.Undo.group,			isEnabled		: function(){ return this.redoStack.length > 0 }.bind(this),			index			: 1		}); 				// Register on event for executing commands --> store all commands in a stack		 		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_EXECUTE_COMMANDS, this.handleExecuteCommands.bind(this) );    		},		/**	 * Stores all executed commands in a stack	 * 	 * @param {Object} evt	 */	handleExecuteCommands: function( evt ){				// If the event has commands		if( !evt.commands ){ return }				// Add the commands to a undo stack ...		this.undoStack.push( evt.commands );		// ...and delete the redo stack		this.redoStack = [];			},		/**	 * Does the undo	 * 	 */	doUndo: function(){		// Get the last commands		var lastCommands = this.undoStack.pop();				if( lastCommands ){			// Add the commands to the redo stack			this.redoStack.push( lastCommands );						// Rollback every command			lastCommands.each(function(command){				command.rollback();			});		}				// Update and refresh the canvas		//this.facade.getCanvas().update();		//this.facade.updateSelection();		this.facade.raiseEvent({			type 	: ORYX.CONFIG.EVENT_UNDO_ROLLBACK, 			commands: lastCommands		});	},		/**	 * Does the redo	 * 	 */	doRedo: function(){				// Get the last commands from the redo stack		var lastCommands = this.redoStack.pop();				if( lastCommands ){			// Add this commands to the undo stack			this.undoStack.push( lastCommands );						// Execute those commands			lastCommands.each(function(command){				command.execute();			});		}		// Update and refresh the canvas				//this.facade.getCanvas().update();		//this.facade.updateSelection();		this.facade.raiseEvent({			type 	: ORYX.CONFIG.EVENT_UNDO_EXECUTE, 			commands: lastCommands		});	}	});/**
 * Copyright (c) 2008
 * Stefan Krumnow
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Supports EPCs by offering a syntax check and export and import ability..
 * 
 * 
 */
ORYX.Plugins.EPCSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {
		this.facade = facade;
		
		this.facade.offer({
			'name':ORYX.I18N.EPCSupport.exp,
			'functionality': this.exportEPC.bind(this),
			'group': ORYX.I18N.EPCSupport.group,
			'icon': ORYX.PATH + "images/epml_export_icon.png",
			'description': ORYX.I18N.EPCSupport.expDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0});
			
		this.facade.offer({
			'name':ORYX.I18N.EPCSupport.imp,
			'functionality': this.importEPC.bind(this),
			'group': ORYX.I18N.EPCSupport.group,
			'icon': ORYX.PATH + "images/epml_import_icon.png",
			'description': ORYX.I18N.EPCSupport.impDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0});
	
	},

	
	/**
	 * Imports an AML or EPML description
	 */
	importEPC: function(){
		this.openUploadDialog();
	},		

	
	/**
	 * Exports the diagram into an AML or EPML file
	 */
	exportEPC: function(){

		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.EPCSupport.progressExp});
		var xmlSerializer = new XMLSerializer();

		
		// TODO: a Syntax Syntax-Check should be triggered, here.
		 
		// TODO: get process' name
		var resource = "Oryx-EPC";
		
		// Force to set all resource IDs
		var serializedDOM = DataManager.serializeDOM( this.facade );

		//add namespaces
		serializedDOM = '<?xml version="1.0" encoding="utf-8"?>' +
		'<html xmlns="http://www.w3.org/1999/xhtml" ' +
		'xmlns:b3mn="http://b3mn.org/2007/b3mn" ' +
		'xmlns:ext="http://b3mn.org/2007/ext" ' +
		'xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" ' +
		'xmlns:atom="http://b3mn.org/2007/atom+xhtml">' +
		'<head profile="http://purl.org/NET/erdf/profile">' +
		'<link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" />' +
		'<link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " />' +
		'<link rel="schema.b3mn" href="http://b3mn.org" />' +
		'<link rel="schema.oryx" href="http://oryx-editor.org/" />' +
		'<link rel="schema.raziel" href="http://raziel.org/" />' +
		'<base href="' +
		location.href.split("?")[0] +
		'" />' +
		'</head><body>' +
		serializedDOM +
		'<div id="generatedProcessInfos"><span class="oryx-id">' + resource + '</span>' + 
		'<span class="oryx-name">' + resource + '</span></div>' +
		'</body></html>';
		
		/*
		 * Transform eRDF -> RDF
		 */
		var erdf2rdfXslt = ORYX.PATH + "/lib/extract-rdf.xsl";

		var rdfResultString;
		rdfResult = this.transformString(serializedDOM, erdf2rdfXslt, true);
		if (rdfResult instanceof String) {
			rdfResultString = rdfResult;
			rdfResult = null;
		} else {
			rdfResultString = xmlSerializer.serializeToString(rdfResult);
			if (!rdfResultString.startsWith("<?xml")) {
				rdfResultString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + rdfResultString;
			}
		}
		
		/*
		 * Transform RDF -> EPML
		 */
		var rdf2epmlXslt = ORYX.PATH + "/xslt/RDF2EPML.xslt";
		
		var epmlResult = this.transformDOM(rdfResult, rdf2epmlXslt, true);
		var epmlResultString;
		if (epmlResult instanceof String) {
			epmlResultString = epmlResult;
			epmlResult = null;
		} else {
			epmlResultString = xmlSerializer.serializeToString(epmlResult);
			if (!epmlResultString.startsWith("<?xml")) {
				epmlResultString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + epmlResultString;
			}
		}
		
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
		
		// At the moment, only EPML is going to be returned.
		this.openDownloadWindow(resource + ".epml", epmlResultString);
    },
	
	/**
	 * Transforms the given string via xslt.
	 * 
	 * @param {String} string
	 * @param {String} xsltPath
	 * @param {Boolean} getDOM
	 */
	transformString: function(string_, xsltPath, getDOM){
		var parser = new DOMParser();
		var parsedDOM = parser.parseFromString(string_,"text/xml");	
		
		return this.transformDOM(parsedDOM, xsltPath, getDOM);
	},
	
	/**
	 * Transforms the given dom via xslt.
	 * 
	 * @param {Object} domContent
	 * @param {String} xsltPath
	 * @param {Boolean} getDOM
	 */
	transformDOM: function(domContent, xsltPath, getDOM){	
		if (domContent == null) {
			return new String("Parse Error: \nThe given dom content is null.");
		}
		var xsl = "";
		source=ORYX.PATH + "lib/extract-rdf.xsl";
		new Ajax.Request(source, {
			asynchronous: false,
			method: 'get',
			onSuccess: function(transport){
				xsl = transport.responseText
			}.bind(this),
			onFailure: (function(transport){
				ORYX.Log.error("XSL load failed" + transport);
			}).bind(this)
		});
		var result;
		var resultString;
		var xsltProcessor = new XSLTProcessor();
		var domParser = new DOMParser();
		var xslObject = domParser.parseFromString(xsl, "text/xml");
		xsltProcessor.importStylesheet(xslObject);
		try {
			result = xsltProcessor.transformToFragment(domContent, document);
		} catch (error){
			return new String("Parse Error: "+error.name + "\n" + error.message);
		}
		if (getDOM){
			return result;
		}
		resultString = (new XMLSerializer()).serializeToString(result);
		return resultString;
	},

	/**
	 * Opens a upload dialog.
	 * 
	 */
	openUploadDialog: function(){
		
		var form = new Ext.form.FormPanel({
			frame : 		true,
			bodyStyle:		'padding:5px;',
			defaultType : 	'textfield',
		  	labelAlign : 	'left',
		  	buttonAlign: 	'right',
		  	fileUpload : 	true,
		  	enctype : 		'multipart/form-data',
		  	items : [
		  	{
		    	text : 		ORYX.I18N.EPCSupport.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
				xtype : 	'label'
		  	},{
		    	fieldLabel : 	ORYX.I18N.EPCSupport.file,
		    	inputType : 	'file',
				labelStyle :	'width:50px;',
				itemCls :		'ext_specific_window_overflow'
		  	}]
		});


		var dialog = new Ext.Window({ 
			autoCreate: true, 
			title: 		ORYX.I18N.EPCSupport.impPanel, 
			height: 	'auto', 
			width: 		'auto', 
			modal:		true,
			collapsible:false,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	false,
			items: [form],
			buttons:[
				{
					text:ORYX.I18N.EPCSupport.impBtn,
					handler: function(){
						
							
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.EPCSupport.progressImp});
						loadMask.show();
												
						form.form.submit({
				      		url: ORYX.PATH + '/epc-upload',
				      		success: function(f,a){
								
								dialog.hide();
								
								// Get the erdf string					
								var erdf = a.result;
								erdf = erdf.startsWith('<?xml') ? erdf : '<?xml version="1.0" encoding="utf-8"?><div>'+erdf+'</div>';	
								// Load the content to the editor
								this.loadContent(erdf);
								// Hide the waiting panel
								loadMask.hide();
								
				      		}.bind(this),
							failure: function(f,a){
								dialog.hide();
								loadMask.hide();
								Ext.MessageBox.show({
		           					title: ORYX.I18N.EPCSupport.error,
		          	 				msg: a.response.responseText.substring(a.response.responseText.indexOf("content:'")+9, a.response.responseText.indexOf("'}")),
		           					buttons: Ext.MessageBox.OK,
		           					icon: Ext.MessageBox.ERROR
		       					});
				      		}
				  		});
					}.bind(this)
				},{
					text:ORYX.I18N.EPCSupport.close,
					handler:function(){
						dialog.hide();
					}.bind(this)
				}
			]
		});

		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});
		dialog.show();
	},
	
	/**
	 * Creates a hidden form element to communicate parameter values
	 * to a php file.
	 * 
	 * @param {Object} name  The name of the hidden field
	 * @param {Object} value The value of the hidden field
	 */
	createHiddenElement: function(name, value) {
		var newElement = document.createElement("input");
		newElement.name=name;
		newElement.type="hidden";
		newElement.value = value;
		return newElement
	},
	
	/**
	 * Returns the file name to the given result-entry.
	 * 
	 * @param {String} entry.
	 */
	getFileName: function(entry) {
		var l = entry.length;
		if (l > 5){
			if (entry.substr(l-5, 5) == "(AML)"){
				return entry.substr(0, l-6);
			}
		}
		return entry
	},
	
	/**
	 * Opens a download window for downloading the given content.
	 * 
	 * Creates a submit form to communicate the contents to the 
	 * download.php file.
	 * 
	 * @param {Object} content The content to be downloaded. If it is a zip 
	 *                         file, then this should be an array of contents.
	 * @param {Object} zip     True, if it is a zip file, false otherwise
	 */
	openDownloadWindow: function(file, content) {
		var win = window.open("");
		if (win != null) {
			win.document.open();
			win.document.write("<html><body>");
			var submitForm = win.document.createElement("form");
			win.document.body.appendChild(submitForm);
			
			var file = this.getFileName(file);
			submitForm.appendChild( this.createHiddenElement("download", content));
			submitForm.appendChild( this.createHiddenElement("file", file));
			
			
			submitForm.method = "POST";
			win.document.write("</body></html>");
			win.document.close();
			submitForm.action= ORYX.PATH + "/download";
			submitForm.submit();
		}		
	},
	
	
	/**
	 * Loads the imported string into the oryx
	 * 
	 * @param {Object} content
	 */
	loadContent: function( content ){
		
		var parser	= new DOMParser();			
		var doc 	= parser.parseFromString( content ,"text/xml");
		
		this.facade.importERDF( doc );
		
	}
	
});/**
 * Copyright (c) 2009
 * Stefan Krumnow, Ole Eckermann
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.JPDLSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	
	stencilSetExtensionNamespace: 'http://oryx-editor.org/stencilsets/extensions/jbpm#',
	stencilSetExtensionDefinition: 'jbpm/jbpm.json',
	
	stencilSetNamespace: 'http://b3mn.org/stencilset/bpmn1.1#',
	stencilSetUrlSuffix: '/bpmn1.1/bpmn1.1.json',

	/**
	 * constructor method
	 * 
	 */
	construct: function(facade) {
		
		this.facade = facade;
			
		this.facade.offer({
			'name':				ORYX.I18N.jPDLSupport.exp,
			'functionality': 	this.exportJPDL.bind(this),
			'group': 			ORYX.I18N.jPDLSupport.group,
			'icon': 			ORYX.PATH + "images/jpdl_export_icon.png",
			'description': 		ORYX.I18N.jPDLSupport.expDesc,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'index': 			1,
			'minShape': 		0,
			'maxShape': 		0,
			'maxShape': 		0,
			'isEnabled': 		this._isJpdlStencilSetExtensionLoaded.bind(this)
		});
					
		this.facade.offer({
			'name':				ORYX.I18N.jPDLSupport.imp,
			'functionality': 	this.importJPDL.bind(this),
			'group': 			ORYX.I18N.jPDLSupport.group,
            dropDownGroupIcon: ORYX.PATH + "images/import.png",
			'icon': 			ORYX.PATH + "images/jpdl_import_icon.png",
			'description': 		ORYX.I18N.jPDLSupport.impDesc,
			'index': 			2,
			'minShape': 		0,
			'maxShape': 		0
		});

	},
	
	/**
	 * Checks if the jPDL stencil set is loaded right now.
	 */
	_isJpdlStencilSetExtensionLoaded: function() {
		return this.isStencilSetExtensionLoaded(this.stencilSetExtensionNamespace);
	},

	/**
	 * Imports jPDL
	 * 
	 */
	importJPDL: function(){
		this._showImportDialog();
	},		

	/**
	 * Exports jPDL
	 * 
	 */
	exportJPDL: function(){
		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
    		this._doExport();			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;

		
	},
	
	/**
	 * Sends request to a given URL.
	 * 
	 */
	_sendRequest: function( url, method, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
           method			: method,
           asynchronous	: false,
           parameters		: params,
		   onSuccess		: function(transport) {
				
				suc = true;
				
				if(successcallback){
					successcallback( transport.responseText )	
				}
				
			}.bind(this),
			
			onFailure		: function(transport) {

				if(failedcallback){
					
					failedcallback();
					
				} else {
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedReq);
					ORYX.log.warn("Import jPDL failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		return suc;		
	},
	
	/**
	 * Loads JSON into the editor
	 * 
	 */
	_loadJSON: function( jsonString ){
		
		if (jsonString) {
			var jsonObj = jsonString.evalJSON();
			if( jsonObj && this._hasStencilset(jsonObj) ) {
				if ( this._isJpdlStencilSetExtensionLoaded() ) {
					this.facade.importJSON(jsonString);
				} else {
					Ext.MessageBox.confirm(
						ORYX.I18N.jPDLSupport.loadSseQuestionTitle,
						ORYX.I18N.jPDLSupport.loadSseQuestionBody,
						function(btn){
							if (btn == 'yes') {
								
								if (this.loadStencilSetExtension(this.stencilSetNamespace, this.stencilSetExtensionDefinition)){
									this.facade.importJSON(jsonString);
								} else {
									this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJson);
								}
								
							} else {
								this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJsonAbort);
							}
						},
						this
					);
				}
				
			} else {
				this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJson);
			}
		} else {
			this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.impFailedJson);
		}
	},
	
	loadStencilSetExtension: function(stencilSetNamespace, stencilSetExtensionDefinition) {
		var stencilset = this.facade.getStencilSets()[stencilSetNamespace];
		if (stencilset) {
			stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + stencilSetExtensionDefinition);
			this.facade.getRules().initializeRules(stencilset);
			this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED});
			return true;
		} 
		return false;
	},
	
	/**
	 * Checks if a json object references the jPDL stencil set extension.
	 * 
	 */
	_hasStencilset: function( jsonObj ){
		return jsonObj.properties.ssextension == this.stencilSetExtensionNamespace && jsonObj.stencilset.url.endsWith(this.stencilSetUrlSuffix);
	},
	

	/**
	 * Opens an export window / tab.
	 * 
	 */
	_doExport: function(){
		var serialized_json = this.facade.getSerializedJSON();

		this._sendRequest(
			ORYX.CONFIG.JPDLEXPORTURL,
			'POST',
			{ data:serialized_json },
			function( result ) { 
				var parser = new DOMParser();
				var parsedResult = parser.parseFromString(result, "text/xml");
				if (parsedResult.firstChild.localName == "error") {
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.expFailedXml + parsedResult.firstChild.firstChild.data);
				} else {
					this.openXMLWindow(result);
				}
			}.bind(this),
			function() { 
				this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.jPDLSupport.expFailedReq);
		 	}.bind(this)
		)
	}, 
	
	/**
	 * Opens a upload dialog.
	 * 
	 */
	_showImportDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.jPDLSupport.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            fieldLabel: ORYX.I18N.jPDLSupport.file,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	        }, {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	        }]
	    });

		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.jPDLSupport.impJPDL, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.jPDLSupport.impBtn,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.jPDLSupport.impProgress});
						loadMask.show();
						
						window.setTimeout(function(){
					
							var jpdlString =  form.items.items[2].getValue();
							
							this._sendRequest(
									ORYX.CONFIG.JPDLIMPORTURL,
									'POST',
									{ 'data' : jpdlString },
									function( arg ) { this._loadJSON( arg );  loadMask.hide();  dialog.hide(); }.bind(this),
									function() { loadMask.hide();  dialog.hide(); }.bind(this)
								);

						}.bind(this), 100);
			
					}.bind(this)
				},{
					text:ORYX.I18N.jPDLSupport.close,
					handler:function(){
						
						dialog.hide();
					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt){
				var text = evt.target.files[0].getAsText('UTF-8');
				form.items.items[2].setValue( text );
			}, true)

	},
	
	_showErrorMessageBox: function(title, msg){
        Ext.MessageBox.show({
           title: title,
           msg: msg,
           buttons: Ext.MessageBox.OK,
           icon: Ext.MessageBox.ERROR
       });
	}
	
});/** * Copyright (c) 2008-2009 * Falko Menge * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Aggregates an XForms user interface based on an annotated BPMN model */ORYX.Plugins.BPMN2XForms = ORYX.Plugins.AbstractPlugin.extend({		stencilSetExtensionSuffix: '/bpmn-xforms-user-interfaces#',	construct: function() {		arguments.callee.$.construct.apply(this, arguments);			this.facade.offer({			'name'				: "Aggregate User Interface",			'functionality'		: this.aggregateUI.bind(this),			'group'				: "User Interface Generation",            dropDownGroupIcon   : ORYX.PATH + "images/bpmn2xforms.png",			'icon'				: ORYX.PATH + "images/page_world.png",			'description'		: "Aggregates an XForm out of BPMN (requires 'BPMN Extension for XForms User Interfaces')",			'index'				: 1,			'minShape'			: 0,			'maxShape'			: 0//,//			'isEnabled'			: this.isStencilSetExtensionLoaded.bind(this)		});/*		this.facade.offer({			'name'				: "Aggregate User Interface and render in Orbeon",			'functionality'		: this.aggregateUIAndRenderInOrbeon.bind(this),			'group'				: "User Interface Generation",            dropDownGroupIcon   : ORYX.PATH + "images/bpmn2xforms.png",			'icon'				: ORYX.PATH + "images/xforms_orbeon_export.png",			'description'		: "Aggregates an XForm out of BPMN (requires 'BPMN Extension for XForms User Interfaces')",			'index'				: 2,			'minShape'			: 0,			'maxShape'			: 0//,//			'isEnabled'			: this.isStencilSetExtensionLoaded.bind(this)		});*/		this.facade.offer({			'name'				: "Save Aggregated User Interface",			'functionality'		: this.saveAggregatedUI.bind(this),			'group'				: "User Interface Generation",            dropDownGroupIcon   : ORYX.PATH + "images/bpmn2xforms.png",			'icon'				: ORYX.PATH + "images/page_save.png",			'description'		: "Aggregates an XForm out of BPMN and stores it on the server (requires 'BPMN Extension for XForms User Interfaces')",			'index'				: 3,			'minShape'			: 0,			'maxShape'			: 0//,//			'isEnabled'			: this.isStencilSetExtensionLoaded.bind(this)		});				this.facade.offer({			'name'				: "Browse Saved User Interfaces",			'functionality'		: this.browseAggregatedUIs.bind(this),			'group'				: "User Interface Generation",            dropDownGroupIcon   : ORYX.PATH + "images/bpmn2xforms.png",			'icon'				: ORYX.PATH + "images/folder_page.png",			'description'		: "Opens a list of Aggregated User Interfaces that are stored on the server.",			'index'				: 4,			'minShape'			: 0,			'maxShape'			: 0//,//			'isEnabled'			: this.isStencilSetExtensionLoaded.bind(this)		});						},	aggregateUI: function() {		this.invokeBPMN2XFormsServlet(ORYX.CONFIG.ROOT_PATH + 'bpmn2xforms', this.openXMLWindow.bind(this));	},	aggregateUIAndRenderInOrbeon: function() {		this.invokeBPMN2XFormsServlet(ORYX.CONFIG.ROOT_PATH + 'bpmn2xforms-orbeon', this.openOrbeonWindow.bind(this));	},	saveAggregatedUI: function() {		this.invokeBPMN2XFormsServlet(ORYX.CONFIG.ROOT_PATH + 'bpmn2xforms?save=true', window.open.bind(window));	},	browseAggregatedUIs: function() {		window.open(ORYX.PATH + "/generated-uis/", "_blank", "resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");	},	openOrbeonWindow: function(content) {		var win = window.open(		   'data:application/xml,' + encodeURIComponent(		     content		   ),		   '_blank', "resizable=yes,width=600,height=600,toolbar=0,scrollbars=yes"		);	},	invokeBPMN2XFormsServlet: function( servletURL, xhtmlHandleFunction ) {				var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:"Aggregating User Interface..."});		loadMask.show();				var rdfString = this.getRDFFromDOM();		this._sendRequest(				servletURL,				'POST',				{ 'data' : rdfString },				function( arg ) { 					xhtmlHandleFunction( arg );  					loadMask.hide();				}.bind(this),				function() { 					loadMask.hide(); 					this._showErrorMessageBox("Oryx", "User Interface Aggregation failed.");					ORYX.log.warn("User Interface Aggregation failed: " + transport.responseText);				}.bind(this)			);	},	_sendRequest: function( url, method, params, successcallback, failedcallback ){		var suc = false;		new Ajax.Request(url, {           method			: method,           asynchronous	: false,           parameters		: params,		   onSuccess		: function(transport) {								suc = true;								if(successcallback){					successcallback( transport.responseText );				}							}.bind(this),						onFailure : function(transport) {				if(failedcallback){					failedcallback();									} else {					Ext.Msg.alert("Oryx", "User Interface Aggregation failed.");					ORYX.log.warn("User Interface Aggregation failed: " + transport.responseText);					}							}.bind(this)				});				return suc;			},		_showErrorMessageBox: function(title, msg){        Ext.MessageBox.show({           title: title,           msg: msg,           buttons: Ext.MessageBox.OK,           icon: Ext.MessageBox.ERROR       });	},	// unused: only XHTML without interaction diagram	transform: function() {				var xslt		= ORYX.PATH + "xslt/BPMN2XHTML.xslt"; 		var transformed = this.doTransform( this.getRDFFromDOM(), xslt );				//this.openDownloadWindow( window.document.title + ".xml", transformed );				var win = window.open("data:application/xhtml+xml," +				transformed, 				"_blank", 				"resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");			},		isStencilSetExtensionLoaded: function() {		return this.facade.getStencilSets().values().any(			function(ss){ 				return ss.extensions().keys().any(					function(extensionKey) {						return extensionKey.endsWith(this.stencilSetExtensionSuffix);					}.bind(this)				);			}.bind(this)		);	}});/** * Copyright (c) 2009 * Stefan Krumnow * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.BPMN2BPEL = ORYX.Plugins.AbstractPlugin.extend({		bpmn2BpelHandlerUrl: ORYX.PATH + "/bpmn2bpel",		stencilSetExtensionSuffix: '/bpmnservicecompositionsubset-goldeneye#',		construct: function(facade) {			this.facade = facade;			this.facade.offer({			'name'				: ORYX.I18N.Bpmn2Bpel.show,			'functionality'		: this.showBpel.bind(this),			'group'				: ORYX.I18N.Bpmn2Bpel.group,            dropDownGroupIcon   : ORYX.PATH + "images/bpmn2bpel_icon.png",			'description'		: ORYX.I18N.Bpmn2Bpel.showDesc,			'index'				: 0,			'minShape'			: 0,			'maxShape'			: 0,			'isEnabled': 		this.isStencilSetExtensionLoaded.bind(this)		});				this.facade.offer({			'name'				: ORYX.I18N.Bpmn2Bpel.download,			'functionality'		: this.downloadBpel.bind(this),			'group'				: ORYX.I18N.Bpmn2Bpel.group,            dropDownGroupIcon   : ORYX.PATH + "images/bpmn2bpel_icon.png",			'description'		: ORYX.I18N.Bpmn2Bpel.downloadDesc,			'index'				: 0,			'minShape'			: 0,			'maxShape'			: 0,			'isEnabled': 		this.isStencilSetExtensionLoaded.bind(this)		});				this.facade.offer({			'name'				: ORYX.I18N.Bpmn2Bpel.deploy,			'functionality'		: this.deployBpel.bind(this),			'group'				: ORYX.I18N.Bpmn2Bpel.group,            dropDownGroupIcon   : ORYX.PATH + "images/bpmn2bpel_icon.png",			'description'		: ORYX.I18N.Bpmn2Bpel.deployDesc,			'index'				: 0,			'minShape'			: 0,			'maxShape'			: 0,			'isEnabled': 		this.isStencilSetExtensionLoaded.bind(this)		});						},		isStencilSetExtensionLoaded: function() {		return this.facade.getStencilSets().values().any(			function(ss){ 				return ss.extensions().keys().any(					function(extensionKey) {						return extensionKey.endsWith(this.stencilSetExtensionSuffix);					}.bind(this)				);			}.bind(this)		);	},	showBpel: function() {			var options = JSON.stringify({action : 'transform'});				this.generateBpel( function( process ) {			this.openXMLWindow(process.process);		}.bind(this), options);	},		downloadBpel: function() {			var options = JSON.stringify({action : 'transform'});		this.generateBpel(			function ( process ) {				this.openDownloadWindow("Oryx-BPEL", process.process);			}.bind(this), options);	},		deployBpel: function() {		this._showInputBox(			function ( apacheOdeUrl ) {				var options = {					apacheOdeUrl : apacheOdeUrl,					action : 'deploy'				};				options = JSON.stringify(options);				this.generateBpel(this._showProcessUrl.bind(this), options);			}.bind(this));	},		generateBpel: function( bpelHandleFunction, options ) {		var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:"Transforming BPMN to BPEL"});		loadMask.show();				var erdfString = this.getRDFFromDOM();		this._sendRequest(				this.bpmn2BpelHandlerUrl,				'POST',				{ 'data' : erdfString,				  'options' : options },				function( arg ) { 					eval("var process = " + arg);					bpelHandleFunction( process );  					loadMask.hide();				}.bind(this),				function() { 					loadMask.hide(); 					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2Bpel.transfFailed);					ORYX.log.warn("Transformation to BPEL failed: " + transport.responseText);				}.bind(this)			);	},			_sendRequest: function( url, method, params, successcallback, failedcallback ){		var suc = false;		new Ajax.Request(url, {           method			: method,           asynchronous	: false,           parameters		: params,		   onSuccess		: function(transport) {								suc = true;								if(successcallback){					successcallback( transport.responseText );				}							}.bind(this),						onFailure : function(transport) {				if(failedcallback){					failedcallback();									} else {					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2Bpel.transfFailed);					ORYX.log.warn("Transformation to BPEL failed: " + transport.responseText);					}							}.bind(this)				});				return suc;			},		_showErrorMessageBox: function(title, msg){        Ext.MessageBox.show({           title: title,           msg: msg,           buttons: Ext.MessageBox.OK,           icon: Ext.MessageBox.ERROR       });	},		_showProcessUrl : function( processUrl ) {		Ext.MessageBox.show({           title: 'BPEL-Process-URL',           msg: processUrl.serviceName,           buttons: Ext.MessageBox.OK,           icon: Ext.MessageBox.INFO       });	},		_showInputBox : function( successCallback ) {				// Create URL - InputField		var urlInputField = new Ext.form.TextField({			value : 'http://localhost:8080/ode',			fieldLabel : 'URL',			width : 200		}		);				// Create a new Panel        var panel = new Ext.FormPanel({            items: [{                xtype: 'label',                text: ORYX.I18N.Bpmn2Bpel.ApacheOdeUrlInputPanelText,                style: 'margin:10px;display:block'            }, urlInputField],            frame: true,            buttons: [{                text: ORYX.I18N.Bpmn2Bpel.ApacheOdeUrlInputLabelDeploy,                handler: function(){                    var url = urlInputField.getValue();  					Ext.getCmp('oryx_ode_url_input_panel_window').close();                    successCallback(url);                }.bind(this)            }, {                text: ORYX.I18N.Bpmn2Bpel.ApacheOdeUrlInputLabelCancel,                handler: function(){                    Ext.getCmp('oryx_ode_url_input_panel_window').close();                }.bind(this)            }]        })				// Create a new Window        var window = new Ext.Window({            id: 'oryx_ode_url_input_panel_window',            width: 350,            title: ORYX.I18N.Bpmn2Bpel.ApacheOdeUrlInputTitle,            floating: true,            shim: true,            modal: true,            resizable: false,            autoHeight: true,            items: [panel]        })                // Show the window        window.show();	}	});/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Supports EPCs by offering a syntax check and export and import ability..
 * 
 * 
 */
ORYX.Plugins.ProcessLink = Clazz.extend({

	facade: undefined,

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {

		this.facade = facade;
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.propertyChanged.bind(this) );
		
	},


	/**
	 * 
	 * @param {Object} option
	 */
	propertyChanged: function( option, node){

		if( option.name !== "oryx-refuri" || !node instanceof ORYX.Core.Node ){ return }
		
		
		if( option.value && option.value.length > 0 && option.value != "undefined"){
			
			this.show( node, option.value );
					
		} else {

			this.hide( node );

		}				

	},
	
	/**
	 * Shows the Link for a particular shape with a specific url
	 * 
	 * @param {Object} shape
	 * @param {Object} url
	 */
	show: function( shape, url){

		
		// Generate the svg-representation of a link
		var link  = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,
					[ 'a',
						{'target': '_blank'},
						['path', 
							{ "stroke-width": 1.0, "stroke":"#00DD00", "fill": "#00AA00", "d":  "M3,3 l0,-2.5 l7.5,0 l0,-2.5 l7.5,4.5 l-7.5,3.5 l0,-2.5 l-8,0", "line-captions": "round"}
						]
					]);

		var link  = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,		
						[ 'a',
							{'target': '_blank'},
							['path', { "style": "fill:#92BFFC;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72", "d": "M0 1.44 L0 15.05 L11.91 15.05 L11.91 5.98 L7.37 1.44 L0 1.44 Z"}],
							['path', { "style": "stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72;fill:none;", "transform": "translate(7.5, -8.5)", "d": "M0 10.51 L0 15.05 L4.54 15.05"}],
							['path', { "style": "fill:#f28226;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-width:0.72", "transform": "translate(-3, -1)", "d": "M0 8.81 L0 13.06 L5.95 13.06 L5.95 15.05 A50.2313 50.2313 -175.57 0 0 10.77 11.08 A49.9128 49.9128 -1.28 0 0 5.95 6.54 L5.95 8.81 L0 8.81 Z"}],
						]);

	/*
	 * 
	 * 					[ 'a',
						{'target': '_blank'},
						['path', { "style": "fill:none;stroke-width:0.5px; stroke:#000000", "d": "M7,4 l0,2"}],
						['path', { "style": "fill:none;stroke-width:0.5px; stroke:#000000", "d": "M4,8 l-2,0 l0,6"}],
						['path', { "style": "fill:none;stroke-width:0.5px; stroke:#000000", "d": "M10,8 l2,0 l0,6"}],
						['rect', { "style": "fill:#96ff96;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 4, "y": 0}],
						['rect', { "style": "fill:#ffafff;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 4, "y": 6}],
						['rect', { "style": "fill:#96ff96;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 0, "y": 12}],
						['rect', { "style": "fill:#96ff96;stroke:#000000;stroke-width:1", "width": 6, "height": 4, "x": 8, "y": 12}],
						['rect', { "style": "fill:none;stroke:none;pointer-events:all", "width": 14, "height": 16, "x": 0, "y": 0}]
					]);
	 */
		
		// Set the link with the special namespace
		link.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", url);
		
		
		// Shows the link in the overlay					
		this.facade.raiseEvent({
					type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
					id: 			"arissupport.urlref_" + shape.id,
					shapes: 		[shape],
					node:			link,
					nodePosition:	"SE"
				});	
							
	},	

	/**
	 * Hides the Link for a particular shape
	 * 
	 * @param {Object} shape
	 */
	hide: function( shape ){

		this.facade.raiseEvent({
					type: 			ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id: 			"arissupport.urlref_" + shape.id
				});	
							
	}		
});/**
 * Copyright (c) 2008
 * Stefan Krumnow
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Supports creating and editing ad-hoc completion conditions
 * 
 */
ORYX.Plugins.AdHocCC = Clazz.extend({

	facade: undefined,
	UNSAVED_RESOURCE: "unsaved",

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {
		this.facade = facade;
		
		this.facade.offer({
			'name':ORYX.I18N.AdHocCC.compl,
			'functionality': this.editCC.bind(this),
			'group': ORYX.I18N.AdHocCC.group,
			'icon': ORYX.PATH + "images/adhoc.gif",
			'description': ORYX.I18N.AdHocCC.complDesc,
			'index': 0,
			'minShape': 1,
			'maxShape': 1
			// ISSUE: Should the Context Area this Plugin is creating be removed?
		});
	},
	
	
	/**
	 * Opens a Dialog that can be used to edit an ad-hoc activity's completion condition
	 * 
	 */
	editCC: function(){	
	
		/*
		 * 	check pre conditions
		 */ 
		var elements = this.facade.getSelection();
		if (elements.length != 1) {
			// Should not happen!
			this.openErroDialog(ORYX.I18N.AdHocCC.notOne);
			return ; 
		}
		var adHocActivity = elements[0];
		if (adHocActivity._stencil.id() != "http://b3mn.org/stencilset/bpmnexec#Subprocess" || !adHocActivity.properties['oryx-isadhoc']){
			this.openErroDialog(ORYX.I18N.AdHocCC.nodAdHocCC); 
			return ;
		}
	
		/*
		 * 	load relevant data
		 */ 	
		var oldCC = adHocActivity.properties['oryx-adhoccompletioncondition'];
		var taskArrayFields = ['resourceID', 'resourceName'];
		var taskArray = []; 
		var stateArrayFields = ['state'];
		var stateArray = [ ['ready'], ['skipped'], ['completed'] ];
		var dataArrayFields = ['resourceID_FieldName', 'dataNameAndFieldName'];
		var dataArray = [];

		var parser = new DOMParser();
		
		var childNodes = adHocActivity.getChildNodes();
		for (var i = 0; i < childNodes.length; i++) {
			var child = childNodes[i];
			if (child._stencil.id() == "http://b3mn.org/stencilset/bpmnexec#Task") {
				var resourceName = child.properties['oryx-name'];
				var resourceID = child.resourceId;
				if (typeof resourceID == "undefined") {
					DataManager.__persistDOM(this.facade);
					resourceID = child.resourceId;
					if (typeof resourceID == "undefined") {
						resourceID = this.UNSAVED_RESOURCE;
						resourceName = resourceName + " (unsaved)";
					}
				}
				taskArray.push([resourceID, resourceName]);
			}
			else if (child._stencil.id() == "http://b3mn.org/stencilset/bpmnexec#DataObject") {
				var resourceName = child.properties['oryx-name'];
				var resourceID = child.resourceId;
				if (typeof resourceID == "undefined") {
					DataManager.__persistDOM(this.facade);
					resourceID = child.resourceId;
					if (typeof resourceID == "undefined") {
						resourceID = this.UNSAVED_RESOURCE;
						resourceName = resourceName + " (unsaved)";
					}
				}
				var dataModelString = child.properties['oryx-datamodel'];
				var dataModel = parser.parseFromString(dataModelString,"text/xml");
				var rootXMLNode = dataModel.childNodes[0];
				if (rootXMLNode != null){
					var childXMLNodes = rootXMLNode.childNodes;
					for (var j = 0; j < childXMLNodes.length; j++) {
						var dataFieldTagName = childXMLNodes[j].attributes['name'].nodeValue;
						if (dataFieldTagName != null) {
							dataArray.push([[resourceID, dataFieldTagName], resourceName + "/" + dataFieldTagName]);
						}
					}
				}
			}
		}
				
		/*
		 * 	initialiaze UI
		 */ 
		var taskStore = new Ext.data.SimpleStore({
   			fields: taskArrayFields,
    		data : taskArray
		});
		
		var stateStore = new Ext.data.SimpleStore({
   			fields: stateArrayFields,
    		data : stateArray
		});
		
		var dataStore = new Ext.data.SimpleStore({
   			fields: dataArrayFields,
    		data : dataArray
		});
		
		var taskCombo = new Ext.form.ComboBox({
    		store: taskStore,
			valueField: taskArrayFields[0],
			displayField: taskArrayFields[1],
    		emptyText: ORYX.I18N.AdHocCC.selectTask,
			typeAhead: true,
    		mode: 'local',
    		triggerAction: 'all',
   			selectOnFocus: true,
			editable: false,
			width: 180
		});
		
		var stateCombo = new Ext.form.ComboBox({
    		store: stateStore,
    		displayField: stateArrayFields[0],
    		emptyText: ORYX.I18N.AdHocCC.selectState,
			typeAhead: true,
    		mode: 'local',
    		triggerAction: 'all',
   			selectOnFocus: true,
			editable: false,
			width: 180
		});

		var addStateExprButton = new Ext.Button({
			text: ORYX.I18N.AdHocCC.addExp,
			handler: function(){
				var task = taskCombo.getValue();
				var state = stateCombo.getValue();
				if (task != this.UNSAVED_RESOURCE && task != "" && state != "") {
					this.addStringToTextArea(textArea, "stateExpression('"+task+"', '"+state+"')");
					taskCombo.setValue("");
					stateCombo.setValue("");
				}
			}.bind(this)
		});
		
		var dataCombo = new Ext.form.ComboBox({
    		store: dataStore,
			valueField: dataArrayFields[0],
    		displayField: dataArrayFields[1],
    		emptyText: ORYX.I18N.AdHocCC.selectDataField,
			typeAhead: true,
    		mode: 'local',
    		triggerAction: 'all',
   			selectOnFocus: true,
			editable: false,
			width: 180
		});
		
		var valueField = new Ext.form.TextField({
			width: 180,
			emptyText: ORYX.I18N.AdHocCC.enterEqual,
		});
		
		var addDataExprButton = new Ext.Button({
			text: ORYX.I18N.AdHocCC.addExp,
			handler: function(){
				var data = dataCombo.getValue();
				var value = valueField.getValue();
				if (data != null && data[0] != this.UNSAVED_RESOURCE && value != "") {
					this.addStringToTextArea(textArea, "dataExpression('"+data[0]+"', '"+data[1]+"', '"+value+"')");
					dataCombo.setValue("");
					valueField.setValue("");
				}
			}.bind(this)
		});
		
		var addAndButton = new Ext.Button({
			text: ORYX.I18N.AdHocCC.and, 
			minWidth: 50,
			handler: function(){
				this.addStringToTextArea(textArea, "&");
			}.bind(this)
		});
					
		var addOrButton = new Ext.Button({
			text: ORYX.I18N.AdHocCC.or, 
			minWidth: 50,
			handler: function(){
				this.addStringToTextArea(textArea, "|");
			}.bind(this)
		});
		
		var addLPButton = new Ext.Button({
			text: "(", 
			minWidth: 50,
			handler: function(){
				this.addStringToTextArea(textArea, "(");
			}.bind(this)
		});
					
		var addRPButton = new Ext.Button({
			text: ")", 
			minWidth: 50,
			handler: function(){
				this.addStringToTextArea(textArea, ")");
			}.bind(this)
		});
		
		var addNotButton = new Ext.Button({
			text: ORYX.I18N.AdHocCC.not, 
			minWidth: 50,
			handler: function(){
				this.addStringToTextArea(textArea, "!");
			}.bind(this)
		});
		
		var textArea = new Ext.form.TextArea({
			width: 418,
			height: 100,
			value: oldCC
		});
		
		var clearButton = new Ext.Button({
			text: ORYX.I18N.AdHocCC.clearCC,
			handler: function(){
				textArea.setValue("");
			}
		});
		
		var win = new Ext.Window({ 
			width: 450,
			//minWidth: 400,
			height: 485,
			//minHeight: 450,
			resizable: false,
			minimizable: false,
			modal: true,
			autoScroll: true,
			title: ORYX.I18N.AdHocCC.editCC,
			layout: 'table',
			defaults: {
		        bodyStyle:'padding:3px;background-color:transparent;border-width:0px'
		    },
			layoutConfig: {
		        columns: 7
		    },
			items: [
				{ items: [new Ext.form.Label({text: ORYX.I18N.AdHocCC.addExecState, style: 'font-size:12px;'})], colspan: 7},
				{}, {items: [taskCombo], colspan: 6},
				{}, {items: [stateCombo], colspan: 4}, {items: [addStateExprButton]}, {},
				{colspan: 7},
				{ items: [new Ext.form.Label({text: ORYX.I18N.AdHocCC.addDataExp, style: 'font-size:12px;'})], colspan: 7},	
				{}, {items: [dataCombo], colspan: 6},
				{}, {items: [valueField], colspan: 4}, {items: [addDataExprButton]}, {},
				{colspan: 7},
				{ items: [new Ext.form.Label({text: ORYX.I18N.AdHocCC.addLogOp, style: 'font-size:12px;'})], colspan: 7},	
				{}, {items: [addAndButton]}, {items: [addOrButton]}, {items: [addLPButton]}, {items: [addRPButton]}, {items: [addNotButton]}, {},
				{colspan: 7},
				{ items: [new Ext.form.Label({text: ORYX.I18N.AdHocCC.curCond, style: 'font-size:12px;'})], colspan: 7},
				{}, {items: [textArea], colspan: 5}, {},
				{colspan: 5}, {items: [clearButton]}, {}
			],
			buttons: [
				{
		        	text: 'Apply',
		        	handler: function(){
		            	win.hide();
						adHocActivity.properties['oryx-adhoccompletioncondition'] = textArea.getValue();
						// ISSUE: This might be done more elegant using a refresh-event implemented in the property window plugin
						this.facade.setSelection([]);
						this.facade.setSelection(elements);
		        	}.bind(this)
		    	},
				{
		        	text: 'Cancel',
		        	handler: function(){win.hide();}
		    	}
			],
	    	keys: [{
	        	key: 27,  // Esc
	        	fn: function(){win.hide();}
	    	}]
		});
		win.show();	
	},
	
	
	/**
	 * Adds an string into a text area
	 * 
	 * NOTE: This implementation does only work with Gecko browsers (e.g. Mozilla Firefox)
	 * 
	 * @param {TextField} textArea
	 * @param {String} string
	 */
	addStringToTextArea: function(textArea, string){
		var selectionStart = textArea.getEl().dom.selectionStart;
		var selectionEnd = textArea.getEl().dom.selectionEnd;
		var currentValue = textArea.getValue();
		textArea.setValue(currentValue.substring(0, selectionStart)+string+currentValue.substring(selectionEnd));
		textArea.getEl().dom.selectionStart = selectionStart + string.length;
		textArea.getEl().dom.selectionEnd = textArea.getEl().dom.selectionStart;
	},
	
	/**
	 * Opens an error dialog
	 * 
	 * @param {String} errorMsg
	 */
	openErroDialog: function(errorMsg){
		Ext.MessageBox.show({
           title: 'Error',
           msg: errorMsg,
           buttons: Ext.MessageBox.OK,
           icon: Ext.MessageBox.ERROR
       });
	}	
	
});
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.CPNToolsSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	stencilSetNamespace: 'http://b3mn.org/stencilset/coloredpetrinet#',

	construct: function(facade) 
	{
		
		this.facade = facade;
			
		this.facade.offer({
			'name':				"Export to CPN Tools",
			'functionality': 	this.exportCPN.bind(this),
			'group': 			ORYX.I18N.cpntoolsSupport.group,
			'dropDownGroupIcon':ORYX.PATH + "images/export2.png",
			'icon': 			ORYX.PATH + "images/cpn/cpn_export.png",
			'description': 		ORYX.I18N.cpntoolsSupport.exportDescription,
			'index': 			0,
			'minShape': 		0,
			'maxShape': 		0,
			'maxShape': 		0
		});
					
		this.facade.offer({
			'name':				"Import from CPN Tools",
			'functionality': 	this.importCPN.bind(this),
			'group': 			ORYX.I18N.cpntoolsSupport.group,
			'dropDownGroupIcon':ORYX.PATH + "images/import.png",
			'icon': 			ORYX.PATH + "images/cpn/cpn_import.png",
			'description': 		ORYX.I18N.cpntoolsSupport.importDescription,
			'index': 			1,
			'minShape': 		0,
			'maxShape': 		0
		});

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_RESIZE_END, this.resetTokenPosition.bind(this));
	},

	// Imports CPN - File
	importCPN: function()
	{
		this._showImportDialog();
	},		
	
	// Exports CPN - File
	exportCPN: function()
	{
				
		// Get the JSON representation which is needed for the mapping 
		var cpnJson = this.facade.getSerializedJSON();
		
		// Do the export
		this._doExportToCPNTools( cpnJson );
	},
	
	resetTokenPosition: function()
	{
		// Get selected places		
		var allplaces = this.facade.getSelection().findAll(function(selectedItem) {
			return (selectedItem.getStencil().id() === "http://b3mn.org/stencilset/coloredpetrinet#Place");
		});
		
		if (allplaces.length > 0)
		{
			allplaces.each(function(place) {
				
				var placeBounds = place.absoluteBounds();
				var placeCenter = placeBounds.center();
				
				// Calculate radius in order to check if a token is in the place
				var radiusY = placeCenter.y - placeBounds.upperLeft().y;
				var radiusX = placeCenter.x - placeBounds.upperLeft().x;
				var radius = Math.min(radiusY,radiusX);
				var c = radius / 2;
				
				// Get all tokens inside the place 
				var alltokens = place.getChildNodes(false).findAll(function(child) {
					return (child.getStencil().id() === "http://b3mn.org/stencilset/coloredpetrinet#Token");
				});
				
				if (alltokens.length > 0)
				{
					var i = 0;
					var x = 0;
					var y = 0;
					
					alltokens.each(function(token) {
						var tokenBounds = token.absoluteBounds();
						var tokenCenter = tokenBounds.center();
						
						// Calculate the distance between token and center of the place
						var diffX = placeCenter.x - tokenCenter.x;
						var diffY = placeCenter.y - tokenCenter.y;
						var distanceToPlaceCenter= diffX*diffX + diffY*diffY; // take care it's squared
						
						// Check if the token is in the place
						if (radius*radius <= distanceToPlaceCenter)
						{	// if the token is out of the place, calculate the position for the token
							// the token are positioned in circle which is in the place
							y = Math.round(Math.sin((Math.PI / 6) * i) * c);
							x = Math.round(Math.cos((Math.PI / 6) * i) * c);
							// take care centerMoveTo is referred to the position in the selected place (not absolute) 
							token.bounds.centerMoveTo(place.bounds.width() / 2  + x, place.bounds.height() / 2 + y);
							token.update();
							i = i + 1;
						}
					});					
				}
			});

		}			
		this.facade.getCanvas().update();
	},

	// ---------------------------------------- Ajax Request --------------------------------
	
	_sendRequest: function( url, method, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(
		url, 
		{
           method			: method,
           asynchronous		: false,
           parameters		: params,
		   onSuccess		: function(transport) 
		   {
				suc = true;
		
				if(successcallback)
				{
					successcallback( transport.responseText )	
				}
		
		   }.bind(this),
		   onFailure		: function(transport) 
		   {
				if(failedcallback)
				{							
					failedcallback();							
				} 
				else 
				{
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
					ORYX.log.warn("Communication failed: " + transport.responseText);	
				}					
		   }.bind(this)		
		});
		
		return suc;		
	},	

// -------------------------------------------- Export Functions ----------------------------
	
	_doExportToCPNTools: function( cpnJSON )
	{		
		this._sendRequest
		(
			ORYX.CONFIG.CPNTOOLSEXPORTER,
			'POST',
			{ 
				data: cpnJSON
			},
			function( result )
			{ 			
				if (result.startsWith("error:"))
				{
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, result);
				}
				else
				{
					this.openDownloadWindow( window.document.title + ".cpn", result );
				}				
			}.bind(this),
			function()
			{ 
				this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
		 	}.bind(this)
		)
	}, 

// -------------------------------------------- Import Functions ------------------------
	
	 // Opens a upload dialog
	_showImportDialog: function( successCallback )
	{
		// Define the form panel
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: 
	        [
	         {
	            text : 		ORYX.I18N.cpntoolsSupport.importTask, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	         },
	         {
	            fieldLabel: ORYX.I18N.cpntoolsSupport.File,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	         }, 
	         {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	         }
	        ]
	    });

		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.cpntoolsSupport.cpn, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text: ORYX.I18N.cpntoolsSupport.importLable,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.jPDLSupport.impProgress});
						loadMask.show();
						
						window.setTimeout(function()
						{					
							// Get the text which is in the text field
							var cpnToImport =  form.items.items[2].getValue();							
							this._getAllPages(cpnToImport, loadMask);

						}.bind(this), 100);

						dialog.hide();
						
					}.bind(this)
					
				},{
					text: ORYX.I18N.cpntoolsSupport.close,
					handler:function()
					{						
						dialog.hide();					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function()
		{
			dialog.destroy(true);
			delete dialog;
		});

		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt)
			{
				var text = evt.target.files[0].getAsText('UTF-8');
				form.items.items[2].setValue( text );
			}, true)

	},
	
	_getAllPages: function(cpnXML, loadMask)
	{
		var parser = new DOMParser();
		var xmlDoc = parser.parseFromString(cpnXML,"text/xml");
		var allPages = xmlDoc.getElementsByTagName("page");
		
		// If there are no pages then it is propably that cpnXML is not a cpn - File
		if (allPages.length == 0)
		{
			loadMask.hide();
			this._showErrorMessageBox(ORYX.I18N.cpntoolsSupport.title, ORYX.I18N.cpntoolsSupport.wrongCPNFile);
			
			return;
		}
		
		
		if (allPages.length == 1)
		{
			pageAttr = allPages[0].children[0];
			pageName = pageAttr.attributes[0].nodeValue;
			
			this._sendRequest(
					ORYX.CONFIG.CPNTOOLSIMPORTER,
					'POST',
					{ 
						'pagesToImport': pageName,
						'data' : cpnXML 
					},
					function( arg )
					{
						if (arg.startsWith("error:"))
						{
							this._showErrorMessageBox(ORYX.I18N.Oryx.title, arg);
							loadMask.hide();
						}
						else
						{
							this.facade.importJSON(arg); 
							loadMask.hide();							
						}
					}.bind(this),
					function()
					{
						loadMask.hide();
						this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
					}.bind(this)
				);
			
			return;
		}
		
		var i, pageName, data = [];
		for (i = 0; i < allPages.length; i++)
		{
			pageAttr = allPages[i].children[0];
			pageName = pageAttr.attributes[0].nodeValue;
			data.push([pageName]);
		}
		
		loadMask.hide();
		this.showPageDialog(data, cpnXML);		
	},
	
	_showErrorMessageBox: function(title, msg)
	{
        Ext.MessageBox.show({
           title: title,
           msg: msg,
           buttons: Ext.MessageBox.OK,
           icon: Ext.MessageBox.ERROR
       });
	},
	
	
	showPageDialog: function(data, cpnXML)
	{
		var reader = new Ext.data.ArrayReader(
				{}, 
				[ {name: 'name'} ]);
		
		var sm = new Ext.grid.CheckboxSelectionModel(
			{
				singleSelect: true
			});
		
	    var grid2 = new Ext.grid.GridPanel({
	    		store: new Ext.data.Store({
		            reader: reader,
		            data: data
		        	}),
		        cm: new Ext.grid.ColumnModel([
		            {
		            	id:'name',
		            	width:200,
		            	sortable: true, 
		            	dataIndex: 'name'
		            },
					sm]),
			sm: sm,
	        frame:true,
			hideHeaders:true,
	        iconCls:'icon-grid',
			listeners : {
				render: function() {
					var recs=[];
					this.grid.getStore().each(function(rec)
					{
						if(rec.data.engaged){
							recs.push(rec);
						}
					}.bind(this));
					this.suspendEvents();
					this.selectRecords(recs);
					this.resumeEvents();
				}.bind(sm)
			}
	    });
	    
	 // Create a new Panel
        var panel = new Ext.Panel({
            items: [{
                xtype: 'label',
                text: 'CPNTools Page',
                style: 'margin:10px;display:block'
            }, grid2],
            frame: true
        })
        
        // Create a new Window
        var window = new Ext.Window({
            id: 'oryx_new_page_selection',
            autoWidth: true,
            title: ORYX.I18N.cpntoolsSupport.title,
            floating: true,
            shim: true,
            modal: true,
            resizable: true,
            autoHeight: true,
            items: [panel],
            buttons: [{
                text: ORYX.I18N.cpntoolsSupport.importLable,
                handler: function()
                {
            		var chosenRecs = "";

            		// Actually it doesn't matter because it's one
            		sm.getSelections().each(function(rec)
            		{
						chosenRecs = rec.data.name;						
					}.bind(this));
            		
            		var strLen = chosenRecs.length; 
            		
            		if (chosenRecs.length == 0)
            		{
            			alert(ORYX.I18N.cpntoolsSupport.noPageSelection);
            			return;
            		}
            		
            		var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.cpntoolsSupport.importProgress});
					loadMask.show();
					
            		window.hide();
            		
        			pageName = chosenRecs;
        			this._sendRequest(
        					ORYX.CONFIG.CPNTOOLSIMPORTER,
        					'POST',
        					{ 
        						'pagesToImport': pageName,
        						'data' : cpnXML 
        					},
        					function( arg )
        					{
								if (arg.startsWith("error:"))
								{
									this._showErrorMessageBox(ORYX.I18N.Oryx.title, arg);
									loadMask.hide();
								}
								else
								{
									this.facade.importJSON(arg); 
									loadMask.hide();							
								}
							}.bind(this),
        					function()
        					{
								loadMask.hide();
								this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.cpntoolsSupport.serverConnectionFailed);
							}.bind(this)
        				);
                }.bind(this)
            }, 
            {
                text: ORYX.I18N.cpntoolsSupport.close,
                handler: function(){
                    window.hide();
                }.bind(this)
            }]
        })
        
        // Show the window
        window.show();
	}		
	
});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/Array.prototype.insertFrom = function(from, to){	to 			= Math.max(0, to);	from 		= Math.min( Math.max(0, from), this.length-1 );			var el 		= this[from];	var old 	= this.without(el);	var newA 	= old.slice(0, to);	newA.push(el);	if(old.length > to ){		newA 	= newA.concat(old.slice(to))	};	return newA;}if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.Arrangement = Clazz.extend({	facade: undefined,	construct: function(facade) {		this.facade = facade;		// Z-Ordering		this.facade.offer({			'name':ORYX.I18N.Arrangement.btf,			'functionality': this.setZLevel.bind(this, this.setToTop),			'group': ORYX.I18N.Arrangement.groupZ,			'icon': ORYX.PATH + "images/shape_move_front.png",			'description': ORYX.I18N.Arrangement.btfDesc,			'index': 1,			'minShape': 1});					this.facade.offer({			'name':ORYX.I18N.Arrangement.btb,			'functionality': this.setZLevel.bind(this, this.setToBack),			'group': ORYX.I18N.Arrangement.groupZ,			'icon': ORYX.PATH + "images/shape_move_back.png",			'description': ORYX.I18N.Arrangement.btbDesc,			'index': 2,			'minShape': 1});		this.facade.offer({			'name':ORYX.I18N.Arrangement.bf,			'functionality': this.setZLevel.bind(this, this.setForward),			'group': ORYX.I18N.Arrangement.groupZ,			'icon': ORYX.PATH + "images/shape_move_forwards.png",			'description': ORYX.I18N.Arrangement.bfDesc,			'index': 3,			'minShape': 1});		this.facade.offer({			'name':ORYX.I18N.Arrangement.bb,			'functionality': this.setZLevel.bind(this, this.setBackward),			'group': ORYX.I18N.Arrangement.groupZ,			'icon': ORYX.PATH + "images/shape_move_backwards.png",			'description': ORYX.I18N.Arrangement.bbDesc,			'index': 4,			'minShape': 1});		// Aligment		this.facade.offer({			'name':ORYX.I18N.Arrangement.ab,			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_BOTTOM]),			'group': ORYX.I18N.Arrangement.groupA,			'icon': ORYX.PATH + "images/shape_align_bottom.png",			'description': ORYX.I18N.Arrangement.abDesc,			'index': 1,			'minShape': 2});		this.facade.offer({			'name':ORYX.I18N.Arrangement.am,			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_MIDDLE]),			'group': ORYX.I18N.Arrangement.groupA,			'icon': ORYX.PATH + "images/shape_align_middle.png",			'description': ORYX.I18N.Arrangement.amDesc,			'index': 2,			'minShape': 2});		this.facade.offer({			'name':ORYX.I18N.Arrangement.at,			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_TOP]),			'group': ORYX.I18N.Arrangement.groupA,			'icon': ORYX.PATH + "images/shape_align_top.png",			'description': ORYX.I18N.Arrangement.atDesc,			'index': 3,			'minShape': 2});		this.facade.offer({			'name':ORYX.I18N.Arrangement.al,			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_LEFT]),			'group': ORYX.I18N.Arrangement.groupA,			'icon': ORYX.PATH + "images/shape_align_left.png",			'description': ORYX.I18N.Arrangement.alDesc,			'index': 4,			'minShape': 2});		this.facade.offer({			'name':ORYX.I18N.Arrangement.ac,			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_CENTER]),			'group': ORYX.I18N.Arrangement.groupA,			'icon': ORYX.PATH + "images/shape_align_center.png",			'description': ORYX.I18N.Arrangement.acDesc,			'index': 5,			'minShape': 2});		this.facade.offer({			'name':ORYX.I18N.Arrangement.ar,			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_RIGHT]),			'group': ORYX.I18N.Arrangement.groupA,			'icon': ORYX.PATH + "images/shape_align_right.png",			'description': ORYX.I18N.Arrangement.arDesc,			'index': 6,			'minShape': 2});					this.facade.offer({			'name':ORYX.I18N.Arrangement.as,			'functionality': this.alignShapes.bind(this, [ORYX.CONFIG.EDITOR_ALIGN_SIZE]),			'group': ORYX.I18N.Arrangement.groupA,			'icon': ORYX.PATH + "images/shape_align_size.png",			'description': ORYX.I18N.Arrangement.asDesc,			'index': 7,			'minShape': 2});					this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_TOP, 	this.setZLevel.bind(this, this.setToTop)	);		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_BACK, 	this.setZLevel.bind(this, this.setToBack)	);		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_FORWARD, 	this.setZLevel.bind(this, this.setForward)	);		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_ARRANGEMENT_BACKWARD, 	this.setZLevel.bind(this, this.setBackward)	);								},		setZLevel:function(callback, event){					//Command-Pattern for dragging one docker		var zLevelCommand = ORYX.Core.Command.extend({			construct: function(callback, elements, facade){				this.callback 	= callback;				this.elements 	= elements;				// For redo, the previous elements get stored				this.elAndIndex	= elements.map(function(el){ return {el:el, previous:el.parent.children[el.parent.children.indexOf(el)-1]} })				this.facade		= facade;			},						execute: function(){								// Call the defined z-order callback with the elements				this.callback( this.elements )							this.facade.setSelection( this.elements )			},			rollback: function(){								// Sort all elements on the index of there containment				var sortedEl =	this.elAndIndex.sortBy( function( el ) {									var value 	= el.el;									var t 		= $A(value.node.parentNode.childNodes);									return t.indexOf(value.node);								}); 								// Every element get setted back bevor the old previous element				for(var i=0; i<sortedEl.length; i++){					var el			= sortedEl[i].el;					var p 			= el.parent;								var oldIndex 	= p.children.indexOf(el);					var newIndex 	= p.children.indexOf(sortedEl[i].previous);					newIndex		= newIndex || 0					p.children 	= p.children.insertFrom(oldIndex, newIndex)								el.node.parentNode.insertBefore(el.node, el.node.parentNode.childNodes[newIndex+1]);				}				// Reset the selection				this.facade.setSelection( this.elements )			}		});			// Instanziate the dockCommand		var command = new zLevelCommand(callback, this.facade.getSelection(), this.facade);		if( event.excludeCommand ){			command.execute();		} else {			this.facade.executeCommands( [command] );			}			},	setToTop: function(elements) {		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.		var tmpElem =  elements.sortBy( function(value, index) {			var t = $A(value.node.parentNode.childNodes);			return t.indexOf(value.node);		});		// Sortiertes Array wird nach oben verschoben.		tmpElem.each( function(value) {			var p = value.parent			p.children = p.children.without( value )			p.children.push( value );			value.node.parentNode.appendChild(value.node);					});	},	setToBack: function(elements) {		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.		var tmpElem =  elements.sortBy( function(value, index) {			var t = $A(value.node.parentNode.childNodes);			return t.indexOf(value.node);		});		tmpElem = tmpElem.reverse();		// Sortiertes Array wird nach unten verschoben.		tmpElem.each( function(value) {			var p = value.parent			p.children = p.children.without( value )			p.children.unshift( value );			value.node.parentNode.insertBefore(value.node, value.node.parentNode.firstChild);		});					},	setBackward: function(elements) {		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.		var tmpElem =  elements.sortBy( function(value, index) {			var t = $A(value.node.parentNode.childNodes);			return t.indexOf(value.node);		});		// Reverse the elements		tmpElem = tmpElem.reverse();				// Delete all Nodes who are the next Node in the nodes-Array		var compactElem = tmpElem.findAll(function(el) {return !tmpElem.some(function(checkedEl){ return checkedEl.node == el.node.previousSibling})});				// Sortiertes Array wird nach eine Ebene nach oben verschoben.		compactElem.each( function(el) {			if(el.node.previousSibling === null) { return; }			var p 		= el.parent;						var index 	= p.children.indexOf(el);			p.children 	= p.children.insertFrom(index, index-1)						el.node.parentNode.insertBefore(el.node, el.node.previousSibling);		});					},	setForward: function(elements) {		// Sortieren des Arrays nach dem Index des SVGKnotens im Bezug auf dem Elternknoten.		var tmpElem =  elements.sortBy( function(value, index) {			var t = $A(value.node.parentNode.childNodes);			return t.indexOf(value.node);		});		// Delete all Nodes who are the next Node in the nodes-Array		var compactElem = tmpElem.findAll(function(el) {return !tmpElem.some(function(checkedEl){ return checkedEl.node == el.node.nextSibling})});						// Sortiertes Array wird eine Ebene nach unten verschoben.		compactElem.each( function(el) {			var nextNode = el.node.nextSibling					if(nextNode === null) { return; }			var index 	= el.parent.children.indexOf(el);			var p 		= el.parent;			p.children 	= p.children.insertFrom(index, index+1)						el.node.parentNode.insertBefore(nextNode, el.node);		});	},	alignShapes: function(way) {		var elements = this.facade.getSelection();		// Set the elements to all Top-Level elements		elements = this.facade.getCanvas().getShapesWithSharedParent(elements);		// Get only nodes		elements = elements.findAll(function(value) {			return (value instanceof ORYX.Core.Node)		});		// Delete all attached intermediate events from the array		elements = elements.findAll(function(value) {			var d = value.getIncomingShapes()			return d.length == 0 || !elements.include(d[0])		});		if(elements.length < 2) { return; }		// get bounds of all shapes.		var bounds = elements[0].absoluteBounds().clone();		elements.each(function(shape) {		        bounds.include(shape.absoluteBounds().clone());		});				// get biggest width and heigth		var maxWidth = 0;		var maxHeight = 0;		elements.each(function(shape){			maxWidth = Math.max(shape.bounds.width(), maxWidth);			maxHeight = Math.max(shape.bounds.height(), maxHeight);		});		var commandClass = ORYX.Core.Command.extend({			construct: function(elements, bounds, maxHeight, maxWidth, way, facade){				this.elements = elements;				this.bounds = bounds;				this.maxHeight = maxHeight;				this.maxWidth = maxWidth;				this.way = way;				this.facade = facade;				this.orgPos = [];			},			setBounds: function(shape, maxSize) {				if(!maxSize)					maxSize = {width: ORYX.CONFIG.MAXIMUM_SIZE, height: ORYX.CONFIG.MAXIMUM_SIZE};				if(!shape.bounds) { throw "Bounds not definined." }								var newBounds = {                    a: {x: shape.bounds.upperLeft().x - (this.maxWidth - shape.bounds.width())/2,                        y: shape.bounds.upperLeft().y - (this.maxHeight - shape.bounds.height())/2},                    b: {x: shape.bounds.lowerRight().x + (this.maxWidth - shape.bounds.width())/2,                        y: shape.bounds.lowerRight().y + (this.maxHeight - shape.bounds.height())/2}	            }								/* If the new width of shape exceeds the maximum width, set width value to maximum. */				if(this.maxWidth > maxSize.width) {					newBounds.a.x = shape.bounds.upperLeft().x - 									(maxSize.width - shape.bounds.width())/2;										newBounds.b.x =	shape.bounds.lowerRight().x + (maxSize.width - shape.bounds.width())/2				}								/* If the new height of shape exceeds the maximum height, set height value to maximum. */				if(this.maxHeight > maxSize.height) {					newBounds.a.y = shape.bounds.upperLeft().y - 									(maxSize.height - shape.bounds.height())/2;										newBounds.b.y =	shape.bounds.lowerRight().y + (maxSize.height - shape.bounds.height())/2				}								/* set bounds of shape */				shape.bounds.set(newBounds);							},						execute: function(){				// align each shape according to the way that was specified.				this.elements.each(function(shape, index) {					this.orgPos[index] = shape.bounds.upperLeft();										var relBounds = this.bounds.clone();					if (shape.parent && !(shape.parent instanceof ORYX.Core.Canvas) ) {						var upL = shape.parent.absoluteBounds().upperLeft();						relBounds.moveBy(-upL.x, -upL.y);					}										switch (this.way) {						// align the shapes in the requested way.						case ORYX.CONFIG.EDITOR_ALIGN_BOTTOM:			                shape.bounds.moveTo({								x: shape.bounds.upperLeft().x,								y: relBounds.b.y - shape.bounds.height()							}); break;						        case ORYX.CONFIG.EDITOR_ALIGN_MIDDLE:			                shape.bounds.moveTo({								x: shape.bounds.upperLeft().x,								y: (relBounds.a.y + relBounds.b.y - shape.bounds.height()) / 2							}); break;						        case ORYX.CONFIG.EDITOR_ALIGN_TOP:			                shape.bounds.moveTo({								x: shape.bounds.upperLeft().x,								y: relBounds.a.y							}); break;						        case ORYX.CONFIG.EDITOR_ALIGN_LEFT:			                shape.bounds.moveTo({								x: relBounds.a.x,								y: shape.bounds.upperLeft().y							}); break;						        case ORYX.CONFIG.EDITOR_ALIGN_CENTER:			                shape.bounds.moveTo({								x: (relBounds.a.x + relBounds.b.x - shape.bounds.width()) / 2,								y: shape.bounds.upperLeft().y							}); break;						        case ORYX.CONFIG.EDITOR_ALIGN_RIGHT:			                shape.bounds.moveTo({								x: relBounds.b.x - shape.bounds.width(),								y: shape.bounds.upperLeft().y							}); break;													case ORYX.CONFIG.EDITOR_ALIGN_SIZE:							if(shape.isResizable) {								this.orgPos[index] = {a: shape.bounds.upperLeft(), b: shape.bounds.lowerRight()};								this.setBounds(shape, shape.maximumSize);							}							break;					}					//shape.update()				}.bind(this));						this.facade.getCanvas().update();								this.facade.updateSelection();			},			rollback: function(){				this.elements.each(function(shape, index) {					if (this.way == ORYX.CONFIG.EDITOR_ALIGN_SIZE) {						if(shape.isResizable) {shape.bounds.set(this.orgPos[index]);}					} else {shape.bounds.moveTo(this.orgPos[index]);}				}.bind(this));								this.facade.getCanvas().update();								this.facade.updateSelection();			}		})				var command = new commandClass(elements, bounds, maxHeight, maxWidth, parseInt(way), this.facade);				this.facade.executeCommands([command]);		}});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner, Philipp Berger * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.Save = Clazz.extend({	    facade: undefined,		processURI: undefined,	    construct: function(facade){		this.facade = facade;				this.facade.offer({			'name': ORYX.I18N.Save.save,			'functionality': this.save.bind(this,false),			'group': ORYX.I18N.Save.group,			'icon': ORYX.PATH + "images/disk.png",			'description': ORYX.I18N.Save.saveDesc,			'index': 1,			'minShape': 0,			'maxShape': 0		});						this.facade.offer({			'name': ORYX.I18N.Save.saveAs,			'functionality': this.save.bind(this,true),			'group': ORYX.I18N.Save.group,			'icon': ORYX.PATH + "images/disk_multi.png",			'description': ORYX.I18N.Save.saveAsDesc,			'index': 2,			'minShape': 0,			'maxShape': 0		});					window.onbeforeunload = this.onUnLoad.bind(this);			this.changeDifference = 0;				// Register on event for executing commands --> store all commands in a stack		 		// --> Execute		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_EXECUTE, function(){ this.changeDifference++ }.bind(this) );		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_EXECUTE_COMMANDS, function(){ this.changeDifference++ }.bind(this) );		// --> Rollback		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_ROLLBACK, function(){ this.changeDifference-- }.bind(this) );				//TODO very critical for load time performance!!!		//this.serializedDOM = DataManager.__persistDOM(this.facade);	},		onUnLoad: function(){				if( this.changeDifference !== 0 ){					return ORYX.I18N.Save.unsavedData;					}						},			    saveSynchronously: function(forceNew){            		// Reset changes		this.changeDifference = 0;		var reqURI ='';				if (this.processURI) {			reqURI = this.processURI;		}		else {			if(!location.hash.slice(1)){				reqURI= "/backend/poem/new";			}			else{				reqURI = '/backend/poem/'+(location.hash.slice(1).replace(/^\/?/,"").replace(/\/?$/,""))+"/self";			}		}		// If the  current url is the API-URL, try to find out the needed one.		/* if( reqURI.endsWith("/api") || reqURI.include("/api?") ){			// Parse params			var params = {};			window.location.search.slice(1).split("&").each(function(param){ params[param.split("=")[0]]=param.split("=")[1]})						// If there is model in param, take this			if(  params.model ){				reqURI = window.location.href.split("/api")[0] + params.model + "/self";			// If not, force to get a new one			} else {				forceNew = true;			}		}*/				if(forceNew){			var ss 		= this.facade.getStencilSets();			var source 	= ss[ss.keys()[0]].source().split('stencilsets')[1];				reqURI = '/backend/poem' + ORYX.CONFIG.ORYX_NEW_URL + "?stencilset=/stencilsets" + source ;				}		// Get the serialized svg image source        var svgClone 	= this.facade.getCanvas().getSVGRepresentation(true);        var svgDOM 		= DataManager.serialize(svgClone);		this.serializedDOM = Ext.encode(this.facade.getJSON());				// Check if this is the NEW URL		if( reqURI.include( ORYX.CONFIG.ORYX_NEW_URL ) ){						// Get the stencilset			var ss = this.facade.getStencilSets().values()[0]					// Define Default values			var defaultData = {title:ORYX.I18N.Save.newProcess, summary:'', type:ss.title(), url: reqURI, namespace: ss.namespace() }						// Create a Template			var dialog = new Ext.XTemplate(								// TODO find some nice words here -- copy from above ;)						'<form class="oryx_repository_edit_model" action="#" id="edit_model" onsubmit="return false;">',																	'<fieldset>',								'<p class="description">' + ORYX.I18N.Save.dialogDesciption + '</p>',								'<input type="hidden" name="namespace" value="{namespace}" />',								'<p><label for="edit_model_title">' + ORYX.I18N.Save.dialogLabelTitle + '</label><input type="text" class="text" name="title" value="{title}" id="edit_model_title" onfocus="this.className = \'text activated\'" onblur="this.className = \'text\'"/></p>',								'<p><label for="edit_model_summary">' + ORYX.I18N.Save.dialogLabelDesc + '</label><textarea rows="5" name="summary" id="edit_model_summary" onfocus="this.className = \'activated\'" onblur="this.className = \'\'">{summary}</textarea></p>',								'<p><label for="edit_model_type">' + ORYX.I18N.Save.dialogLabelType + '</label><input type="text" name="type" class="text disabled" value="{type}" disabled="disabled" id="edit_model_type" /></p>',															'</fieldset>',												'</form>')						// Create the callback for the template			callback = function(form){										var title 		= form.elements["title"].value.strip();				title 			= title.length == 0 ? defaultData.title : title;								//added changing title of page after first save				window.document.title = title + " - Oryx";								var summary = form.elements["summary"].value.strip();					summary 	= summary.length == 0 ? defaultData.summary : summary;								var namespace	= form.elements["namespace"].value.strip();				namespace		= namespace.length == 0 ? defaultData.namespace : namespace;								win.destroy();								// Send the request out				this.sendSaveRequest( reqURI, { data: this.serializedDOM, svg: svgDOM, title: title, summary: summary, type: namespace }, forceNew);							}.bind(this);						// Create a new window							win = new Ext.Window({				id:		'Propertie_Window',		        width:	'auto',		        height:	'auto',		        title:	forceNew ? ORYX.I18N.Save.saveAsTitle : ORYX.I18N.Save.save,		        modal:	true,				bodyStyle: 'background:#FFFFFF',		        html: 	dialog.apply( defaultData ),				buttons:[{					text: ORYX.I18N.Save.saveBtn,					handler: function(){						callback( $('edit_model') )										}				},{                	text: ORYX.I18N.Save.close,                	handler: function(){		               this.facade.raiseEvent({		                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE		                });						                    	win.destroy();                	}.bind(this)				}]		    });					      			win.show();					} else {						// Send the request out			this.sendSaveRequest( reqURI, { data: this.serializedDOM, svg: svgDOM } );					}    },		sendSaveRequest: function(url, params, forceNew){		// Send the request to the server.		new Ajax.Request(url, {                method: 'POST',                asynchronous: false,                parameters: params,			onSuccess: (function(transport) {				var loc = transport.getResponseHeader("location");				if (loc) {					this.processURI = loc;				}				else {					this.processURI = url;				}								var modelUri="/model"+this.processURI.split("model")[1].replace(/self\/?$/i,"");				location.hash="#"+modelUri;								if( forceNew ){					var newURLWin = new Ext.Window({						title:		ORYX.I18N.Save.savedAs, 						bodyStyle:	"background:white;padding:10px", 						width:		'auto', 						height:		'auto',						html:"<div style='font-weight:bold;margin-bottom:10px'>"+ORYX.I18N.Save.saveAsHint+"</div><span><a href='" + loc +"' target='_blank'>" + loc + "</a></span>",						buttons:[{text:'Ok',handler:function(){newURLWin.destroy()}}]					});					newURLWin.show();				}				//raise saved event				this.facade.raiseEvent({					type:ORYX.CONFIG.EVENT_MODEL_SAVED				});				//show saved status				this.facade.raiseEvent({						type:ORYX.CONFIG.EVENT_LOADING_STATUS,						text:ORYX.I18N.Save.saved					});			}).bind(this),			onFailure: (function(transport) {				// raise loading disable event.                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.failed);								ORYX.Log.warn("Saving failed: " + transport.responseText);			}).bind(this),			on403: (function(transport) {				// raise loading disable event.                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.noRights);								ORYX.Log.warn("Saving failed: " + transport.responseText);			}).bind(this)		});					},        /**     * Saves the current process to the server.     */    save: function(forceNew, event){            // raise loading enable event        this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,			text: ORYX.I18N.Save.saving        });                // asynchronously ...        window.setTimeout((function(){                    // ... save synchronously            this.saveSynchronously(forceNew);                    }).bind(this), 10);                return true;    }	});			ORYX.Plugins.File = Clazz.extend({    facade: undefined,	        construct: function(facade){        this.facade = facade;                this.facade.offer({            'name': ORYX.I18N.File.print,            'functionality': this.print.bind(this),            'group': ORYX.I18N.File.group,            'icon': ORYX.PATH + "images/printer.png",            'description': ORYX.I18N.File.printDesc,            'index': 3,            'minShape': 0,            'maxShape': 0        });                this.facade.offer({            'name': ORYX.I18N.File.pdf,            'functionality': this.exportPDF.bind(this),            'group': ORYX.I18N.File.group,            'icon': ORYX.PATH + "images/page_white_acrobat.png",            'description': ORYX.I18N.File.pdfDesc,            'index': 4,            'minShape': 0,            'maxShape': 0        });                this.facade.offer({            'name': ORYX.I18N.File.info,            'functionality': this.info.bind(this),            'group': ORYX.I18N.File.group,            'icon': ORYX.PATH + "images/information.png",            'description': ORYX.I18N.File.infoDesc,            'index': 5,            'minShape': 0,            'maxShape': 0        });    },            info: function(){            var info = '<iframe src="' + ORYX.CONFIG.LICENSE_URL + '" type="text/plain" ' + 				   'style="border:none;display:block;width:575px;height:460px;"/>' +				   '\n\n<pre style="display:inline;">Version: </pre>' + 				   '<iframe src="' + ORYX.CONFIG.VERSION_URL + '" type="text/plain" ' + 				   'style="border:none;overflow:hidden;display:inline;width:40px;height:20px;"/>';		this.infoBox = Ext.Msg.show({		   title: ORYX.I18N.Oryx.title,		   msg: info,		   width: 640,		   maxWidth: 640,		   maxHeight: 480,		   buttons: Ext.MessageBox.OK		});                return false;    },        exportPDF: function(){    			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.File.genPDF});		        var resource = location.href;                // Get the serialized svg image source        var svgClone = this.facade.getCanvas().getSVGRepresentation(true);                var svgDOM = DataManager.serialize(svgClone);		        // Send the svg to the server.        //TODO make this better by using content negotiation instead of format parameter.        //TODO make this better by generating svg on the server, too.        new Ajax.Request(ORYX.CONFIG.PDF_EXPORT_URL, {            method: 'POST',            parameters: {                resource: resource,                data: svgDOM,                format: "pdf"            },            onSuccess: (function(request){            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});				                // Because the pdf may be opened in the same window as the                // process, yet the process may not have been saved, we're                // opening every other representation in a new window.                // location.href = request.responseText                window.open(request.responseText);            }).bind(this),			onFailure: (function(){				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});								Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.File.genPDFFailed);			}).bind(this)        });    },        print: function(){				Ext.Msg.show({		   title		: ORYX.I18N.File.printTitle,		   msg			: ORYX.I18N.File.printMsg,		   buttons		: Ext.Msg.YESNO,		   icon			: Ext.MessageBox.QUESTION,		   fn			:  function(btn) {	        								if (btn == "yes") {																	// Set all options for the new window									var option = $H({										width: 300,										height: 400,										toolbar: "no",										status: "no",										menubar: "yes",										dependent: "yes",										resizable: "yes",										scrollbars: "yes"									});																		// Create the new window with all the settings									var newWindow = window.open("", "PrintWindow", option.invoke('join', '=').join(','));																		// Add a style tag to the head and hide all controls									var head = newWindow.document.getElementsByTagName('head')[0];									var style = document.createElement("style");									style.innerHTML = " body {padding:0px; margin:0px} .svgcontainer { display:none; }";									head.appendChild(style);																		// Clone the svg-node and append this to the new body									newWindow.document.getElementsByTagName('body')[0].appendChild(this.facade.getCanvas().getSVGRepresentation());									var svg = newWindow.document.getElementsByTagName('body')[0].getElementsByTagName('svg')[0];																		// Set the width and height									svg.setAttributeNS(null, 'width', 1100);									svg.setAttributeNS(null, 'height', 1400);																		// Set the correct size and rotation									svg.lastChild.setAttributeNS(null, 'transform', 'scale(0.47, 0.47) rotate(270, 1510, 1470)');																		var markers = ['marker-start', 'marker-mid', 'marker-end']									var path = $A(newWindow.document.getElementsByTagName('path'));									path.each(function(pathNode){										markers.each(function(marker){											// Get the marker value											var url = pathNode.getAttributeNS(null, marker);											if (!url) {												return											};																						// Replace the URL and set them new											url = "url(about:blank#" + url.slice(5);											pathNode.setAttributeNS(null, marker, url);										});									});																		// Get the print dialog									newWindow.print();																		return true;								}							}.bind(this)			});    }   });/** * Method to load model or create new one * (moved from editor handler) */window.onOryxResourcesLoaded = function() {		if (location.hash.slice(1).length == 0 || location.hash.slice(1).indexOf('new')!=-1) {		var stencilset = ORYX.Utils.getParamFromUrl('stencilset') || ORYX.CONFIG.SSET; // || "stencilsets/bpmn2.0/bpmn2.0.json";				new ORYX.Editor({			id: 'oryx-canvas123',			stencilset: {				url: ORYX.PATH + "/" + stencilset			}		});	} else {		ORYX.Editor.createByUrl(			"/backend/poem" + location.hash.slice(1).replace(/\/*$/,"/").replace(/^\/*/,"/")+'json',			{				id: 'oryx-canvas123',				onFailure: function(transport) {		    	  if (403 == transport.status) {		    		  Ext.Msg.show({		                  title:'Authentication Failed',		                  msg: 'You may not have access rights for this model, maybe you forgot to <a href="'+ORYX.CONFIG.WEB_URL+'/backend/poem/repository">log in</a>?',		                  icon: Ext.MessageBox.WARNING,		                  closeable: false,		                  closable: false		              });		    	  }		    	  else if (404 == transport.status) {		    		  Ext.Msg.show({		                  title:'Not Found',		                  msg: 'The model you requested could not be found.',		                  icon: Ext.MessageBox.WARNING,		                  closeable: false,		                  closable: false		              });		    	  }		    	  else {		    		  Ext.Msg.show({		                  title:'Internal Error',		                  msg: 'We\'re sorry, the model cannot be loaded due to an internal error',		                  icon: Ext.MessageBox.WARNING,		                  closeable: false,		                  closable: false		              });				  }			  }			}		);  	}};/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner, Philipp Berger * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.Save = Clazz.extend({	    facade: undefined,		processURI: undefined,	    construct: function(facade){		this.facade = facade;				this.facade.offer({			'name': ORYX.I18N.Save.save,			'functionality': this.save.bind(this,false),			'group': ORYX.I18N.Save.group,			'icon': ORYX.PATH + "images/disk.png",			'description': ORYX.I18N.Save.saveDesc,			'index': 1,			'minShape': 0,			'maxShape': 0		});						this.facade.offer({			'name': ORYX.I18N.Save.saveAs,			'functionality': this.save.bind(this,true),			'group': ORYX.I18N.Save.group,			'icon': ORYX.PATH + "images/disk_multi.png",			'description': ORYX.I18N.Save.saveAsDesc,			'index': 2,			'minShape': 0,			'maxShape': 0		});					window.onbeforeunload = this.onUnLoad.bind(this);			this.changeDifference = 0;				// Register on event for executing commands --> store all commands in a stack		 		// --> Execute		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_EXECUTE, function(){ this.changeDifference++ }.bind(this) );		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_EXECUTE_COMMANDS, function(){ this.changeDifference++ }.bind(this) );		// --> Rollback		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_ROLLBACK, function(){ this.changeDifference-- }.bind(this) );				//TODO very critical for load time performance!!!		//this.serializedDOM = DataManager.__persistDOM(this.facade);	},		onUnLoad: function(){				if( this.changeDifference !== 0 ){					return ORYX.I18N.Save.unsavedData;					}						},			    saveSynchronously: function(forceNew){            		// Reset changes		this.changeDifference = 0;		var reqURI ='';				if (this.processURI) {			reqURI = this.processURI;		}		else {			if(!location.hash.slice(1)){				reqURI= "/backend/poem/new";			}			else{				reqURI = '/backend/poem/'+(location.hash.slice(1).replace(/^\/?/,"").replace(/\/?$/,""))+"/self";			}		}		// If the  current url is the API-URL, try to find out the needed one.		/* if( reqURI.endsWith("/api") || reqURI.include("/api?") ){			// Parse params			var params = {};			window.location.search.slice(1).split("&").each(function(param){ params[param.split("=")[0]]=param.split("=")[1]})						// If there is model in param, take this			if(  params.model ){				reqURI = window.location.href.split("/api")[0] + params.model + "/self";			// If not, force to get a new one			} else {				forceNew = true;			}		}*/				if(forceNew){			var ss 		= this.facade.getStencilSets();			var source 	= ss[ss.keys()[0]].source().split('stencilsets')[1];				reqURI = '/backend/poem' + ORYX.CONFIG.ORYX_NEW_URL + "?stencilset=/stencilsets" + source ;				}		// Get the serialized svg image source        var svgClone 	= this.facade.getCanvas().getSVGRepresentation(true);        var svgDOM 		= DataManager.serialize(svgClone);		this.serializedDOM = Ext.encode(this.facade.getJSON());				// Check if this is the NEW URL		if( reqURI.include( ORYX.CONFIG.ORYX_NEW_URL ) ){						// Get the stencilset			var ss = this.facade.getStencilSets().values()[0]					// Define Default values			var defaultData = {title:ORYX.I18N.Save.newProcess, summary:'', type:ss.title(), url: reqURI, namespace: ss.namespace() }						// Create a Template			var dialog = new Ext.XTemplate(								// TODO find some nice words here -- copy from above ;)						'<form class="oryx_repository_edit_model" action="#" id="edit_model" onsubmit="return false;">',																	'<fieldset>',								'<p class="description">' + ORYX.I18N.Save.dialogDesciption + '</p>',								'<input type="hidden" name="namespace" value="{namespace}" />',								'<p><label for="edit_model_title">' + ORYX.I18N.Save.dialogLabelTitle + '</label><input type="text" class="text" name="title" value="{title}" id="edit_model_title" onfocus="this.className = \'text activated\'" onblur="this.className = \'text\'"/></p>',								'<p><label for="edit_model_summary">' + ORYX.I18N.Save.dialogLabelDesc + '</label><textarea rows="5" name="summary" id="edit_model_summary" onfocus="this.className = \'activated\'" onblur="this.className = \'\'">{summary}</textarea></p>',								'<p><label for="edit_model_type">' + ORYX.I18N.Save.dialogLabelType + '</label><input type="text" name="type" class="text disabled" value="{type}" disabled="disabled" id="edit_model_type" /></p>',															'</fieldset>',												'</form>')						// Create the callback for the template			callback = function(form){										var title 		= form.elements["title"].value.strip();				title 			= title.length == 0 ? defaultData.title : title;								//added changing title of page after first save				window.document.title = title + " - Oryx";								var summary = form.elements["summary"].value.strip();					summary 	= summary.length == 0 ? defaultData.summary : summary;								var namespace	= form.elements["namespace"].value.strip();				namespace		= namespace.length == 0 ? defaultData.namespace : namespace;								win.destroy();								// Send the request out				this.sendSaveRequest( reqURI, { data: this.serializedDOM, svg: svgDOM, title: title, summary: summary, type: namespace }, forceNew);							}.bind(this);						// Create a new window							win = new Ext.Window({				id:		'Propertie_Window',		        width:	'auto',		        height:	'auto',		        title:	forceNew ? ORYX.I18N.Save.saveAsTitle : ORYX.I18N.Save.save,		        modal:	true,				bodyStyle: 'background:#FFFFFF',		        html: 	dialog.apply( defaultData ),				buttons:[{					text: ORYX.I18N.Save.saveBtn,					handler: function(){						callback( $('edit_model') )										}				},{                	text: ORYX.I18N.Save.close,                	handler: function(){		               this.facade.raiseEvent({		                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE		                });						                    	win.destroy();                	}.bind(this)				}]		    });					      			win.show();					} else {						// Send the request out			this.sendSaveRequest( reqURI, { data: this.serializedDOM, svg: svgDOM } );					}    },		sendSaveRequest: function(url, params, forceNew){		// Send the request to the server.		new Ajax.Request(url, {                method: 'POST',                asynchronous: false,                parameters: params,			onSuccess: (function(transport) {				var loc = transport.getResponseHeader("location");				if (loc) {					this.processURI = loc;				}				else {					this.processURI = url;				}								var modelUri="/model"+this.processURI.split("model")[1].replace(/self\/?$/i,"");				location.hash="#"+modelUri;								if( forceNew ){					var newURLWin = new Ext.Window({						title:		ORYX.I18N.Save.savedAs, 						bodyStyle:	"background:white;padding:10px", 						width:		'auto', 						height:		'auto',						html:"<div style='font-weight:bold;margin-bottom:10px'>"+ORYX.I18N.Save.saveAsHint+"</div><span><a href='" + loc +"' target='_blank'>" + loc + "</a></span>",						buttons:[{text:'Ok',handler:function(){newURLWin.destroy()}}]					});					newURLWin.show();				}				//raise saved event				this.facade.raiseEvent({					type:ORYX.CONFIG.EVENT_MODEL_SAVED				});				//show saved status				this.facade.raiseEvent({						type:ORYX.CONFIG.EVENT_LOADING_STATUS,						text:ORYX.I18N.Save.saved					});			}).bind(this),			onFailure: (function(transport) {				// raise loading disable event.                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.failed);								ORYX.Log.warn("Saving failed: " + transport.responseText);			}).bind(this),			on403: (function(transport) {				// raise loading disable event.                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });				Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Save.noRights);								ORYX.Log.warn("Saving failed: " + transport.responseText);			}).bind(this)		});					},        /**     * Saves the current process to the server.     */    save: function(forceNew, event){            // raise loading enable event        this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,			text: ORYX.I18N.Save.saving        });                // asynchronously ...        window.setTimeout((function(){                    // ... save synchronously            this.saveSynchronously(forceNew);                    }).bind(this), 10);                return true;    }	});			ORYX.Plugins.File = Clazz.extend({    facade: undefined,	        construct: function(facade){        this.facade = facade;                this.facade.offer({            'name': ORYX.I18N.File.print,            'functionality': this.print.bind(this),            'group': ORYX.I18N.File.group,            'icon': ORYX.PATH + "images/printer.png",            'description': ORYX.I18N.File.printDesc,            'index': 3,            'minShape': 0,            'maxShape': 0        });                this.facade.offer({            'name': ORYX.I18N.File.pdf,            'functionality': this.exportPDF.bind(this),            'group': ORYX.I18N.File.group,            'icon': ORYX.PATH + "images/page_white_acrobat.png",            'description': ORYX.I18N.File.pdfDesc,            'index': 4,            'minShape': 0,            'maxShape': 0        });                this.facade.offer({            'name': ORYX.I18N.File.info,            'functionality': this.info.bind(this),            'group': ORYX.I18N.File.group,            'icon': ORYX.PATH + "images/information.png",            'description': ORYX.I18N.File.infoDesc,            'index': 5,            'minShape': 0,            'maxShape': 0        });    },            info: function(){            var info = '<iframe src="' + ORYX.CONFIG.LICENSE_URL + '" type="text/plain" ' + 				   'style="border:none;display:block;width:575px;height:460px;"/>' +				   '\n\n<pre style="display:inline;">Version: </pre>' + 				   '<iframe src="' + ORYX.CONFIG.VERSION_URL + '" type="text/plain" ' + 				   'style="border:none;overflow:hidden;display:inline;width:40px;height:20px;"/>';		this.infoBox = Ext.Msg.show({		   title: ORYX.I18N.Oryx.title,		   msg: info,		   width: 640,		   maxWidth: 640,		   maxHeight: 480,		   buttons: Ext.MessageBox.OK		});                return false;    },        exportPDF: function(){    			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.File.genPDF});		        var resource = location.href;                // Get the serialized svg image source        var svgClone = this.facade.getCanvas().getSVGRepresentation(true);                var svgDOM = DataManager.serialize(svgClone);		        // Send the svg to the server.        //TODO make this better by using content negotiation instead of format parameter.        //TODO make this better by generating svg on the server, too.        new Ajax.Request(ORYX.CONFIG.PDF_EXPORT_URL, {            method: 'POST',            parameters: {                resource: resource,                data: svgDOM,                format: "pdf"            },            onSuccess: (function(request){            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});				                // Because the pdf may be opened in the same window as the                // process, yet the process may not have been saved, we're                // opening every other representation in a new window.                // location.href = request.responseText                window.open(request.responseText);            }).bind(this),			onFailure: (function(){				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});								Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.File.genPDFFailed);			}).bind(this)        });    },        print: function(){				Ext.Msg.show({		   title		: ORYX.I18N.File.printTitle,		   msg			: ORYX.I18N.File.printMsg,		   buttons		: Ext.Msg.YESNO,		   icon			: Ext.MessageBox.QUESTION,		   fn			:  function(btn) {	        								if (btn == "yes") {																	// Set all options for the new window									var option = $H({										width: 300,										height: 400,										toolbar: "no",										status: "no",										menubar: "yes",										dependent: "yes",										resizable: "yes",										scrollbars: "yes"									});																		// Create the new window with all the settings									var newWindow = window.open("", "PrintWindow", option.invoke('join', '=').join(','));																		// Add a style tag to the head and hide all controls									var head = newWindow.document.getElementsByTagName('head')[0];									var style = document.createElement("style");									style.innerHTML = " body {padding:0px; margin:0px} .svgcontainer { display:none; }";									head.appendChild(style);																		// Clone the svg-node and append this to the new body									newWindow.document.getElementsByTagName('body')[0].appendChild(this.facade.getCanvas().getSVGRepresentation());									var svg = newWindow.document.getElementsByTagName('body')[0].getElementsByTagName('svg')[0];																		// Set the width and height									svg.setAttributeNS(null, 'width', 1100);									svg.setAttributeNS(null, 'height', 1400);																		// Set the correct size and rotation									svg.lastChild.setAttributeNS(null, 'transform', 'scale(0.47, 0.47) rotate(270, 1510, 1470)');																		var markers = ['marker-start', 'marker-mid', 'marker-end']									var path = $A(newWindow.document.getElementsByTagName('path'));									path.each(function(pathNode){										markers.each(function(marker){											// Get the marker value											var url = pathNode.getAttributeNS(null, marker);											if (!url) {												return											};																						// Replace the URL and set them new											url = "url(about:blank#" + url.slice(5);											pathNode.setAttributeNS(null, marker, url);										});									});																		// Get the print dialog									newWindow.print();																		return true;								}							}.bind(this)			});    }   });/** * Method to load model or create new one * (moved from editor handler) */window.onOryxResourcesLoaded = function() {		if (location.hash.slice(1).length == 0 || location.hash.slice(1).indexOf('new')!=-1) {		var stencilset = ORYX.Utils.getParamFromUrl('stencilset') || ORYX.CONFIG.SSET; // || "stencilsets/bpmn2.0/bpmn2.0.json";				new ORYX.Editor({			id: 'oryx-canvas123',			stencilset: {				url: ORYX.PATH + "/" + stencilset			}		});	} else {		ORYX.Editor.createByUrl(			"/backend/poem" + location.hash.slice(1).replace(/\/*$/,"/").replace(/^\/*/,"/")+'json',			{				id: 'oryx-canvas123',				onFailure: function(transport) {		    	  if (403 == transport.status) {		    		  Ext.Msg.show({		                  title:'Authentication Failed',		                  msg: 'You may not have access rights for this model, maybe you forgot to <a href="'+ORYX.CONFIG.WEB_URL+'/backend/poem/repository">log in</a>?',		                  icon: Ext.MessageBox.WARNING,		                  closeable: false,		                  closable: false		              });		    	  }		    	  else if (404 == transport.status) {		    		  Ext.Msg.show({		                  title:'Not Found',		                  msg: 'The model you requested could not be found.',		                  icon: Ext.MessageBox.WARNING,		                  closeable: false,		                  closable: false		              });		    	  }		    	  else {		    		  Ext.Msg.show({		                  title:'Internal Error',		                  msg: 'We\'re sorry, the model cannot be loaded due to an internal error',		                  icon: Ext.MessageBox.WARNING,		                  closeable: false,		                  closable: false		              });				  }			  }			}		);  	}};/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * @namespace Oryx name space for plugins * @name ORYX.Plugins*/if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * The view plugin offers all of zooming functionality accessible over the  * tool bar. This are zoom in, zoom out, zoom to standard, zoom fit to model. *  * @class ORYX.Plugins.View * @extends Clazz * @param {Object} facade The editor facade for plugins.*/ORYX.Plugins.View = {	/** @lends ORYX.Plugins.View.prototype */	facade: undefined,	construct: function(facade, ownPluginData) {		this.facade = facade;		//Standard Values		this.zoomLevel = 1.0;		this.maxFitToScreenLevel=1.5;		this.minZoomLevel = 0.1;		this.maxZoomLevel = 2.5;		this.diff=5; //difference between canvas and view port, s.th. like toolbar??				//Read properties		ownPluginData.properties.each( function(property) {						if (property.zoomLevel) {this.zoomLevel = Number(1.0);}					if (property.maxFitToScreenLevel) {this.maxFitToScreenLevel=Number(property.maxFitToScreenLevel);}			if (property.minZoomLevel) {this.minZoomLevel = Number(property.minZoomLevel);}			if (property.maxZoomLevel) {this.maxZoomLevel = Number(property.maxZoomLevel);}		}.bind(this));				/* Register zoom in */		this.facade.offer({			'name':ORYX.I18N.View.zoomIn,			'functionality': this.zoom.bind(this, [1.0 + ORYX.CONFIG.ZOOM_OFFSET]),			'group': ORYX.I18N.View.group,			'icon': ORYX.PATH + "images/magnifier_zoom_in.png",			'description': ORYX.I18N.View.zoomInDesc,			'index': 1,			'minShape': 0,			'maxShape': 0,			'isEnabled': function(){return this.zoomLevel < this.maxZoomLevel }.bind(this)});				/* Register zoom out */		this.facade.offer({			'name':ORYX.I18N.View.zoomOut,			'functionality': this.zoom.bind(this, [1.0 - ORYX.CONFIG.ZOOM_OFFSET]),			'group': ORYX.I18N.View.group,			'icon': ORYX.PATH + "images/magnifier_zoom_out.png",			'description': ORYX.I18N.View.zoomOutDesc,			'index': 2,			'minShape': 0,			'maxShape': 0,			'isEnabled': function(){ return this._checkSize() }.bind(this)});				/* Register zoom standard */		this.facade.offer({			'name':ORYX.I18N.View.zoomStandard,			'functionality': this.setAFixZoomLevel.bind(this, 1),			'group': ORYX.I18N.View.group,			'icon': ORYX.PATH + "images/zoom_standard.png",			'cls' : 'icon-large',			'description': ORYX.I18N.View.zoomStandardDesc,			'index': 3,			'minShape': 0,			'maxShape': 0,			'isEnabled': function(){return this.zoomLevel != 1}.bind(this)		});				/* Register zoom fit to model */		this.facade.offer({			'name':ORYX.I18N.View.zoomFitToModel,			'functionality': this.zoomFitToModel.bind(this),			'group': ORYX.I18N.View.group,			'icon': ORYX.PATH + "images/image.png",			'description': ORYX.I18N.View.zoomFitToModelDesc,			'index': 4,			'minShape': 0,			'maxShape': 0		});	},		/**	 * It sets the zoom level to a fix value and call the zooming function.	 * 	 * @param {Number} zoomLevel	 * 			the zoom level	 */	setAFixZoomLevel : function(zoomLevel) {		this.zoomLevel = zoomLevel;		this._checkZoomLevelRange();		this.zoom(1);	},		/**	 * It does the actual zooming. It changes the viewable size of the canvas 	 * and all to its child elements.	 * 	 * @param {Number} factor	 * 		the factor to adjust the zoom level	 */	zoom: function(factor) {		// TODO: Zoomen auf allen Objekten im SVG-DOM				this.zoomLevel *= factor;		var scrollNode 	= this.facade.getCanvas().getHTMLContainer().parentNode.parentNode;		var canvas 		= this.facade.getCanvas();		var newWidth 	= canvas.bounds.width()  * this.zoomLevel;		var newHeight 	= canvas.bounds.height() * this.zoomLevel;				/* Set new top offset */		var offsetTop = (canvas.node.parentNode.parentNode.parentNode.offsetHeight - newHeight) / 2.0;			offsetTop = offsetTop > 20 ? offsetTop - 20 : 0;		canvas.node.parentNode.parentNode.style.marginTop = offsetTop + "px";		offsetTop += 5;		canvas.getHTMLContainer().style.top = offsetTop + "px";				/*readjust scrollbar*/		var newScrollTop=	scrollNode.scrollTop - Math.round((canvas.getHTMLContainer().parentNode.getHeight()-newHeight) / 2)+this.diff;		var newScrollLeft=	scrollNode.scrollLeft - Math.round((canvas.getHTMLContainer().parentNode.getWidth()-newWidth) / 2)+this.diff;				/* Set new Zoom-Level */		canvas.setSize({width: newWidth, height: newHeight}, true);				/* Set Scale-Factor */		canvas.node.setAttributeNS(null, "transform", "scale(" +this.zoomLevel+ ")");			/* Refresh the Selection */		this.facade.updateSelection();		scrollNode.scrollTop=newScrollTop;		scrollNode.scrollLeft=newScrollLeft;				/* Update the zoom-level*/		canvas.zoomLevel = this.zoomLevel;	},			/**	 * It calculates the zoom level to fit whole model into the visible area	 * of the canvas. Than the model gets zoomed and the position of the 	 * scroll bars are adjusted.	 * 	 */	zoomFitToModel: function() {				/* Get the size of the visible area of the canvas */		var scrollNode 	= this.facade.getCanvas().getHTMLContainer().parentNode.parentNode;		var visibleHeight = scrollNode.getHeight() - 30;		var visibleWidth = scrollNode.getWidth() - 30;				var nodes = this.facade.getCanvas().getChildShapes();				if(!nodes || nodes.length < 1) {			return false;					}					/* Calculate size of canvas to fit the model */		var bounds = nodes[0].absoluteBounds().clone();		nodes.each(function(node) {			bounds.include(node.absoluteBounds().clone());		});						/* Set new Zoom Level */		var scaleFactorWidth =  visibleWidth / bounds.width();		var scaleFactorHeight = visibleHeight / bounds.height();				/* Choose the smaller zoom level to fit the whole model */		var zoomFactor = scaleFactorHeight < scaleFactorWidth ? scaleFactorHeight : scaleFactorWidth;				/*Test if maximum zoom is reached*/		if(zoomFactor>this.maxFitToScreenLevel){zoomFactor=this.maxFitToScreenLevel}		/* Do zooming */		this.setAFixZoomLevel(zoomFactor);				/* Set scroll bar position */		scrollNode.scrollTop = Math.round(bounds.upperLeft().y * this.zoomLevel) - 5;		scrollNode.scrollLeft = Math.round(bounds.upperLeft().x * this.zoomLevel) - 5;			},		/**	 * It checks if the zoom level is less or equal to the level, which is required	 * to schow the whole canvas.	 * 	 * @private	 */	_checkSize:function(){		var canvasParent=this.facade.getCanvas().getHTMLContainer().parentNode;		var minForCanvas= Math.min((canvasParent.parentNode.getWidth()/canvasParent.getWidth()),(canvasParent.parentNode.getHeight()/canvasParent.getHeight()));		return 1.05 > minForCanvas;			},	/**	 * It checks if the zoom level is included in the definined zoom	 * level range.	 * 	 * @private	 */	_checkZoomLevelRange: function() {		/*var canvasParent=this.facade.getCanvas().getHTMLContainer().parentNode;		var maxForCanvas= Math.max((canvasParent.parentNode.getWidth()/canvasParent.getWidth()),(canvasParent.parentNode.getHeight()/canvasParent.getHeight()));		if(this.zoomLevel > maxForCanvas) {			this.zoomLevel = maxForCanvas;					}*/		if(this.zoomLevel < this.minZoomLevel) {			this.zoomLevel = this.minZoomLevel;					}				if(this.zoomLevel > this.maxZoomLevel) {			this.zoomLevel = this.maxZoomLevel;					}	}};ORYX.Plugins.View = Clazz.extend(ORYX.Plugins.View);/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins) 	ORYX.Plugins = new Object();ORYX.Plugins.DragDropResize = ORYX.Plugins.AbstractPlugin.extend({	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		// Initialize variables		this.currentShapes 		= [];			// Current selected Shapes		//this.pluginsData 		= [];			// Available Plugins		this.toMoveShapes 		= [];			// Shapes there will be moved		this.distPoints 		= [];			// Distance Points for Snap on Grid		this.isResizing 		= false;		// Flag: If there was currently resized		this.dragEnable 		= false;		// Flag: If Dragging is enabled		this.dragIntialized 	= false;		// Flag: If the Dragging is initialized		this.edgesMovable		= true;			// Flag: If an edge is docked it is not movable		this.offSetPosition 	= {x: 0, y: 0};	// Offset of the Dragging		this.faktorXY 			= {x: 1, y: 1};	// The Current Zoom-Faktor		this.containmentParentNode;				// the current future parent node for the dragged shapes		this.isAddingAllowed 	= false;		// flag, if adding current selected shapes to containmentParentNode is allowed		this.isAttachingAllowed = false;		// flag, if attaching to the current shape is allowed				this.callbackMouseMove	= this.handleMouseMove.bind(this);		this.callbackMouseUp	= this.handleMouseUp.bind(this);				// Get the SVG-Containernode 		var containerNode = this.facade.getCanvas().getSvgContainer();				// Create the Selected Rectangle in the SVG		this.selectedRect = new ORYX.Plugins.SelectedRect(containerNode);				// Show grid line if enabled		if (ORYX.CONFIG.SHOW_GRIDLINE) {			this.vLine = new ORYX.Plugins.GridLine(containerNode, ORYX.Plugins.GridLine.DIR_VERTICAL);			this.hLine = new ORYX.Plugins.GridLine(containerNode, ORYX.Plugins.GridLine.DIR_HORIZONTAL);		}				// Get a HTML-ContainerNode		containerNode = this.facade.getCanvas().getHTMLContainer();				this.scrollNode = this.facade.getCanvas().rootNode.parentNode.parentNode;				// Create the southeastern button for resizing		this.resizerSE = new ORYX.Plugins.Resizer(containerNode, "southeast", this.facade);		this.resizerSE.registerOnResize(this.onResize.bind(this)); // register the resize callback		this.resizerSE.registerOnResizeEnd(this.onResizeEnd.bind(this)); // register the resize end callback		this.resizerSE.registerOnResizeStart(this.onResizeStart.bind(this)); // register the resize start callback				// Create the northwestern button for resizing		this.resizerNW = new ORYX.Plugins.Resizer(containerNode, "northwest", this.facade);		this.resizerNW.registerOnResize(this.onResize.bind(this)); // register the resize callback		this.resizerNW.registerOnResizeEnd(this.onResizeEnd.bind(this)); // register the resize end callback		this.resizerNW.registerOnResizeStart(this.onResizeStart.bind(this)); // register the resize start callback				// For the Drag and Drop		// Register on MouseDown-Event on a Shape		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));	},	/**	 * On Mouse Down	 *	 */	handleMouseDown: function(event, uiObj) {		// If the selection Bounds not intialized and the uiObj is not member of current selectio		// then return		if(!this.dragBounds || !this.currentShapes.member(uiObj) || !this.toMoveShapes.length) {return};				// Start Dragging		this.dragEnable = true;		this.dragIntialized = true;		this.edgesMovable = true;		// Calculate the current zoom factor		var a = this.facade.getCanvas().node.getScreenCTM();		this.faktorXY.x = a.a;		this.faktorXY.y = a.d;		// Set the offset position of dragging		var upL = this.dragBounds.upperLeft();		this.offSetPosition =  {			x: Event.pointerX(event) - (upL.x * this.faktorXY.x),			y: Event.pointerY(event) - (upL.y * this.faktorXY.y)};				this.offsetScroll	= {x:this.scrollNode.scrollLeft,y:this.scrollNode.scrollTop};					// Register on Global Mouse-MOVE Event		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.callbackMouseMove, false);			// Register on Global Mouse-UP Event		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.callbackMouseUp, true);					return;	},	/**	 * On Key Mouse Up	 *	 */	handleMouseUp: function(event) {				//disable containment highlighting		this.facade.raiseEvent({									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,									highlightId:"dragdropresize.contain"								});										this.facade.raiseEvent({									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,									highlightId:"dragdropresize.attached"								});		// If Dragging is finished		if(this.dragEnable) {					// and update the current selection			if(!this.dragIntialized) {								// Do Method after Dragging				this.afterDrag();									// Check if the Shape is allowed to dock to the other Shape										if ( 	this.isAttachingAllowed &&						this.toMoveShapes.length == 1 && this.toMoveShapes[0] instanceof ORYX.Core.Node  &&						this.toMoveShapes[0].dockers.length > 0) {										// Get the position and the docker										var position 	= this.facade.eventCoordinates( event );						var docker 		= this.toMoveShapes[0].dockers[0];								//Command-Pattern for dragging several Shapes					var dockCommand = ORYX.Core.Command.extend({						construct: function(docker, position, newDockedShape, facade){							this.docker 		= docker;							this.newPosition	= position;							this.newDockedShape = newDockedShape;							this.newParent 		= newDockedShape.parent || facade.getCanvas();							this.oldPosition	= docker.parent.bounds.center();							this.oldDockedShape	= docker.getDockedShape();							this.oldParent 		= docker.parent.parent || facade.getCanvas();							this.facade			= facade;														if( this.oldDockedShape ){								this.oldPosition = docker.parent.absoluteBounds().center();							}													},									execute: function(){							this.dock( this.newDockedShape, this.newParent,  this.newPosition );														// Raise Event for having the docked shape on top of the other shape							this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_ARRANGEMENT_TOP, excludeCommand: true})															},						rollback: function(){							this.dock( this.oldDockedShape, this.oldParent, this.oldPosition );						},						dock:function( toDockShape, parent, pos ){							// Add to the same parent Shape							parent.add( this.docker.parent )																					// Set the Docker to the new Shape							this.docker.setDockedShape( undefined );							this.docker.bounds.centerMoveTo( pos )											this.docker.setDockedShape( toDockShape );								//this.docker.update();														this.facade.setSelection( [this.docker.parent] );								this.facade.getCanvas().update();							this.facade.updateSelection();																																													}					});								// Instanziate the dockCommand					var commands = [new dockCommand(docker, position, this.containmentParentNode, this.facade)];					this.facade.executeCommands(commands);																// Check if adding is allowed to the other Shape					} else if( this.isAddingAllowed ) {														// Refresh all Shapes --> Set the new Bounds					this.refreshSelectedShapes();									}								this.facade.updateSelection();											//this.currentShapes.each(function(shape) {shape.update()})				// Raise Event: Dragging is finished				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_DRAGDROP_END});			}				if (this.vLine)				this.vLine.hide();			if (this.hLine)				this.hLine.hide();		}		// Disable 		this.dragEnable = false;					// UnRegister on Global Mouse-UP/-Move Event		document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.callbackMouseUp, true);			document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.callbackMouseMove, false);									return;	},	/**	* On Key Mouse Move	*	*/	handleMouseMove: function(event) {		// If dragging is not enabled, go return		if(!this.dragEnable) { return };		// If Dragging is initialized		if(this.dragIntialized) {			// Raise Event: Drag will be started			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_DRAGDROP_START});			this.dragIntialized = false;						// And hide the resizers and the highlighting			this.resizerSE.hide();			this.resizerNW.hide();						// if only edges are selected, containmentParentNode must be the canvas			this._onlyEdges = this.currentShapes.all(function(currentShape) {				return (currentShape instanceof ORYX.Core.Edge);			});			//			/* If only edges are selected, check if they are movable. An Edge is//			 * movable in case it is not docked//			 *///			if(this._onlyEdges) {//				this.currentShapes.each(function(edge) {//					if(edge.isDocked()) {//						this.edgesMovable = false;//						throw $break;//					}//				}.bind(this));//			}						// Do method before Drag			this.beforeDrag();						this._currentUnderlyingNodes = [];					}					// Calculate the new position		var position = {			x: Event.pointerX(event) - this.offSetPosition.x,			y: Event.pointerY(event) - this.offSetPosition.y}		position.x 	-= this.offsetScroll.x - this.scrollNode.scrollLeft; 		position.y 	-= this.offsetScroll.y - this.scrollNode.scrollTop;				// If not the Control-Key are pressed		var modifierKeyPressed = event.shiftKey || event.ctrlKey;		if(ORYX.CONFIG.GRID_ENABLED && !modifierKeyPressed) {			// Snap the current position to the nearest Snap-Point			position = this.snapToGrid(position);		} else {			if (this.vLine)				this.vLine.hide();			if (this.hLine)				this.hLine.hide();		}		// Adjust the point by the zoom faktor 		position.x /= this.faktorXY.x;		position.y /= this.faktorXY.y;		// Set that the position is not lower than zero		position.x = Math.max( 0 , position.x)		position.y = Math.max( 0 , position.y)		// Set that the position is not bigger than the canvas		var c = this.facade.getCanvas();		position.x = Math.min( c.bounds.width() - this.dragBounds.width(), 		position.x)		position.y = Math.min( c.bounds.height() - this.dragBounds.height(), 	position.y)									// Drag this bounds		this.dragBounds.moveTo(position);		// Update all selected shapes and the selection rectangle		//this.refreshSelectedShapes();		this.resizeRectangle(this.dragBounds);		this.isAttachingAllowed = false;		//check, if a node can be added to the underlying node		var underlyingNodes = $A(this.facade.getCanvas().getAbstractShapesAtPosition(this.facade.eventCoordinates(event)));				var checkIfAttachable = this.toMoveShapes.length == 1 && this.toMoveShapes[0] instanceof ORYX.Core.Node && this.toMoveShapes[0].dockers.length > 0		checkIfAttachable	= checkIfAttachable && underlyingNodes.length != 1							if(		!checkIfAttachable &&				underlyingNodes.length === this._currentUnderlyingNodes.length  &&				underlyingNodes.all(function(node, index){return this._currentUnderlyingNodes[index] === node}.bind(this))) {								return					} else if(this._onlyEdges) {						this.isAddingAllowed = true;			this.containmentParentNode = this.facade.getCanvas();					} else {					/* Check the containment and connection rules */			var options = {				event : event,				underlyingNodes : underlyingNodes,				checkIfAttachable : checkIfAttachable			};			this.checkRules(options);									}				this._currentUnderlyingNodes = underlyingNodes.reverse();				//visualize the containment result		if( this.isAttachingAllowed ) {						this.facade.raiseEvent({									type: 			ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,									highlightId: 	"dragdropresize.attached",									elements: 		[this.containmentParentNode],									style: 			ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE,									color: 			ORYX.CONFIG.SELECTION_VALID_COLOR								});										} else {						this.facade.raiseEvent({									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,									highlightId:"dragdropresize.attached"								});		}				if( !this.isAttachingAllowed ){			if( this.isAddingAllowed ) {				this.facade.raiseEvent({										type:ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,										highlightId:"dragdropresize.contain",										elements:[this.containmentParentNode],										color: ORYX.CONFIG.SELECTION_VALID_COLOR									});			} else {				this.facade.raiseEvent({										type:ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW,										highlightId:"dragdropresize.contain",										elements:[this.containmentParentNode],										color: ORYX.CONFIG.SELECTION_INVALID_COLOR									});			}		} else {			this.facade.raiseEvent({									type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,									highlightId:"dragdropresize.contain"								});					}			// Stop the Event		//Event.stop(event);		return;	},	//	/**//	 * Rollbacks the docked shape of an edge, if the edge is not movable.//	 *///	redockEdges: function() {//		this._undockedEdgesCommand.dockers.each(function(el){//			el.docker.setDockedShape(el.dockedShape);//			el.docker.setReferencePoint(el.refPoint);//		})//	},		/**	 *  Checks the containment and connection rules for the selected shapes.	 */	checkRules : function(options) {		var event = options.event;		var underlyingNodes = options.underlyingNodes;		var checkIfAttachable = options.checkIfAttachable;		var noEdges = options.noEdges;				//get underlying node that is not the same than one of the currently selected shapes or		// a child of one of the selected shapes with the highest z Order.		// The result is a shape or the canvas		this.containmentParentNode = underlyingNodes.reverse().find((function(node) {			return (node instanceof ORYX.Core.Canvas) || 					(((node instanceof ORYX.Core.Node) || ((node instanceof ORYX.Core.Edge) && !noEdges)) 					&& (!(this.currentShapes.member(node) || 							this.currentShapes.any(function(shape) {								return (shape.children.length > 0 && shape.getChildNodes(true).member(node));							}))));		}).bind(this));										if( checkIfAttachable &&  this.containmentParentNode){							this.isAttachingAllowed	= this.facade.getRules().canConnect({												sourceShape:	this.containmentParentNode, 												edgeShape:		this.toMoveShapes[0], 												targetShape:	this.toMoveShapes[0]												});												if ( this.isAttachingAllowed	) {				var point = this.facade.eventCoordinates(event);				this.isAttachingAllowed	= this.containmentParentNode.isPointOverOffset( point.x, point.y );			}								}				if( !this.isAttachingAllowed ){			//check all selected shapes, if they can be added to containmentParentNode			this.isAddingAllowed = this.toMoveShapes.all((function(currentShape) {				if(currentShape instanceof ORYX.Core.Edge ||					currentShape instanceof ORYX.Core.Controls.Docker ||					this.containmentParentNode === currentShape.parent) {					return true;				} else if(this.containmentParentNode !== currentShape) {										if(!(this.containmentParentNode instanceof ORYX.Core.Edge) || !noEdges) {											if(this.facade.getRules().canContain({containingShape:this.containmentParentNode,															  containedShape:currentShape})) {	  								return true;						}					}				}				return false;			}).bind(this));						}				if(!this.isAttachingAllowed && !this.isAddingAllowed && 				(this.containmentParentNode instanceof ORYX.Core.Edge)) {			options.noEdges = true;			options.underlyingNodes.reverse();			this.checkRules(options);					}	},		/**	 * Redraw the selected Shapes.	 *	 */	refreshSelectedShapes: function() {		// If the selection bounds not initialized, return		if(!this.dragBounds) {return}		// Calculate the offset between the bounds and the old bounds		var upL = this.dragBounds.upperLeft();		var oldUpL = this.oldDragBounds.upperLeft();		var offset = {			x: upL.x - oldUpL.x,			y: upL.y - oldUpL.y };		// Instanciate the dragCommand		var commands = [new ORYX.Core.Command.Move(this.toMoveShapes, offset, this.containmentParentNode, this.currentShapes, this)];		// If the undocked edges command is setted, add this command		if( this._undockedEdgesCommand instanceof ORYX.Core.Command ){			commands.unshift( this._undockedEdgesCommand );		}		// Execute the commands					this.facade.executeCommands( commands );			// copy the bounds to the old bounds		if( this.dragBounds )			this.oldDragBounds = this.dragBounds.clone();	},		/**	 * Callback for Resize	 *	 */	onResize: function(bounds) {		// If the selection bounds not initialized, return		if(!this.dragBounds) {return}				this.dragBounds = bounds;		this.isResizing = true;		// Update the rectangle 		this.resizeRectangle(this.dragBounds);	},		onResizeStart: function() {		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_RESIZE_START});	},	onResizeEnd: function() {				if (!(this.currentShapes instanceof Array)||this.currentShapes.length<=0) {			return;		}				// If Resizing finished, the Shapes will be resize		if(this.isResizing) {						var commandClass = ORYX.Core.Command.extend({				construct: function(shape, newBounds, plugin){					this.shape = shape;					this.oldBounds = shape.bounds.clone();					this.newBounds = newBounds;					this.plugin = plugin;				},							execute: function(){					this.shape.bounds.set(this.newBounds.a, this.newBounds.b);					this.update(this.getOffset(this.oldBounds, this.newBounds));									},				rollback: function(){					this.shape.bounds.set(this.oldBounds.a, this.oldBounds.b);					this.update(this.getOffset(this.newBounds, this.oldBounds))				},								getOffset:function(b1, b2){					return {						x: b2.a.x - b1.a.x,						y: b2.a.y - b1.a.y,						xs: b2.width()/b1.width(),						ys: b2.height()/b1.height()					}				},				update:function(offset){					this.shape.getLabels().each(function(label) {						label.changed();					});										var allEdges = [].concat(this.shape.getIncomingShapes())						.concat(this.shape.getOutgoingShapes())						// Remove all edges which are included in the selection from the list						.findAll(function(r){ return r instanceof ORYX.Core.Edge }.bind(this))																	this.plugin.layoutEdges(this.shape, allEdges, offset);					this.plugin.facade.setSelection([this.shape]);					this.plugin.facade.getCanvas().update();					this.plugin.facade.updateSelection();				}			});						var bounds = this.dragBounds.clone();			var shape = this.currentShapes[0];						if(shape.parent) {				var parentPosition = shape.parent.absoluteXY();				bounds.moveBy(-parentPosition.x, -parentPosition.y);			}							var command = new commandClass(shape, bounds, this);						this.facade.executeCommands([command]);						this.isResizing = false;						this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_RESIZE_END});		}	},		/**	 * Prepare the Dragging	 *	 */	beforeDrag: function(){		var undockEdgeCommand = ORYX.Core.Command.extend({			construct: function(moveShapes){				this.dockers = moveShapes.collect(function(shape){ return shape instanceof ORYX.Core.Controls.Docker ? {docker:shape, dockedShape:shape.getDockedShape(), refPoint:shape.referencePoint} : undefined }).compact();			},						execute: function(){				this.dockers.each(function(el){					el.docker.setDockedShape(undefined);				})			},			rollback: function(){				this.dockers.each(function(el){					el.docker.setDockedShape(el.dockedShape);					el.docker.setReferencePoint(el.refPoint);					//el.docker.update();				})			}		});				this._undockedEdgesCommand = new undockEdgeCommand( this.toMoveShapes );		this._undockedEdgesCommand.execute();				},	hideAllLabels: function(shape) {						// Hide all labels from the shape			shape.getLabels().each(function(label) {				label.hide();			});			// Hide all labels from docked shapes			shape.getAllDockedShapes().each(function(dockedShape) {				var labels = dockedShape.getLabels();				if(labels.length > 0) {					labels.each(function(label) {						label.hide();					});				}			});			// Do this recursive for all child shapes			// EXP-NICO use getShapes			shape.getChildren().each((function(value) {				if(value instanceof ORYX.Core.Shape)					this.hideAllLabels(value);			}).bind(this));	},	/**	 * Finished the Dragging	 *	 */	afterDrag: function(){					},	/**	 * Show all Labels at these shape	 * 	 */	showAllLabels: function(shape) {			// Show the label of these shape			//shape.getLabels().each(function(label) {			for(var i=0; i<shape.length ;i++){				var label = shape[i];				label.show();			}//);			// Show all labels at docked shapes			//shape.getAllDockedShapes().each(function(dockedShape) {			var allDockedShapes = shape.getAllDockedShapes()			for(var i=0; i<allDockedShapes.length ;i++){				var dockedShape = allDockedShapes[i];								var labels = dockedShape.getLabels();				if(labels.length > 0) {					labels.each(function(label) {						label.show();					});				}			}//);			// Do this recursive			//shape.children.each((function(value) {			for(var i=0; i<shape.children.length ;i++){				var value = shape.children[i];					if(value instanceof ORYX.Core.Shape)					this.showAllLabels(value);			}//).bind(this));	},	/**	 * Intialize Method, if there are new Plugins	 *	 */	/*registryChanged: function(pluginsData) {		// Save all new Plugin, sorted by group and index		this.pluginsData = pluginsData.sortBy( function(value) {			return (value.group + "" + value.index);		});	},*/	/**	 * On the Selection-Changed	 *	 */	onSelectionChanged: function(event) {		var elements = event.elements;				// Reset the drag-variables		this.dragEnable = false;		this.dragIntialized = false;		this.resizerSE.hide();		this.resizerNW.hide();		// If there is no elements		if(!elements || elements.length == 0) {			// Hide all things and reset all variables			this.selectedRect.hide();			this.currentShapes = [];			this.toMoveShapes = [];			this.dragBounds = undefined;			this.oldDragBounds = undefined;		} else {			// Set the current Shapes			this.currentShapes = elements;			// Get all shapes with the highest parent in object hierarchy (canvas is the top most parent)			var topLevelElements = this.facade.getCanvas().getShapesWithSharedParent(elements);			this.toMoveShapes = topLevelElements;						this.toMoveShapes = this.toMoveShapes.findAll( function(shape) { return shape instanceof ORYX.Core.Node && 																			(shape.dockers.length === 0 || !elements.member(shape.dockers.first().getDockedShape()))});																								elements.each((function(shape){				if(!(shape instanceof ORYX.Core.Edge)) {return}								var dks = shape.getDockers() 												var hasF = elements.member(dks.first().getDockedShape());				var hasL = elements.member(dks.last().getDockedShape());							//				if(!hasL) {//					this.toMoveShapes.push(dks.last());//				}//				if(!hasF){//					this.toMoveShapes.push(dks.first())//				} 				/* Enable movement of undocked edges */				if(!hasF && !hasL) {					var isUndocked = !dks.first().getDockedShape() && !dks.last().getDockedShape()					if(isUndocked) {						this.toMoveShapes = this.toMoveShapes.concat(dks);					}				}								if( shape.dockers.length > 2 && hasF && hasL){					this.toMoveShapes = this.toMoveShapes.concat(dks.findAll(function(el,index){ return index > 0 && index < dks.length-1}))				}							}).bind(this));						// Calculate the new area-bounds of the selection			var newBounds = undefined;			this.toMoveShapes.each(function(value) {				var shape = value;				if(value instanceof ORYX.Core.Controls.Docker) {					/* Get the Shape */					shape = value.parent;				}								if(!newBounds){					newBounds = shape.absoluteBounds();				}				else {					newBounds.include(shape.absoluteBounds());				}			}.bind(this));						if(!newBounds){				elements.each(function(value){					if(!newBounds) {						newBounds = value.absoluteBounds();					} else {						newBounds.include(value.absoluteBounds());					}				});			}						// Set the new bounds			this.dragBounds = newBounds;			this.oldDragBounds = newBounds.clone();			// Update and show the rectangle			this.resizeRectangle(newBounds);			this.selectedRect.show();						// Show the resize button, if there is only one element and this is resizeable			if(elements.length == 1 && elements[0].isResizable) {				var aspectRatio = elements[0].getStencil().fixedAspectRatio() ? elements[0].bounds.width() / elements[0].bounds.height() : undefined;				this.resizerSE.setBounds(this.dragBounds, elements[0].minimumSize, elements[0].maximumSize, aspectRatio);				this.resizerSE.show();				this.resizerNW.setBounds(this.dragBounds, elements[0].minimumSize, elements[0].maximumSize, aspectRatio);				this.resizerNW.show();			} else {				this.resizerSE.setBounds(undefined);				this.resizerNW.setBounds(undefined);			}			// If Snap-To-Grid is enabled, the Snap-Point will be calculate			if(ORYX.CONFIG.GRID_ENABLED) {				// Reset all points				this.distPoints = [];				if (this.distPointTimeout)					window.clearTimeout(this.distPointTimeout)								this.distPointTimeout = window.setTimeout(function(){					// Get all the shapes, there will consider at snapping					// Consider only those elements who shares the same parent element					var distShapes = this.facade.getCanvas().getChildShapes(true).findAll(function(value){						var parentShape = value.parent;						while(parentShape){							if(elements.member(parentShape)) return false;							parentShape = parentShape.parent						}						return true;					})										// The current selection will delete from this array					//elements.each(function(shape) {					//	distShapes = distShapes.without(shape);					//});					// For all these shapes					distShapes.each((function(value) {						if(!(value instanceof ORYX.Core.Edge)) {							var ul = value.absoluteXY();							var width = value.bounds.width();							var height = value.bounds.height();							// Add the upperLeft, center and lowerRight - Point to the distancePoints							this.distPoints.push({								ul: {									x: ul.x,									y: ul.y								},								c: {									x: ul.x + (width / 2),									y: ul.y + (height / 2)								},								lr: {									x: ul.x + width,									y: ul.y + height								}							});						}					}).bind(this));									}.bind(this), 10)			}		}	},	/**	 * Adjust an Point to the Snap Points	 *	 */	snapToGrid: function(position) {		// Get the current Bounds		var bounds = this.dragBounds;				var point = {};		var ulThres = 6;		var cThres = 10;		var lrThres = 6;		var scale = this.vLine ? this.vLine.getScale() : 1;				var ul = { x: (position.x/scale), y: (position.y/scale)};		var c = { x: (position.x/scale) + (bounds.width()/2), y: (position.y/scale) + (bounds.height()/2)};		var lr = { x: (position.x/scale) + (bounds.width()), y: (position.y/scale) + (bounds.height())};		var offsetX, offsetY;		var gridX, gridY;				// For each distant point		this.distPoints.each(function(value) {			var x, y, gx, gy;			if (Math.abs(value.c.x-c.x) < cThres){				x = value.c.x-c.x;				gx = value.c.x;			}/* else if (Math.abs(value.ul.x-ul.x) < ulThres){				x = value.ul.x-ul.x;				gx = value.ul.x;			} else if (Math.abs(value.lr.x-lr.x) < lrThres){				x = value.lr.x-lr.x;				gx = value.lr.x;			} */						if (Math.abs(value.c.y-c.y) < cThres){				y = value.c.y-c.y;				gy = value.c.y;			}/* else if (Math.abs(value.ul.y-ul.y) < ulThres){				y = value.ul.y-ul.y;				gy = value.ul.y;			} else if (Math.abs(value.lr.y-lr.y) < lrThres){				y = value.lr.y-lr.y;				gy = value.lr.y;			} */			if (x !== undefined) {				offsetX = offsetX === undefined ? x : (Math.abs(x) < Math.abs(offsetX) ? x : offsetX);				if (offsetX === x)					gridX = gx;			}			if (y !== undefined) {				offsetY = offsetY === undefined ? y : (Math.abs(y) < Math.abs(offsetY) ? y : offsetY);				if (offsetY === y)					gridY = gy;			}		});						if (offsetX !== undefined) {			ul.x += offsetX;				ul.x *= scale;			if (this.vLine&&gridX)				this.vLine.update(gridX);		} else {			ul.x = (position.x - (position.x % (ORYX.CONFIG.GRID_DISTANCE/2)));			if (this.vLine)				this.vLine.hide()		}				if (offsetY !== undefined) {				ul.y += offsetY;			ul.y *= scale;			if (this.hLine&&gridY)				this.hLine.update(gridY);		} else {			ul.y = (position.y - (position.y % (ORYX.CONFIG.GRID_DISTANCE/2)));			if (this.hLine)				this.hLine.hide();		}				return ul;	},		showGridLine: function(){			},	/**	 * Redraw of the Rectangle of the SelectedArea	 * @param {Object} bounds	 */	resizeRectangle: function(bounds) {		// Resize the Rectangle		this.selectedRect.resize(bounds);	}});ORYX.Plugins.SelectedRect = Clazz.extend({	construct: function(parentId) {		this.parentId = parentId;		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", $(parentId),					['g']);		this.dashedArea = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,			['rect', {x: 0, y: 0,				'stroke-width': 1, stroke: '#777777', fill: 'none',				'stroke-dasharray': '2,2',				'pointer-events': 'none'}]);		this.hide();	},	hide: function() {		this.node.setAttributeNS(null, 'display', 'none');	},	show: function() {		this.node.setAttributeNS(null, 'display', '');	},	resize: function(bounds) {		var upL = bounds.upperLeft();		var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;		this.dashedArea.setAttributeNS(null, 'width', bounds.width() + 2*padding);		this.dashedArea.setAttributeNS(null, 'height', bounds.height() + 2*padding);		this.node.setAttributeNS(null, 'transform', "translate("+ (upL.x - padding) +", "+ (upL.y - padding) +")");	}});ORYX.Plugins.GridLine = Clazz.extend({		construct: function(parentId, direction) {		if (ORYX.Plugins.GridLine.DIR_HORIZONTAL !== direction && ORYX.Plugins.GridLine.DIR_VERTICAL !== direction) {			direction = ORYX.Plugins.GridLine.DIR_HORIZONTAL		}					this.parent = $(parentId);		this.direction = direction;		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parent,					['g']);		this.line = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,			['path', {				'stroke-width': 1, stroke: 'silver', fill: 'none',				'stroke-dasharray': '5,5',				'pointer-events': 'none'}]);		this.hide();	},	hide: function() {		this.node.setAttributeNS(null, 'display', 'none');	},	show: function() {		this.node.setAttributeNS(null, 'display', '');	},	getScale: function(){		try {			return this.parent.parentNode.transform.baseVal.getItem(0).matrix.a;		} catch(e) {			return 1;		}	},		update: function(pos) {				if (this.direction === ORYX.Plugins.GridLine.DIR_HORIZONTAL) {			var y = pos instanceof Object ? pos.y : pos; 			var cWidth = this.parent.parentNode.parentNode.width.baseVal.value/this.getScale();			this.line.setAttributeNS(null, 'd', 'M 0 '+y+ ' L '+cWidth+' '+y);		} else {			var x = pos instanceof Object ? pos.x : pos; 			var cHeight = this.parent.parentNode.parentNode.height.baseVal.value/this.getScale();			this.line.setAttributeNS(null, 'd', 'M'+x+ ' 0 L '+x+' '+cHeight);		}				this.show();	}});ORYX.Plugins.GridLine.DIR_HORIZONTAL = "hor";ORYX.Plugins.GridLine.DIR_VERTICAL = "ver";ORYX.Plugins.Resizer = Clazz.extend({	construct: function(parentId, orientation, facade) {		this.parentId 		= parentId;		this.orientation	= orientation;		this.facade			= facade;		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", $(this.parentId),			['div', {'class': 'resizer_'+ this.orientation, style:'left:0px; top:0px;'}]);		this.node.addEventListener(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this), true);		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, 	this.handleMouseUp.bind(this), 		true);		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, 	this.handleMouseMove.bind(this), 	false);		this.dragEnable = false;		this.offSetPosition = {x: 0, y: 0};		this.bounds = undefined;		this.canvasNode = this.facade.getCanvas().node;		this.minSize = undefined;		this.maxSize = undefined;				this.aspectRatio = undefined;		this.resizeCallbacks 		= [];		this.resizeStartCallbacks 	= [];		this.resizeEndCallbacks 	= [];		this.hide();				// Calculate the Offset		this.scrollNode = this.node.parentNode.parentNode.parentNode;	},	handleMouseDown: function(event) {		this.dragEnable = true;		this.offsetScroll	= {x:this.scrollNode.scrollLeft,y:this.scrollNode.scrollTop};					this.offSetPosition =  {			x: Event.pointerX(event) - this.position.x,			y: Event.pointerY(event) - this.position.y};				this.resizeStartCallbacks.each((function(value) {			value(this.bounds);		}).bind(this));	},	handleMouseUp: function(event) {		this.dragEnable = false;		this.containmentParentNode = null;		this.resizeEndCallbacks.each((function(value) {			value(this.bounds);		}).bind(this));					},	handleMouseMove: function(event) {		if(!this.dragEnable) { return }				if(event.shiftKey || event.ctrlKey) {			this.aspectRatio = this.bounds.width() / this.bounds.height();		} else {			this.aspectRatio = undefined;		}		var position = {			x: Event.pointerX(event) - this.offSetPosition.x,			y: Event.pointerY(event) - this.offSetPosition.y}		position.x 	-= this.offsetScroll.x - this.scrollNode.scrollLeft; 		position.y 	-= this.offsetScroll.y - this.scrollNode.scrollTop;				position.x  = Math.min( position.x, this.facade.getCanvas().bounds.width())		position.y  = Math.min( position.y, this.facade.getCanvas().bounds.height())				var offset = {			x: position.x - this.position.x,			y: position.y - this.position.y		}				if(this.aspectRatio) {			// fixed aspect ratio			newAspectRatio = (this.bounds.width()+offset.x) / (this.bounds.height()+offset.y);			if(newAspectRatio>this.aspectRatio) {				offset.x = this.aspectRatio * (this.bounds.height()+offset.y) - this.bounds.width();			} else if(newAspectRatio<this.aspectRatio) {				offset.y = (this.bounds.width()+offset.x) / this.aspectRatio - this.bounds.height();			}		}				// respect minimum and maximum sizes of stencil		if(this.orientation==="northwest") {			if(this.bounds.width()-offset.x > this.maxSize.width) {				offset.x = -(this.maxSize.width - this.bounds.width());				if(this.aspectRatio)					offset.y = this.aspectRatio * offset.x;			}			if(this.bounds.width()-offset.x < this.minSize.width) {				offset.x = -(this.minSize.width - this.bounds.width());				if(this.aspectRatio)					offset.y = this.aspectRatio * offset.x;			}			if(this.bounds.height()-offset.y > this.maxSize.height) {				offset.y = -(this.maxSize.height - this.bounds.height());				if(this.aspectRatio)					offset.x = offset.y / this.aspectRatio;			}			if(this.bounds.height()-offset.y < this.minSize.height) {				offset.y = -(this.minSize.height - this.bounds.height());				if(this.aspectRatio)					offset.x = offset.y / this.aspectRatio;			}		} else { // defaults to southeast			if(this.bounds.width()+offset.x > this.maxSize.width) {				offset.x = this.maxSize.width - this.bounds.width();				if(this.aspectRatio)					offset.y = this.aspectRatio * offset.x;			}			if(this.bounds.width()+offset.x < this.minSize.width) {				offset.x = this.minSize.width - this.bounds.width();				if(this.aspectRatio)					offset.y = this.aspectRatio * offset.x;			}			if(this.bounds.height()+offset.y > this.maxSize.height) {				offset.y = this.maxSize.height - this.bounds.height();				if(this.aspectRatio)					offset.x = offset.y / this.aspectRatio;			}			if(this.bounds.height()+offset.y < this.minSize.height) {				offset.y = this.minSize.height - this.bounds.height();				if(this.aspectRatio)					offset.x = offset.y / this.aspectRatio;			}		}		if(this.orientation==="northwest") {			var oldLR = {x: this.bounds.lowerRight().x, y: this.bounds.lowerRight().y};			this.bounds.extend({x:-offset.x, y:-offset.y});			this.bounds.moveBy(offset);		} else { // defaults to southeast			this.bounds.extend(offset);		}		this.update();		this.resizeCallbacks.each((function(value) {			value(this.bounds);		}).bind(this));		Event.stop(event);	},		registerOnResizeStart: function(callback) {		if(!this.resizeStartCallbacks.member(callback)) {			this.resizeStartCallbacks.push(callback);		}	},		unregisterOnResizeStart: function(callback) {		if(this.resizeStartCallbacks.member(callback)) {			this.resizeStartCallbacks = this.resizeStartCallbacks.without(callback);		}	},	registerOnResizeEnd: function(callback) {		if(!this.resizeEndCallbacks.member(callback)) {			this.resizeEndCallbacks.push(callback);		}	},		unregisterOnResizeEnd: function(callback) {		if(this.resizeEndCallbacks.member(callback)) {			this.resizeEndCallbacks = this.resizeEndCallbacks.without(callback);		}	},			registerOnResize: function(callback) {		if(!this.resizeCallbacks.member(callback)) {			this.resizeCallbacks.push(callback);		}	},	unregisterOnResize: function(callback) {		if(this.resizeCallbacks.member(callback)) {			this.resizeCallbacks = this.resizeCallbacks.without(callback);		}	},	hide: function() {		this.node.style.display = "none";	},	show: function() {		if(this.bounds)			this.node.style.display = "";	},	setBounds: function(bounds, min, max, aspectRatio) {		this.bounds = bounds;		if(!min)			min = {width: ORYX.CONFIG.MINIMUM_SIZE, height: ORYX.CONFIG.MINIMUM_SIZE};		if(!max)			max = {width: ORYX.CONFIG.MAXIMUM_SIZE, height: ORYX.CONFIG.MAXIMUM_SIZE};		this.minSize = min;		this.maxSize = max;				this.aspectRatio = aspectRatio;		this.update();	},	update: function() {		if(!this.bounds) { return; }		var upL = this.bounds.upperLeft();		if(this.bounds.width() < this.minSize.width)	{ this.bounds.set(upL.x, upL.y, upL.x + this.minSize.width, upL.y + this.bounds.height())};		if(this.bounds.height() < this.minSize.height)	{ this.bounds.set(upL.x, upL.y, upL.x + this.bounds.width(), upL.y + this.minSize.height)};		if(this.bounds.width() > this.maxSize.width)	{ this.bounds.set(upL.x, upL.y, upL.x + this.maxSize.width, upL.y + this.bounds.height())};		if(this.bounds.height() > this.maxSize.height)	{ this.bounds.set(upL.x, upL.y, upL.x + this.bounds.width(), upL.y + this.maxSize.height)};		var a = this.canvasNode.getScreenCTM();				upL.x *= a.a;		upL.y *= a.d;				if(this.orientation==="northwest") {			upL.x -= 13;			upL.y -= 26;		} else { // defaults to southeast			upL.x +=  (a.a * this.bounds.width()) + 3 ;			upL.y +=  (a.d * this.bounds.height())  + 3;		}				this.position = upL;		this.node.style.left = this.position.x + "px";		this.node.style.top = this.position.y + "px";	}});/** * Implements a Command to move shapes *  */ ORYX.Core.Command.Move = ORYX.Core.Command.extend({	construct: function(moveShapes, offset, parent, selectedShapes, plugin){		this.moveShapes = moveShapes;		this.selectedShapes = selectedShapes;		this.offset 	= offset;		this.plugin		= plugin;		// Defines the old/new parents for the particular shape		this.newParents	= moveShapes.collect(function(t){ return parent || t.parent });		this.oldParents	= moveShapes.collect(function(shape){ return shape.parent });		this.dockedNodes= moveShapes.findAll(function(shape){ return shape instanceof ORYX.Core.Node && shape.dockers.length == 1}).collect(function(shape){ return {docker:shape.dockers[0], dockedShape:shape.dockers[0].getDockedShape(), refPoint:shape.dockers[0].referencePoint} });	},				execute: function(){		this.dockAllShapes()						// Moves by the offset		this.move( this.offset);		// Addes to the new parents		this.addShapeToParent( this.newParents ); 		// Set the selection to the current selection		this.selectCurrentShapes();		this.plugin.facade.getCanvas().update();		this.plugin.facade.updateSelection();	},	rollback: function(){		// Moves by the inverted offset		var offset = { x:-this.offset.x, y:-this.offset.y };		this.move( offset );		// Addes to the old parents		this.addShapeToParent( this.oldParents ); 		this.dockAllShapes(true)					// Set the selection to the current selection		this.selectCurrentShapes();		this.plugin.facade.getCanvas().update();		this.plugin.facade.updateSelection();			},	move:function(offset, doLayout){				// Move all Shapes by these offset		for(var i=0; i<this.moveShapes.length ;i++){			var value = this.moveShapes[i];								value.bounds.moveBy(offset);						if (value instanceof ORYX.Core.Node) {								(value.dockers||[]).each(function(d){					d.bounds.moveBy(offset);				})								// Update all Dockers of Child shapes				/*var childShapesNodes = value.getChildShapes(true).findAll(function(shape){ return shape instanceof ORYX.Core.Node });											var childDockedShapes = childShapesNodes.collect(function(shape){ return shape.getAllDockedShapes() }).flatten().uniq();											var childDockedEdge = childDockedShapes.findAll(function(shape){ return shape instanceof ORYX.Core.Edge });											childDockedEdge = childDockedEdge.findAll(function(shape){ return shape.getAllDockedShapes().all(function(dsh){ return childShapesNodes.include(dsh) }) });											var childDockedDockers = childDockedEdge.collect(function(shape){ return shape.dockers }).flatten();								for (var j = 0; j < childDockedDockers.length; j++) {					var docker = childDockedDockers[j];					if (!docker.getDockedShape() && !this.moveShapes.include(docker)) {						//docker.bounds.moveBy(offset);						//docker.update();					}				}*/												var allEdges = [].concat(value.getIncomingShapes())					.concat(value.getOutgoingShapes())					// Remove all edges which are included in the selection from the list					.findAll(function(r){ return	r instanceof ORYX.Core.Edge && !this.moveShapes.any(function(d){ return d == r || (d instanceof ORYX.Core.Controls.Docker && d.parent == r)}) }.bind(this))					// Remove all edges which are between the node and a node contained in the selection from the list					.findAll(function(r){ return 	(r.dockers.first().getDockedShape() == value || !this.moveShapes.include(r.dockers.first().getDockedShape())) &&  													(r.dockers.last().getDockedShape() == value || !this.moveShapes.include(r.dockers.last().getDockedShape()))}.bind(this))																	// Layout all outgoing/incoming edges				this.plugin.layoutEdges(value, allEdges, offset);												var allSameEdges = [].concat(value.getIncomingShapes())					.concat(value.getOutgoingShapes())					// Remove all edges which are included in the selection from the list					.findAll(function(r){ return r instanceof ORYX.Core.Edge && r.dockers.first().isDocked() && r.dockers.last().isDocked() && !this.moveShapes.include(r) && !this.moveShapes.any(function(d){ return d == r || (d instanceof ORYX.Core.Controls.Docker && d.parent == r)}) }.bind(this))					// Remove all edges which are included in the selection from the list					.findAll(function(r){ return this.moveShapes.indexOf(r.dockers.first().getDockedShape()) > i ||  this.moveShapes.indexOf(r.dockers.last().getDockedShape()) > i}.bind(this))				for (var j = 0; j < allSameEdges.length; j++) {					for (var k = 1; k < allSameEdges[j].dockers.length-1; k++) {						var docker = allSameEdges[j].dockers[k];						if (!docker.getDockedShape() && !this.moveShapes.include(docker)) {							docker.bounds.moveBy(offset);						}					}				}									/*var i=-1;				var nodes = value.getChildShapes(true);				var allEdges = [];				while(++i<nodes.length){					var edges = [].concat(nodes[i].getIncomingShapes())						.concat(nodes[i].getOutgoingShapes())						// Remove all edges which are included in the selection from the list						.findAll(function(r){ return r instanceof ORYX.Core.Edge && !allEdges.include(r) && r.dockers.any(function(d){ return !value.bounds.isIncluded(d.bounds.center)})})					allEdges = allEdges.concat(edges);					if (edges.length <= 0){ continue }					//this.plugin.layoutEdges(nodes[i], edges, offset);				}*/			}		}											},	dockAllShapes: function(shouldDocked){		// Undock all Nodes		for (var i = 0; i < this.dockedNodes.length; i++) {			var docker = this.dockedNodes[i].docker;						docker.setDockedShape( shouldDocked ? this.dockedNodes[i].dockedShape : undefined )			if (docker.getDockedShape()) {				docker.setReferencePoint(this.dockedNodes[i].refPoint);				//docker.update();			}		}	},		addShapeToParent:function( parents ){				// For every Shape, add this and reset the position				for(var i=0; i<this.moveShapes.length ;i++){			var currentShape = this.moveShapes[i];			if(currentShape instanceof ORYX.Core.Node &&			   currentShape.parent !== parents[i]) {								// Calc the new position				var unul = parents[i].absoluteXY();				var csul = currentShape.absoluteXY();				var x = csul.x - unul.x;				var y = csul.y - unul.y;				// Add the shape to the new contained shape				parents[i].add(currentShape);				// Add all attached shapes as well				currentShape.getOutgoingShapes((function(shape) {					if(shape instanceof ORYX.Core.Node && !this.moveShapes.member(shape)) {						parents[i].add(shape);					}				}).bind(this));				// Set the new position				if(currentShape instanceof ORYX.Core.Node && currentShape.dockers.length == 1){					var b = currentShape.bounds;					x += b.width()/2;y += b.height()/2					currentShape.dockers.first().bounds.centerMoveTo(x, y);				} else {					currentShape.bounds.moveTo(x, y);				}							} 						// Update the shape			//currentShape.update();					}	},	selectCurrentShapes:function(){		this.plugin.facade.setSelection( this.selectedShapes );	}});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.Grouping = Clazz.extend({	facade: undefined,	construct: function(facade) {		this.facade = facade;		this.facade.offer({			'name':ORYX.I18N.Grouping.group,			'functionality': this.createGroup.bind(this),			'group': ORYX.I18N.Grouping.grouping,			'icon': ORYX.PATH + "images/shape_group.png",			'description': ORYX.I18N.Grouping.groupDesc,			'index': 1,			'minShape': 2,			'isEnabled': this.isEnabled.bind(this, false)});		this.facade.offer({			'name':ORYX.I18N.Grouping.ungroup,			'functionality': this.deleteGroup.bind(this),			'group': ORYX.I18N.Grouping.grouping,			'icon': ORYX.PATH + "images/shape_ungroup.png",			'description': ORYX.I18N.Grouping.ungroupDesc,			'index': 2,			'minShape': 2,			'isEnabled': this.isEnabled.bind(this, true)});					this.selectedElements = [];		this.groups = [];	},	isEnabled: function(handles) {				var selectedEl = this.selectedElements;		return	handles === this.groups.any(function(group) {					return 		group.length === selectedEl.length &&								group.all(function(grEl) { return selectedEl.member(grEl)})								});	},	onSelectionChanged: function(event) {		// Get the new selection		var newSelection = event.elements;				// Find all groups with these selection		this.selectedElements = this.groups.findAll(function(group) {				return group.any(function(grEl) { return newSelection.member(grEl)})		});				// Add the selection to them		this.selectedElements.push(newSelection)				// Do all in one level and unique		this.selectedElements = this.selectedElements.flatten().uniq();				// If there are more element, set new selection in the editor		if(this.selectedElements.length !== newSelection.length) {			this.facade.setSelection(this.selectedElements);		}	},		createGroup: function() {			var selectedElements = this.facade.getSelection();				var commandClass = ORYX.Core.Command.extend({			construct: function(selectedElements, groups, setGroupsCB, facade){				this.selectedElements = selectedElements;				this.groups = groups;				this.callback = setGroupsCB;				this.facade = facade;			},						execute: function(){				var g = this.groups.findAll(function(group) {					return !group.any(function(grEl) { return selectedElements.member(grEl)})				});								g.push(selectedElements);				this.callback(g.clone());								this.facade.setSelection(this.selectedElements);			},			rollback: function(){				this.callback(this.groups.clone());								this.facade.setSelection(this.selectedElements);			}		})				var command = new commandClass(selectedElements, this.groups.clone(), this.setGroups.bind(this), this.facade);				this.facade.executeCommands([command]);	},		deleteGroup: function() {				var selectedElements = this.facade.getSelection();				var commandClass = ORYX.Core.Command.extend({			construct: function(selectedElements, groups, setGroupsCB, facade){				this.selectedElements = selectedElements;				this.groups = groups;				this.callback = setGroupsCB;				this.facade = facade;			},						execute: function(){				// Delete all groups where all these elements are member and where the elements length the same				var groupPartition = this.groups.partition(function(group) {						return 		group.length !== selectedElements.length ||									!group.all(function(grEl) { return selectedElements.member(grEl)})					});				this.callback(groupPartition[0]);								this.facade.setSelection(this.selectedElements);			},			rollback: function(){				this.callback(this.groups.clone());								this.facade.setSelection(this.selectedElements);			}		})				var command = new commandClass(selectedElements, this.groups.clone(), this.setGroups.bind(this), this.facade);				this.facade.executeCommands([command]);		},		setGroups: function(groups) {		this.groups = groups;	}});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object(); ORYX.Plugins.ShapeHighlighting = Clazz.extend({	construct: function(facade) {				this.parentNode = facade.getCanvas().getSvgContainer();				// The parent Node		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parentNode,					['g']);		this.highlightNodes = {};				facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, this.setHighlight.bind(this));		facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, this.hideHighlight.bind(this));			},	setHighlight: function(options) {		if(options && options.highlightId){			var node = this.highlightNodes[options.highlightId];						if(!node){				node= ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,					['path', {						"stroke-width": 2.0, "fill":"none"						}]);								this.highlightNodes[options.highlightId] = node;			}			if(options.elements && options.elements.length > 0) {								this.setAttributesByStyle( node, options );				this.show(node);						} else {							this.hide(node);									}					}	},		hideHighlight: function(options) {		if(options && options.highlightId && this.highlightNodes[options.highlightId]){			this.hide(this.highlightNodes[options.highlightId]);		}			},		hide: function(node) {		node.setAttributeNS(null, 'display', 'none');	},	show: function(node) {		node.setAttributeNS(null, 'display', '');	},		setAttributesByStyle: function( node, options ){				// If the style say, that it should look like a rectangle		if( options.style && options.style == ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE ){						// Set like this			var bo = options.elements[0].absoluteBounds();						var strWidth = options.strokewidth ? options.strokewidth 	: ORYX.CONFIG.BORDER_OFFSET						node.setAttributeNS(null, "d", this.getPathRectangle( bo.a, bo.b , strWidth ) );			node.setAttributeNS(null, "stroke", 		options.color 		? options.color 		: ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);			node.setAttributeNS(null, "stroke-opacity", options.opacity 	? options.opacity 		: 0.2);			node.setAttributeNS(null, "stroke-width", 	strWidth);								} else if(options.elements.length == 1 					&& options.elements[0] instanceof ORYX.Core.Edge &&					options.highlightId != "selection") {						/* Highlight containment of edge's childs */			node.setAttributeNS(null, "d", this.getPathEdge(options.elements[0].dockers));			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 0.2);			node.setAttributeNS(null, "stroke-width", 	ORYX.CONFIG.OFFSET_EDGE_BOUNDS);					}else {			// If not, set just the corners			node.setAttributeNS(null, "d", this.getPathByElements(options.elements));			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 1.0);			node.setAttributeNS(null, "stroke-width", 	options.strokewidth ? options.strokewidth 	: 2.0);								}	},		getPathByElements: function(elements){		if(!elements || elements.length <= 0) {return undefined}				// Get the padding and the size		var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;				var path = ""				// Get thru all Elements		elements.each((function(element) {			if(!element) {return}			// Get the absolute Bounds and the two Points			var bounds = element.absoluteBounds();			bounds.widen(padding)			var a = bounds.upperLeft();			var b = bounds.lowerRight();						path = path + this.getPath(a ,b);														}).bind(this));		return path;			},	getPath: function(a, b){						return this.getPathCorners(a, b);		},				getPathCorners: function(a, b){		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;						var path = ""		// Set: Upper left 		path = path + "M" + a.x + " " + (a.y + size) + " l0 -" + size + " l" + size + " 0 ";		// Set: Lower left		path = path + "M" + a.x + " " + (b.y - size) + " l0 " + size + " l" + size + " 0 ";		// Set: Lower right		path = path + "M" + b.x + " " + (b.y - size) + " l0 " + size + " l-" + size + " 0 ";		// Set: Upper right		path = path + "M" + b.x + " " + (a.y + size) + " l0 -" + size + " l-" + size + " 0 ";				return path;	},		getPathRectangle: function(a, b, strokeWidth){		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;		var path 	= ""		var offset 	= strokeWidth / 2.0;		 		// Set: Upper left 		path = path + "M" + (a.x + offset) + " " + (a.y);		path = path + " L" + (a.x + offset) + " " + (b.y - offset);		path = path + " L" + (b.x - offset) + " " + (b.y - offset);		path = path + " L" + (b.x - offset) + " " + (a.y + offset);		path = path + " L" + (a.x + offset) + " " + (a.y + offset);		return path;	},		getPathEdge: function(edgeDockers) {		var length = edgeDockers.length;		var path = "M" + edgeDockers[0].bounds.center().x + " " 					+  edgeDockers[0].bounds.center().y;				for(i=1; i<length; i++) {			var dockerPoint = edgeDockers[i].bounds.center();			path = path + " L" + dockerPoint.x + " " +  dockerPoint.y;		}				return path;	}	}); ORYX.Plugins.HighlightingSelectedShapes = Clazz.extend({	construct: function(facade) {		this.facade = facade;		this.opacityFull = 0.9;		this.opacityLow = 0.4;		// Register on Dragging-Events for show/hide of ShapeMenu		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_START, this.hide.bind(this));		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_END,  this.show.bind(this));			},	/**	 * On the Selection-Changed	 *	 */	onSelectionChanged: function(event) {		if(event.elements && event.elements.length > 1) {			this.facade.raiseEvent({										type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 										highlightId:'selection',										elements:	event.elements.without(event.subSelection),										color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,										opacity: 	!event.subSelection ? this.opacityFull : this.opacityLow									});			if(event.subSelection){				this.facade.raiseEvent({											type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 											highlightId:'subselection',											elements:	[event.subSelection],											color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,											opacity: 	this.opacityFull										});				} else {				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});							}											} else {			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'selection'});			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});		}			}});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.DragDocker = Clazz.extend({	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;				// Set the valid and invalid color		this.VALIDCOLOR 	= ORYX.CONFIG.SELECTION_VALID_COLOR;		this.INVALIDCOLOR 	= ORYX.CONFIG.SELECTION_INVALID_COLOR;				// Define Variables 		this.shapeSelection = undefined;		this.docker 		= undefined;		this.dockerParent   = undefined;		this.dockerSource 	= undefined;		this.dockerTarget 	= undefined;		this.lastUIObj 		= undefined;		this.isStartDocker 	= undefined;		this.isEndDocker 	= undefined;		this.undockTreshold	= 10;		this.initialDockerPosition = undefined;		this.outerDockerNotMoved = undefined;		this.isValid 		= false;				// For the Drag and Drop		// Register on MouseDown-Event on a Docker		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DOCKERDRAG, this.handleDockerDrag.bind(this));				// Register on over/out to show / hide a docker		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOVER, this.handleMouseOver.bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOUT, this.handleMouseOut.bind(this));							},		/**	 * MouseOut Handler	 *	 */	handleMouseOut: function(event, uiObj) {		// If there is a Docker, hide this		if(!this.docker && uiObj instanceof ORYX.Core.Controls.Docker) {			uiObj.hide()			} else if(!this.docker && uiObj instanceof ORYX.Core.Edge) {			uiObj.dockers.each(function(docker){				docker.hide();			})		}	},	/**	 * MouseOver Handler	 *	 */	handleMouseOver: function(event, uiObj) {		// If there is a Docker, show this				if(!this.docker && uiObj instanceof ORYX.Core.Controls.Docker) {			uiObj.show()			} else if(!this.docker && uiObj instanceof ORYX.Core.Edge) {			uiObj.dockers.each(function(docker){				docker.show();			})		}	},	/**	 * DockerDrag Handler	 * delegates the uiEvent of the drag event to the mouseDown function	 */	handleDockerDrag: function(event, uiObj) {		this.handleMouseDown(event.uiEvent, uiObj);	},		/**	 * MouseDown Handler	 *	 */		handleMouseDown: function(event, uiObj) {		// If there is a Docker		if(uiObj instanceof ORYX.Core.Controls.Docker && uiObj.isMovable) {						/* Buffering shape selection and clear selection*/			this.shapeSelection = this.facade.getSelection();			this.facade.setSelection();						this.docker = uiObj;			this.initialDockerPosition = this.docker.bounds.center();			this.outerDockerNotMoved = false;						this.dockerParent = uiObj.parent;						// Define command arguments			this._commandArg = {docker:uiObj, dockedShape:uiObj.getDockedShape(), refPoint:uiObj.referencePoint || uiObj.bounds.center()};			// Show the Docker			this.docker.show();						// If the Dockers Parent is an Edge, 			//  and the Docker is either the first or last Docker of the Edge			if(uiObj.parent instanceof ORYX.Core.Edge && 			   	(uiObj.parent.dockers.first() == uiObj || uiObj.parent.dockers.last() == uiObj)) {								// Get the Edge Source or Target				if(uiObj.parent.dockers.first() == uiObj && uiObj.parent.dockers.last().getDockedShape()) {					this.dockerTarget = uiObj.parent.dockers.last().getDockedShape()				} else if(uiObj.parent.dockers.last() == uiObj && uiObj.parent.dockers.first().getDockedShape()) {					this.dockerSource = uiObj.parent.dockers.first().getDockedShape()				}							} else {				// If there parent is not an Edge, undefined the Source and Target				this.dockerSource = undefined;				this.dockerTarget = undefined;							}					this.isStartDocker = this.docker.parent.dockers.first() === this.docker			this.isEndDocker = this.docker.parent.dockers.last() === this.docker								// add to canvas while dragging			this.facade.getCanvas().add(this.docker.parent);						// Hide all Labels from Docker			this.docker.parent.getLabels().each(function(label) {				label.hide();			});						// Undocked the Docker from current Shape			if ((!this.isStartDocker && !this.isEndDocker) || !this.docker.isDocked()) {								this.docker.setDockedShape(undefined)				// Set the Docker to the center of the mouse pointer				var evPos = this.facade.eventCoordinates(event);				this.docker.bounds.centerMoveTo(evPos);				//this.docker.update()				//this.facade.getCanvas().update();				this.dockerParent._update();			} else {				this.outerDockerNotMoved = true;			}						var option = {movedCallback: this.dockerMoved.bind(this), upCallback: this.dockerMovedFinished.bind(this)}							// Enable the Docker for Drag'n'Drop, give the mouseMove and mouseUp-Callback with			ORYX.Core.UIEnableDrag(event, uiObj, option);		}	},		/**	 * Docker MouseMove Handler	 *	 */	dockerMoved: function(event) {		this.outerDockerNotMoved = false;		var snapToMagnet = undefined;				if (this.docker.parent) {			if (this.isStartDocker || this.isEndDocker) {							// Get the EventPosition and all Shapes on these point				var evPos = this.facade.eventCoordinates(event);								if(this.docker.isDocked()) {					/* Only consider start/end dockers if they are moved over a treshold */					var distanceDockerPointer = 						ORYX.Core.Math.getDistancePointToPoint(evPos, this.initialDockerPosition);					if(distanceDockerPointer < this.undockTreshold) {						this.outerDockerNotMoved = true;						return;					}										/* Undock the docker */					this.docker.setDockedShape(undefined)					// Set the Docker to the center of the mouse pointer					//this.docker.bounds.centerMoveTo(evPos);					this.dockerParent._update();				}								var shapes = this.facade.getCanvas().getAbstractShapesAtPosition(evPos);								// Get the top level Shape on these, but not the same as Dockers parent				var uiObj = shapes.pop();				if (this.docker.parent === uiObj) {					uiObj = shapes.pop();				}																// If the top level Shape the same as the last Shape, then return				if (this.lastUIObj == uiObj) {				//return;								// If the top level uiObj instance of Shape and this isn't the parent of the docker 				}				else 					if (uiObj instanceof ORYX.Core.Shape) {											// Get the StencilSet of the Edge						var sset = this.docker.parent.getStencil().stencilSet();												// Ask by the StencilSet if the source, the edge and the target valid connections.						if (this.docker.parent instanceof ORYX.Core.Edge) {														var highestParent = this.getHighestParentBeforeCanvas(uiObj);							/* Ensure that the shape to dock is not a child shape 							 * of the same edge.							 */							if(highestParent instanceof ORYX.Core.Edge 									&& this.docker.parent === highestParent) {								this.isValid = false;								this.dockerParent._update();								return;							}							this.isValid = false;							var curObj = uiObj, orgObj = uiObj;							while(!this.isValid && curObj && !(curObj instanceof ORYX.Core.Canvas)){								uiObj = curObj;								this.isValid = this.facade.getRules().canConnect({											sourceShape: this.dockerSource ? // Is there a docked source 															this.dockerSource : // than set this															(this.isStartDocker ? // if not and if the Docker is the start docker																uiObj : // take the last uiObj																undefined), // if not set it to undefined;											edgeShape: this.docker.parent,											targetShape: this.dockerTarget ? // Is there a docked target 											this.dockerTarget : // than set this														(this.isEndDocker ? // if not and if the Docker is not the start docker															uiObj : // take the last uiObj															undefined) // if not set it to undefined;										});								curObj = curObj.parent;							}														// Reset uiObj if no 							// valid parent is found							if (!this.isValid){								uiObj = orgObj;							}						}						else {							this.isValid = this.facade.getRules().canConnect({								sourceShape: uiObj,								edgeShape: this.docker.parent,								targetShape: this.docker.parent							});						}												// If there is a lastUIObj, hide the magnets						if (this.lastUIObj) {							this.hideMagnets(this.lastUIObj)						}												// If there is a valid connection, show the magnets						if (this.isValid) {							this.showMagnets(uiObj)						}												// Set the Highlight Rectangle by these value						this.showHighlight(uiObj, this.isValid ? this.VALIDCOLOR : this.INVALIDCOLOR);												// Buffer the current Shape						this.lastUIObj = uiObj;					}					else {						// If there is no top level Shape, then hide the highligting of the last Shape						this.hideHighlight();						this.lastUIObj ? this.hideMagnets(this.lastUIObj) : null;						this.lastUIObj = undefined;						this.isValid = false;					}								// Snap to the nearest Magnet				if (this.lastUIObj && this.isValid && !(event.shiftKey || event.ctrlKey)) {					snapToMagnet = this.lastUIObj.magnets.find(function(magnet){						return magnet.absoluteBounds().isIncluded(evPos)					});										if (snapToMagnet) {						this.docker.bounds.centerMoveTo(snapToMagnet.absoluteCenterXY());					//this.docker.update()					}				}			}		}		// Snap to on the nearest Docker of the same parent		if(!(event.shiftKey || event.ctrlKey) && !snapToMagnet) {			var minOffset = ORYX.CONFIG.DOCKER_SNAP_OFFSET;			var nearestX = minOffset + 1			var nearestY = minOffset + 1						var dockerCenter = this.docker.bounds.center();						if (this.docker.parent) {								this.docker.parent.dockers.each((function(docker){					if (this.docker == docker) {						return					};										var center = docker.referencePoint ? docker.getAbsoluteReferencePoint() : docker.bounds.center();										nearestX = Math.abs(nearestX) > Math.abs(center.x - dockerCenter.x) ? center.x - dockerCenter.x : nearestX;					nearestY = Math.abs(nearestY) > Math.abs(center.y - dockerCenter.y) ? center.y - dockerCenter.y : nearestY;														}).bind(this));								if (Math.abs(nearestX) < minOffset || Math.abs(nearestY) < minOffset) {					nearestX = Math.abs(nearestX) < minOffset ? nearestX : 0;					nearestY = Math.abs(nearestY) < minOffset ? nearestY : 0;										this.docker.bounds.centerMoveTo(dockerCenter.x + nearestX, dockerCenter.y + nearestY);					//this.docker.update()				} else {																				var previous = this.docker.parent.dockers[Math.max(this.docker.parent.dockers.indexOf(this.docker)-1, 0)]					var next = this.docker.parent.dockers[Math.min(this.docker.parent.dockers.indexOf(this.docker)+1, this.docker.parent.dockers.length-1)]										if (previous && next && previous !== this.docker && next !== this.docker){						var cp = previous.bounds.center();						var cn = next.bounds.center();						var cd = this.docker.bounds.center();												// Checks if the point is on the line between previous and next						if (ORYX.Core.Math.isPointInLine(cd.x, cd.y, cp.x, cp.y, cn.x, cn.y, 10)) {							// Get the rise							var raise = (Number(cn.y)-Number(cp.y))/(Number(cn.x)-Number(cp.x));							// Calculate the intersection point							var intersecX = ((cp.y-(cp.x*raise))-(cd.y-(cd.x*(-Math.pow(raise,-1)))))/((-Math.pow(raise,-1))-raise);							var intersecY = (cp.y-(cp.x*raise))+(raise*intersecX);														if(isNaN(intersecX) || isNaN(intersecY)) {return;}														this.docker.bounds.centerMoveTo(intersecX, intersecY);						}					}									}			}		}		//this.facade.getCanvas().update();		this.dockerParent._update();	},	/**	 * Docker MouseUp Handler	 *	 */	dockerMovedFinished: function(event) {				/* Reset to buffered shape selection */		this.facade.setSelection(this.shapeSelection);				// Hide the border		this.hideHighlight();				// Show all Labels from Docker		this.dockerParent.getLabels().each(function(label){			label.show();			//label.update();		});			// If there is a last top level Shape		if(this.lastUIObj && (this.isStartDocker || this.isEndDocker)){							// If there is a valid connection, the set as a docked Shape to them			if(this.isValid) {								this.docker.setDockedShape(this.lastUIObj);									this.facade.raiseEvent({					type 	:ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, 					docker	: this.docker,					parent	: this.docker.parent,					target	: this.lastUIObj				});			}						this.hideMagnets(this.lastUIObj)		}				// Hide the Docker		this.docker.hide();				if(this.outerDockerNotMoved) {			// Get the EventPosition and all Shapes on these point			var evPos = this.facade.eventCoordinates(event);			var shapes = this.facade.getCanvas().getAbstractShapesAtPosition(evPos);						/* Remove edges from selection */			var shapeWithoutEdges = shapes.findAll(function(node) {				return node instanceof ORYX.Core.Node;			});			shapes = shapeWithoutEdges.length ? shapeWithoutEdges : shapes;			this.facade.setSelection(shapes);		} else {			//Command-Pattern for dragging one docker			var dragDockerCommand = ORYX.Core.Command.extend({				construct: function(docker, newPos, oldPos, newDockedShape, oldDockedShape, facade){					this.docker 		= docker;					this.index			= docker.parent.dockers.indexOf(docker);					this.newPosition	= newPos;					this.newDockedShape = newDockedShape;					this.oldPosition	= oldPos;					this.oldDockedShape	= oldDockedShape;					this.facade			= facade;					this.index			= docker.parent.dockers.indexOf(docker);					this.shape			= docker.parent;									},							execute: function(){					if (!this.docker.parent){						this.docker = this.shape.dockers[this.index];					}					this.dock( this.newDockedShape, this.newPosition );					this.removedDockers = this.shape.removeUnusedDockers();					this.facade.updateSelection();				},				rollback: function(){					this.dock( this.oldDockedShape, this.oldPosition );					(this.removedDockers||$H({})).each(function(d){						this.shape.add(d.value, Number(d.key));						this.shape._update(true);					}.bind(this))					this.facade.updateSelection();				},				dock:function( toDockShape, pos ){								// Set the Docker to the new Shape					this.docker.setDockedShape( undefined );					if( toDockShape ){									this.docker.setDockedShape( toDockShape );							this.docker.setReferencePoint( pos );						//this.docker.update();							//this.docker.parent._update();									} else {						this.docker.bounds.centerMoveTo( pos );					}						this.facade.getCanvas().update();																													}			});									if (this.docker.parent){				// Instanziate the dockCommand				var command = new dragDockerCommand(this.docker, this.docker.getDockedShape() ? this.docker.referencePoint : this.docker.bounds.center(), this._commandArg.refPoint, this.docker.getDockedShape(), this._commandArg.dockedShape, this.facade);				this.facade.executeCommands( [command] );				}		}							// Update all Shapes		//this.facade.updateSelection();					// Undefined all variables		this.docker 		= undefined;		this.dockerParent   = undefined;		this.dockerSource 	= undefined;		this.dockerTarget 	= undefined;			this.lastUIObj 		= undefined;			},		/**	 * Hide the highlighting	 */	hideHighlight: function() {		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'validDockedShape'});	},	/**	 * Show the highlighting	 *	 */	showHighlight: function(uiObj, color) {				this.facade.raiseEvent({										type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 										highlightId:'validDockedShape',										elements:	[uiObj],										color:		color									});	},		showMagnets: function(uiObj){		uiObj.magnets.each(function(magnet) {			magnet.show();		});	},		hideMagnets: function(uiObj){		uiObj.magnets.each(function(magnet) {			magnet.hide();		});	},		getHighestParentBeforeCanvas: function(shape) {		if(!(shape instanceof ORYX.Core.Shape)) {return undefined;}				var parent = shape.parent;		while(parent && !(parent.parent instanceof ORYX.Core.Canvas)) {			parent = parent.parent;		}					return parent;			}	});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.AddDocker = Clazz.extend({	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		this.facade.offer({			'name':ORYX.I18N.AddDocker.add,			'functionality': this.enableAddDocker.bind(this),			'group': ORYX.I18N.AddDocker.group,			'icon': ORYX.PATH + "images/vector_add.png",			'description': ORYX.I18N.AddDocker.addDesc,			'index': 1,            'toggle': true,			'minShape': 0,			'maxShape': 0});		this.facade.offer({			'name':ORYX.I18N.AddDocker.del,			'functionality': this.enableDeleteDocker.bind(this),			'group': ORYX.I18N.AddDocker.group,			'icon': ORYX.PATH + "images/vector_delete.png",			'description': ORYX.I18N.AddDocker.delDesc,			'index': 2,            'toggle': true,			'minShape': 0,			'maxShape': 0});				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));	},		enableAddDocker: function(button, pressed) {        //FIXME This should be done while construct, but this isn't possible right now!        this.addDockerButton = button;                // Unpress deleteDockerButton        if(pressed && this.deleteDockerButton)            this.deleteDockerButton.toggle(false);	},    enableDeleteDocker: function(button, pressed) {        //FIXME This should be done while construct, but this isn't possible right now!        this.deleteDockerButton = button;                // Unpress addDockerButton        if(pressed && this.addDockerButton)            this.addDockerButton.toggle(false);    },        enabledAdd: function(){        return this.addDockerButton ? this.addDockerButton.pressed : false;    },    enabledDelete: function(){        return this.deleteDockerButton ? this.deleteDockerButton.pressed : false;    },		/**	 * MouseDown Handler	 *	 */		handleMouseDown: function(event, uiObj) {		if (this.enabledAdd() && uiObj instanceof ORYX.Core.Edge) {            this.newDockerCommand({                edge: uiObj,                position: this.facade.eventCoordinates(event)            });		} else if (this.enabledDelete() &&				   uiObj instanceof ORYX.Core.Controls.Docker &&				   uiObj.parent instanceof ORYX.Core.Edge) {            this.newDockerCommand({                edge: uiObj.parent,                docker: uiObj            });		} else if ( this.enabledAdd() ){            this.addDockerButton.toggle(false);        } else if ( this.enabledDelete() ) {            this.deleteDockerButton.toggle(false);        }	},        // Options: edge (required), position (required if add), docker (required if delete)    newDockerCommand: function(options){        if(!options.edge)            return;        var commandClass = ORYX.Core.Command.extend({            construct: function(addEnabled, deleteEnabled, edge, docker, pos, facade){                this.addEnabled = addEnabled;                this.deleteEnabled = deleteEnabled;                this.edge = edge;                this.docker = docker;                this.pos = pos;                this.facade = facade;				//this.index = docker.parent.dockers.indexOf(docker);            },            execute: function(){                if (this.addEnabled) {                        this.docker = this.edge.addDocker(this.pos, this.docker);						this.index = this.edge.dockers.indexOf(this.docker);                }                else if (this.deleteEnabled) {					this.index = this.edge.dockers.indexOf(this.docker);                    this.pos = this.docker.bounds.center();                    this.edge.removeDocker(this.docker);                }                                this.facade.getCanvas().update();                this.facade.updateSelection();            },            rollback: function(){                if (this.addEnabled) {                    if (this.docker instanceof ORYX.Core.Controls.Docker) {                        this.edge.removeDocker(this.docker);                    }                }                else if (this.deleteEnabled) {                    this.edge.add(this.docker, this.index);                }                                this.facade.getCanvas().update();                this.facade.updateSelection();            }        })                var command = new commandClass(this.enabledAdd(), this.enabledDelete(), options.edge, options.docker, options.position, this.facade);                this.facade.executeCommands([command]);    }});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();//TODO this one fails when importing a stencilset that is already loaded. Hoewver, since an asynchronous callback throws the error, the user doesn#t recognize it.ORYX.Plugins.SSExtensionLoader = {    /**     *	Constructor     *	@param {Object} Facade: The Facade of the Editor     */    construct: function(facade){        this.facade = facade;                this.facade.offer({            'name': ORYX.I18N.SSExtensionLoader.add,            'functionality': this.addSSExtension.bind(this),            'group': ORYX.I18N.SSExtensionLoader.group,            'icon': ORYX.PATH + "images/add.png",            'description': ORYX.I18N.SSExtensionLoader.addDesc,            'index': 1,            'minShape': 0,            'maxShape': 0        });    },        addSSExtension: function(facade){        this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,            text: ORYX.I18N.SSExtensionLoader.loading        });                var url = ORYX.CONFIG.SS_EXTENSIONS_CONFIG;        //var url = "/oryx/build/stencilsets/extensions/extensions.json";        new Ajax.Request(url, {            method: 'GET',            asynchronous: false,            onSuccess: (function(transport){                            try {                    eval("var jsonObject = " + transport.responseText);                    					var stencilsets = this.facade.getStencilSets();                                        var validExtensions = jsonObject.extensions.findAll(function(extension){                        var stencilset = stencilsets[extension["extends"]];												if(stencilset) return true;						else return false;                    });                                             var loadedExtensions = validExtensions.findAll(function(extension) {                    	return stencilsets.values().any(function(ss) {                     		if(ss.extensions()[extension.namespace]) return true;                    		else return false;                    	})                    });					if (validExtensions.size() == 0)						Ext.Msg.alert(ORYX.I18N.Oryx.title, 						ORYX.I18N.SSExtensionLoader.noExt);					else                     	this._showPanel(validExtensions, loadedExtensions, this._loadExtensions.bind(this));                                    }                 catch (e) {                	console.log(e);                    Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SSExtensionLoader.failed1);				}                                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });                            }).bind(this),            onFailure: (function(transport){                Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SSExtensionLoader.failed2);                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });            }).bind(this)        });    },		_loadExtensions: function(extensions) {		var stencilsets = this.facade.getStencilSets();				var atLeastOne = false;				// unload unselected extensions		stencilsets.values().each(function(stencilset) {			var unselected = stencilset.extensions().values().select(function(ext) { return extensions[ext.namespace] == undefined }); 			unselected.each(function(ext) {				stencilset.removeExtension(ext.namespace);				atLeastOne = true;			});		});				// load selected extensions		extensions.each(function(extension) {			var stencilset = stencilsets[extension["extends"]];						if(stencilset) {				stencilset.addExtension(ORYX.CONFIG.SS_EXTENSIONS_FOLDER + extension.definition);				atLeastOne = true;			}		}.bind(this));				if (atLeastOne) {			stencilsets.values().each(function(stencilset) {				this.facade.getRules().initializeRules(stencilset);			}.bind(this));			this.facade.raiseEvent({				type: ORYX.CONFIG.EVENT_STENCIL_SET_LOADED,				lazyLoaded : true			});			var selection = this.facade.getSelection();			this.facade.setSelection();			this.facade.setSelection(selection);		}	},        _showPanel: function(validExtensions, loadedExtensions, successCallback){            // Extract the data        var data = [];        validExtensions.each(function(value){            data.push([value.title, value.definition, value["extends"]])        });                // Create a new Selection Model        var sm = new Ext.grid.CheckboxSelectionModel();                // Create a new Grid with a selection box        var grid = new Ext.grid.GridPanel({        	deferRowRender: false,            id: 'oryx_new_stencilset_extention_grid',            store: new Ext.data.SimpleStore({                fields: ['title', 'definition', 'extends']            }),            cm: new Ext.grid.ColumnModel([sm, {                header: ORYX.I18N.SSExtensionLoader.panelTitle,                width: 200,                sortable: true,                dataIndex: 'title'            }]),            sm: sm,            frame: true,            width: 200,            height: 200,            iconCls: 'icon-grid',            listeners: {                "render": function(){                    this.getStore().loadData(data);                    selectItems.defer(1);                }            }        });                function selectItems() {        	// Select loaded extensions    		var selectedRecords = new Array();    		grid.store.each(function(rec) {    			if(loadedExtensions.any(function(ext) { return ext.definition == rec.get('definition') }))    				selectedRecords.push(rec);    		});    		sm.selectRecords(selectedRecords);        }               /* grid.store.on("load", function() {         	console.log("okay");         	grid.getSelectionModel().selectRecords(selectedRecords);        }, this, {delay:500});*/                                // Create a new Panel        var panel = new Ext.Panel({            items: [{                xtype: 'label',                text: ORYX.I18N.SSExtensionLoader.panelText,                style: 'margin:10px;display:block'            }, grid],            frame: true,            buttons: [{                text: ORYX.I18N.SSExtensionLoader.labelImport,                handler: function(){                    var selectionModel = Ext.getCmp('oryx_new_stencilset_extention_grid').getSelectionModel();                    var result = selectionModel.selections.items.collect(function(item){                        return item.data;                    })                    Ext.getCmp('oryx_new_stencilset_extention_window').close();                    successCallback(result);                }.bind(this)            }, {                text: ORYX.I18N.SSExtensionLoader.labelCancel,                handler: function(){                    Ext.getCmp('oryx_new_stencilset_extention_window').close();                }.bind(this)            }]        })                // Create a new Window        var window = new Ext.Window({            id: 'oryx_new_stencilset_extention_window',            width: 227,            title: ORYX.I18N.Oryx.title,            floating: true,            shim: true,            modal: true,            resizable: false,            autoHeight: true,            items: [panel]        })                // Show the window        window.show();            }};ORYX.Plugins.SSExtensionLoader = Clazz.extend(ORYX.Plugins.SSExtensionLoader);/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object(); ORYX.Plugins.SelectionFrame = Clazz.extend({	construct: function(facade) {		this.facade = facade;		// Register on MouseEvents		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));		document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEUP, this.handleMouseUp.bind(this), true);		// Some initiale variables		this.position 		= {x:0, y:0};		this.size 			= {width:0, height:0};		this.offsetPosition = {x: 0, y: 0}		// (Un)Register Mouse-Move Event		this.moveCallback 	= undefined;		this.offsetScroll	= {x:0,y:0}		// HTML-Node of Selection-Frame		this.node = ORYX.Editor.graft("http://www.w3.org/1999/xhtml", this.facade.getCanvas().getHTMLContainer(),			['div', {'class':'Oryx_SelectionFrame'}]);		this.hide();	},	handleMouseDown: function(event, uiObj) {		// If there is the Canvas		if( uiObj instanceof ORYX.Core.Canvas ) {			// Calculate the Offset			var scrollNode = uiObj.rootNode.parentNode.parentNode;									var a = this.facade.getCanvas().node.getScreenCTM();			this.offsetPosition = {				x: a.e,				y: a.f			}			// Set the new Position			this.setPos({x: Event.pointerX(event)-this.offsetPosition.x, y:Event.pointerY(event)-this.offsetPosition.y});			// Reset the size			this.resize({width:0, height:0});			this.moveCallback = this.handleMouseMove.bind(this);					// Register Mouse-Move Event			document.documentElement.addEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.moveCallback, false);			this.offsetScroll		= {x:scrollNode.scrollLeft,y:scrollNode.scrollTop};						// Show the Frame			this.show();								}		Event.stop(event);	},	handleMouseUp: function(event) {		// If there was an MouseMoving		if(this.moveCallback) {			// Hide the Frame			this.hide();			// Unregister Mouse-Move			document.documentElement.removeEventListener(ORYX.CONFIG.EVENT_MOUSEMOVE, this.moveCallback, false);								this.moveCallback = undefined;			var corrSVG = this.facade.getCanvas().node.getScreenCTM();			// Calculate the positions of the Frame			var a = {				x: this.size.width > 0 ? this.position.x : this.position.x + this.size.width,				y: this.size.height > 0 ? this.position.y : this.position.y + this.size.height			}			var b = {				x: a.x + Math.abs(this.size.width),				y: a.y + Math.abs(this.size.height)			}			// Fit to SVG-Coordinates			a.x /= corrSVG.a; a.y /= corrSVG.d;			b.x /= corrSVG.a; b.y /= corrSVG.d;			// Calculate the elements from the childs of the canvas			var elements = this.facade.getCanvas().getChildShapes(true).findAll(function(value) {				var absBounds = value.absoluteBounds();				var bA = absBounds.upperLeft();				var bB = absBounds.lowerRight();				if(bA.x > a.x && bA.y > a.y && bB.x < b.x && bB.y < b.y)					return true;				return false			});			// Set the selection			this.facade.setSelection(elements);		}	},	handleMouseMove: function(event) {		// Calculate the size		var size = {			width	: Event.pointerX(event) - this.position.x - this.offsetPosition.x,			height	: Event.pointerY(event) - this.position.y - this.offsetPosition.y,		}		var scrollNode 	= this.facade.getCanvas().rootNode.parentNode.parentNode;		size.width 		-= this.offsetScroll.x - scrollNode.scrollLeft; 		size.height 	-= this.offsetScroll.y - scrollNode.scrollTop;								// Set the size		this.resize(size);		Event.stop(event);	},	hide: function() {		this.node.style.display = "none";	},	show: function() {		this.node.style.display = "";	},	setPos: function(pos) {		// Set the Position		this.node.style.top = pos.y + "px";		this.node.style.left = pos.x + "px";		this.position = pos;	},	resize: function(size) {		// Calculate the negative offset		this.setPos(this.position);		this.size = Object.clone(size);				if(size.width < 0) {			this.node.style.left = (this.position.x + size.width) + "px";			size.width = - size.width;		}		if(size.height < 0) {			this.node.style.top = (this.position.y + size.height) + "px";			size.height = - size.height;		}		// Set the size		this.node.style.width = size.width + "px";		this.node.style.height = size.height + "px";	}});/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object(); ORYX.Plugins.ShapeHighlighting = Clazz.extend({	construct: function(facade) {				this.parentNode = facade.getCanvas().getSvgContainer();				// The parent Node		this.node = ORYX.Editor.graft("http://www.w3.org/2000/svg", this.parentNode,					['g']);		this.highlightNodes = {};				facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, this.setHighlight.bind(this));		facade.registerOnEvent(ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, this.hideHighlight.bind(this));			},	setHighlight: function(options) {		if(options && options.highlightId){			var node = this.highlightNodes[options.highlightId];						if(!node){				node= ORYX.Editor.graft("http://www.w3.org/2000/svg", this.node,					['path', {						"stroke-width": 2.0, "fill":"none"						}]);								this.highlightNodes[options.highlightId] = node;			}			if(options.elements && options.elements.length > 0) {								this.setAttributesByStyle( node, options );				this.show(node);						} else {							this.hide(node);									}					}	},		hideHighlight: function(options) {		if(options && options.highlightId && this.highlightNodes[options.highlightId]){			this.hide(this.highlightNodes[options.highlightId]);		}			},		hide: function(node) {		node.setAttributeNS(null, 'display', 'none');	},	show: function(node) {		node.setAttributeNS(null, 'display', '');	},		setAttributesByStyle: function( node, options ){				// If the style say, that it should look like a rectangle		if( options.style && options.style == ORYX.CONFIG.SELECTION_HIGHLIGHT_STYLE_RECTANGLE ){						// Set like this			var bo = options.elements[0].absoluteBounds();						var strWidth = options.strokewidth ? options.strokewidth 	: ORYX.CONFIG.BORDER_OFFSET						node.setAttributeNS(null, "d", this.getPathRectangle( bo.a, bo.b , strWidth ) );			node.setAttributeNS(null, "stroke", 		options.color 		? options.color 		: ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);			node.setAttributeNS(null, "stroke-opacity", options.opacity 	? options.opacity 		: 0.2);			node.setAttributeNS(null, "stroke-width", 	strWidth);								} else if(options.elements.length == 1 					&& options.elements[0] instanceof ORYX.Core.Edge &&					options.highlightId != "selection") {						/* Highlight containment of edge's childs */			node.setAttributeNS(null, "d", this.getPathEdge(options.elements[0].dockers));			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 0.2);			node.setAttributeNS(null, "stroke-width", 	ORYX.CONFIG.OFFSET_EDGE_BOUNDS);					}else {			// If not, set just the corners			node.setAttributeNS(null, "d", this.getPathByElements(options.elements));			node.setAttributeNS(null, "stroke", options.color ? options.color : ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR);			node.setAttributeNS(null, "stroke-opacity", options.opacity ? options.opacity : 1.0);			node.setAttributeNS(null, "stroke-width", 	options.strokewidth ? options.strokewidth 	: 2.0);								}	},		getPathByElements: function(elements){		if(!elements || elements.length <= 0) {return undefined}				// Get the padding and the size		var padding = ORYX.CONFIG.SELECTED_AREA_PADDING;				var path = ""				// Get thru all Elements		elements.each((function(element) {			if(!element) {return}			// Get the absolute Bounds and the two Points			var bounds = element.absoluteBounds();			bounds.widen(padding)			var a = bounds.upperLeft();			var b = bounds.lowerRight();						path = path + this.getPath(a ,b);														}).bind(this));		return path;			},	getPath: function(a, b){						return this.getPathCorners(a, b);		},				getPathCorners: function(a, b){		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;						var path = ""		// Set: Upper left 		path = path + "M" + a.x + " " + (a.y + size) + " l0 -" + size + " l" + size + " 0 ";		// Set: Lower left		path = path + "M" + a.x + " " + (b.y - size) + " l0 " + size + " l" + size + " 0 ";		// Set: Lower right		path = path + "M" + b.x + " " + (b.y - size) + " l0 " + size + " l-" + size + " 0 ";		// Set: Upper right		path = path + "M" + b.x + " " + (a.y + size) + " l0 -" + size + " l-" + size + " 0 ";				return path;	},		getPathRectangle: function(a, b, strokeWidth){		var size = ORYX.CONFIG.SELECTION_HIGHLIGHT_SIZE;		var path 	= ""		var offset 	= strokeWidth / 2.0;		 		// Set: Upper left 		path = path + "M" + (a.x + offset) + " " + (a.y);		path = path + " L" + (a.x + offset) + " " + (b.y - offset);		path = path + " L" + (b.x - offset) + " " + (b.y - offset);		path = path + " L" + (b.x - offset) + " " + (a.y + offset);		path = path + " L" + (a.x + offset) + " " + (a.y + offset);		return path;	},		getPathEdge: function(edgeDockers) {		var length = edgeDockers.length;		var path = "M" + edgeDockers[0].bounds.center().x + " " 					+  edgeDockers[0].bounds.center().y;				for(i=1; i<length; i++) {			var dockerPoint = edgeDockers[i].bounds.center();			path = path + " L" + dockerPoint.x + " " +  dockerPoint.y;		}				return path;	}	}); ORYX.Plugins.HighlightingSelectedShapes = Clazz.extend({	construct: function(facade) {		this.facade = facade;		this.opacityFull = 0.9;		this.opacityLow = 0.4;		// Register on Dragging-Events for show/hide of ShapeMenu		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_START, this.hide.bind(this));		//this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDROP_END,  this.show.bind(this));			},	/**	 * On the Selection-Changed	 *	 */	onSelectionChanged: function(event) {		if(event.elements && event.elements.length > 1) {			this.facade.raiseEvent({										type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 										highlightId:'selection',										elements:	event.elements.without(event.subSelection),										color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,										opacity: 	!event.subSelection ? this.opacityFull : this.opacityLow									});			if(event.subSelection){				this.facade.raiseEvent({											type:		ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 											highlightId:'subselection',											elements:	[event.subSelection],											color:		ORYX.CONFIG.SELECTION_HIGHLIGHT_COLOR,											opacity: 	this.opacityFull										});				} else {				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});							}											} else {			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'selection'});			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE, highlightId:'subselection'});		}			}});/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 * 
 * HOW to USE the OVERLAY PLUGIN:
 * 	You can use it via the event mechanism from the editor
 * 	by using facade.raiseEvent( <option> )
 * 
 * 	As an example please have a look in the overlayexample.js
 * 
 * 	The option object should/have to have following attributes:
 * 
 * 	Key				Value-Type							Description
 * 	================================================================
 * 
 *	type 			ORYX.CONFIG.EVENT_OVERLAY_SHOW | ORYX.CONFIG.EVENT_OVERLAY_HIDE		This is the type of the event	
 *	id				<String>							You have to use an unified id for later on hiding this overlay
 *	shapes 			<ORYX.Core.Shape[]>					The Shapes where the attributes should be changed
 *	attributes 		<Object>							An object with svg-style attributes as key-value pair
 *	node			<SVGElement>						An SVG-Element could be specified for adding this to the Shape
 *	nodePosition	"N"|"NE"|"E"|"SE"|"S"|"SW"|"W"|"NW"|"START"|"END"	The position for the SVG-Element relative to the 
 *														specified Shape. "START" and "END" are just using for a Edges, then
 *														the relation is the start or ending Docker of this edge.
 *	
 * 
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Overlay = Clazz.extend({

    facade: undefined,
	
	styleNode: undefined,
    
    construct: function(facade){
		
        this.facade = facade;

		this.changes = [];

		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_OVERLAY_SHOW, this.show.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_OVERLAY_HIDE, this.hide.bind(this));	

		this.styleNode = document.createElement('style')
		this.styleNode.setAttributeNS(null, 'type', 'text/css')
		
		document.getElementsByTagName('head')[0].appendChild( this.styleNode )

    },
	
	/**
	 * Show the overlay for specific nodes
	 * @param {Object} options
	 * 
	 * 	String				options.id		- MUST - Define the id of the overlay (is needed for the hiding of this overlay)		
	 *	ORYX.Core.Shape[] 	options.shapes 	- MUST - Define the Shapes for the changes
	 * 	attr-name:value		options.changes	- Defines all the changes which should be shown
	 * 
	 * 
	 */
	show: function( options ){
		
		// Checks if all arguments are available
		if( 	!options || 
				!options.shapes || !options.shapes instanceof Array ||
				!options.id	|| !options.id instanceof String || options.id.length == 0) { 
				
					return
					
		}
		
		//if( this.changes[options.id]){
		//	this.hide( options )
		//}
			

		// Checked if attributes are setted
		if( options.attributes ){
			
			// FOR EACH - Shape
			options.shapes.each(function(el){
				
				// Checks if the node is a Shape
				if( !el instanceof ORYX.Core.Shape){ return }
				
				this.setAttributes( el.node , options.attributes )
				
			}.bind(this))

		}	
		
		var isSVG = true
		try {
			isSVG = options.node && options.node instanceof SVGElement;
		} catch(e){}
		
		// Checks if node is setted and if this is an SVGElement		
		if ( options.node && isSVG) {
			
			options["_temps"] = []
						
			// FOR EACH - Node
			options.shapes.each(function(el, index){
				
				// Checks if the node is a Shape
				if( !el instanceof ORYX.Core.Shape){ return }
				
				var _temp = {}
				_temp.svg = options.dontCloneNode ? options.node : options.node.cloneNode( true );
				
				// Add the svg node to the ORYX-Shape
				el.node.firstChild.appendChild( _temp.svg )		
				
				// If
				if (el instanceof ORYX.Core.Edge && !options.nodePosition) {
					options['nodePosition'] = "START"
				}
						
				// If the node position is setted, it has to be transformed
				if( options.nodePosition ){
					
					var b = el.bounds;
					var p = options.nodePosition.toUpperCase();
										
					// Check the values of START and END
					if( el instanceof ORYX.Core.Node && p == "START"){
						p = "NW";
					} else if(el instanceof ORYX.Core.Node && p == "END"){
						p = "SE";
					} else if(el instanceof ORYX.Core.Edge && p == "START"){
						b = el.getDockers().first().bounds
					} else if(el instanceof ORYX.Core.Edge && p == "END"){
						b = el.getDockers().last().bounds
					}

					// Create a callback for the changing the position 
					// depending on the position string
					_temp.callback = function(){
						
						var x = 0; var y = 0;
						
						if( p == "NW" ){
							// Do Nothing
						} else if( p == "N" ) {
							x = b.width() / 2;
						} else if( p == "NE" ) {
							x = b.width();
						} else if( p == "E" ) {
							x = b.width(); y = b.height() / 2;
						} else if( p == "SE" ) {
							x = b.width(); y = b.height();
						} else if( p == "S" ) {
							x = b.width() / 2; y = b.height();
						} else if( p == "SW" ) {
							y = b.height();
						} else if( p == "W" ) {
							y = b.height() / 2;
						} else if( p == "START" || p == "END") {
							x = b.width() / 2; y = b.height() / 2;
						}						
						else {
							return
						}
						
						if( el instanceof ORYX.Core.Edge){
							x  += b.upperLeft().x ; y  += b.upperLeft().y ;
						}
						
						_temp.svg.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")")
					
					}.bind(this)
					
					_temp.element = el;
					_temp.callback();
					
					b.registerCallback( _temp.callback );
					
				}
				
				// Show the ghostpoint
				if(options.ghostPoint){
					var point={x:0, y:0};
					point=options.ghostPoint;
					_temp.callback = function(){
						
						var x = 0; var y = 0;
						x = point.x -7;
						y = point.y -7;
						_temp.svg.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")")
						
					}.bind(this)
					
					_temp.element = el;
					_temp.callback();
					
					b.registerCallback( _temp.callback );
				}
				
				if(options.labelPoint){
					var point={x:0, y:0};
					point=options.labelPoint;
					_temp.callback = function(){
						
						var x = 0; var y = 0;
						x = point.x;
						y = point.y;
						_temp.svg.setAttributeNS(null, "transform", "translate(" + x + ", " + y + ")")
						
					}.bind(this)
					
					_temp.element = el;
					_temp.callback();
					
					b.registerCallback( _temp.callback );
				}
				
				
				options._temps.push( _temp )	
				
			}.bind(this))
			
			
			
		}		
	

		// Store the changes
		if( !this.changes[options.id] ){
			this.changes[options.id] = [];
		}
		
		this.changes[options.id].push( options );
				
	},
	
	/**
	 * Hide the overlay with the spefic id
	 * @param {Object} options
	 */
	hide: function( options ){
		
		// Checks if all arguments are available
		if( 	!options || 
				!options.id	|| !options.id instanceof String || options.id.length == 0 ||
				!this.changes[options.id]) { 
				
					return
					
		}		
		
		
		// Delete all added attributes
		// FOR EACH - Shape
		this.changes[options.id].each(function(option){
			
			option.shapes.each(function(el, index){
				
				// Checks if the node is a Shape
				if( !el instanceof ORYX.Core.Shape){ return }
				
				this.deleteAttributes( el.node )
							
			}.bind(this));

	
			if( option._temps ){
				
				option._temps.each(function(tmp){
					// Delete the added Node, if there is one
					if( tmp.svg && tmp.svg.parentNode ){
						tmp.svg.parentNode.removeChild( tmp.svg )
					}
		
					// If 
					if( tmp.callback && tmp.element){
						// It has to be unregistered from the edge
						tmp.element.bounds.unregisterCallback( tmp.callback )
					}
							
				}.bind(this))
				
			}
		
			
		}.bind(this));

		
		this.changes[options.id] = null;
		
		
	},
	
	
	/**
	 * Set the given css attributes to that node
	 * @param {HTMLElement} node
	 * @param {Object} attributes
	 */
	setAttributes: function( node, attributes ) {
		
		
		// Get all the childs from ME
		var childs = this.getAllChilds( node.firstChild.firstChild )
		
		var ids = []
		
		// Add all Attributes which have relation to another node in this document and concate the pure id out of it
		// This is for example important for the markers of a edge
		childs.each(function(e){ ids.push( $A(e.attributes).findAll(function(attr){ return attr.nodeValue.startsWith('url(#')}) )})
		ids = ids.flatten().compact();
		ids = ids.collect(function(s){return s.nodeValue}).uniq();
		ids = ids.collect(function(s){return s.slice(5, s.length-1)})
		
		// Add the node ID to the id
		ids.unshift( node.id + ' .me')
		
		var attr				= $H(attributes);
        var attrValue			= attr.toJSON().gsub(',', ';').gsub('"', '');
        var attrMarkerValue		= attributes.stroke ? attrValue.slice(0, attrValue.length-1) + "; fill:" + attributes.stroke + ";}" : attrValue;
        var attrTextValue;
        if( attributes.fill ){
            var copyAttr        = Object.clone(attributes);
        	copyAttr.fill		= "black";
        	attrTextValue		= $H(copyAttr).toJSON().gsub(',', ';').gsub('"', '');
        }
                	
        // Create the CSS-Tags Style out of the ids and the attributes
        csstags = ids.collect(function(s, i){return "#" + s + " * " + (!i? attrValue : attrMarkerValue) + "" + (attrTextValue ? " #" + s + " text * " + attrTextValue : "") })
		
		// Join all the tags
		var s = csstags.join(" ") + "\n" 
		
		// And add to the end of the style tag
		this.styleNode.appendChild(document.createTextNode(s));
		
		
	},
	
	/**
	 * Deletes all attributes which are
	 * added in a special style sheet for that node
	 * @param {HTMLElement} node 
	 */
	deleteAttributes: function( node ) {
				
		// Get all children which contains the node id		
		var delEl = $A(this.styleNode.childNodes)
					 .findAll(function(e){ return e.textContent.include( '#' + node.id ) });
		
		// Remove all of them
		delEl.each(function(el){
			el.parentNode.removeChild(el);
		});		
	},
	
	getAllChilds: function( node ){
		
		var childs = $A(node.childNodes)
		
		$A(node.childNodes).each(function( e ){ 
		        childs.push( this.getAllChilds( e ) )
		}.bind(this))

    	return childs.flatten();
	}

    
});
/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.Edit = Clazz.extend({        construct: function(facade){            this.facade = facade;        this.clipboard = new ORYX.Plugins.Edit.ClipBoard(facade);                //this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keyHandler.bind(this));                this.facade.offer({         name: ORYX.I18N.Edit.cut,         description: ORYX.I18N.Edit.cutDesc,         icon: ORYX.PATH + "images/cut.png",		 keyCodes: [{				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: 88,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN			}		 ],         functionality: this.callEdit.bind(this, this.editCut),         group: ORYX.I18N.Edit.group,         index: 1,         minShape: 1         });                 this.facade.offer({         name: ORYX.I18N.Edit.copy,         description: ORYX.I18N.Edit.copyDesc,         icon: ORYX.PATH + "images/page_copy.png",		 keyCodes: [{				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: 67,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN			}		 ],         functionality: this.callEdit.bind(this, this.editCopy, [true, false]),         group: ORYX.I18N.Edit.group,         index: 2,         minShape: 1         });                 this.facade.offer({         name: ORYX.I18N.Edit.paste,         description: ORYX.I18N.Edit.pasteDesc,         icon: ORYX.PATH + "images/page_paste.png",		 keyCodes: [{				metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: 86,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN			}		 ],         functionality: this.callEdit.bind(this, this.editPaste),         isEnabled: this.clipboard.isOccupied.bind(this.clipboard),         group: ORYX.I18N.Edit.group,         index: 3,         minShape: 0,         maxShape: 0         });                 this.facade.offer({            name: ORYX.I18N.Edit.del,            description: ORYX.I18N.Edit.delDesc,            icon: ORYX.PATH + "images/cross.png",			keyCodes: [{					metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],					keyCode: 8,					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN				},				{						keyCode: 46,					keyAction: ORYX.CONFIG.KEY_ACTION_DOWN				}			],            functionality: this.callEdit.bind(this, this.editDelete),            group: ORYX.I18N.Edit.group,            index: 4,            minShape: 1        });    },		callEdit: function(fn, args){		window.setTimeout(function(){			fn.apply(this, (args instanceof Array ? args : []));		}.bind(this), 1);	},		/**	 * Handles the mouse down event and starts the copy-move-paste action, if	 * control or meta key is pressed.	 */	handleMouseDown: function(event) {		if(this._controlPressed) {			this._controlPressed = false;			this.editCopy();//			console.log("copiedEle: %0",this.clipboard.shapesAsJson())//			console.log("mousevent: %o",event)			this.editPaste();			event.forceExecution = true;			this.facade.raiseEvent(event, this.clipboard.shapesAsJson());					}	},        /**     * The key handler for this plugin. Every action from the set of cut, copy,     * paste and delete should be accessible trough simple keyboard shortcuts.     * This method checks whether any event triggers one of those actions.     *     * @param {Object} event The keyboard event that should be analysed for     *     triggering of this plugin.     *///    keyHandler: function(event){//        //TODO document what event.which is.//        //        ORYX.Log.debug("edit.js handles a keyEvent.");//        //        // assure we have the current event.//        if (!event) //            event = window.event;//        //        //        // get the currently pressed key and state of control key.//        var pressedKey = event.which || event.keyCode;//        var ctrlPressed = event.ctrlKey;//        //        // if the object is to be deleted, do so, and return immediately.//        if ((pressedKey == ORYX.CONFIG.KEY_CODE_DELETE) ||//        ((pressedKey == ORYX.CONFIG.KEY_CODE_BACKSPACE) &&//        (event.metaKey || event.appleMetaKey))) {//        //            ORYX.Log.debug("edit.js deletes the shape.");//            this.editDelete();//            return;//        }//        //         // if control key is not pressed, we're not interested anymore.//         if (!ctrlPressed)//         return;//         //         // when ctrl is pressed, switch trough the possibilities.//         switch (pressedKey) {//         //	         // cut.//	         case ORYX.CONFIG.KEY_CODE_X://	         this.editCut();//	         break;//	         //	         // copy.//	         case ORYX.CONFIG.KEY_CODE_C://	         this.editCopy();//	         break;//	         //	         // paste.//	         case ORYX.CONFIG.KEY_CODE_V://	         this.editPaste();//	         break;//         }//    },	    /**     * Returns a list of shapes which should be considered while copying.     * Besides the shapes of given ones, edges and attached nodes are added to the result set.     * If one of the given shape is a child of another given shape, it is not put into the result.      */    getAllShapesToConsider: function(shapes){        var shapesToConsider = []; // only top-level shapes        var childShapesToConsider = []; // all child shapes of top-level shapes                shapes.each(function(shape){            //Throw away these shapes which have a parent in given shapes            isChildShapeOfAnother = shapes.any(function(s2){                return s2.hasChildShape(shape);            });            if(isChildShapeOfAnother) return;                        // This shape should be considered            shapesToConsider.push(shape);            // Consider attached nodes (e.g. intermediate events)            if (shape instanceof ORYX.Core.Node) {				var attached = shape.getOutgoingNodes();				attached = attached.findAll(function(a){ return !shapes.include(a) });                shapesToConsider = shapesToConsider.concat(attached);            }                        childShapesToConsider = childShapesToConsider.concat(shape.getChildShapes(true));        }.bind(this));                // All edges between considered child shapes should be considered        // Look for these edges having incoming and outgoing in childShapesToConsider        var edgesToConsider = this.facade.getCanvas().getChildEdges().select(function(edge){            // Ignore if already added            if(shapesToConsider.include(edge)) return false;            // Ignore if there are no docked shapes            if(edge.getAllDockedShapes().size() === 0) return false;             // True if all docked shapes are in considered child shapes            return edge.getAllDockedShapes().all(function(shape){                // Remember: Edges can have other edges on outgoing, that is why edges must not be included in childShapesToConsider                return shape instanceof ORYX.Core.Edge || childShapesToConsider.include(shape);            });        });        shapesToConsider = shapesToConsider.concat(edgesToConsider);                return shapesToConsider;    },        /**     * Performs the cut operation by first copy-ing and then deleting the     * current selection.     */    editCut: function(){        //TODO document why this returns false.        //TODO document what the magic boolean parameters are supposed to do.try {                this.editCopy(false, true);        this.editDelete(true);} catch(e){ORYX.Log.error(e)}        return false;    },        /**     * Performs the copy operation.     * @param {Object} will_not_update ??     */    editCopy: function( will_update, useNoOffset ){        var selection = this.facade.getSelection();                //if the selection is empty, do not remove the previously copied elements        if(selection.length == 0) return;                this.clipboard.refresh(selection, this.getAllShapesToConsider(selection), this.facade.getCanvas().getStencil().stencilSet().namespace(), useNoOffset);        if( will_update ) this.facade.updateSelection();    },        /**     * Performs the paste operation.     */    editPaste: function(){        // Create a new canvas with childShapes 		//and stencilset namespace to be JSON Import conform		var canvas = {            childShapes: this.clipboard.shapesAsJson(),			stencilset:{				namespace:this.clipboard.SSnamespace			}        }        // Apply json helper to iterate over json object        Ext.apply(canvas, ORYX.Core.AbstractShape.JSONHelper);                var childShapeResourceIds =  canvas.getChildShapes(true).pluck("resourceId");        var outgoings = {};        // Iterate over all shapes        canvas.eachChild(function(shape, parent){            // Throw away these references where referenced shape isn't copied            shape.outgoing = shape.outgoing.select(function(out){                return childShapeResourceIds.include(out.resourceId);            });			shape.outgoing.each(function(out){				if (!outgoings[out.resourceId]){ outgoings[out.resourceId] = [] }				outgoings[out.resourceId].push(shape)			});			            return shape;        }.bind(this), true, true);                // Iterate over all shapes        canvas.eachChild(function(shape, parent){                    	// Check if there has a valid target            if(shape.target && !(childShapeResourceIds.include(shape.target.resourceId))){                shape.target = undefined;                shape.targetRemoved = true;            }    		    		// Check if the first docker is removed    		if(	shape.dockers &&     			shape.dockers.length >= 1 &&     			shape.dockers[0].getDocker &&    			((shape.dockers[0].getDocker().getDockedShape() &&    			!childShapeResourceIds.include(shape.dockers[0].getDocker().getDockedShape().resourceId)) ||     			!shape.getShape().dockers[0].getDockedShape()&&!outgoings[shape.resourceId])) {    				    			shape.sourceRemoved = true;    		}			            return shape;        }.bind(this), true, true);		        // Iterate over top-level shapes        canvas.eachChild(function(shape, parent){            // All top-level shapes should get an offset in their bounds            // Move the shape occording to COPY_MOVE_OFFSET        	if (this.clipboard.useOffset) {	            shape.bounds = {	                lowerRight: {	                    x: shape.bounds.lowerRight.x + ORYX.CONFIG.COPY_MOVE_OFFSET,	                    y: shape.bounds.lowerRight.y + ORYX.CONFIG.COPY_MOVE_OFFSET	                },	                upperLeft: {	                    x: shape.bounds.upperLeft.x + ORYX.CONFIG.COPY_MOVE_OFFSET,	                    y: shape.bounds.upperLeft.y + ORYX.CONFIG.COPY_MOVE_OFFSET	                }	            };        	}            // Only apply offset to shapes with a target            if (shape.dockers){                shape.dockers = shape.dockers.map(function(docker, i){                    // If shape had a target but the copied does not have anyone anymore,                    // migrate the relative dockers to absolute ones.                    if( (shape.targetRemoved === true && i == shape.dockers.length - 1&&docker.getDocker) ||						(shape.sourceRemoved === true && i == 0&&docker.getDocker)){                        docker = docker.getDocker().bounds.center();                    }					// If it is the first docker and it has a docked shape, 					// just return the coordinates				   	if ((i == 0 && docker.getDocker instanceof Function && 				   		shape.sourceRemoved !== true && (docker.getDocker().getDockedShape() || ((outgoings[shape.resourceId]||[]).length > 0 && (!(shape.getShape() instanceof ORYX.Core.Node) || outgoings[shape.resourceId][0].getShape() instanceof ORYX.Core.Node)))) || 						(i == shape.dockers.length - 1 && docker.getDocker instanceof Function && 						shape.targetRemoved !== true && (docker.getDocker().getDockedShape() || shape.target))){													return {                        	x: docker.x,                         	y: docker.y,                        	getDocker: docker.getDocker						}					} else if (this.clipboard.useOffset) {	                    return {		                        x: docker.x + ORYX.CONFIG.COPY_MOVE_OFFSET, 		                        y: docker.y + ORYX.CONFIG.COPY_MOVE_OFFSET,	                        	getDocker: docker.getDocker		                    };				   	} else {				   		return {                        	x: docker.x,                         	y: docker.y,                        	getDocker: docker.getDocker						};				   	}                }.bind(this));            } else if (shape.getShape() instanceof ORYX.Core.Node && shape.dockers && shape.dockers.length > 0 && (!shape.dockers.first().getDocker || shape.sourceRemoved === true || !(shape.dockers.first().getDocker().getDockedShape() || outgoings[shape.resourceId]))){            	            	shape.dockers = shape.dockers.map(function(docker, i){            		                    if((shape.sourceRemoved === true && i == 0&&docker.getDocker)){                    	docker = docker.getDocker().bounds.center();                    }                                        if (this.clipboard.useOffset) {	            		return {	                        x: docker.x + ORYX.CONFIG.COPY_MOVE_OFFSET, 	                        y: docker.y + ORYX.CONFIG.COPY_MOVE_OFFSET,	                    	getDocker: docker.getDocker	                    };                    } else {	            		return {	                        x: docker.x, 	                        y: docker.y,	                    	getDocker: docker.getDocker	                    };                    }            	}.bind(this));            }                        return shape;        }.bind(this), false, true);        this.clipboard.useOffset = true;        this.facade.importJSON(canvas);    },        /**     * Performs the delete operation. No more asking.     */    editDelete: function(){        var selection = this.facade.getSelection();        		var shapes = this.getAllShapesToConsider(selection);		var command = new ORYX.Plugins.Edit.DeleteCommand(shapes, this.facade);                                       		this.facade.executeCommands([command]);    }}); ORYX.Plugins.Edit.ClipBoard = Clazz.extend({    construct: function(){        this._shapesAsJson = [];        this.selection = [];		this.SSnamespace="";		this.useOffset=true;    },    isOccupied: function(){        return this.shapesAsJson().length > 0;    },    refresh: function(selection, shapes, namespace, useNoOffset){        this.selection = selection;        this.SSnamespace=namespace;        // Store outgoings, targets and parents to restore them later on        this.outgoings = {};        this.parents = {};        this.targets = {};        this.useOffset = useNoOffset !== true;                this._shapesAsJson = shapes.map(function(shape){            var s = shape.toJSON();            s.parent = {resourceId : shape.getParentShape().resourceId};            s.parentIndex = shape.getParentShape().getChildShapes().indexOf(shape)            return s;        });    },	shapesAsJson: function() {		return this._shapesAsJson;	}});ORYX.Plugins.Edit.DeleteCommand = ORYX.Core.Command.extend({    construct: function(shapes, facade){	try {        this.shapesAsJson       = shapes;        this.facade             = facade;ORYX.Log.info("this.shapesAsJson", this.shapesAsJson);                // Store dockers of deleted shapes to restore connections        this.dockers            = this.shapesAsJson.map(function(shape){//            var shape = shapeAsJson.getShape();            var incomingDockers = shape.getIncomingShapes().map(function(s){return s.getDockers().last()})            var outgoingDockers = shape.getOutgoingShapes().map(function(s){return s.getDockers().first()})            var dockers = shape.getDockers().concat(incomingDockers, outgoingDockers).compact().map(function(docker){                return {                    object: docker,                    referencePoint: docker.referencePoint,                    dockedShape: docker.getDockedShape()                };            });            return dockers;        }).flatten();}catch(e){ORYX.Log.error(e)}    },              execute: function(){        this.shapesAsJson.each(function(shape){            // Delete shape            this.facade.deleteShape(shape); // AsJson.getShape()        }.bind(this));                this.facade.setSelection([]);        this.facade.getCanvas().update();				this.facade.updateSelection();            },    rollback: function(){        this.shapesAsJson.each(function(shape) {    		var parent = ("undefined" != typeof(shape.parent) ?  this.facade.getCanvas().getChildShapeByResourceId(shape.parent.resourceId) : this.facade.getCanvas());            parent.add(shape, shape.parentIndex);            parent.add(shape, shape.parentIndex);        }.bind(this));                //reconnect shapes        this.dockers.each(function(d) {            d.object.setDockedShape(d.dockedShape);            d.object.setReferencePoint(d.referencePoint);        }.bind(this));                this.facade.setSelection(this.selectedShapes);        this.facade.getCanvas().update();			this.facade.updateSelection();            }});/** * Copyright (c) 2009 * Jan-Felix Schwarz * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.KeysMove = ORYX.Plugins.AbstractPlugin.extend({    facade: undefined,        construct: function(facade){            this.facade = facade;        this.copyElements = [];                //this.facade.registerOnEvent(ORYX.CONFIG.EVENT_KEYDOWN, this.keyHandler.bind(this));		// SELECT ALL		this.facade.offer({		keyCodes: [{		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: 65,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.selectAll.bind(this)         });		 		// MOVE LEFT SMALL				this.facade.offer({		keyCodes: [{		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: ORYX.CONFIG.KEY_CODE_LEFT,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_LEFT, false)         });		 		 // MOVE LEFT		 this.facade.offer({		 keyCodes: [{				keyCode: ORYX.CONFIG.KEY_CODE_LEFT,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_LEFT, true)         });		 		// MOVE RIGHT SMALL			 this.facade.offer({		 keyCodes: [{		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: ORYX.CONFIG.KEY_CODE_RIGHT,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_RIGHT, false)         });		 		// MOVE RIGHT			 this.facade.offer({		 keyCodes: [{				keyCode: ORYX.CONFIG.KEY_CODE_RIGHT,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_RIGHT, true)         });		 		// MOVE UP SMALL			 this.facade.offer({		 keyCodes: [{		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: ORYX.CONFIG.KEY_CODE_UP,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_UP, false)         });		 		// MOVE UP			 this.facade.offer({		 keyCodes: [{				keyCode: ORYX.CONFIG.KEY_CODE_UP,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_UP, true)         });		 		// MOVE DOWN SMALL			 this.facade.offer({		 keyCodes: [{		 		metaKeys: [ORYX.CONFIG.META_KEY_META_CTRL],				keyCode: ORYX.CONFIG.KEY_CODE_DOWN,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_DOWN, false)         });		 		// MOVE DOWN			 this.facade.offer({		 keyCodes: [{				keyCode: ORYX.CONFIG.KEY_CODE_DOWN,				keyAction: ORYX.CONFIG.KEY_ACTION_DOWN 			}		 ],         functionality: this.move.bind(this, ORYX.CONFIG.KEY_CODE_DOWN, true)         });		              },    	/**	 * Select all shapes in the editor	 *	 */	selectAll: function(e){    	Event.stop(e.event);		this.facade.setSelection(this.facade.getCanvas().getChildShapes(true))	},		move: function(key, far, e) {		    	Event.stop(e.event);		// calculate the distance to move the objects and get the selection.		var distance = far? 20 : 5;		var selection = this.facade.getSelection();		var currentSelection = this.facade.getSelection();		var p = {x: 0, y: 0};				// switch on the key pressed and populate the point to move by.		switch(key) {			case ORYX.CONFIG.KEY_CODE_LEFT:				p.x = -1*distance;				break;			case ORYX.CONFIG.KEY_CODE_RIGHT:				p.x = distance;				break;			case ORYX.CONFIG.KEY_CODE_UP:				p.y = -1*distance;				break;			case ORYX.CONFIG.KEY_CODE_DOWN:				p.y = distance;				break;		}				// move each shape in the selection by the point calculated and update it.		selection = selection.findAll(function(shape){ 			// Check if this shape is docked to an shape in the selection						if(shape instanceof ORYX.Core.Node && shape.dockers.length == 1 && selection.include( shape.dockers.first().getDockedShape() )){ 				return false 			} 						// Check if any of the parent shape is included in the selection			var s = shape.parent; 			do{ 				if(selection.include(s)){ 					return false				}			}while(s = s.parent); 						// Otherwise, return true			return true;					});				/* Edges must not be movable, if only edges are selected and at least 		 * one of them is docked.		 */		var edgesMovable = true;		var onlyEdgesSelected = selection.all(function(shape) {			if(shape instanceof ORYX.Core.Edge) {				if(shape.isDocked()) {					edgesMovable = false;				}				return true;				}			return false;		});				if(onlyEdgesSelected && !edgesMovable) {			/* Abort moving shapes */			return;		}				selection = selection.map(function(shape){ 			if( shape instanceof ORYX.Core.Node ){				/*if( shape.dockers.length == 1 ){					return shape.dockers.first()				} else {*/					return shape				//}			} else if( shape instanceof ORYX.Core.Edge ) {								var dockers = shape.dockers;								if( selection.include( shape.dockers.first().getDockedShape() ) ){					dockers = dockers.without( shape.dockers.first() )				}				if( selection.include( shape.dockers.last().getDockedShape() ) ){					dockers = dockers.without( shape.dockers.last() )				}								return dockers											} else {				return null			}				}).flatten().compact();				if (selection.size() > 0) {						//Stop moving at canvas borders			var selectionBounds = [ this.facade.getCanvas().bounds.lowerRight().x,			                        this.facade.getCanvas().bounds.lowerRight().y,			                        0,			                        0 ];			selection.each(function(s) {				selectionBounds[0] = Math.min(selectionBounds[0], s.bounds.upperLeft().x);				selectionBounds[1] = Math.min(selectionBounds[1], s.bounds.upperLeft().y);				selectionBounds[2] = Math.max(selectionBounds[2], s.bounds.lowerRight().x);				selectionBounds[3] = Math.max(selectionBounds[3], s.bounds.lowerRight().y);			});			if(selectionBounds[0]+p.x < 0)				p.x = -selectionBounds[0];			if(selectionBounds[1]+p.y < 0)				p.y = -selectionBounds[1];			if(selectionBounds[2]+p.x > this.facade.getCanvas().bounds.lowerRight().x)				p.x = this.facade.getCanvas().bounds.lowerRight().x - selectionBounds[2];			if(selectionBounds[3]+p.y > this.facade.getCanvas().bounds.lowerRight().y)				p.y = this.facade.getCanvas().bounds.lowerRight().y - selectionBounds[3];						if(p.x!=0 || p.y!=0) {				// Instantiate the moveCommand				var commands = [new ORYX.Core.Command.Move(selection, p, null, currentSelection, this)];				// Execute the commands							this.facade.executeCommands(commands);			}					}	},		getUndockedCommant: function(shapes){		var undockEdgeCommand = ORYX.Core.Command.extend({			construct: function(moveShapes){				this.dockers = moveShapes.collect(function(shape){ return shape instanceof ORYX.Core.Controls.Docker ? {docker:shape, dockedShape:shape.getDockedShape(), refPoint:shape.referencePoint} : undefined }).compact();			},						execute: function(){				this.dockers.each(function(el){					el.docker.setDockedShape(undefined);				})			},			rollback: function(){				this.dockers.each(function(el){					el.docker.setDockedShape(el.dockedShape);					el.docker.setReferencePoint(el.refPoint);					//el.docker.update();				})			}		});				command = new undockEdgeCommand( shapes );		command.execute();			return command;	},	//    /**//     * The key handler for this plugin. Every action from the set of cut, copy,//     * paste and delete should be accessible trough simple keyboard shortcuts.//     * This method checks whether any event triggers one of those actions.//     *//     * @param {Object} event The keyboard event that should be analysed for//     *     triggering of this plugin.//     *///    keyHandler: function(event){//        //TODO document what event.which is.//        //        ORYX.Log.debug("keysMove.js handles a keyEvent.");//        //        // assure we have the current event.//        if (!event) //            event = window.event;//        //        // get the currently pressed key and state of control key.//        var pressedKey = event.which || event.keyCode;//        var ctrlPressed = event.ctrlKey;////		// if the key is one of the arrow keys, forward to move and return.//		if ([ORYX.CONFIG.KEY_CODE_LEFT, ORYX.CONFIG.KEY_CODE_RIGHT,//			ORYX.CONFIG.KEY_CODE_UP, ORYX.CONFIG.KEY_CODE_DOWN].include(pressedKey)) {//			//			this.move(pressedKey, !ctrlPressed);//			return;//		}//		//    }	});/**
 * Copyright (c) 2009
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
   @namespace Oryx name space for plugins
   @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	

/**
 * This plugin provides methods to layout elements that typically contain 
 * a bunch of child elements, such as subprocesses or lanes.
 * 
 * @class ORYX.Plugins.ContainerLayouter
 * @extends ORYX.Plugins.AbstractPlugin
 * @param {Object} facade
 * 		The facade of the Editor
 */
ORYX.Plugins.ContainerLayouter = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade){
		this.facade = facade;

		// this does NOT work, because lanes and pools are loaded at start and initialized with a default size
		// if the lane was saved and had a bigger size, the dockers/edges will be corrupted, because the first 
		// positioning is handled as a resize event which triggers the layout with incorrect oldBounds!
		
		//this.facade.registerOnEvent('layout.container.minBounds', 
		//							this.handleLayoutContainerMinBounds.bind(this));
		//this.facade.registerOnEvent('layout.container.dockers', 
		//							this.handleLayoutContainerDockers.bind(this));
		
		this.hashedContainers = new Hash();
	},
	
	handleLayoutContainerDockers: function(event) {
		var sh = event.shape;
		
		if (!this.hashedContainers[sh.resourceId]) {
			this.hashedContainers[sh.resourceId] = sh.bounds.clone();
			return;
		}
		
		var offset = sh.bounds.upperLeft();
		offset.x -= this.hashedContainers[sh.resourceId].upperLeft().x;
		offset.y -= this.hashedContainers[sh.resourceId].upperLeft().y;
		
		this.hashedContainers[sh.resourceId] = sh.bounds.clone();
		
		this.moveChildDockers(sh, offset);
	},
	
	/**
	 * 
	 * 
	 * @param {Object} event
	 * 		The layout event object
	 */
	handleLayoutContainerMinBounds: function(event) {
		var shape = event.shape;
		var topOffset = event.topOffset;
		var oldBounds = shape._oldBounds;
		var options = event.options;
		var ignoreList = (options.ignoreChildsWithId ? options.ignoreChildsWithId : new Array());
		
		var childsBounds = this.retrieveChildsIncludingBounds(shape, ignoreList);
		if(!childsBounds) {return;}
		
		/* Get the upper left child shape */
		var ulShape = this.getChildShapesWithout(shape, ignoreList).find(function(node) {
			return childsBounds.upperLeft().y == node.bounds.upperLeft().y;
		});
		
		/* Ensure minimum size of the container */
		if(this.ensureContainersMinimumSize(shape, childsBounds, ulShape.absoluteBounds(), ignoreList, options)) {
			return;
		};
		
		
		var childsUl = childsBounds.upperLeft();
		var childsLr = childsBounds.lowerRight();
		var bottomTopSpaceRatio = (childsUl.y ? childsUl.y : 1) / 
				((oldBounds.height() - childsLr.y) ? (oldBounds.height() - childsLr.y) : 1);
		
		var newYValue = bottomTopSpaceRatio * (shape.bounds.height() - childsBounds.height())
						/ (1 + bottomTopSpaceRatio );
		
		this.getChildShapesWithout(shape, ignoreList).each(function(childShape){
			var innerOffset = childShape.bounds.upperLeft().y - childsUl.y;
			childShape.bounds.moveTo({	x: childShape.bounds.upperLeft().x,	
										y: newYValue + innerOffset});
		});
		
		/* Calculate adjustment for dockers */
		var yAdjustment = ulShape.bounds.upperLeft().y - ulShape._oldBounds.upperLeft().y;
		
		/* Move docker by adjustment */
		this.moveChildDockers(shape, {x: 0, y: yAdjustment});
	},
	
	/**
	 * Ensures that the container has a minimum height and width to place all
	 * child elements inside.
	 * 
	 * @param {Object} shape
	 * 		The container.
	 * @param {Object} childsBounds
	 * 		The bounds including all children
	 * @param {Object} ulChildAbsBounds
	 * 		The absolute bounds including all children
	 */
	ensureContainersMinimumSize: function(shape, childsBounds, ulChildAbsBounds, ignoreList, options) {
		var bounds = shape.bounds;
		var ulShape = bounds.upperLeft();
		var lrShape = bounds.lowerRight();
		var ulChilds = childsBounds.upperLeft();
		var lrChilds = childsBounds.lowerRight();
		var absBounds = shape.absoluteBounds();
		if(!options) {
			options = new Object();
		}
		
		if(!shape.isResized) {
			/* Childs movement after widening the conatiner */
			var yMovement = 0;
			var xMovement = 0;
			var changeBounds = false;
			
			/* Widen the shape by the child bounds */
			var ulx = ulShape.x;
			var uly = ulShape.y;
			var lrx = lrShape.x;
			var lry = lrShape.y;
			
			if(ulChilds.x < 0) {
				ulx += ulChilds.x;
				xMovement -= ulChilds.x;
				changeBounds = true;
			}
			
			if(ulChilds.y < 0) {
				uly += ulChilds.y;
				yMovement -= ulChilds.y;
				changeBounds = true;
			}
			
			var xProtrusion = xMovement + ulChilds.x + childsBounds.width()
								- bounds.width();
			if(xProtrusion > 0) {
				lrx += xProtrusion;
				changeBounds = true;
			}
			
			var yProtrusion = yMovement + ulChilds.y + childsBounds.height()
								- bounds.height();
			if(yProtrusion > 0) {
				lry += yProtrusion;
				changeBounds = true;
			}
			
			bounds.set(ulx, uly, lrx, lry);
			
			/* Update hashed bounds for docker positioning */
			if(changeBounds) {
				this.hashedContainers[shape.resourceId] = bounds.clone();
			}
			
			this.moveChildsBy(shape, {x: xMovement, y: yMovement}, ignoreList);
			
			/* Signals that children are already move to correct position */
			return true;
		}
		
		/* Resize container to minimum size */
		
		var ulx = ulShape.x;
		var uly = ulShape.y;
		var lrx = lrShape.x;
		var lry = lrShape.y;
		changeBounds = false;
			
		/* Ensure height */
		if(bounds.height() < childsBounds.height()) {
			/* Shape was resized on upper left in height */
			if(ulShape.y != shape._oldBounds.upperLeft().y &&
				lrShape.y == shape._oldBounds.lowerRight().y) {
				uly = lry - childsBounds.height() - 1;	
				if(options.fixedY) {
					uly -= childsBounds.upperLeft().y;
				}
				changeBounds = true;
			} 
			/* Shape was resized on lower right in height */
			else if(ulShape.y == shape._oldBounds.upperLeft().y &&
				lrShape.y != shape._oldBounds.lowerRight().y) {
				lry = uly + childsBounds.height() + 1;	
				if(options.fixedY) {
					lry += childsBounds.upperLeft().y;
				}
				changeBounds = true;
			} 
			/* Both upper left and lower right changed */
			else if(ulChildAbsBounds) {
				var ulyDiff = absBounds.upperLeft().y - ulChildAbsBounds.upperLeft().y;
				var lryDiff = absBounds.lowerRight().y - ulChildAbsBounds.lowerRight().y;
				uly -= ulyDiff;
				lry -= lryDiff;
				uly--;
				lry++;
				changeBounds = true;
			}
		}
		
		/* Ensure width */
		if(bounds.width() < childsBounds.width()) {
			/* Shape was resized on upper left in height */
			if(ulShape.x != shape._oldBounds.upperLeft().x &&
				lrShape.x == shape._oldBounds.lowerRight().x) {
				ulx = lrx - childsBounds.width() - 1;
				if(options.fixedX) {
					ulx -= childsBounds.upperLeft().x;
				}	
				changeBounds = true;
			} 
			/* Shape was resized on lower right in height */
			else if(ulShape.x == shape._oldBounds.upperLeft().x &&
				lrShape.x != shape._oldBounds.lowerRight().x) {
				lrx = ulx + childsBounds.width() + 1;
				if(options.fixedX) {
					lrx += childsBounds.upperLeft().x;
				}	
				changeBounds = true;
			} 
			/* Both upper left and lower right changed */
			else if(ulChildAbsBounds) {
				var ulxDiff = absBounds.upperLeft().x - ulChildAbsBounds.upperLeft().x;
				var lrxDiff = absBounds.lowerRight().x - ulChildAbsBounds.lowerRight().x;
				ulx -= ulxDiff;
				lrx -= lrxDiff;
				ulx--;
				lrx++;
				changeBounds = true;
			}
		}
		
		/* Set minimum bounds */
		bounds.set(ulx, uly, lrx, lry);
		if(changeBounds) {
			//this.hashedContainers[shape.resourceId] = bounds.clone();
			this.handleLayoutContainerDockers({shape:shape});
		}
	},
	
	/**
	 * Moves all child shapes and related dockers of the container shape by the 
	 * relative move point.
	 * 
	 * @param {Object} shape
	 * 		The container shape
	 * @param {Object} relativeMovePoint
	 * 		The point that defines the movement
	 */
	moveChildsBy: function(shape, relativeMovePoint, ignoreList) {
		if(!shape || !relativeMovePoint) {
			return;
		}
		
		/* Move child shapes */
		this.getChildShapesWithout(shape, ignoreList).each(function(child) {
			child.bounds.moveBy(relativeMovePoint);
		});
		
		/* Move related dockers */
		//this.moveChildDockers(shape, relativeMovePoint);
	},
	
	/**
	 * Retrieves the absolute bounds that include all child shapes.
	 * 
	 * @param {Object} shape
	 */
	getAbsoluteBoundsForChildShapes: function(shape) {
//		var childsBounds = this.retrieveChildsIncludingBounds(shape);
//		if(!childsBounds) {return undefined}
//		
//		var ulShape = shape.getChildShapes(false).find(function(node) {
//			return childsBounds.upperLeft().y == node.bounds.upperLeft().y;
//		});
//		
////		var lrShape = shape.getChildShapes(false).find(function(node) {
////			return childsBounds.lowerRight().y == node.bounds.lowerRight().y;
////		});
//		
//		var absUl = ulShape.absoluteBounds().upperLeft();
//		
//		this.hashedContainers[shape.getId()].childsBounds = 
//						new ORYX.Core.Bounds(absUl.x, 
//											absUl.y,
//											absUl.x + childsBounds.width(),
//											absUl.y + childsBounds.height());
//		
//		return this.hashedContainers[shape.getId()];
	},
	
	/**
	 * Moves the docker when moving shapes.
	 * 
	 * @param {Object} shape
	 * @param {Object} offset
	 */
	moveChildDockers: function(shape, offset){
		
		if (!offset.x && !offset.y) {
			return;
		} 
		
		// Get all nodes
		shape.getChildNodes(true)
			// Get all incoming and outgoing edges
			.map(function(node){
				return [].concat(node.getIncomingShapes())
						.concat(node.getOutgoingShapes())
			})
			// Flatten all including arrays into one
			.flatten()
			// Get every edge only once
			.uniq()
			// Get all dockers
			.map(function(edge){
				return edge.dockers.length > 2 ? 
						edge.dockers.slice(1, edge.dockers.length-1) : 
						[];
			})
			// Flatten the dockers lists
			.flatten()
			.each(function(docker){
				docker.bounds.moveBy(offset);
			})
	},
	
	/**
	 * Calculates the bounds that include all child shapes of the given shape.
	 * 
	 * @param {Object} shape
	 * 		The parent shape.
	 */
	retrieveChildsIncludingBounds: function(shape, ignoreList) {
		var childsBounds = undefined;
		this.getChildShapesWithout(shape, ignoreList).each(function(childShape, i) {
			if(i == 0) {
				/* Initialize bounds that include all direct child shapes of the shape */
				childsBounds = childShape.bounds.clone();
				return;
			}
			
			/* Include other child elements */
			childsBounds.include(childShape.bounds);			
		});
		
		return childsBounds;
	},
	
	/**
	 * Returns the direct child shapes that are not on the ignore list.
	 */
	getChildShapesWithout: function(shape, ignoreList) {
		var childs = shape.getChildShapes(false);
		return childs.findAll(function(child) {
					return !ignoreList.member(child.getStencil().id());				
				});
	}
}

ORYX.Plugins.ContainerLayouter = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.ContainerLayouter);

/**
 * Copyright (c) 2008
 * Lutz Gericke
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

function gup(name){
    name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
    var regexS = "[\\?&]" + name + "=([^&#]*)";
    var regex = new RegExp(regexS);
    var results = regex.exec(window.location.href);
    if (results == null) 
        return "";
    else 
        return results[1];
}

ORYX.Plugins.Pnmlexport = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
        this.facade = facade;
        
        this.facade.offer({
            'name': ORYX.I18N.Pnmlexport.name,
            'functionality': this.exportIt.bind(this),
            'group': ORYX.I18N.Pnmlexport.group,
            'icon': ORYX.PATH + "images/bpmn2pn_deploy.png",
            'description': ORYX.I18N.Pnmlexport.desc,
            'index': 2,
            'minShape': 0,
            'maxShape': 0
        });
        
    },
    
    exportIt: function(){
    
        // raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
        
        // asynchronously ...
        window.setTimeout((function(){
        
            // ... save synchronously
            this.exportSynchronously();
            
            // raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
            
        }).bind(this), 10);
        
        return true;
    },
    
    exportSynchronously: function(){
    
        var resource = location.href;
        
        
        try {
            var serialized_rdf =this.getRDFFromDOM();
            //serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
            
            var diagramTitle = gup('resource');
            
            // Send the request to the server.
            new Ajax.Request(ORYX.CONFIG.PNML_EXPORT_URL, {
                method: 'POST',
                asynchronous: false,
                parameters: {
                    resource: resource,
                    data: serialized_rdf,
                    title: diagramTitle
                },
                onSuccess: function(request){
                    var pnmlfile = request.responseText;
                    if (pnmlfile.indexOf("RDF to BPMN failed with Exception:") == 0) {
                        //open error window
                        alert(pnmlfile); //errormessage
                    }
                    else {
                        var absolutepath = "http://" + location.host + ORYX.CONFIG.ROOT_PATH + pnmlfile;
                        var output = "<h2>Process: " +
                        self.document.title +
                        "</h2><a target=\"_blank\" href=\"" +
                        absolutepath;

                        var win = new Ext.Window({
                            width: 320,
                            height: 240,
                            resizable: false,
                            minimizable: false,
                            modal: true,
                            autoScroll: true,
                            title: 'Deployment successful',
                            html: output,
                            buttons: [{
                                text: 'OK',
                                handler: function(){
                                    win.hide();
                                }
                            }]
                        });
                        win.show();

                    }
                }
            });
            
        } 
        catch (error) {
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
            alert(error);
        }
    }
});

/**
 * Copyright (c) 2006
 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner, Gero Decker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.SimplePnmlexport = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
        this.facade = facade;
        
        this.facade.offer({
            'name': ORYX.I18N.SimplePnmlexport.name,
            'functionality': this.exportIt.bind(this),
            'group': ORYX.I18N.SimplePnmlexport.group,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': ORYX.PATH + "images/page_white_gear.png",
            'description': ORYX.I18N.SimplePnmlexport.desc,
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
        this.facade.offer({
            'name': "PNML For LOLA",
            'functionality': this.exportIt.bind(this,true),
            'group': ORYX.I18N.SimplePnmlexport.group,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': ORYX.PATH + "images/page_white_gear.png",
            'description': ORYX.I18N.SimplePnmlexport.desc,
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
        
    },

    exportIt: function(lola){

		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously(lola);
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },

    exportSynchronously: function(lola) {

        var resource = location.href;
		var tool = "none";
		if(lola){
			tool = "lola";
		}
		
		try {
			var serialized_rdf = this.getRDFFromDOM();
			if (!serialized_rdf.startsWith("<?xml")) {
				serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
			}
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.SIMPLE_PNML_EXPORT_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf,
					tool: tool
				},
				onSuccess: function(request){
					this.openDownloadWindow(window.document.title+".xml",request.responseText);
					/* 
					 * Data URIs do not work properly in chrome
					 * this.openXMLWindow(request.responseText);
					 * TODO Check for an better solution for download windows, without remaining open window
					 * @author Philipp Berger
					 */
				}.bind(this)
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
	}
});
/**
 * Copyright (c) 2008, Gero Decker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.DesynchronizabilityOverlay = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active = false;
		this.el 	= undefined;
		this.callback = undefined;
		
        this.facade.offer({
            'name': ORYX.I18N.DesynchronizabilityOverlay.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.DesynchronizabilityOverlay.group,
            'icon': ORYX.PATH + "images/bpmn2pn.png",
            'description': ORYX.I18N.DesynchronizabilityOverlay.desc,
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
		
    },
    
	showOverlay: function(){

		if (this.active) {
			
			this.facade.raiseEvent({
				type: 	ORYX.CONFIG.EVENT_OVERLAY_HIDE,
				id: 	"desynchronizability"
			});
			this.active = !this.active;				

		} else {
			

		try {
			var serialized_rdf =this.getRDFFromDOM();
//			serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
			
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.DESYNCHRONIZABILITY_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: location.href,
					data: serialized_rdf
				},
				onSuccess: function(request){
					var resp = request.responseText.evalJSON();
	
					if (resp.conflicttransitions) {
					if (resp.conflicttransitions.length > 0) {
					
						// Get all Valid ResourceIDs and collect all shapes
						var transitionshapes = resp.conflicttransitions.collect(function(res){ 
							return this.facade.getCanvas()
								.getChildShapeByResourceId( res ) 
						}.bind(this)).compact();
	
						this.facade.raiseEvent({
							type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
							id: 			"desynchronizability",
							shapes: 		transitionshapes,
							attributes: 	{fill: "red", stroke: "black"}
						});
	
						this.active = !this.active;				
	
					} else {
	
						Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.DesynchronizabilityOverlay.sync);
						// var win = window.open('data:text/plain,' +request.responseText, '_blank', "resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");
					}
					} else if (resp.syntaxerrors) {
	
						// Get all Valid ResourceIDs and collect all shapes
	//							var shapes = transitions.collect(function(res){ return this.facade.getCanvas().getChildShapeByResourceId( res ) }.bind(this)).compact();
	
						Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.DesynchronizabilityOverlay.error.replace(/1/, resp.syntaxerrors.length));
	
	//							this.active = !this.active;				
	
					} else {
						Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.DesynchronizabilityOverlay.invalid);
					}
				}.bind(this)
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}

		}
		
	}	
    
});

/**
 * Copyright (c) 2008, Gero Decker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.EnforceabilityOverlay = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active = false;
		this.el 	= undefined;
		this.callback = undefined;
		
        this.facade.offer({
            'name': "Enforceability",
            'functionality': this.showOverlay.bind(this),
            'group': "Enforceability",
            'icon': ORYX.PATH + "images/checker_validation.png",
            'description': "enforce?",
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
		
    },
    
	showOverlay: function(){

		if (this.active) {
			
			this.facade.raiseEvent({
				type: 	ORYX.CONFIG.EVENT_OVERLAY_HIDE,
				id: 	"enforceability"
			});
			this.active = !this.active;				

		} else {
			

		try {
			var serialized_rdf =this.getRDFFromDOM();
//			serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
			
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.ENFORCEABILITY_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: location.href,
					data: serialized_rdf
				},
				onSuccess: function(request){
					var resp = request.responseText.evalJSON();
	
					if (resp.conflicttransitions) {
					if (resp.conflicttransitions.length > 0) {
					
						// Get all Valid ResourceIDs and collect all shapes
						var transitionshapes = resp.conflicttransitions.collect(function(res){ 
							return this.facade.getCanvas()
								.getChildShapeByResourceId( res ) 
						}.bind(this)).compact();
	
						this.facade.raiseEvent({
							type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
							id: 			"enforceability",
							shapes: 		transitionshapes,
							attributes: 	{fill: "red", stroke: "black"}
						});
	
						this.active = !this.active;				
	
					} else {
	
						Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.DesynchronizabilityOverlay.sync);
						// var win = window.open('data:text/plain,' +request.responseText, '_blank', "resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");
					}
					} else if (resp.syntaxerrors) {
	
						// Get all Valid ResourceIDs and collect all shapes
	//							var shapes = transitions.collect(function(res){ return this.facade.getCanvas().getChildShapeByResourceId( res ) }.bind(this)).compact();
	
						Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.DesynchronizabilityOverlay.error.replace(/1/, resp.syntaxerrors.length));
	
	//							this.active = !this.active;				
	
					} else {
						Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.DesynchronizabilityOverlay.invalid);
					}
				}.bind(this)
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}

		}
		
	}	
    
});
/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Supports EPCs by offering a syntax check and export and import ability..
 * 
 * 
 */
ORYX.Plugins.IBPMN2BPMN = Clazz.extend({

	facade: undefined,
	
	TransformServletURL: './ibpmn2bpmn',

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {
		
		this.facade = facade;
			
			
		this.facade.offer({
			'name':				"Transform from iBPMN to BPMN",
			'functionality': 	this.transform.bind(this),
			'icon': 			ORYX.PATH + "images/erdf_import_icon.png",
			'description': 		"Transformation from iBPMN to BPMN",
            'index': 1,
			'minShape': 		0,
			'maxShape': 		0,
			'group': ORYX.I18N.JSONSupport.imp.group,
            dropDownGroupIcon: ORYX.PATH + "images/import.png"

		});


	},

	
	/**
	 * Imports an AML description
	 * 
	 */
	transform: function(){
		this._showImportDialog();
	},		

	
	
	/**
	 * 
	 * 
	 * @param {Object} url
	 * @param {Object} params
	 * @param {Object} successcallback
	 */
	sendRequest: function( url, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
            method			: 'POST',
            asynchronous	: false,
            parameters		: params,
			onSuccess		: function(transport) {
				
				suc = true;
				
				if(successcallback){
					successcallback( transport.responseText )	
				}
				
			}.bind(this),
			
			onFailure		: function(transport) {

				if(failedcallback){
					
					failedcallback( );
					
				} else {
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.ERDFSupport.impFailed);
					ORYX.log.warn("Transform failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		
		return suc;
							
	},


	transformToBPMN: function( rdfString, success, failed ){
		
		var s 	= rdfString;
		s 		= s.startsWith('<?xml') ? s : '<?xml version="1.0" encoding="utf-8"?>'+s+'';	
						
		var parser	= new DOMParser();			
		var doc 	=  parser.parseFromString( s ,"text/xml");
							
		if( doc.firstChild.tagName == "parsererror" ){

			Ext.MessageBox.show({
					title: 		"Parse Error",
 					msg: 		"The given RDF is not xml valid.",
					buttons: 	Ext.MessageBox.OK,
					icon: 		Ext.MessageBox.ERROR
				});
																
			if(failed)
				failed();
				
		} else {
			
			/**
			 * SUCCESSCALLBACK for positive return while transformation
			 * 
			 */
			var transformSuccessCallback = function( e ){
				
				e = '<?xml version="1.0" encoding="utf-8"?><div>'+e+'</div>';

				var parser	= new DOMParser();			
				var doc 	=  parser.parseFromString( e ,"text/xml");
				
				this.facade.importERDF( doc );
				
			}.bind(this);
			
			var xsl = "";
			source=ORYX.PATH + "lib/extract-rdf.xsl";
			new Ajax.Request(source, {
				asynchronous: false,
				method: 'get',
				onSuccess: function(transport){
					xsl = transport.responseText
				}.bind(this),
				onFailure: (function(transport){
					ORYX.Log.error("XSL load failed" + transport);
				}).bind(this)
			});
			
			var parser = new DOMParser();
			var parsedDOM = parser.parseFromString(s, "text/xml");
			var xslObject = domParser.parseFromString(xsl, "text/xml");
			var xsltProcessor = new XSLTProcessor();
			xsltProcessor.importStylesheet(xslObject);
			try {
				var rdf = xsltProcessor.transformToFragment(parsedDOM, document);
				var serialized_rdf = (new XMLSerializer()).serializeToString(rdf);
				if (!serialized_rdf.startsWith("<?xml")) {
					serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
				}
						
				// Send request
				this.sendRequest( this.TransformServletURL, {data:serialized_rdf}, transformSuccessCallback)
			
			}catch(e){}
		
			if(success)
				success();
		
		}
	},

	

	/**
	 * Opens a upload dialog.
	 * 
	 */
	_showImportDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.ERDFSupport.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            fieldLabel: ORYX.I18N.ERDFSupport.file,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	        }, {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	        }]
	    });



		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.ERDFSupport.impERDF, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.ERDFSupport.impBtn,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.ERDFSupport.impProgress});
						loadMask.show();
						
						window.setTimeout(function(){
					
							
							var rdfString =  form.items.items[2].getValue();
							this.transformToBPMN(rdfString, function(){loadMask.hide();dialog.hide()}.bind(this), function(){loadMask.hide();}.bind(this))
														
														
							
						}.bind(this), 100);
			
					}.bind(this)
				},{
					text:ORYX.I18N.ERDFSupport.close,
					handler:function(){
						
						dialog.hide();
					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt){
				var text = evt.target.files[0].getAsBinary();
				form.items.items[2].setValue( text );
			}, true)

	}
	
});/**
 * Copyright (c) 2008, Gero Decker, refactored by Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
   This plugin is a generic syntax checker for different diagram types.
   Needs server communication.
   @class ORYX.Plugins.SyntaxChecker
   @constructor Creates a new instance
   @extends ORYX.Plugins.AbstractPlugin
*/
ORYX.Plugins.SyntaxChecker = ORYX.Plugins.AbstractPlugin.extend({
    /**@private*/
    construct: function(){
        arguments.callee.$.construct.apply(this, arguments);
                
        this.active = false;
        this.raisedEventIds = [];
        
        this.facade.offer({
            'name': ORYX.I18N.SyntaxChecker.name,
            'functionality': this.perform.bind(this),
            'group': ORYX.I18N.SyntaxChecker.group,
            'icon': ORYX.PATH + "images/checker_syntax.png",
            'description': ORYX.I18N.SyntaxChecker.desc,
            'index': 0,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT, this.checkForErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT, this.resetErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT, this.doShowErrors.bind(this));
    },
    
    perform: function(button, pressed){
        if (!pressed) {
            this.resetErrors();
        } else {
            this.checkForErrors({
                onNoErrors: function(){
                    this.setActivated(button, false);
                    this.facade.raiseEvent({
            			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
            			text:ORYX.I18N.SyntaxChecker.noErrors,
            			timeout:10000
            		});
                    //Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.noErrors);
                }.bind(this),
                onErrors: function(){
                    this.enableDeactivationHandler(button);
                }.bind(this),
                onFailure: function(){
                    this.setActivated(button, false);
                    Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.invalid);
                }.bind(this)
            });      
        }
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActivated(button, false);
            this.resetErrors();
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    },
    
    /**
     * Sets the activated state of the plugin
     * @param {Ext.Button} Toolbar button
     * @param {Object} activated
     */
    setActivated: function(button, activated){
        button.toggle(activated);
        if(activated === undefined){
            this.active = !this.active;
        } else {
            this.active = activated;
        }
    },
    
    /**
     * Performs request to server to check for errors on current model.
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Object} options Configuration hash
     * @param {String} context A context send to the syntax checker servlet
     * @param {Function} [options.onNoErrors] Raised when model has no errors.
     * @param {Function} [options.onErrors] Raised when model has errors.
     * @param {Function} [options.onFailure] Raised when server communcation failed.
     * @param {boolean} [options.showErrors=true] Display errors on nodes on canvas (by calling ORYX.Plugins.SyntaxChecker.prototype.showErrors)
     */
    checkForErrors: function(options){
        Ext.applyIf(options || {}, {
          showErrors: true,
          onErrors: Ext.emptyFn,
          onNoErrors: Ext.emptyFn,
          onFailure: Ext.emptyFn
        });
            
        Ext.Msg.wait(ORYX.I18N.SyntaxChecker.checkingMessage);

		var ss = this.facade.getStencilSets();
		var data = null;
		var includesJson = false;
		
		if(ss.keys().include("http://b3mn.org/stencilset/bpmn2.0#") ||
				ss.keys().include("http://b3mn.org/stencilset/bpmn2.0conversation#")) {
			data = this.facade.getSerializedJSON();
			includesJson = true;
		} else {
			data = this.getRDFFromDOM();
		}
        
        // Send the request to the server.
        new Ajax.Request(ORYX.CONFIG.SYNTAXCHECKER_URL, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                resource: location.href,
                data: data,
                context: options.context,
				isJson: includesJson
            },
            onSuccess: function(request){
                var resp = (request&&request.responseText?request.responseText:"{}").evalJSON();
                
                Ext.Msg.hide();
                
                if (resp instanceof Object) {
                    resp = $H(resp)
                    if (resp.size() > 0) {
                        if(options.showErrors) this.showErrors(resp);
                 
                        options.onErrors();
                    }
                    else {
                        options.onNoErrors();
                    }
                }
                else {
                    options.onFailure();
                }
            }.bind(this),
            onFailure: function(){
                Ext.Msg.hide();
                options.onFailure();
            }
        });
    },
    
    /** Called on SHOW_ERRORS_EVENT.
     * 
     * @param {Object} event
     * @param {Object} args
     */
    doShowErrors: function(event, args){
        this.showErrors(event.errors);
    },
    
    /**
     * Shows overlays for each given error
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Hash|Object} errors
     * @example
     * showErrors({
     *     myShape1: "This has an error!",
     *     myShape2: "Another error!"
     * })
     */
    showErrors: function(errors){
        // If normal object is given, convert to hash
        if(!(errors instanceof Hash)){
            errors = new Hash(errors);
        }
        
        // Get all Valid ResourceIDs and collect all shapes
        errors.keys().each(function(value){
            var sh = this.facade.getCanvas().getChildShapeByResourceId(value);
            if (sh) {
                this.raiseOverlay(sh, this.parseCodeToMsg(errors[value]));
            }
        }.bind(this));
        this.active = !this.active;
        
        //show a status message with a hint to the error messages in the tooltip
        this.facade.raiseEvent({
			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
			text:ORYX.I18N.SyntaxChecker.notice,
			timeout:10000
		});
    },
    parseCodeToMsg: function(code){
    	var msg = code.replace(/: /g, "<br />").replace(/, /g, "<br />");
    	var codes = msg.split("<br />");
    	for (var i=0; i < codes.length; i++) {
    		var singleCode = codes[i];
    		var replacement = this.parseSingleCodeToMsg(singleCode);
    		if (singleCode != replacement) {
    			msg = msg.replace(singleCode, replacement);
    		}
    	}
		
		return msg;
	},
	
	parseSingleCodeToMsg: function(code){
		return ORYX.I18N.SyntaxChecker[code]||code;
	},
    /**
     * Resets all (displayed) errors
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     */
    resetErrors: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this))
        
        this.raisedEventIds = [];
        this.active = false;
    },
    
    raiseOverlay: function(shape, errorMsg){
        var id = "syntaxchecker." + this.raisedEventIds.length;
        var crossId = ORYX.Editor.provideId();
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "id":crossId,
            "title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	html:errorMsg,
        	target:crossId
        });
        
        this.raisedEventIds.push(id);
        
        return cross;
    }
});

ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT = "checkForErrors";
ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT = "resetErrors";
ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT = "showErrors";

ORYX.Plugins.PetrinetSyntaxChecker = ORYX.Plugins.SyntaxChecker.extend({
    /*FIXME:: BPMN + EPC syntax checker needs rdf, but petri nets needs erdf.
     * So we override getRDFFromDOM from AbstractPlugin to return erdf.
     */
    getRDFFromDOM: function(){
        return this.facade.getERDF();
    }
});/**
 * Copyright (c) 2008, Gero Decker, refactored by Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
   This plugin is a generic syntax checker for different diagram types.
   Needs server communication.
   @class ORYX.Plugins.SyntaxChecker
   @constructor Creates a new instance
   @extends ORYX.Plugins.AbstractPlugin
*/
ORYX.Plugins.SyntaxChecker = ORYX.Plugins.AbstractPlugin.extend({
    /**@private*/
    construct: function(){
        arguments.callee.$.construct.apply(this, arguments);
                
        this.active = false;
        this.raisedEventIds = [];
        
        this.facade.offer({
            'name': ORYX.I18N.SyntaxChecker.name,
            'functionality': this.perform.bind(this),
            'group': ORYX.I18N.SyntaxChecker.group,
            'icon': ORYX.PATH + "images/checker_syntax.png",
            'description': ORYX.I18N.SyntaxChecker.desc,
            'index': 0,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
        
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT, this.checkForErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT, this.resetErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT, this.doShowErrors.bind(this));
    },
    
    perform: function(button, pressed){
        if (!pressed) {
            this.resetErrors();
        } else {
            this.checkForErrors({
                onNoErrors: function(){
                    this.setActivated(button, false);
                    this.facade.raiseEvent({
            			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
            			text:ORYX.I18N.SyntaxChecker.noErrors,
            			timeout:10000
            		});
                    //Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.noErrors);
                }.bind(this),
                onErrors: function(){
                    this.enableDeactivationHandler(button);
                }.bind(this),
                onFailure: function(){
                    this.setActivated(button, false);
                    Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.SyntaxChecker.invalid);
                }.bind(this)
            });      
        }
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActivated(button, false);
            this.resetErrors();
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    },
    
    /**
     * Sets the activated state of the plugin
     * @param {Ext.Button} Toolbar button
     * @param {Object} activated
     */
    setActivated: function(button, activated){
        button.toggle(activated);
        if(activated === undefined){
            this.active = !this.active;
        } else {
            this.active = activated;
        }
    },
    
    /**
     * Performs request to server to check for errors on current model.
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Object} options Configuration hash
     * @param {String} context A context send to the syntax checker servlet
     * @param {Function} [options.onNoErrors] Raised when model has no errors.
     * @param {Function} [options.onErrors] Raised when model has errors.
     * @param {Function} [options.onFailure] Raised when server communcation failed.
     * @param {boolean} [options.showErrors=true] Display errors on nodes on canvas (by calling ORYX.Plugins.SyntaxChecker.prototype.showErrors)
     */
    checkForErrors: function(options){
        Ext.applyIf(options || {}, {
          showErrors: true,
          onErrors: Ext.emptyFn,
          onNoErrors: Ext.emptyFn,
          onFailure: Ext.emptyFn
        });
            
        Ext.Msg.wait(ORYX.I18N.SyntaxChecker.checkingMessage);

		var ss = this.facade.getStencilSets();
		var data = null;
		var includesJson = false;
		
		if(ss.keys().include("http://b3mn.org/stencilset/bpmn2.0#") ||
				ss.keys().include("http://b3mn.org/stencilset/bpmn2.0conversation#")) {
			data = this.facade.getSerializedJSON();
			includesJson = true;
		} else {
			data = this.getRDFFromDOM();
		}
        
        // Send the request to the server.
        new Ajax.Request(ORYX.CONFIG.SYNTAXCHECKER_URL, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                resource: location.href,
                data: data,
                context: options.context,
				isJson: includesJson
            },
            onSuccess: function(request){
                var resp = (request&&request.responseText?request.responseText:"{}").evalJSON();
                
                Ext.Msg.hide();
                
                if (resp instanceof Object) {
                    resp = $H(resp)
                    if (resp.size() > 0) {
                        if(options.showErrors) this.showErrors(resp);
                 
                        options.onErrors();
                    }
                    else {
                        options.onNoErrors();
                    }
                }
                else {
                    options.onFailure();
                }
            }.bind(this),
            onFailure: function(){
                Ext.Msg.hide();
                options.onFailure();
            }
        });
    },
    
    /** Called on SHOW_ERRORS_EVENT.
     * 
     * @param {Object} event
     * @param {Object} args
     */
    doShowErrors: function(event, args){
        this.showErrors(event.errors);
    },
    
    /**
     * Shows overlays for each given error
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     * @param {Hash|Object} errors
     * @example
     * showErrors({
     *     myShape1: "This has an error!",
     *     myShape2: "Another error!"
     * })
     */
    showErrors: function(errors){
        // If normal object is given, convert to hash
        if(!(errors instanceof Hash)){
            errors = new Hash(errors);
        }
        
        // Get all Valid ResourceIDs and collect all shapes
        errors.keys().each(function(value){
            var sh = this.facade.getCanvas().getChildShapeByResourceId(value);
            if (sh) {
                this.raiseOverlay(sh, this.parseCodeToMsg(errors[value]));
            }
        }.bind(this));
        this.active = !this.active;
        
        //show a status message with a hint to the error messages in the tooltip
        this.facade.raiseEvent({
			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
			text:ORYX.I18N.SyntaxChecker.notice,
			timeout:10000
		});
    },
    parseCodeToMsg: function(code){
    	var msg = code.replace(/: /g, "<br />").replace(/, /g, "<br />");
    	var codes = msg.split("<br />");
    	for (var i=0; i < codes.length; i++) {
    		var singleCode = codes[i];
    		var replacement = this.parseSingleCodeToMsg(singleCode);
    		if (singleCode != replacement) {
    			msg = msg.replace(singleCode, replacement);
    		}
    	}
		
		return msg;
	},
	
	parseSingleCodeToMsg: function(code){
		return ORYX.I18N.SyntaxChecker[code]||code;
	},
    /**
     * Resets all (displayed) errors
     * @methodOf ORYX.Plugins.SyntaxChecker.prototype
     */
    resetErrors: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this))
        
        this.raisedEventIds = [];
        this.active = false;
    },
    
    raiseOverlay: function(shape, errorMsg){
        var id = "syntaxchecker." + this.raisedEventIds.length;
        var crossId = ORYX.Editor.provideId();
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            "id":crossId,
            "title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	html:errorMsg,
        	target:crossId
        });
        
        this.raisedEventIds.push(id);
        
        return cross;
    }
});

ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT = "checkForErrors";
ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT = "resetErrors";
ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT = "showErrors";

ORYX.Plugins.PetrinetSyntaxChecker = ORYX.Plugins.SyntaxChecker.extend({
    /*FIXME:: BPMN + EPC syntax checker needs rdf, but petri nets needs erdf.
     * So we override getRDFFromDOM from AbstractPlugin to return erdf.
     */
    getRDFFromDOM: function(){
        return this.facade.getERDF();
    }
});
/**
 * Copyright (c) 2008, Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Validator = ORYX.Plugins.AbstractPlugin.extend({
    construct: function(facade){
        this.facade = facade;
        
        this.active = false;
        this.raisedEventIds = [];
        
        this.buttonId = ORYX.Editor.provideId();
        
        this.facade.offer({
            'name': ORYX.I18N.Validator.name,
            'id': this.buttonId,
            'functionality': this.load.bind(this),
            'group': "Verification",
            'icon': ORYX.PATH + "images/checker_validation.png",
            'description': ORYX.I18N.Validator.description,
            'index': 1,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    load: function(button, pressed){
        if (!pressed) {
            this.hideOverlays();
            this.active = !this.active;
        }
        else {
            this.validate(button);
        }
    },
    
    setActive: function(active){
        this.active = active;
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_BUTTON_UPDATE,
            id: this.buttonId,
            pressed: active
        });
    },
    
    hideOverlays: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }
.bind(this));
        
        this.raisedEventIds = [];
    },
    validate: function(button){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.Validator.checking
        });
      
        // Send the request to the server.
        new Ajax.Request(ORYX.CONFIG.VALIDATOR_URL, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                resource: location.href,
                data: this.getRDFFromDOM()
            },
            onSuccess: function(request){
                var result = Ext.decode(request.responseText);
                
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                
                // This should be implemented by child instances of validator 
                this.handleValidationResponse(result, button);
            }
.bind(this),
            onFailure: function(){
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                Ext.Msg.alert(ORYX.I18N.Validator.error, ORYX.I18N.Validator.errorDesc);
            }.bind(this)
        });
    },
    
    showOverlay: function(shape, errorMsg, errorTitle){
    
        var id = "syntaxchecker." + this.raisedEventIds.length;
        
        var crossId = ORYX.Editor.provideId();
        
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
        	"id":crossId,
        	"title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        this.raisedEventIds.push(id);
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	title:errorTitle,
        	html:errorMsg,
        	target:crossId
        });   
        
        return cross;
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActive(false);
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    }
});

ORYX.Plugins.BPMNValidator = Ext.extend(ORYX.Plugins.Validator, {
    handleValidationResponse: function(result, button){
        var conflictingNodes = result.conflictingNodes;
        var leadsToEnd = result.leadsToEnd;
        var unsafeNode = result.unsafeNode;
        // Only stay active if there is anything to visualize
        this.setActive(conflictingNodes.size() > 0);
        
//        if (!leadsToEnd) {
//            Ext.Msg.alert("Validation Result", "The process will never reach a final state!");
//        }
        if (conflictingNodes.size() > 0) {
            conflictingNodes.each(function(node){
                sh = this.facade.getCanvas().getChildShapeByResourceId(node.id);
                if (sh) {
                    this.showOverlay(sh, ORYX.I18N.Validator.bpmnDeadlock,  ORYX.I18N.Validator.bpmnDeadlockTitle);
                }
            }.bind(this));
        }
        if(unsafeNode) {
        	var shape = this.facade.getCanvas().getChildShapeByResourceId(unsafeNode);
        	if (shape) {
                this.showOverlay(shape, ORYX.I18N.Validator.bpmnUnsafe, ORYX.I18N.Validator.bpmnUnsafeTitle);
            }
        }
        if(leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode) {
        	this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.Validator.noErrors,
    			timeout:10000
    		});
        	//Ext.Msg.alert(ORYX.I18N.Validator.result, ORYX.I18N.Validator.noErrors);
        } else if(!leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode){
        	Ext.Msg.alert(ORYX.I18N.Validator.bpmnLeadsToNoEndTitle, ORYX.I18N.Validator.bpmnLeadsToNoEnd);
        } else {
        	this.enableDeactivationHandler(button);
        	//show a status message with a hint to the error messages in the tooltip
            this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.SyntaxChecker.notice,
    			timeout:10000
    		});
        }
    }
});

ORYX.Plugins.EPCValidator = Ext.extend(ORYX.Plugins.Validator, {
  getLabelOfShape: function(node){
    if(node.properties["oryx-title"] === ""){
      return node.id;
    } else {
      return node.properties["oryx-title"];
    }
  },
  findShapeById: function(id){
    return this.facade.getCanvas().getChildShapeByResourceId(id);
  },
  
    handleValidationResponse: function(result, button){
      //TODO use Ext XTemplate
        var isSound = result.isSound;
        var badStartArcs = result.badStartArcs;
        var badEndArcs = result.badEndArcs;
        var goodInitialMarkings = result.goodInitialMarkings;
        var goodFinalMarkings = result.goodFinalMarkings;
        
        var message = "";
        
        if (isSound) {
          message += ORYX.I18N.Validator.epcIsSound;
        } else {
          message += ORYX.I18N.Validator.epcNotSound;
        }
        
        message += "<hr />";
        
        var arrayOfArraysToMessage = function(arrayOfArrays, formatter){
          var message = "<ul>"
          arrayOfArrays.each(function(array){
            message += "<li> - ";
            array.each(function(element){
              message += '"' + formatter(element) + '" ';
            });
            message += "</li>";
          });
          message += "</ul>";
          return message;
        }
        var arrayToMessage = function(array, formatter){
          var message = "<ul>"
          array.each(function(element){
            message += "<li> - " + formatter(element) + "</li>";
          });
          message += "</ul>";
          return message;
        }
        
        message += "<p>There are "+ goodInitialMarkings.length +" initial markings which does not run into a deadlock.</p>";
        message += arrayOfArraysToMessage(goodInitialMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The initial markings do not include "+ badStartArcs.length +" start nodes.</p>";
        message += arrayToMessage(badStartArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        
        message += "<hr />";
        
        message += "<p>There are "+ goodFinalMarkings.length +" final markings which can be reached from the initial markings.</p>";
        message += arrayOfArraysToMessage(goodFinalMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The final markings do not include "+ badEndArcs.length +" end nodes.</p>";
        message += arrayToMessage(badEndArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this))
        
        message += "<hr />";
        
        message += "<p><i>Remark: Set titles of functions and events to get some nicer output (names instead of ids)</i></p>"
        
        Ext.Msg.alert('Validation Result', message);
        
        this.setActive(false);
    }
});
/**
 * Copyright (c) 2008, Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.Validator = ORYX.Plugins.AbstractPlugin.extend({
    construct: function(facade){
        this.facade = facade;
        
        this.active = false;
        this.raisedEventIds = [];
        
        this.buttonId = ORYX.Editor.provideId();
        
        this.facade.offer({
            'name': ORYX.I18N.Validator.name,
            'id': this.buttonId,
            'functionality': this.load.bind(this),
            'group': "Verification",
            'icon': ORYX.PATH + "images/checker_validation.png",
            'description': ORYX.I18N.Validator.description,
            'index': 1,
            'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    load: function(button, pressed){
        if (!pressed) {
            this.hideOverlays();
            this.active = !this.active;
        }
        else {
            this.validate(button);
        }
    },
    
    setActive: function(active){
        this.active = active;
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_BUTTON_UPDATE,
            id: this.buttonId,
            pressed: active
        });
    },
    
    hideOverlays: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }
.bind(this));
        
        this.raisedEventIds = [];
    },
    validate: function(button){
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.Validator.checking
        });
      
        // Send the request to the server.
        new Ajax.Request(ORYX.CONFIG.VALIDATOR_URL, {
            method: 'POST',
            asynchronous: false,
            parameters: {
                resource: location.href,
                data: this.getRDFFromDOM()
            },
            onSuccess: function(request){
                var result = Ext.decode(request.responseText);
                
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                
                // This should be implemented by child instances of validator 
                this.handleValidationResponse(result, button);
            }
.bind(this),
            onFailure: function(){
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
                Ext.Msg.alert(ORYX.I18N.Validator.error, ORYX.I18N.Validator.errorDesc);
            }.bind(this)
        });
    },
    
    showOverlay: function(shape, errorMsg, errorTitle){
    
        var id = "syntaxchecker." + this.raisedEventIds.length;
        
        var crossId = ORYX.Editor.provideId();
        
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
        	"id":crossId,
        	"title":"",
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        this.raisedEventIds.push(id);
        
        var tooltip = new Ext.ToolTip({
        	showDelay:50,
        	title:errorTitle,
        	html:errorMsg,
        	target:crossId
        });   
        
        return cross;
    },
    
    /**
     * Registers handler for deactivating syntax checker as soon as somewhere is clicked...
     * @param {Ext.Button} Toolbar button
     */
    enableDeactivationHandler: function(button){
        var deactivate = function(){
            this.setActive(false);
            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate);
        };
        
        this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, deactivate.bind(this));
    }
});

ORYX.Plugins.BPMNValidator = Ext.extend(ORYX.Plugins.Validator, {
    handleValidationResponse: function(result, button){
        var conflictingNodes = result.conflictingNodes;
        var leadsToEnd = result.leadsToEnd;
        var unsafeNode = result.unsafeNode;
        // Only stay active if there is anything to visualize
        this.setActive(conflictingNodes.size() > 0);
        
//        if (!leadsToEnd) {
//            Ext.Msg.alert("Validation Result", "The process will never reach a final state!");
//        }
        if (conflictingNodes.size() > 0) {
            conflictingNodes.each(function(node){
                sh = this.facade.getCanvas().getChildShapeByResourceId(node.id);
                if (sh) {
                    this.showOverlay(sh, ORYX.I18N.Validator.bpmnDeadlock,  ORYX.I18N.Validator.bpmnDeadlockTitle);
                }
            }.bind(this));
        }
        if(unsafeNode) {
        	var shape = this.facade.getCanvas().getChildShapeByResourceId(unsafeNode);
        	if (shape) {
                this.showOverlay(shape, ORYX.I18N.Validator.bpmnUnsafe, ORYX.I18N.Validator.bpmnUnsafeTitle);
            }
        }
        if(leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode) {
        	this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.Validator.noErrors,
    			timeout:10000
    		});
        	//Ext.Msg.alert(ORYX.I18N.Validator.result, ORYX.I18N.Validator.noErrors);
        } else if(!leadsToEnd && conflictingNodes.size() === 0 && !unsafeNode){
        	Ext.Msg.alert(ORYX.I18N.Validator.bpmnLeadsToNoEndTitle, ORYX.I18N.Validator.bpmnLeadsToNoEnd);
        } else {
        	this.enableDeactivationHandler(button);
        	//show a status message with a hint to the error messages in the tooltip
            this.facade.raiseEvent({
    			type:ORYX.CONFIG.EVENT_LOADING_STATUS,
    			text:ORYX.I18N.SyntaxChecker.notice,
    			timeout:10000
    		});
        }
    }
});

ORYX.Plugins.EPCValidator = Ext.extend(ORYX.Plugins.Validator, {
  getLabelOfShape: function(node){
    if(node.properties["oryx-title"] === ""){
      return node.id;
    } else {
      return node.properties["oryx-title"];
    }
  },
  findShapeById: function(id){
    return this.facade.getCanvas().getChildShapeByResourceId(id);
  },
  
    handleValidationResponse: function(result, button){
      //TODO use Ext XTemplate
        var isSound = result.isSound;
        var badStartArcs = result.badStartArcs;
        var badEndArcs = result.badEndArcs;
        var goodInitialMarkings = result.goodInitialMarkings;
        var goodFinalMarkings = result.goodFinalMarkings;
        
        var message = "";
        
        if (isSound) {
          message += ORYX.I18N.Validator.epcIsSound;
        } else {
          message += ORYX.I18N.Validator.epcNotSound;
        }
        
        message += "<hr />";
        
        var arrayOfArraysToMessage = function(arrayOfArrays, formatter){
          var message = "<ul>"
          arrayOfArrays.each(function(array){
            message += "<li> - ";
            array.each(function(element){
              message += '"' + formatter(element) + '" ';
            });
            message += "</li>";
          });
          message += "</ul>";
          return message;
        }
        var arrayToMessage = function(array, formatter){
          var message = "<ul>"
          array.each(function(element){
            message += "<li> - " + formatter(element) + "</li>";
          });
          message += "</ul>";
          return message;
        }
        
        message += "<p>There are "+ goodInitialMarkings.length +" initial markings which does not run into a deadlock.</p>";
        message += arrayOfArraysToMessage(goodInitialMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The initial markings do not include "+ badStartArcs.length +" start nodes.</p>";
        message += arrayToMessage(badStartArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getIncomingShapes()[0]);
        }.createDelegate(this));
        
        message += "<hr />";
        
        message += "<p>There are "+ goodFinalMarkings.length +" final markings which can be reached from the initial markings.</p>";
        message += arrayOfArraysToMessage(goodFinalMarkings, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this));
        message += "<p>The final markings do not include "+ badEndArcs.length +" end nodes.</p>";
        message += arrayToMessage(badEndArcs, function(arc){
          return this.getLabelOfShape(this.findShapeById(arc.id).getOutgoingShapes()[0]);
        }.createDelegate(this))
        
        message += "<hr />";
        
        message += "<p><i>Remark: Set titles of functions and events to get some nicer output (names instead of ids)</i></p>"
        
        Ext.Msg.alert('Validation Result', message);
        
        this.setActive(false);
    }
});/* * TODO interaction format step through <=> oryx should be json!!! *//** * Copyright (c) 2008, Christoph Neijenhuis, modified by Kai Schlichting * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * @namespace Oryx name space for plugins * @name ORYX.Plugins **/Ext.namespace("ORYX.Plugins");ORYX.Plugins.AbstractStepThroughPlugin = ORYX.Plugins.AbstractPlugin.extend({    construct: function() {        // Call super class constructor        arguments.callee.$.construct.apply(this, arguments);                this.facade.offer({            'name': ORYX.I18N.StepThroughPlugin.stepThrough,            'functionality': this.load.bind(this),            'group': ORYX.I18N.StepThroughPlugin.group,            'icon': ORYX.PATH + "images/control_play.png",            'description': ORYX.I18N.StepThroughPlugin.stepThroughDesc,            'index': 1,            'toggle' : true,            'minShape': 0,            'maxShape': 0        });                this.facade.offer({            'name': ORYX.I18N.StepThroughPlugin.undo,            'functionality': this.undo.bind(this),            'group': ORYX.I18N.StepThroughPlugin.group,            'icon': ORYX.PATH + "images/control_rewind.png",            'description': ORYX.I18N.StepThroughPlugin.undoDesc,            'index': 2,            'minShape': 0,            'maxShape': 0        });    },    showEnabled: function(shape, display){        // Creates overlay for an enabled shape        // display is beeing ignored        if (!(shape instanceof ORYX.Core.Shape)) {            return;        }        else if (this.isOrSplit(shape)) { //special handling for OR-Split            this.showEnabledOrSplit(shape);            return;        }                this.showPlayOnShape(shape);    },        showPlayOnShape: function(shape){        var attr;        if (shape instanceof ORYX.Core.Edge) {            attr = {                stroke: "green"            };        }        else {            attr = {                fill: "green"            };        }                var play = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {            "title": "Click the element to execute it!",            "stroke-width": 2.0,            "stroke": "black",            "d": "M0,-5 L5,0 L0,5 Z",            "line-captions": "round"        }]);                this.showOverlayOnShape(shape, attr, play);    },        showOverlayOnShape: function(shape, attributes, node){        this.hideOverlayOnShape(shape);                this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,            id: "st." + shape.resourceId,            shapes: [shape],            attributes: attributes,            node: (node ? node : null),            nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"        });    },        hideOverlayOnShape: function(shape){        this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,            id: "st." + shape.resourceId        });    },        // Pass preserveInitialMarking = true as config option, if initial marking     // should not be deleted     hideOverlays: function(preserveInitialMarking){        // hides all overlays        var els = this.facade.getCanvas().getChildShapes(true);        var el;        for (i = 0; i < els.size(); i++) {            el = els[i];            // This may send hide-events for objects that have no overlay            if (!(preserveInitialMarking && this.isStartNode(el))) {                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,                    id: "st." + el.resourceId                });            }        }    },        /**     * Called when the user loads or unloads the plugin     * @methodOf ORYX.Plugins.StepThroughPlugin     */    load: function(button, pressed){        this.initializeLoadButton(button, pressed);        this.togglePlugin(pressed);    },	togglePlugin: function(turn_on) {		if (turn_on) {			 this.initialMarking = [];            if (this.getDiagramType() === "epc") {                this.prepareInitialMarking();            }            else { //only start immediately for bpmn diagrams and Petri nets                this.startAndCheckSyntax();            }		}		else {			 // Reset vars	        this.executionTrace = "";            this.rdf = undefined;            // Reset syntax checker errors            this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});            this.onDeactivate();		}				if (this.active()) {            this.callback = this.doMouseUp.bind(this)            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)        } else {            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)            this.callback = undefined;        }	},        // When plugin is deactivated through pressing the button    // Overwrite to implement custom behavior    onDeactivate: function(){        // Hide overlays        this.hideOverlays();    },        // Very evil, this method is a result from Oryx generalized plugin infrastructure    // Direct access to button needed, so that this can be done in construct method    initializeLoadButton: function(button, pressed){        if(this.loadButton !== button){            // Sets state of the loadButton and sets the model readonly            var toggleActive = function(active){                if(active){                    //Set "readonly" (edges cannot be moved anymore)                    this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);                } else {                    this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);                }            }.createDelegate(this);                        button.on('toggle', function(button, p){                toggleActive(p);            });            // Very evil!! The first time, toggle event isn't thrown             // Should be like that listeners can be defined earlier!!!            toggleActive(button, pressed);        }        this.loadButton = button;    },        active: function(){        return this.loadButton ? this.loadButton.pressed : false;    },        onSelectionChanged: function(){        if (this.active() && this.facade.getSelection().length > 0) {            // Stop the user from editing the diagram while the plugin is active            this.facade.setSelection([]);        }    },        //TODO generic function    getDiagramType: function(){        switch (this.facade.getCanvas().getStencil().namespace()) {            case "http://b3mn.org/stencilset/epc#":                return "epc";            case "http://b3mn.org/stencilset/bpmn#":                return "bpmn";            default:                return null;        }    },        showUsed: function(shape, display){        // Creates overlay for a shape that has been used and is not enabled        if (!(shape instanceof ORYX.Core.Shape))             return;                var attr;        if (shape instanceof ORYX.Core.Edge) {            attr = {                stroke: "mediumslateblue"            };        }        else {            attr = {                fill: "mediumslateblue"            };        }                this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,            id: "st." + shape.resourceId        });                if (display != "-1" && display != "1") {            // Show the number            var text = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {                "style": "font-size: 16px; font-weight: bold;"            }, display]);                        this.facade.raiseEvent({                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,                id: "st." + shape.resourceId,                shapes: [shape],                attributes: attr,                node: text,                nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"            });        }        else {            // This is an XOR split, don't display number            this.facade.raiseEvent({                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,                id: "st." + shape.resourceId,                shapes: [shape],                attributes: attr            });        }    }});ORYX.Plugins.PetriNetStepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({    construct: function() {        // Call super class constructor        arguments.callee.$.construct.apply(this, arguments);    },    startAndCheckSyntax: function(){        this.facade.raiseEvent({            type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,            onErrors: function(){                Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!");            }.bind(this),            onNoErrors: function(){	            if (this.initializeMarking()) {					this.firedTransitions = [];	                this.showEnabledTransition();				} 				else {					this.togglePlugin(false); // turn off 				}            }.bind(this)        });    },    /**     * Initializes the number of tokens for each place. Additionally, if none of the places have a token, the initial places     * get one.     */    initializeMarking: function(){        		// monkeypatching place marking (add/remove tokens) towards new stencil set		// definitions from r3187		var markPlaces = function(shape, propertyValue) {			if(propertyValue == 0) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "0");			} else if(propertyValue == 1) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "1");			} else if(propertyValue == 2) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "2");			} else if(propertyValue == 3) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "3");			} else if(propertyValue == 4) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "4");			} else {				var tokens = parseInt(propertyValue, 10);				if(tokens && tokens > 0) {					shape.setProperty("oryx-numberoftokens_text", "" + tokens);					shape.setProperty("oryx-numberoftokens_drawing", "0");				} else {					shape.setProperty("oryx-numberoftokens_text", "");					shape.setProperty("oryx-numberoftokens_drawing", "0");				}			}		}		this.getPlaces().each(function(place){			if ("undefined" == typeof(place._setProperty_monkey)) {				place._setProperty_monkey = place.setProperty;				place.setProperty = function(p,a) {					if ("oryx-numberoftokens" == p) {						markPlaces(place, a)					}					place._setProperty_monkey.apply(place, arguments);				}			}		})        		var anyTokenFound = 0;        this.getPlaces().each(function(place){            var tokens = parseInt(place.properties["oryx-numberoftokens"]);            if(isNaN(tokens)){                // All places which don't have any number of tokens, gets 0 tokens explicitly                place.setProperty("oryx-numberoftokens", 0);            } else if(tokens > 0){                anyTokenFound += tokens;            }        });                // If no place has any token, all incoming places gets tokens        if(0 == anyTokenFound){            this.getPlaces().each(function(place){                if(place.getIncomingShapes().length == 0){                    place.setProperty("oryx-numberoftokens", 1);                }            });            Ext.Msg.show({               title:'No Tokens Found',               msg: 'Current marking of the Petri net doesn\'t contain any token. Tokens are added to the initial places of the net.',               buttons: Ext.Msg.OK,               icon: Ext.MessageBox.INFO            });        }				if(anyTokenFound > 3){            Ext.Msg.show({               title:'Too Many Tokens On Place',               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',               buttons: Ext.Msg.OK,               icon: Ext.MessageBox.WARNING            });		}		return true;    },        doMouseUp: function(event, shape){        if (!(this.isTransition(shape))) return; // Can be a docker, place or something else		// assuming correct syntax    	var enabled = this.getIncomingNodes(shape).all(function(place) {			return parseInt(place.properties["oryx-numberoftokens"]) > 0;		});		if (enabled) {        	this.fireTransition(shape);			}        this.showEnabledTransition();    },        onDeactivate: function(){        // Hide overlays        this.hideOverlays();                // Undo all fired transitions so that the marking is the initial marking        while(this.firedTransitions.length !== 0){            this.undoLastFiredTransition();        }        this.facade.getCanvas().update(); //update markings                this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});    },        fireTransition: function(transition){        this.firedTransitions.push(transition);        this.getIncomingNodes(transition).each(function(place){            this.removeToken(place);        }.bind(this));        this.getOutgoingNodes(transition).each(function(place){            this.addToken(place);        }.bind(this));    },        undoLastFiredTransition: function(){        var transition = this.firedTransitions.pop();                // If there is no transition anymore, just quit        if(!transition) return;                this.getIncomingNodes(transition).each(function(place){            this.addToken(place);        }.bind(this));        this.getOutgoingNodes(transition).each(function(place){            this.removeToken(place);        }.bind(this));    },        removeToken: function(place){        place.setProperty("oryx-numberoftokens", parseInt(place.properties["oryx-numberoftokens"])-1);    },        addToken: function(place){        var tokens = parseInt(place.properties["oryx-numberoftokens"]) +1;            place.setProperty("oryx-numberoftokens", tokens);                if(tokens > 3){            Ext.Msg.show({               title:'Too Many Tokens On Place',               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',               buttons: Ext.Msg.OK,               icon: Ext.MessageBox.WARNING            });        }    },        showEnabledTransition: function(){        this.hideOverlays();                this.firedTransitions.each(function(transition){            this.showUsed(transition, "1");        }.bind(this));                this.getEnabledTransitions().each(function(transition){            this.showPlayOnShape(transition);        }.bind(this));                this.facade.getCanvas().update();    },    getTransitions: function(){        return this.facade.getCanvas().getChildShapes().select(function(shape){            return this.isTransition(shape);        }.bind(this));    },    isTransition: function(shape){        return shape instanceof ORYX.Core.Shape && shape.getStencil().id().search(/Transition/) > -1;    },    getPlaces: function(){        return this.facade.getCanvas().getChildShapes().select(function(shape){            return shape.getStencil().id().search(/Place/) > -1;        });    },    getIncomingNodes: function(node){      return node.getIncomingShapes().collect(function(arc){        return arc.getIncomingShapes();      }).flatten();    },    getOutgoingNodes: function(node){      return node.getOutgoingShapes().collect(function(arc){        return arc.getOutgoingShapes();      }).flatten();    },    getEnabledTransitions:function(){        return this.getTransitions().select(function(transition){            // Checks whether all incoming places have at least 1 token            return this.getIncomingNodes(transition).all(function(place){                return parseInt(place.properties["oryx-numberoftokens"]) > 0;            });        }.bind(this));    },    undo: function(){        this.undoLastFiredTransition();        this.showEnabledTransition();    }});/** * Step Through Plugin * @class ORYX.Plugins.StepThroughPlugin * @constructor Creates new plugin instance */ORYX.Plugins.StepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({    /**     * My method!     * @methodOf ORYX.Plugins.StepThroughPlugin     */    construct: function(facade){        this.el = undefined;        this.callback = undefined;        this.executionTrace = ""; // A string containing all objects that have been fired        this.rdf = undefined;                        arguments.callee.$.construct.apply(this, arguments);    },        // Each start node and each start arc gets colored    prepareInitialMarking: function(){        this.startNodes = [];                Ext.each(this.facade.getCanvas().getChildShapes(true), function(shape){            if (this.isStartNode(shape)) {                this.startNodes.push(shape);                shape.initialMarkingFired = false;                this.showPlayOnShape(shape);                if (shape.getOutgoingShapes().size() == 1) {                    this.showOverlayOnShape(shape.getOutgoingShapes()[0], {                        stroke: "green"                    });                    shape.getOutgoingShapes()[0].initialMarking = true;                }            }        }.createDelegate(this));    },        /* Returns true if node is start node */    isStartNode: function(shape){        return (shape.getStencil().id().search(/#Event$/) > -1) && shape.getIncomingShapes().length == 0 && shape.getOutgoingShapes().length == 1;    },        /* Returns true if source node from arc is start node */    isStartArc: function(shape){        return this.isStartNode(shape.getIncomingShapes()[0]);    },        isStartArcOrNode: function(shape){        return this.isStartNode(shape) || this.isStartArc(shape);    },        /* TODO this should be a general oryx helper method!! */    generateRDF: function(){                try {            var serialized_rdf = this.getRDFFromDOM();                        // Firefox 2 to 3 problem?!            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;        }         catch (error) {            this.facade.raiseEvent({                type: ORYX.CONFIG.EVENT_LOADING_DISABLE            });            Ext.Msg.alert(ORYX.I18N.Oryx.title, error);        }                this.rdf = serialized_rdf;    },        getRDF: function(){        if (this.rdf == undefined) {            this.generateRDF();        }                return this.rdf;    },        startAndCheckSyntax: function(){        this.postExecutionTrace({            checkSyntax: true,            onlyChangedObjects: false,            onSuccess: function(request){                //TODO use always json!!!! This is a bad hack!!!                if (request.responseText.startsWith("{")){ //seems to be json                    var errors = Ext.decode(request.responseText).syntaxErrors;                                        // Show errors                    this.facade.raiseEvent({                        type: ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT,                        errors: errors                    });                } else { //normal step through response                    this.showObjectStates(request.responseText);                }            }.bind(this)        });    },        fireObject: function(objResourceId){        // Add this object to executionTrace        this.executionTrace += objResourceId + ";";                // Add selected edges for or split        if (this.isOrSplit(this.el)) {            //eliminate ;            this.executionTrace = this.executionTrace.substring(0, this.executionTrace.length - 1);            this.executionTrace += "#";            var outgoingEdges = new Ext.util.MixedCollection();            outgoingEdges.addAll(this.el.getOutgoingShapes());            var firingEdgesResourceIds = [];            outgoingEdges.filter("selectedForOrSplit", "true").each(function(edge){                firingEdgesResourceIds.push(edge.resourceId);            }.createDelegate(this));            outgoingEdges.each(function(edge){                edge.selectedForOrSplit = false;                this.hideOverlayOnShape(edge);            }.createDelegate(this));            this.executionTrace += firingEdgesResourceIds.join(",") + ";";        }                this.postExecutionTrace({            checkSyntax: false,            onlyChangedObjects: true,            onSuccess: function(request){                if (request.responseText != "") {                    // successful                    this.showObjectStates(request.responseText);                }                else {                    // object couldn't be fired, remove it from executionTrace                    this.removeLastFiredObject();                }            }.bind(this)        });    },        doMouseUp: function(event, arg){        if (arg instanceof ORYX.Core.Shape) {            // if its an or split            if (arg instanceof ORYX.Core.Edge && this.isOrSplit(arg.getIncomingShapes()[0])) {                this.doMouseUpOnEdgeComingFromOrSplit(arg);                // else if its an epc start node            }            else if (arg instanceof ORYX.Core.Edge && this.getDiagramType() === "epc" && this.isStartNode(arg.getIncomingShapes()[0])) {                this.doMouseUpOnEdgeComingFromStartNode(arg);            }            else if (this.getDiagramType() === "epc" && this.isStartNode(arg)) {                arg.initialMarkingFired = true;                var edge = arg.getOutgoingShapes()[0];                this.hideOverlayOnShape(edge);                if (edge.initialMarking) {                    this.showUsed(arg, "1");                    this.initialMarking.push(arg.resourceId);                }                else {                    this.hideOverlayOnShape(arg);                }                                // If clicked node is the last startNode, activate real step through                var allStartNodesFired = true;                Ext.each(this.startNodes, function(startNode){                    if (!startNode.initialMarkingFired) {                        allStartNodesFired = false;                    }                });                                if (allStartNodesFired) {                    this.startAndCheckSyntax();                }            }            else {                this.el = arg;                this.fireObject(this.el.resourceId);            }        }    },        showObjectStates: function(objs){        var objsAndState = objs.split(";");        for (i = 0; i < objsAndState.size(); i++) {            var objAndState = objsAndState[i].split(",");            if (objAndState.size() < 3) {                continue;            }            var obj = this.facade.getCanvas().getChildShapeByResourceId(objAndState[0]);            if (objAndState[2] == "t") { // Is enabled                this.showEnabled(obj, objAndState[1]);            }            else if (objAndState[1] != "0") { // has been used                this.showUsed(obj, objAndState[1]);            }            else { // Was enabled, has not been used                this.hideOverlayOnShape(obj);            }        }    },        doMouseUpOnEdgeComingFromOrSplit: function(edge){        var orSplit = edge.getIncomingShapes()[0];                if (edge.selectedForOrSplit) { //deselect edge            this.showOverlayOnShape(edge, {                stroke: "orange"            });                        // Hide or-split overlay, if last edge has been deselected            var outgoingEdges = new Ext.util.MixedCollection();            outgoingEdges.addAll(orSplit.getOutgoingShapes());            if (outgoingEdges.filter("selectedForOrSplit", "true").length <= 1) { // > 1, because current edge is in this list                this.hideOverlayOnShape(orSplit);            }                    }        else { //select edge            this.showOverlayOnShape(edge, {                stroke: "green"            });            this.showPlayOnShape(orSplit);        }                // toggle selection        edge.selectedForOrSplit = !edge.selectedForOrSplit;    },        // Toggles color and initialMarking value of start arcs    doMouseUpOnEdgeComingFromStartNode: function(edge){        edge.initialMarking = !edge.initialMarking;                if (edge.initialMarking) {            this.showOverlayOnShape(edge, {                stroke: "green"            });        }        else {            this.showOverlayOnShape(edge, {                stroke: "orange"            });        }    },        //checks whether shape is OR gateway and hasn't more than 1 outgoing edges    isOrSplit: function(shape){        return (shape.getStencil().id().search(/#(OR_Gateway|OrConnector)$/) > -1) && (shape.getOutgoingShapes().length > 1);    },        showEnabledOrSplit: function(shape){        Ext.each(shape.getOutgoingShapes(), function(edge){            Ext.apply(edge, {                selectedForOrSplit: false            });                        this.showOverlayOnShape(edge, {                stroke: "orange"            });        }.createDelegate(this));    },       removeLastFiredObject: function(){        // Removes last entry in execution trace        this.executionTrace = this.executionTrace.replace(/[^;]*;$/, "")    },        undo: function(){        if (!this.active())             return;                if (this.executionTrace !== "") {            this.removeLastFiredObject();                        this.postExecutionTrace({                checkSyntax: false,                onlyChangedObjects: false,                onSuccess: function(request){                    // Hide overlays because everything is drawn from scratch                    this.hideOverlays(true);                    // Draw new overlays                    this.showObjectStates(request.responseText);                }.bind(this)            });        }        else if (this.getDiagramType() === "epc") {            this.hideOverlays();            this.prepareInitialMarking(); // "reset" initial marking        }    },        /* Posts current execution trace to server for executing      * options is a hash with following keys:     * - onlyChangedObjects (boolean)     * - onSuccess (function with parameter request)     * - checkSyntax (boolean)     */    postExecutionTrace: function(options){        this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,            text: ORYX.I18N.StepThroughPlugin.executing        });                //TODO merge in default options        new Ajax.Request(ORYX.CONFIG.STEP_THROUGH, {            method: 'POST',            asynchronous: false,            parameters: {                rdf: this.getRDF(),                checkSyntax: options.checkSyntax,                fire: this.executionTrace,                onlyChangedObjects: options.onlyChangedObjects,                initialMarking: this.initialMarking.join(";")            },            onSuccess: function(response){                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });                options.onSuccess(response);            }.createDelegate(this),            onFailure: function(){                //TODO raise error message?                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });            }.createDelegate(this)        });    }});/* * TODO interaction format step through <=> oryx should be json!!! *//** * Copyright (c) 2008, Christoph Neijenhuis, modified by Kai Schlichting * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **//** * @namespace Oryx name space for plugins * @name ORYX.Plugins **/Ext.namespace("ORYX.Plugins");ORYX.Plugins.AbstractStepThroughPlugin = ORYX.Plugins.AbstractPlugin.extend({    construct: function() {        // Call super class constructor        arguments.callee.$.construct.apply(this, arguments);                this.facade.offer({            'name': ORYX.I18N.StepThroughPlugin.stepThrough,            'functionality': this.load.bind(this),            'group': ORYX.I18N.StepThroughPlugin.group,            'icon': ORYX.PATH + "images/control_play.png",            'description': ORYX.I18N.StepThroughPlugin.stepThroughDesc,            'index': 1,            'toggle' : true,            'minShape': 0,            'maxShape': 0        });                this.facade.offer({            'name': ORYX.I18N.StepThroughPlugin.undo,            'functionality': this.undo.bind(this),            'group': ORYX.I18N.StepThroughPlugin.group,            'icon': ORYX.PATH + "images/control_rewind.png",            'description': ORYX.I18N.StepThroughPlugin.undoDesc,            'index': 2,            'minShape': 0,            'maxShape': 0        });    },    showEnabled: function(shape, display){        // Creates overlay for an enabled shape        // display is beeing ignored        if (!(shape instanceof ORYX.Core.Shape)) {            return;        }        else if (this.isOrSplit(shape)) { //special handling for OR-Split            this.showEnabledOrSplit(shape);            return;        }                this.showPlayOnShape(shape);    },        showPlayOnShape: function(shape){        var attr;        if (shape instanceof ORYX.Core.Edge) {            attr = {                stroke: "green"            };        }        else {            attr = {                fill: "green"            };        }                var play = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {            "title": "Click the element to execute it!",            "stroke-width": 2.0,            "stroke": "black",            "d": "M0,-5 L5,0 L0,5 Z",            "line-captions": "round"        }]);                this.showOverlayOnShape(shape, attr, play);    },        showOverlayOnShape: function(shape, attributes, node){        this.hideOverlayOnShape(shape);                this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,            id: "st." + shape.resourceId,            shapes: [shape],            attributes: attributes,            node: (node ? node : null),            nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"        });    },        hideOverlayOnShape: function(shape){        this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,            id: "st." + shape.resourceId        });    },        // Pass preserveInitialMarking = true as config option, if initial marking     // should not be deleted     hideOverlays: function(preserveInitialMarking){        // hides all overlays        var els = this.facade.getCanvas().getChildShapes(true);        var el;        for (i = 0; i < els.size(); i++) {            el = els[i];            // This may send hide-events for objects that have no overlay            if (!(preserveInitialMarking && this.isStartNode(el))) {                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,                    id: "st." + el.resourceId                });            }        }    },        /**     * Called when the user loads or unloads the plugin     * @methodOf ORYX.Plugins.StepThroughPlugin     */    load: function(button, pressed){        this.initializeLoadButton(button, pressed);        this.togglePlugin(pressed);    },	togglePlugin: function(turn_on) {		if (turn_on) {			 this.initialMarking = [];            if (this.getDiagramType() === "epc") {                this.prepareInitialMarking();            }            else { //only start immediately for bpmn diagrams and Petri nets                this.startAndCheckSyntax();            }		}		else {			 // Reset vars	        this.executionTrace = "";            this.rdf = undefined;            // Reset syntax checker errors            this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});            this.onDeactivate();		}				if (this.active()) {            this.callback = this.doMouseUp.bind(this)            this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)        } else {            this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)            this.callback = undefined;        }	},        // When plugin is deactivated through pressing the button    // Overwrite to implement custom behavior    onDeactivate: function(){        // Hide overlays        this.hideOverlays();    },        // Very evil, this method is a result from Oryx generalized plugin infrastructure    // Direct access to button needed, so that this can be done in construct method    initializeLoadButton: function(button, pressed){        if(this.loadButton !== button){            // Sets state of the loadButton and sets the model readonly            var toggleActive = function(active){                if(active){                    //Set "readonly" (edges cannot be moved anymore)                    this.facade.disableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);                } else {                    this.facade.enableEvent(ORYX.CONFIG.EVENT_MOUSEDOWN);                }            }.createDelegate(this);                        button.on('toggle', function(button, p){                toggleActive(p);            });            // Very evil!! The first time, toggle event isn't thrown             // Should be like that listeners can be defined earlier!!!            toggleActive(button, pressed);        }        this.loadButton = button;    },        active: function(){        return this.loadButton ? this.loadButton.pressed : false;    },        onSelectionChanged: function(){        if (this.active() && this.facade.getSelection().length > 0) {            // Stop the user from editing the diagram while the plugin is active            this.facade.setSelection([]);        }    },        //TODO generic function    getDiagramType: function(){        switch (this.facade.getCanvas().getStencil().namespace()) {            case "http://b3mn.org/stencilset/epc#":                return "epc";            case "http://b3mn.org/stencilset/bpmn#":                return "bpmn";            default:                return null;        }    },        showUsed: function(shape, display){        // Creates overlay for a shape that has been used and is not enabled        if (!(shape instanceof ORYX.Core.Shape))             return;                var attr;        if (shape instanceof ORYX.Core.Edge) {            attr = {                stroke: "mediumslateblue"            };        }        else {            attr = {                fill: "mediumslateblue"            };        }                this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,            id: "st." + shape.resourceId        });                if (display != "-1" && display != "1") {            // Show the number            var text = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {                "style": "font-size: 16px; font-weight: bold;"            }, display]);                        this.facade.raiseEvent({                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,                id: "st." + shape.resourceId,                shapes: [shape],                attributes: attr,                node: text,                nodePosition: shape instanceof ORYX.Core.Edge ? "END" : "SE"            });        }        else {            // This is an XOR split, don't display number            this.facade.raiseEvent({                type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,                id: "st." + shape.resourceId,                shapes: [shape],                attributes: attr            });        }    }});ORYX.Plugins.PetriNetStepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({    construct: function() {        // Call super class constructor        arguments.callee.$.construct.apply(this, arguments);    },    startAndCheckSyntax: function(){        this.facade.raiseEvent({            type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,            onErrors: function(){                Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!");            }.bind(this),            onNoErrors: function(){	            if (this.initializeMarking()) {					this.firedTransitions = [];	                this.showEnabledTransition();				} 				else {					this.togglePlugin(false); // turn off 				}            }.bind(this)        });    },    /**     * Initializes the number of tokens for each place. Additionally, if none of the places have a token, the initial places     * get one.     */    initializeMarking: function(){        		// monkeypatching place marking (add/remove tokens) towards new stencil set		// definitions from r3187		var markPlaces = function(shape, propertyValue) {			if(propertyValue == 0) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "0");			} else if(propertyValue == 1) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "1");			} else if(propertyValue == 2) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "2");			} else if(propertyValue == 3) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "3");			} else if(propertyValue == 4) {				shape.setProperty("oryx-numberoftokens_text", "");				shape.setProperty("oryx-numberoftokens_drawing", "4");			} else {				var tokens = parseInt(propertyValue, 10);				if(tokens && tokens > 0) {					shape.setProperty("oryx-numberoftokens_text", "" + tokens);					shape.setProperty("oryx-numberoftokens_drawing", "0");				} else {					shape.setProperty("oryx-numberoftokens_text", "");					shape.setProperty("oryx-numberoftokens_drawing", "0");				}			}		}		this.getPlaces().each(function(place){			if ("undefined" == typeof(place._setProperty_monkey)) {				place._setProperty_monkey = place.setProperty;				place.setProperty = function(p,a) {					if ("oryx-numberoftokens" == p) {						markPlaces(place, a)					}					place._setProperty_monkey.apply(place, arguments);				}			}		})        		var anyTokenFound = 0;        this.getPlaces().each(function(place){            var tokens = parseInt(place.properties["oryx-numberoftokens"]);            if(isNaN(tokens)){                // All places which don't have any number of tokens, gets 0 tokens explicitly                place.setProperty("oryx-numberoftokens", 0);            } else if(tokens > 0){                anyTokenFound += tokens;            }        });                // If no place has any token, all incoming places gets tokens        if(0 == anyTokenFound){            this.getPlaces().each(function(place){                if(place.getIncomingShapes().length == 0){                    place.setProperty("oryx-numberoftokens", 1);                }            });            Ext.Msg.show({               title:'No Tokens Found',               msg: 'Current marking of the Petri net doesn\'t contain any token. Tokens are added to the initial places of the net.',               buttons: Ext.Msg.OK,               icon: Ext.MessageBox.INFO            });        }				if(anyTokenFound > 3){            Ext.Msg.show({               title:'Too Many Tokens On Place',               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',               buttons: Ext.Msg.OK,               icon: Ext.MessageBox.WARNING            });		}		return true;    },        doMouseUp: function(event, shape){        if (!(this.isTransition(shape))) return; // Can be a docker, place or something else		// assuming correct syntax    	var enabled = this.getIncomingNodes(shape).all(function(place) {			return parseInt(place.properties["oryx-numberoftokens"]) > 0;		});		if (enabled) {        	this.fireTransition(shape);			}        this.showEnabledTransition();    },        onDeactivate: function(){        // Hide overlays        this.hideOverlays();                // Undo all fired transitions so that the marking is the initial marking        while(this.firedTransitions.length !== 0){            this.undoLastFiredTransition();        }        this.facade.getCanvas().update(); //update markings                this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});    },        fireTransition: function(transition){        this.firedTransitions.push(transition);        this.getIncomingNodes(transition).each(function(place){            this.removeToken(place);        }.bind(this));        this.getOutgoingNodes(transition).each(function(place){            this.addToken(place);        }.bind(this));    },        undoLastFiredTransition: function(){        var transition = this.firedTransitions.pop();                // If there is no transition anymore, just quit        if(!transition) return;                this.getIncomingNodes(transition).each(function(place){            this.addToken(place);        }.bind(this));        this.getOutgoingNodes(transition).each(function(place){            this.removeToken(place);        }.bind(this));    },        removeToken: function(place){        place.setProperty("oryx-numberoftokens", parseInt(place.properties["oryx-numberoftokens"])-1);    },        addToken: function(place){        var tokens = parseInt(place.properties["oryx-numberoftokens"]) +1;            place.setProperty("oryx-numberoftokens", tokens);                if(tokens > 3){            Ext.Msg.show({               title:'Too Many Tokens On Place',               msg: 'Places with more than 3 tokens aren\'t supported yet. Please avoid this scenario.',               buttons: Ext.Msg.OK,               icon: Ext.MessageBox.WARNING            });        }    },        showEnabledTransition: function(){        this.hideOverlays();                this.firedTransitions.each(function(transition){            this.showUsed(transition, "1");        }.bind(this));                this.getEnabledTransitions().each(function(transition){            this.showPlayOnShape(transition);        }.bind(this));                this.facade.getCanvas().update();    },    getTransitions: function(){        return this.facade.getCanvas().getChildShapes().select(function(shape){            return this.isTransition(shape);        }.bind(this));    },    isTransition: function(shape){        return shape instanceof ORYX.Core.Shape && shape.getStencil().id().search(/Transition/) > -1;    },    getPlaces: function(){        return this.facade.getCanvas().getChildShapes().select(function(shape){            return shape.getStencil().id().search(/Place/) > -1;        });    },    getIncomingNodes: function(node){      return node.getIncomingShapes().collect(function(arc){        return arc.getIncomingShapes();      }).flatten();    },    getOutgoingNodes: function(node){      return node.getOutgoingShapes().collect(function(arc){        return arc.getOutgoingShapes();      }).flatten();    },    getEnabledTransitions:function(){        return this.getTransitions().select(function(transition){            // Checks whether all incoming places have at least 1 token            return this.getIncomingNodes(transition).all(function(place){                return parseInt(place.properties["oryx-numberoftokens"]) > 0;            });        }.bind(this));    },    undo: function(){        this.undoLastFiredTransition();        this.showEnabledTransition();    }});/** * Step Through Plugin * @class ORYX.Plugins.StepThroughPlugin * @constructor Creates new plugin instance */ORYX.Plugins.StepThroughPlugin = ORYX.Plugins.AbstractStepThroughPlugin.extend({    /**     * My method!     * @methodOf ORYX.Plugins.StepThroughPlugin     */    construct: function(facade){        this.el = undefined;        this.callback = undefined;        this.executionTrace = ""; // A string containing all objects that have been fired        this.rdf = undefined;                        arguments.callee.$.construct.apply(this, arguments);    },        // Each start node and each start arc gets colored    prepareInitialMarking: function(){        this.startNodes = [];                Ext.each(this.facade.getCanvas().getChildShapes(true), function(shape){            if (this.isStartNode(shape)) {                this.startNodes.push(shape);                shape.initialMarkingFired = false;                this.showPlayOnShape(shape);                if (shape.getOutgoingShapes().size() == 1) {                    this.showOverlayOnShape(shape.getOutgoingShapes()[0], {                        stroke: "green"                    });                    shape.getOutgoingShapes()[0].initialMarking = true;                }            }        }.createDelegate(this));    },        /* Returns true if node is start node */    isStartNode: function(shape){        return (shape.getStencil().id().search(/#Event$/) > -1) && shape.getIncomingShapes().length == 0 && shape.getOutgoingShapes().length == 1;    },        /* Returns true if source node from arc is start node */    isStartArc: function(shape){        return this.isStartNode(shape.getIncomingShapes()[0]);    },        isStartArcOrNode: function(shape){        return this.isStartNode(shape) || this.isStartArc(shape);    },        /* TODO this should be a general oryx helper method!! */    generateRDF: function(){                try {            var serialized_rdf = this.getRDFFromDOM();                        // Firefox 2 to 3 problem?!            serialized_rdf = !serialized_rdf.startsWith("<?xml") ? "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf : serialized_rdf;        }         catch (error) {            this.facade.raiseEvent({                type: ORYX.CONFIG.EVENT_LOADING_DISABLE            });            Ext.Msg.alert(ORYX.I18N.Oryx.title, error);        }                this.rdf = serialized_rdf;    },        getRDF: function(){        if (this.rdf == undefined) {            this.generateRDF();        }                return this.rdf;    },        startAndCheckSyntax: function(){        this.postExecutionTrace({            checkSyntax: true,            onlyChangedObjects: false,            onSuccess: function(request){                //TODO use always json!!!! This is a bad hack!!!                if (request.responseText.startsWith("{")){ //seems to be json                    var errors = Ext.decode(request.responseText).syntaxErrors;                                        // Show errors                    this.facade.raiseEvent({                        type: ORYX.Plugins.SyntaxChecker.SHOW_ERRORS_EVENT,                        errors: errors                    });                } else { //normal step through response                    this.showObjectStates(request.responseText);                }            }.bind(this)        });    },        fireObject: function(objResourceId){        // Add this object to executionTrace        this.executionTrace += objResourceId + ";";                // Add selected edges for or split        if (this.isOrSplit(this.el)) {            //eliminate ;            this.executionTrace = this.executionTrace.substring(0, this.executionTrace.length - 1);            this.executionTrace += "#";            var outgoingEdges = new Ext.util.MixedCollection();            outgoingEdges.addAll(this.el.getOutgoingShapes());            var firingEdgesResourceIds = [];            outgoingEdges.filter("selectedForOrSplit", "true").each(function(edge){                firingEdgesResourceIds.push(edge.resourceId);            }.createDelegate(this));            outgoingEdges.each(function(edge){                edge.selectedForOrSplit = false;                this.hideOverlayOnShape(edge);            }.createDelegate(this));            this.executionTrace += firingEdgesResourceIds.join(",") + ";";        }                this.postExecutionTrace({            checkSyntax: false,            onlyChangedObjects: true,            onSuccess: function(request){                if (request.responseText != "") {                    // successful                    this.showObjectStates(request.responseText);                }                else {                    // object couldn't be fired, remove it from executionTrace                    this.removeLastFiredObject();                }            }.bind(this)        });    },        doMouseUp: function(event, arg){        if (arg instanceof ORYX.Core.Shape) {            // if its an or split            if (arg instanceof ORYX.Core.Edge && this.isOrSplit(arg.getIncomingShapes()[0])) {                this.doMouseUpOnEdgeComingFromOrSplit(arg);                // else if its an epc start node            }            else if (arg instanceof ORYX.Core.Edge && this.getDiagramType() === "epc" && this.isStartNode(arg.getIncomingShapes()[0])) {                this.doMouseUpOnEdgeComingFromStartNode(arg);            }            else if (this.getDiagramType() === "epc" && this.isStartNode(arg)) {                arg.initialMarkingFired = true;                var edge = arg.getOutgoingShapes()[0];                this.hideOverlayOnShape(edge);                if (edge.initialMarking) {                    this.showUsed(arg, "1");                    this.initialMarking.push(arg.resourceId);                }                else {                    this.hideOverlayOnShape(arg);                }                                // If clicked node is the last startNode, activate real step through                var allStartNodesFired = true;                Ext.each(this.startNodes, function(startNode){                    if (!startNode.initialMarkingFired) {                        allStartNodesFired = false;                    }                });                                if (allStartNodesFired) {                    this.startAndCheckSyntax();                }            }            else {                this.el = arg;                this.fireObject(this.el.resourceId);            }        }    },        showObjectStates: function(objs){        var objsAndState = objs.split(";");        for (i = 0; i < objsAndState.size(); i++) {            var objAndState = objsAndState[i].split(",");            if (objAndState.size() < 3) {                continue;            }            var obj = this.facade.getCanvas().getChildShapeByResourceId(objAndState[0]);            if (objAndState[2] == "t") { // Is enabled                this.showEnabled(obj, objAndState[1]);            }            else if (objAndState[1] != "0") { // has been used                this.showUsed(obj, objAndState[1]);            }            else { // Was enabled, has not been used                this.hideOverlayOnShape(obj);            }        }    },        doMouseUpOnEdgeComingFromOrSplit: function(edge){        var orSplit = edge.getIncomingShapes()[0];                if (edge.selectedForOrSplit) { //deselect edge            this.showOverlayOnShape(edge, {                stroke: "orange"            });                        // Hide or-split overlay, if last edge has been deselected            var outgoingEdges = new Ext.util.MixedCollection();            outgoingEdges.addAll(orSplit.getOutgoingShapes());            if (outgoingEdges.filter("selectedForOrSplit", "true").length <= 1) { // > 1, because current edge is in this list                this.hideOverlayOnShape(orSplit);            }                    }        else { //select edge            this.showOverlayOnShape(edge, {                stroke: "green"            });            this.showPlayOnShape(orSplit);        }                // toggle selection        edge.selectedForOrSplit = !edge.selectedForOrSplit;    },        // Toggles color and initialMarking value of start arcs    doMouseUpOnEdgeComingFromStartNode: function(edge){        edge.initialMarking = !edge.initialMarking;                if (edge.initialMarking) {            this.showOverlayOnShape(edge, {                stroke: "green"            });        }        else {            this.showOverlayOnShape(edge, {                stroke: "orange"            });        }    },        //checks whether shape is OR gateway and hasn't more than 1 outgoing edges    isOrSplit: function(shape){        return (shape.getStencil().id().search(/#(OR_Gateway|OrConnector)$/) > -1) && (shape.getOutgoingShapes().length > 1);    },        showEnabledOrSplit: function(shape){        Ext.each(shape.getOutgoingShapes(), function(edge){            Ext.apply(edge, {                selectedForOrSplit: false            });                        this.showOverlayOnShape(edge, {                stroke: "orange"            });        }.createDelegate(this));    },       removeLastFiredObject: function(){        // Removes last entry in execution trace        this.executionTrace = this.executionTrace.replace(/[^;]*;$/, "")    },        undo: function(){        if (!this.active())             return;                if (this.executionTrace !== "") {            this.removeLastFiredObject();                        this.postExecutionTrace({                checkSyntax: false,                onlyChangedObjects: false,                onSuccess: function(request){                    // Hide overlays because everything is drawn from scratch                    this.hideOverlays(true);                    // Draw new overlays                    this.showObjectStates(request.responseText);                }.bind(this)            });        }        else if (this.getDiagramType() === "epc") {            this.hideOverlays();            this.prepareInitialMarking(); // "reset" initial marking        }    },        /* Posts current execution trace to server for executing      * options is a hash with following keys:     * - onlyChangedObjects (boolean)     * - onSuccess (function with parameter request)     * - checkSyntax (boolean)     */    postExecutionTrace: function(options){        this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,            text: ORYX.I18N.StepThroughPlugin.executing        });                //TODO merge in default options        new Ajax.Request(ORYX.CONFIG.STEP_THROUGH, {            method: 'POST',            asynchronous: false,            parameters: {                rdf: this.getRDF(),                checkSyntax: options.checkSyntax,                fire: this.executionTrace,                onlyChangedObjects: options.onlyChangedObjects,                initialMarking: this.initialMarking.join(";")            },            onSuccess: function(response){                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });                options.onSuccess(response);            }.createDelegate(this),            onFailure: function(){                //TODO raise error message?                this.facade.raiseEvent({                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE                });            }.createDelegate(this)        });    }});/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.XFormsExport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;

		this.facade.offer({
			'name':ORYX.I18N.XFormsSerialization.exportXForms,
			'functionality': this.exportXForms.bind(this),
			'group': ORYX.I18N.XFormsSerialization.group,
			'icon': ORYX.PATH + "images/xforms_export.png",
			'description': ORYX.I18N.XFormsSerialization.exportXFormsDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0});
	},
	
	exportXForms: function(){
		this._showCssDialog();
	},

	exportIt: function(cssUrl){

		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
		
		//this.checkClientXFormsSupport();
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously(cssUrl);
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },

    exportSynchronously: function(cssUrl) {
		 var resource = location.href;
		try {
			var serialized_rdf 	= this.getRDFFromDOM();
			serialized_rdf 		= serialized_rdf.startsWith("<?xml") ? serialized_rdf : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;

			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.XFORMS_EXPORT_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf,
					css: cssUrl
				},
				onSuccess: function(request){
					
						var win = window.open("data:text/xml," +
								request.responseText, 
								"_blank", 
								"resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");
						
				}
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
	},
	
	checkClientXFormsSupport: function() {
		if(!clientSupportsXForms) {
			
			var output = ORYX.I18N.XFormsSerialization.noClientXFormsSupportDesc;

			var win = new Ext.Window({
                            width: 320,
                            height: 240,
                            resizable: false,
                            minimizable: false,
                            modal: true,
                            autoScroll: true,
                            title: ORYX.I18N.XFormsSerialization.noClientXFormsSupport,
                            html: output,
                            buttons: [{
                                text: ORYX.I18N.XFormsSerialization.ok,
                                handler: function(){
                                    win.hide();
                                }
                            }]
                        });
        	win.show();
			
		}
	},
	
	/**
	 * Opens dialog
	 * 
	 */
	_showCssDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.XFormsSerialization.selectCss, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -30' 
	        }]
	    });



		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.XFormsSerialization.expTitle, 
			height: 	150, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.XFormsSerialization.ok,
					handler:function(){		
						this.exportIt(form.items.items[1].getValue());
						dialog.hide();
					}.bind(this)
				},{
					text:ORYX.I18N.XFormsSerialization.close,
					handler:function(){
						dialog.hide();
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();

	}

});

/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.XFormsExportOrbeon = ORYX.Plugins.AbstractPlugin.extend({
	
	CSS_URL: ORYX.PATH + "/css/xforms_default.css",

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;

		this.facade.offer({
			'name': "Run XForm with Orbeon",
			'functionality': this.exportIt.bind(this),
			'group': ORYX.I18N.XFormsSerialization.group,
			'icon': ORYX.PATH + "images/xforms_orbeon_export.png",
			'description': 'XForms export for Orbeon',
			'index': 1,
			'minShape': 0,
			'maxShape': 0});
	},

	exportIt: function(){

		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
		
		//this.checkClientXFormsSupport();
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously();
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },

    exportSynchronously: function() {

        var resource = location.href;
		
		
		try {
			var serialized_rdf 	= this.getRDFFromDOM();
			serialized_rdf 		= serialized_rdf.startsWith("<?xml") ? serialized_rdf : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;

			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.XFORMS_EXPORT_ORBEON_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf,
					css: this.CSS_URL
				},
				onSuccess: function(request){
					
						var win = window.open("");
						win.document.write(request.responseText);
						
				},
				onFailure: function(request){
					var win = window.open("");
					win.document.write(request.responseText);
				}
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
	},
	
	checkClientXFormsSupport: function() {
		if(!clientSupportsXForms) {
			
			var output = ORYX.I18N.XFormsSerialization.noClientXFormsSupportDesc;

			var win = new Ext.Window({
                            width: 320,
                            height: 240,
                            resizable: false,
                            minimizable: false,
                            modal: true,
                            autoScroll: true,
                            title: ORYX.I18N.XFormsSerialization.noClientXFormsSupport,
                            html: output,
                            buttons: [{
                                text: ORYX.I18N.XFormsSerialization.ok,
                                handler: function(){
                                    win.hide();
                                }
                            }]
                        });
        	win.show();
			
		}
	}

});

/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.XFormsImport = Clazz.extend({

	facade: undefined,

	construct: function(facade) {
		this.facade = facade;

		this.facade.offer({
			'name':ORYX.I18N.XFormsSerialization.importXForms,
			'functionality': this.importXForms.bind(this),
			'group': ORYX.I18N.XFormsSerialization.group,
			'icon': ORYX.PATH + "images/xforms_import.png",
			'description': ORYX.I18N.XFormsSerialization.importXFormsDesc,
			'index': 3,
			'minShape': 0,
			'maxShape': 0});
	},

	
	/**
	 * Imports a XForms+XHTML document
	 * 
	 */
	importXForms: function(){
		this._showImportDialog();
	},		

	
	/**
	 * 
	 * 
	 * @param {Object} url
	 * @param {Object} params
	 * @param {Object} successcallback
	 */
	sendRequest: function( url, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
            method			: 'POST',
            asynchronous	: false,
            parameters		: params,
			onSuccess		: function(request) {
				
				suc = true;
				
				if(successcallback){
					successcallback( request )	
				}
				
			}.bind(this),
			
			onFailure		: function(request) {

				if(failedcallback){
					
					failedcallback();
					
				} else {
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.XFormsSerialization.impFailed);
					ORYX.log.warn("Import XForms failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		
		return suc;
							
	},

	
	throwWarning: function( text ){
		Ext.MessageBox.show({
					title: 		ORYX.I18N.Oryx.title,
 					msg: 		text,
					buttons: 	Ext.MessageBox.OK,
					icon: 		Ext.MessageBox.WARNING
				});
	},
	
	
	/**
	 * Opens an upload dialog.
	 * 
	 */
	_showImportDialog: function( successCallback ){
	
	    var form = new Ext.form.FormPanel({
			baseCls: 		'x-plain',
	        labelWidth: 	50,
	        defaultType: 	'textfield',
	        items: [{
	            text : 		ORYX.I18N.XFormsSerialization.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
	            anchor:		'100%',
				xtype : 	'label' 
	        },{
	            fieldLabel: ORYX.I18N.XFormsSerialization.file,
	            name: 		'subject',
				inputType : 'file',
				style : 	'margin-bottom:10px;display:block;',
				itemCls :	'ext_specific_window_overflow'
	        }, {
	            xtype: 'textarea',
	            hideLabel: true,
	            name: 'msg',
	            anchor: '100% -63'  
	        }]
	    });



		// Create the panel
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			layout: 	'fit',
			plain:		true,
			bodyStyle: 	'padding:5px;',
			title: 		ORYX.I18N.XFormsSerialization.impTitle, 
			height: 	350, 
			width:		500,
			modal:		true,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	true,
			items: 		[form],
			buttons:[
				{
					text:ORYX.I18N.XFormsSerialization.impButton,
					handler:function(){
						
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.XFormsSerialization.impProgress});
						loadMask.show();
						
						window.setTimeout(function(){
					
							var xhtmlString =  form.items.items[2].getValue();
							
							var params = { resource: location.href, data: xhtmlString };
							this.sendRequest(
								ORYX.CONFIG.XFORMS_IMPORT_URL, 
								params, 
								function(request) {
									this.facade.importJSON(request.responseText);
									loadMask.hide();
									dialog.hide();
									//this.loadERDF(request.responseText, function(){loadMask.hide();dialog.hide()}.bind(this), function(){loadMask.hide();}.bind(this))
								}.bind(this) );
														
							
						}.bind(this), 100);
			
					}.bind(this)
				},{
					text:ORYX.I18N.XFormsSerialization.close,
					handler:function(){
						
						dialog.hide();
					
					}.bind(this)
				}
			]
		});
		
		// Destroy the panel when hiding
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});


		// Show the panel
		dialog.show();
		
				
		// Adds the change event handler to 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt){
				var text = evt.target.files[0].getAsBinary();
				form.items.items[2].setValue( text );
			}, true)

	}
	
});
/** * Copyright (c) 2008 * Jan-Felix Schwarz * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.RowLayouting = {	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		// Initialize variables				this.currentShapes = [];			// Current selected Shapes		this.toMoveShapes = [];				// Shapes that are moved			this.dragBounds = undefined;		this.offSetPosition = {x:0, y:0};		this.evCoord = {x:0, y:0};		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT_ROWS, this.handleLayoutRows.bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));	},			/**	 * On the Selection-Changed	 *	 */	onSelectionChanged: function(event) {				var elements = event.elements;		// If there are no elements		if(!elements || elements.length == 0) {			// reset all variables			this.currentShapes = [];			this.toMoveShapes = [];			this.dragBounds = undefined;		} else {			// Set the current Shapes			this.currentShapes = elements;			// Get all shapes with the highest parent in object hierarchy (canvas is the top most parent)			this.toMoveShapes = this.facade.getCanvas().getShapesWithSharedParent(elements);						this.toMoveShapes = this.toMoveShapes.findAll( function(shape) { return shape instanceof ORYX.Core.Node && 																			(shape.dockers.length === 0 || !elements.member(shape.dockers.first().getDockedShape()))});							// Calculate the area-bounds of the selection			var newBounds = undefined;			elements.each(function(value) {				if(!newBounds)					newBounds = value.absoluteBounds();				else					newBounds.include(value.absoluteBounds());			});			// Set the new bounds			this.dragBounds = newBounds;		}				/*if(!this.dragBounds) {return};						var ul = this.dragBounds.upperLeft();				var offSetPosition = {			x: this.evCoord.x - ul.x,			y: this.evCoord.y - ul.y		}				this.toMoveShapes.each(function(shape) {			shape.bounds.moveBy(offSetPosition);		});*/				return;	},		handleMouseDown: function(event, uiObj) {		if(!this.dragBounds || !this.toMoveShapes.member(uiObj)) {return};				var evCoord 	= this.facade.eventCoordinates( event );		var ul = this.dragBounds.upperLeft();				this.offSetPosition = {			x: evCoord.x - ul.x,			y: evCoord.y - ul.y		}				return;	},			/**	 * On Layout Rows	 *	 */	handleLayoutRows: function(event) {		var shape = event.shape;				var offsetPos = this.offSetPosition;				var marginLeft = event.marginLeft;		var marginTop = event.marginTop;		var spacingX = event.spacingX;		var spacingY = event.spacingY;		var elements = event.shape.getChildShapes(false);				var movedShapes = this.toMoveShapes;		movedShapes.each(function(shape){			if(elements.include(shape)) shape.bounds.moveBy(offsetPos);		});				// exclude specified stencils from layouting		if (event.exclude) {			elements = elements.filter(function(element){				return !event.exclude.some(function(value){					return element.getStencil().id() == value;				});			});		}				var rowTop = marginTop;		var rowBottom = marginTop - spacingY;				if (event.horizontalLayout) {			// in case of horizontal layout: reset Y values			elements.each(function(element){				var ul = element.bounds.upperLeft();				element.bounds.moveTo(ul.x, rowTop);			})		}		else 			if (event.verticalLayout) {				// in case of vertical layout: reset X values				elements.each(function(element){					var ul = element.bounds.upperLeft();					element.bounds.moveTo(marginLeft, ul.y);				})			}				// Sort top-down		elements = elements.sortBy(function(element){			return element.bounds.upperLeft().y;		});				var insertRowOffset = 0;		var deleteRowOffset = 0;		var isNewRow = false;				// Assign shapes to rows		elements.each(function(element){					var ul = element.bounds.upperLeft();			var lr = element.bounds.lowerRight();						// save old values			var oldUlX = ul.x;			var oldUlY = ul.y;			var oldLrX = lr.x;			var oldLrY = lr.y;						if (movedShapes.include(element)) {				ul.y -= deleteRowOffset;								if ((ul.y > rowBottom) || ((element == elements.first()) && ul.y < marginTop)) {					// ul.y < marginTop wird bei nebeneinander nach oben verschobenen shapes					// mehrmals erfüllt, dadurch mehrmals neue row und untereinanderrutschen					// -> nur falls erstes element										// next row					isNewRow = false;					rowTop = rowBottom + spacingY;					if (ul.y < rowTop) {						// insert new row						//insertRowOffset += element.bounds.height() + 1;						isNewRow = true;					}				}			}			else {				ul.y += insertRowOffset;				ul.y -= deleteRowOffset;								if (ul.y > rowTop) {					// next row					isNewRow = false;					rowTop = rowBottom + spacingY;				}			}						// align shape at row top			ul.y = rowTop;			lr.y = ul.y + element.bounds.height();						if (lr.y > rowBottom) {				// extend row height and inserted rows offset				// following lines don't work as required				if (isNewRow) 					insertRowOffset += lr.y - rowBottom;				else 					if (movedShapes.include(element)) 						insertRowOffset += lr.y - rowBottom;				rowBottom = lr.y;			}						if ((ul.x != oldUlX) || (ul.y != oldUlY) || (lr.x != oldLrX) || (lr.y != oldLrY)) {				// only set bounds if ul or lr updated				if (!movedShapes.include(element)) {					// if non-moved elements are repositioned upwards also move following [moved] elements upwards					// (otherwise dropping the moved element to a row below wouldn't work correctly)					if ((oldUlY - ul.y) > deleteRowOffset) 						deleteRowOffset = oldUlY - ul.y;				}				element.bounds.set(ul.x, ul.y, lr.x, lr.y);			}		});				// Sort top-down from left to right		elements = elements.sortBy(function(element){			return element.bounds.upperLeft().y * 10000 + element.bounds.upperLeft().x;		});				rowTop = marginTop;		var rowRight = marginLeft - spacingX;		var maxRowRight = rowRight;		var maxRowBottom = 0;				// Arrange shapes on rows (align left)		elements.each(function(element){					var ul = element.bounds.upperLeft();			var lr = element.bounds.lowerRight();						// save old values			var oldUlX = ul.x;			var oldUlY = ul.y;			var oldLrX = lr.x;			var oldLrY = lr.y;						if (ul.y > rowTop) {				// next row				rowTop = ul.y;				rowRight = marginLeft - spacingX;			}						// align at right border of the row			ul.x = rowRight + spacingX;			lr.x = ul.x + element.bounds.width();			rowRight = lr.x;						if (rowRight > maxRowRight) 				maxRowRight = rowRight;			if (lr.y > maxRowBottom) 				maxRowBottom = lr.y;						if ((ul.x != oldUlX) || (ul.y != oldUlY) || (lr.x != oldLrX) || (lr.y != oldLrY)) {				// only set bounds if ul or lr updated				element.bounds.set(ul.x, ul.y, lr.x, lr.y);			}					});				if (event.shape != this.facade.getCanvas()) {			// adjust parents bounds			var ul = event.shape.bounds.upperLeft();			if (maxRowRight > marginLeft) 				event.shape.bounds.set(ul.x, ul.y, ul.x + maxRowRight + marginLeft, ul.y + rowBottom + marginTop);		}		else {			// extend canvas size if necessary			if (maxRowRight > this.facade.getCanvas().bounds.width()) {				this.facade.getCanvas().setSize({					width: (maxRowRight + marginLeft),					height: this.facade.getCanvas().bounds.height()				});			}			if (maxRowBottom > this.facade.getCanvas().bounds.height()) {				this.facade.getCanvas().setSize({					width: this.facade.getCanvas().bounds.width(),					height: (rowBottom + marginTop)				});			}		}						return;	}
};ORYX.Plugins.RowLayouting = Clazz.extend(ORYX.Plugins.RowLayouting);/**
 * Copyright (c) 2008
 * Jan-Felix Schwarz
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * The XForms plugin provides layout methods primarily referring to the XForms stencilset. 
 * 
 * @class ORYX.Plugins.XForms
 * @extends Clazz
 * @param {Object} facade The facade of the editor
 */
ORYX.Plugins.XForms = 
/** @lends ORYX.Plugins.XForms.prototype */
{
	/**
	 * Creates a new instance of the XForms plugin and registers it on the
	 * layout events listed in the XForms stencil set.
	 * 
	 * @constructor
	 * @param {Object} facade The facade of the editor
	 */
	construct: function(facade) {
		this.facade = facade;
		this.facade.registerOnEvent('layout.xforms.label', this.handleLayoutLabel.bind(this));
		this.facade.registerOnEvent('layout.xforms.label.button', this.handleLayoutLabelButton.bind(this));
		this.facade.registerOnEvent('layout.xforms.label.item', this.handleLayoutLabelItem.bind(this));
		this.facade.registerOnEvent('layout.xforms.item', this.handleLayoutItem.bind(this));
		this.facade.registerOnEvent('layout.xforms.case', this.handleLayoutCase.bind(this));
		this.facade.registerOnEvent('layout.xforms.action', this.handleLayoutAction.bind(this));
	},
	
	/**
	 * 
	 * @param {Object} event
	 */
	handleLayoutLabel : function(event) {
		var shape = event.shape;
		var moveX = event.moveX;
		var moveY = event.moveY;
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
				return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
			});
			
			if(labels.length > 0) {
				labels.each(function(label) {
					var ul = label.bounds.upperLeft();
					var lr = label.bounds.lowerRight();
					ul.y = - label.bounds.height() + moveY;
					lr.y = moveY;
					ul.x = moveX;
					lr.x = label.bounds.width() + moveX;
					label.bounds.set(ul, lr);
				});
			}
	},
	
	handleLayoutLabelButton : function(event) {
		var shape = event.shape;
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
		});
		
		if(labels.length > 0) {
			labels.each(function(label) {
				
				var ul = label.bounds.upperLeft();
				var lr = label.bounds.lowerRight();
				ul.y = 2;
				lr.y = 2 + label.bounds.height();
				
				if((shape.bounds.width()-4)<label.bounds.width()) {
					var sul = shape.bounds.upperLeft();
					var slr = shape.bounds.lowerRight();
					slr.x = sul.x + label.bounds.width() + 4;
					shape.bounds.set(sul, slr);
				}

				ul.x = (shape.bounds.width() - 4 - label.bounds.width()) * 0.5;
				lr.x = ul.x + label.bounds.width();
				label.bounds.set(ul, lr);
			});
		}
	},
	
	handleLayoutItem : function(event) {
		var shape = event.shape;
		
		var items = shape.getChildNodes(false).findAll(function(node) {
			return ((node.getStencil().id()==="http://b3mn.org/stencilset/xforms#Item")||(node.getStencil().id()==="http://b3mn.org/stencilset/xforms#Choices")||(node.getStencil().id()==="http://b3mn.org/stencilset/xforms#Itemset"));
		});
		
		if(items.length > 0) {
		
			items = items.sortBy(function(item) {
				return item.bounds.upperLeft().y;
			});
			
			var shapeWidth = shape.bounds.width();
			var shapeHeight = 0;
			items.each(function(item) {
				var ul = item.bounds.upperLeft();
				var lr = item.bounds.lowerRight();
				if(item.getStencil().id()==="http://b3mn.org/stencilset/xforms#Choices") {
					ul.y = shapeHeight + 25;
					shapeHeight += 25;
				} else {
					ul.y = shapeHeight + 5;
					shapeHeight += 5;
				}
				lr.y = ul.y + item.bounds.height();
				shapeHeight += item.bounds.height();
				ul.x = 30;
				lr.x = shapeWidth;
				item.bounds.set(ul, lr);
			});
			
			var upl = shape.bounds.upperLeft();
			shape.bounds.set(upl.x, upl.y, shape.bounds.lowerRight().x, upl.y + shapeHeight + 5);
		}
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
		});
		
		if(labels.length > 0) {
			labels.each(function(label) {
				var ul = label.bounds.upperLeft();
				var lr = label.bounds.lowerRight();
				ul.y = - label.bounds.height() - 1;
				lr.y = - 1;
				ul.x = 0;
				lr.x = label.bounds.width();
				label.bounds.set(ul, lr);
			});
		}
	},
	
	handleLayoutCase : function(event) {
		var shape = event.shape;
		
		var cases = shape.getChildNodes(false);
				
		var maxWidth = 0;
		cases.each(function(c) {
			if(c.bounds.width()>maxWidth) maxWidth = c.bounds.width();
		});

		if(cases.length > 0) {
			
			cases = cases.sortBy(function(c) {
				return c.bounds.upperLeft().y;
			});
			
			var shapeHeight = 5;
			cases.each(function(c) {
				var ul = c.bounds.upperLeft();
				var lr = c.bounds.lowerRight();
				ul.y = shapeHeight;
				lr.y = ul.y + c.bounds.height();
				shapeHeight += c.bounds.height() + 5;
				ul.x = 0;
				lr.x = maxWidth;
				c.bounds.set(ul, lr);
			});
			
			var upl = shape.bounds.upperLeft();
			shape.bounds.set(upl.x, upl.y, upl.x + maxWidth, upl.y + shapeHeight + 20);
		}
	},
	
	handleLayoutLabelItem : function(event) {
		var shape = event.shape;
		
		var labels = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/xforms#Label");
		});
		
		if(labels.length > 0) {
			labels.each(function(label) {
				var ul = label.bounds.upperLeft();
				var lr = label.bounds.lowerRight();
				ul.y = 2;
				ul.x = 2;
				lr.y = 2 + label.bounds.height();
				lr.x = 2 + label.bounds.width();
				label.bounds.set(ul, lr);
			});
		}
	},
	
	handleLayoutAction : function(event) {
		var shape = event.shape;
		
		var actions = shape.getChildNodes(false);

		if(actions.length > 0) {
			
			actions = actions.sortBy(function(action) {
				return action.bounds.upperLeft().y;
			});
			
			var shapeHeight = 5;
			actions.each(function(action) {
				var ul = action.bounds.upperLeft();
				var lr = action.bounds.lowerRight();
				ul.y = shapeHeight;
				lr.y = ul.y + action.bounds.height();
				shapeHeight += action.bounds.height() + 5;
				ul.x = 2;
				lr.x = 2 + action.bounds.width();
				action.bounds.set(ul, lr);
			});
			
			var upl = shape.bounds.upperLeft();
			var lor = shape.bounds.lowerRight();
			shape.bounds.set(upl.x, upl.y, lor.x, upl.y + shapeHeight + 15);
		}
	}
	
};

ORYX.Plugins.XForms = Clazz.extend(ORYX.Plugins.XForms);
/** * Copyright (c) 2008-2009 * Sven Wagner-Boysen, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.BPMN11 = {	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDockerDocked.bind(this));				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));		this.facade.registerOnEvent('layout.bpmn11.pool', this.handleLayoutPool.bind(this));		this.facade.registerOnEvent('layout.bpmn11.subprocess', this.handleSubProcess.bind(this));						this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));				//this.facade.registerOnEvent('layout.bpmn11.lane', this.handleLayoutLane.bind(this));	},		afterLoad : function(){			// Force to update ever pool		this.facade.getCanvas().getChildNodes().each(function(shape){			if (shape.getStencil().id().endsWith("Pool")) {				this.handleLayoutPool({shape:shape});			}		}.bind(this))	},		/**	 * If a pool is selected and contains no lane,	 * a lane is created automagically	 */	onSelectionChanged: function(event) {		if(event.elements && event.elements.length === 1) {			var shape = event.elements[0];			if(shape.getStencil().idWithoutNs() === "Pool") {				if(shape.getChildNodes().length === 0) {					// create a lane inside the selected pool					var option = {							type:"http://b3mn.org/stencilset/bpmn1.1#Lane",							position:{x:0,y:0},							namespace:shape.getStencil().namespace(),							parent:shape					};					this.facade.createShape(option);					this.facade.getCanvas().update();				}			}		}	},		hashedSubProcesses: {},		handleSubProcess : function(option) {				var sh = option.shape;				if (!this.hashedSubProcesses[sh.resourceId]) {			this.hashedSubProcesses[sh.resourceId] = sh.bounds.clone();			return;		}				var offset = sh.bounds.upperLeft();		offset.x -= this.hashedSubProcesses[sh.resourceId].upperLeft().x;		offset.y -= this.hashedSubProcesses[sh.resourceId].upperLeft().y;				this.hashedSubProcesses[sh.resourceId] = sh.bounds.clone();				this.moveChildDockers(sh, offset);			},		moveChildDockers: function(shape, offset){				if (!offset.x && !offset.y) {			return;		} 				// Get all nodes		shape.getChildNodes(true)			// Get all incoming and outgoing edges			.map(function(node){				return [].concat(node.getIncomingShapes())						.concat(node.getOutgoingShapes())			})			// Flatten all including arrays into one			.flatten()			// Get every edge only once			.uniq()			// Get all dockers			.map(function(edge){				return edge.dockers.length > 2 ? 						edge.dockers.slice(1, edge.dockers.length-1) : 						[];			})			// Flatten the dockers lists			.flatten()			.each(function(docker){				if (docker.isChanged){ return }				docker.bounds.moveBy(offset);			})	},		/**	 * DragDocker.Docked Handler	 *	 */		handleDockerDocked: function(options) {		var edge = options.parent;		var edgeSource = options.target;				if(edge.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#SequenceFlow") {			var isGateway = edgeSource.getStencil().groups().find(function(group) {					if(group == "Gateways") 						return group;				});			if(!isGateway && (edge.properties["oryx-conditiontype"] == "Expression"))				// show diamond on edge source				edge.setProperty("oryx-showdiamondmarker", true);			else 				// do not show diamond on edge source				edge.setProperty("oryx-showdiamondmarker", false);						// update edge rendering			//edge.update();						this.facade.getCanvas().update();		}	},		/**	 * PropertyWindow.PropertyChanged Handler	 */	handlePropertyChanged: function(option) {				var shapes = option.elements;		var propertyKey = option.key;		var propertyValue = option.value;				var changed = false;		shapes.each(function(shape){			if((shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#SequenceFlow") &&				(propertyKey === "oryx-conditiontype")) {								if(propertyValue != "Expression")					// Do not show the Diamond					shape.setProperty("oryx-showdiamondmarker", false);				else {					var incomingShapes = shape.getIncomingShapes();										if(!incomingShapes) {						shape.setProperty("oryx-showdiamondmarker", true);					}										var incomingGateway = incomingShapes.find(function(aShape) {						var foundGateway = aShape.getStencil().groups().find(function(group) {							if(group == "Gateways") 								return group;						});						if(foundGateway)							return foundGateway;					});										if(!incomingGateway) 						// show diamond on edge source						shape.setProperty("oryx-showdiamondmarker", true);					else						// do not show diamond						shape.setProperty("oryx-showdiamondmarker", false);				}								changed = true;			}		});				if(changed) {this.facade.getCanvas().update();}			},		hashedPoolPositions : {},	hashedLaneDepth : {},	hashedBounds : {},		handleLayoutPool: function(event){				var pool = event.shape;		var selection = this.facade.getSelection(); 		var currentShape = selection.first();				// Check if the current shape is one of the children of the pool		if (currentShape instanceof ORYX.Core.UIObject){			currentShape = currentShape.isParent(pool) ? currentShape : pool;		} else {			currentShape = pool;		}				// Check if it is a pool or a lane		if (!(currentShape.getStencil().id().endsWith("Pool") || currentShape.getStencil().id().endsWith("Lane"))) {			return;		}				if (!this.hashedBounds[pool.resourceId]) {			this.hashedBounds[pool.resourceId] = {};		}		this.currentPool = pool;				// Find all child lanes		var lanes = this.getLanes(pool);				if (lanes.length <= 0) {			return		}				// Show/hide caption regarding the number of lanes		if (lanes.length === 1 && this.getLanes(lanes.first()).length <= 0) {			// TRUE if there is a caption			lanes.first().setProperty("oryx-showcaption", lanes.first().properties["oryx-name"].trim().length > 0);		} else {			lanes.invoke("setProperty", "oryx-showcaption", true);		}								var allLanes = this.getLanes(pool, true);				var deletedLanes = [];		var addedLanes = [];				// Get all new lanes		var i=-1;		while (++i<allLanes.length) {			if (!this.hashedBounds[pool.resourceId][allLanes[i].resourceId]){				addedLanes.push(allLanes[i])			}		}				if (addedLanes.length > 0){			currentShape = addedLanes.first();		}						// Get all deleted lanes		var resourceIds = $H(this.hashedBounds[pool.resourceId]).keys();		var i=-1;		while (++i<resourceIds.length) {			if (!allLanes.any(function(lane){ return lane.resourceId == resourceIds[i]})){				deletedLanes.push(this.hashedBounds[pool.resourceId][resourceIds[i]]);				selection = selection.without(function(r){ return r.resourceId == resourceIds[i] });			}		}								var height, width;				if (deletedLanes.length > 0 || addedLanes.length > 0) {						// Set height from the pool			height = this.updateHeight(pool);			// Set width from the pool			width = this.adjustWidth(lanes, pool.bounds.width());							pool.update();		}				/**		 * Set width/height depending on the pool		 */		else if (pool == currentShape) {						// Set height from the pool			height = this.adjustHeight(lanes, undefined, pool.bounds.height());			// Set width from the pool			width = this.adjustWidth(lanes, pool.bounds.width());				}				/**‚		 * Set width/height depending on containing lanes		 */				else {			// Get height and adjust child heights			height = this.adjustHeight(lanes, currentShape);			// Set width from the current shape			width = this.adjustWidth(lanes, currentShape.bounds.width()+(this.getDepth(currentShape,pool)*30));		}				this.setDimensions(pool, width, height);								// Update all dockers		this.updateDockers(allLanes, pool);				this.hashedBounds[pool.resourceId] = {};				var i=-1;		while (++i < allLanes.length) {			// Cache positions			this.hashedBounds[pool.resourceId][allLanes[i].resourceId] = allLanes[i].absoluteBounds();						this.hashedLaneDepth[allLanes[i].resourceId] = this.getDepth(allLanes[i], pool);						this.forceToUpdateLane(allLanes[i]);		}				this.hashedPoolPositions[pool.resourceId] = pool.bounds.clone();						// Update selection		//this.facade.setSelection(selection);			},		forceToUpdateLane: function(lane){				if (lane.bounds.height() !== lane._svgShapes[0].height) {				lane.isChanged = true;			lane.isResized = true;			lane._update();		}	},		getDepth: function(child, parent){				var i=0;		while(child && child.parent && child !== parent){			child = child.parent;			++i		}		return i;	},		updateDepth: function(lane, fromDepth, toDepth){				var xOffset = (fromDepth - toDepth) * 30;				lane.getChildNodes().each(function(shape){			shape.bounds.moveBy(xOffset, 0);						[].concat(children[j].getIncomingShapes())					.concat(children[j].getOutgoingShapes())							})			},		setDimensions: function(shape, width, height){		var isLane = shape.getStencil().id().endsWith("Lane");		// Set the bounds		shape.bounds.set(				isLane ? 30 : shape.bounds.a.x, 				shape.bounds.a.y, 				width	? shape.bounds.a.x + width - (isLane?30:0) : shape.bounds.b.x, 				height 	? shape.bounds.a.y + height : shape.bounds.b.y			);	},	setLanePosition: function(shape, y){		shape.bounds.moveTo(30, y);	},			adjustWidth: function(lanes, width) {				// Set width to each lane		(lanes||[]).each(function(lane){			this.setDimensions(lane, width);			this.adjustWidth(this.getLanes(lane), width-30);		}.bind(this));				return width;	},			adjustHeight: function(lanes, changedLane, propagateHeight){				var oldHeight = 0;		if (!changedLane && propagateHeight){			var i=-1;			while (++i<lanes.length){					oldHeight += lanes[i].bounds.height();					}		}				var i=-1;		var height = 0;				// Iterate trough every lane		while (++i<lanes.length){						if (lanes[i] === changedLane) {				// Propagate new height down to the children				this.adjustHeight(this.getLanes(lanes[i]), undefined, lanes[i].bounds.height());								lanes[i].bounds.set({x:30, y:height}, {x:lanes[i].bounds.width()+30, y:lanes[i].bounds.height()+height})											} else if (!changedLane && propagateHeight) {								var tempHeight = (lanes[i].bounds.height() * propagateHeight) / oldHeight;				// Propagate height				this.adjustHeight(this.getLanes(lanes[i]), undefined, tempHeight);				// Set height propotional to the propagated and old height				this.setDimensions(lanes[i], null, tempHeight);				this.setLanePosition(lanes[i], height);			} else {				// Get height from children				var tempHeight = this.adjustHeight(this.getLanes(lanes[i]), changedLane, propagateHeight);				if (!tempHeight) {					tempHeight = lanes[i].bounds.height();				}				this.setDimensions(lanes[i], null, tempHeight);				this.setLanePosition(lanes[i], height);			}						height += lanes[i].bounds.height();		}				return height;			},			updateHeight: function(root){				var lanes = this.getLanes(root);				if (lanes.length == 0){			return root.bounds.height();		}				var height = 0;		var i=-1;		while (++i < lanes.length) {			this.setLanePosition(lanes[i], height);			height += this.updateHeight(lanes[i]);		}				this.setDimensions(root, null, height);				return height;	},		getOffset: function(lane, includePool, pool){				var offset = {x:0,y:0};						/*var parent = lane; 		 while(parent) {		 										var offParent = this.hashedBounds[pool.resourceId][parent.resourceId] ||(includePool === true ? this.hashedPoolPositions[parent.resourceId] : undefined);			if (offParent){				var ul = parent.bounds.upperLeft();				var ulo = offParent.upperLeft();				offset.x += ul.x-ulo.x;				offset.y += ul.y-ulo.y;			}						if (parent.getStencil().id().endsWith("Pool")) {				break;			}						parent = parent.parent;		}	*/				var offset = lane.absoluteXY();				var hashed = this.hashedBounds[pool.resourceId][lane.resourceId] ||(includePool === true ? this.hashedPoolPositions[lane.resourceId] : undefined);		if (hashed) {			offset.x -= hashed.upperLeft().x; 				offset.y -= hashed.upperLeft().y;				} else {			return {x:0,y:0}		}				return offset;	},		getNextLane: function(shape){		while(shape && !shape.getStencil().id().endsWith("Lane")){			if (shape instanceof ORYX.Core.Canvas) {				return null;			}			shape = shape.parent;		}		return shape;	},		getParentPool: function(shape){		while(shape && !shape.getStencil().id().endsWith("Pool")){			if (shape instanceof ORYX.Core.Canvas) {				return null;			}			shape = shape.parent;		}		return shape;	},	updateDockers: function(lanes, pool){				var absPool = pool.absoluteBounds();		var oldPool = (this.hashedPoolPositions[pool.resourceId]||absPool).clone();				var i=-1, j=-1, k=-1, l=-1, docker;		var dockers = {};				while (++i < lanes.length) {						if (!this.hashedBounds[pool.resourceId][lanes[i].resourceId]) {				continue;			}						var children = lanes[i].getChildNodes();			var absBounds = lanes[i].absoluteBounds();			var oldBounds = (this.hashedBounds[pool.resourceId][lanes[i].resourceId]||absBounds);			//oldBounds.moveBy((absBounds.upperLeft().x-lanes[i].bounds.upperLeft().x), (absBounds.upperLeft().y-lanes[i].bounds.upperLeft().y));			var offset = this.getOffset(lanes[i], true, pool);			var xOffsetDepth = 0;			var depth = this.getDepth(lanes[i], pool);			if ( this.hashedLaneDepth[lanes[i].resourceId] !== undefined &&  this.hashedLaneDepth[lanes[i].resourceId] !== depth) {				xOffsetDepth = (this.hashedLaneDepth[lanes[i].resourceId] - depth) * 30;				offset.x += xOffsetDepth;			}						j=-1;						while (++j < children.length) {								if (xOffsetDepth) {					children[j].bounds.moveBy(xOffsetDepth, 0);				}								if (children[j].getStencil().id().endsWith("Subprocess")) {					this.moveChildDockers(children[j], offset);				}								var edges = [].concat(children[j].getIncomingShapes())					.concat(children[j].getOutgoingShapes())					// Remove all edges which are included in the selection from the list					.findAll(function(r){ return r instanceof ORYX.Core.Edge })				k=-1;				while (++k < edges.length) {													if (edges[k].getStencil().id().endsWith("MessageFlow")) {						this.layoutEdges(children[j], [edges[k]], offset);						continue;					}										l=-1;					while (++l < edges[k].dockers.length) {												docker = edges[k].dockers[l];												if (docker.getDockedShape()||docker.isChanged){							continue;						}											pos = docker.bounds.center();												// Check if the modified center included the new position						var isOverLane = oldBounds.isIncluded(pos);						// Check if the original center is over the pool						var isOutSidePool = !oldPool.isIncluded(pos);						var previousIsOverLane = l == 0 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l-1].bounds.center());						var nextIsOverLane = l == edges[k].dockers.length-1 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l+1].bounds.center());																		// Check if the previous dockers docked shape is from this lane						// Otherwise, check if the docker is over the lane OR is outside the lane 						// but the previous/next was over this lane						if (isOverLane){							dockers[docker.id] = {docker: docker, offset:offset};						} 						/*else if (l == 1 && edges[k].dockers.length>2 && edges[k].dockers[l-1].isDocked()){							var dockedLane = this.getNextLane(edges[k].dockers[l-1].getDockedShape());							if (dockedLane != lanes[i])								continue;							dockers[docker.id] = {docker: docker, offset:offset};						}						// Check if the next dockers docked shape is from this lane						else if (l == edges[k].dockers.length-2 && edges[k].dockers.length>2 && edges[k].dockers[l+1].isDocked()){							var dockedLane = this.getNextLane(edges[k].dockers[l+1].getDockedShape());							if (dockedLane != lanes[i])								continue;							dockers[docker.id] = {docker: docker, offset:offset};						}																		else if (isOutSidePool) {							dockers[docker.id] = {docker: docker, offset:this.getOffset(lanes[i], true, pool)};						}*/																}				}									}		}				// Set dockers		i=-1;		var keys = $H(dockers).keys();		while (++i < keys.length) {			dockers[keys[i]].docker.bounds.moveBy(dockers[keys[i]].offset);		}	},		moveBy: function(pos, offset){		pos.x += offset.x;		pos.y += offset.y;		return pos;	},		getHashedBounds: function(shape){		return this.currentPool && this.hashedBounds[this.currentPool.resourceId][shape.resourceId] ? this.hashedBounds[this.currentPool.resourceId][shape.resourceId] : shape.bounds.clone();	},		/**	 * Returns a set on all child lanes for the given Shape. If recursive is TRUE, also indirect children will be returned (default is FALSE)	 * The set is sorted with first child the lowest y-coordinate and the last one the highest.	 * @param {ORYX.Core.Shape} shape	 * @param {boolean} recursive	 */	getLanes: function(shape, recursive){		var lanes = shape.getChildNodes(recursive||false).findAll(function(node) { return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane"); });		lanes = lanes.sort(function(a, b){					// Get y coordinate					var ay = Math.round(a.bounds.upperLeft().y);					var by = Math.round(b.bounds.upperLeft().y);										// If equal, than use the old one					if (ay == by) {						ay = Math.round(this.getHashedBounds(a).upperLeft().y);						by = Math.round(this.getHashedBounds(b).upperLeft().y);					}					return  ay < by ? -1 : (ay > by ? 1 : 0)				}.bind(this))		return lanes;	},			/**	 * "layout.bpmn11.pool" handler	 * @param {Object} event	 */		handleLayoutPool_deprecated: function(event) {		var shape = event.shape;				// Find all direct lane children		var lanes = shape.getChildNodes(false).findAll(function(node) {			return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");		});		// If there are lanes...		if(lanes.length > 0) {						// only one lane in pool			if(lanes.length == 1) {								// test whether the sole lane has child lanes				var childLanes = lanes.first().getChildNodes(false).findAll(function(node) {					return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");				});				if(childLanes.length > 0) {					lanes.first().setProperty("oryx-showcaption", true);				} else {					if(lanes.first().properties["oryx-name"].trim().length > 0) {						lanes.first().setProperty("oryx-showcaption", true);					} else {						lanes.first().setProperty("oryx-showcaption", false);					}					// adapt height and width of the lane by size of the pool					// the lowerRight bound is equal to that of the containing pool					var singleLane = lanes.first();					var laneUpperLeft = singleLane.bounds.upperLeft();					laneUpperLeft.x = 30;					laneUpperLeft.y = 0;					var laneLowerRight = singleLane.bounds.lowerRight();					laneLowerRight.x = shape.bounds.width();					laneLowerRight.y = shape.bounds.height();					return;				}			} else {				lanes.each(function(lane) {					lane.setProperty("oryx-showcaption", true);				});			}						lanes = lanes.sortBy(function(lane) {				return lane.bounds.upperLeft().y;			});									var shapeWidth = shape.bounds.width();			lanes.each(function(lane) {				if(lane.isChanged)					shapeWidth = lane.bounds.width() + 30;			});									// get deepest childs in each branch			var firstLanes = lanes.clone();			var turn = 1;						do {								var allChildLanes = new Array();				var parentLanes = lanes.findAll(function(lane) {									var childLanes = lane.getChildNodes(false).findAll(function(node) {						return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");					});									if(childLanes.length > 0) {						allChildLanes = allChildLanes.concat(childLanes);						return true;					}				});									// set bounds of deepest child lanes				var shapeUpperLeft = shape.bounds.upperLeft();				allChildLanes.each(function(lane) {					var upperLeft = lane.bounds.upperLeft();					var lowerRight = lane.bounds.lowerRight();					lowerRight.x = shapeWidth-30*turn;					lane.bounds.set(upperLeft, lowerRight);				});							lanes = allChildLanes.clone();				turn++;							} while(parentLanes.length > 0);						var shapeHeight = 0;			var topBound = 0;			var offsets = [];			firstLanes.each(function(lane) {				var ul = lane.bounds.upperLeft();				var lr = lane.bounds.lowerRight();				ul.y = shapeHeight;				lr.y = ul.y + lane.bounds.height();				shapeHeight += lane.bounds.height();				ul.x = 30;				lr.x = shapeWidth;								offsets.push({					x: ul.x - lane.bounds.upperLeft().x,					y: ul.y - lane.bounds.upperLeft().y									})								//this.handleChildNodes(lane.getChildNodes(true), offset);				lane.bounds.set(ul, lr);							}.bind(this));						this.handleDockers(firstLanes, offsets)						var upl = shape.bounds.upperLeft();			shape.bounds.set(upl.x, upl.y, upl.x + shapeWidth, upl.y + shapeHeight);		}	},		/**	 * "layout.bpmn11.lane" handler	 * @param {Object} event	 */	handleLayoutLane: function(event) {				var shape = event.shape;		var lanes = shape.getChildNodes(false).findAll(function(node) {			return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn1.1#Lane");		});				if(lanes.length > 0) {			lanes = lanes.sortBy(function(lane) {				return lane.bounds.upperLeft().y;			});						var shapeWidth = shape.bounds.width();						lanes.each(function(lane) {				if(lane.isChanged) {					shapeWidth = lane.bounds.width()+30;				}			});						var shapeHeight = 0;			var topBound = 0;			lanes.each(function(lane) {				var ul = lane.bounds.upperLeft();				var lr = lane.bounds.lowerRight();				ul.y = shapeHeight;				lr.y = ul.y + lane.bounds.height();				shapeHeight += lane.bounds.height();				ul.x = 30;				lr.x = shapeWidth;								var offset = {					x: ul.x - lane.bounds.upperLeft().x,					y: ul.y - lane.bounds.upperLeft().y									}								this.handleChildNodes(lane.getChildNodes(true), offset);								lane.bounds.set(ul, lr);			}.bind(this));						var upl = shape.bounds.upperLeft();			shape.bounds.set(upl.x, upl.y, upl.x + shapeWidth, upl.y + shapeHeight);		}	},			handleDockers : function(lanes, offsets){						var i=-1, j=-1, k=-1, l=-1, docker;		while (++i < lanes.length) {			var children = lanes[i].getChildNodes(true);								j=-1;			while (++j < children.length) {								var edges = [].concat(children[j].getIncomingShapes())					.concat(children[j].getOutgoingShapes())					// Remove all edges which are included in the selection from the list					.findAll(function(r){ return r instanceof ORYX.Core.Edge})								k=-1;				while (++k < edges.length) {					l=-1;					while (++l < edges[k].dockers.length) {						docker = edges[k].dockers[l];						pos = docker.bounds.center();						pos.x += offsets[i].x;						pos.y += offsets[i].y;						if (!lanes.any(function(r){ return r != lanes[i] && r.absoluteBounds().isIncluded(pos) })){							docker.bounds.moveBy({x:0, y:-offsets[i].y});						}										}				}									}		}	},		/**	 * Handles the layouting for all child nodes	 * @param {Object} node	 */	handleChildNodes : function(nodes, offset){				return ;		//				var i=-1, j=-1, k=-1, docker;		var allEdges = [];						while(++i<nodes.length){			// Find all edges			var edges = [].concat(nodes[i].getIncomingShapes())				.concat(nodes[i].getOutgoingShapes())				// Remove all edges which are included in the selection from the list				.findAll(function(r){ return r instanceof ORYX.Core.Edge && !allEdges.include(r)})						if (edges.length <= 0){ continue }															allEdges = allEdges.concat(edges);			this.layoutEdges(nodes[i], edges, offset);			if (offset.x !== 0) {				j=-1				while (++j < allEdges.length) {					k=-1;					while (++k < allEdges[j].dockers.length) {						docker = allEdges[j].dockers[k];						if (docker.getDockedShape()){ continue }						docker.bounds.moveBy({x:-offset.x, y:-offset.y})					}				}			}		}	}};ORYX.Plugins.BPMN11 = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN11);/**
 * Copyright (c) 2009
 * Ingo Kitzmann, Christoph Koenig
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if (!ORYX) 
	ORYX = new Object();
if (!ORYX.Plugins) 
	ORYX.Plugins = new Object();

ORYX.Plugins.BpmnLayouter = ORYX.Plugins.AbstractPlugin.extend({
	facade: undefined,
	construct: function(facade){
		this.facade = facade;
		this.facade.offer({
			'name' : "Layout-BPMN",
			'description' : "Layout BPMN Model",
			'functionality' : this.layout.bind(this),
			'group' : "Layout",
			'icon' : ORYX.PATH + "images/auto_layout.png",
			'index' : 1,
			'minShape' : 0,
			'maxShape' : 0
		});
	},
	layout: function(){
		
		this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
			text: ORYX.I18N.Layouting.doing
        });
		
		
		new Ajax.Request(ORYX.CONFIG.BPMN_LAYOUTER, {
			method : 'POST',
			asynchronous : false,
			parameters : {
				data: this.facade.getSerializedJSON(),
				output: "coordinatesonly"
			},
			onFailure: function(request){
				Ext.Msg.alert("Layouting Error", "Error while layouting:!\n" + request.responseText);
            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			},
			onSuccess: function(request){

				/*Ext.Msg.alert("Oryx", "New Layout arrived:!\n" + request.responseText);*/
				
				var setLayoutCommandClass = ORYX.Core.Command.extend({
					construct: function(layoutArray, plugin){
						this.layoutArray = layoutArray;
						this.plugin = plugin;
						this.oldLayoutArray = [];
					},
					execute: function(){
						this.layoutArray.each(function(elem){
							/* get shape */
							var shape = this.plugin.facade.getCanvas().getChildShapeByResourceId(elem.id);
							
							/* save old layout for undo*/
							var oldLayout = {
								id : elem.id,
								bounds : shape.bounds.clone()
							};
							this.oldLayoutArray.push(oldLayout);
							
							/* set new bounds */
							var bound = elem.bounds.split(" ");
							shape.bounds.set(bound[0],bound[1],bound[2],bound[3]);
							
							/* set new dockers */
							if(elem.dockers != null){
								this.plugin.setDockersBad(shape,elem.dockers);
							}
							
							shape.update();
						}.bind(this));
						
						this.plugin.facade.getCanvas().update();
						this.plugin.facade.updateSelection();					
						
					},
					rollback: function(){
						this.oldLayoutArray.each(function(elem){
							var shape = this.plugin.facade.getCanvas().getChildShapeByResourceId(elem.id);
							shape.bounds.set(elem.bounds);
							shape.update();
						}.bind(this));
						
						this.plugin.facade.getCanvas().update();
						this.plugin.facade.updateSelection();	
					}
				});
				
				
				var resp = request.responseText.evalJSON();
				if (resp instanceof Array && resp.size() > 0) {
					/* create command */
					var command = new setLayoutCommandClass(resp, this);
					/* execute command */
					this.facade.executeCommands([command]);
				}
            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			}.bind(this)
		})
	},
	setDockersBad: function(shape, dockers){
		var dockersString = "";
		dockers.each(function(p){
			dockersString += p.x + " " + p.y + " ";
		});
		dockersString += " # ";
		shape.deserialize([{
								prefix: 'oryx',
								name: 'dockers',
								value: dockersString
							}]);
	},
	setDockersGood: function(shape, dockers){
		if(elem.dockers.length == 1){
			/* docked event */
			
		}else{
			
			/* clear all except of the first and last dockers */
			var dockers = shape.getDockers().slice(1,-1);
			dockers.each(function(docker){
				shape.removeDocker(docker);
			});
			
			/* set first and last docker */
			var firstDocker = shape.getDockers()[0];
			if (firstDocker.getDockedShape()) {
				firstDocker.setReferencePoint(elem.dockers[0]);
			}
			else {
				firstDocker.bounds.moveTo(elem.dockers[0].x,elem.dockers[0].y);
			}
			firstDocker.refresh();
			
			var lastDocker = shape.getDockers()[1];
			if (lastDocker.getDockedShape()) {
				lastDocker.setReferencePoint(elem.dockers[elem.dockers.length - 1]);
			}
			else {
				lastDocker.bounds.moveTo(elem.dockers[elem.dockers.length - 1].x, elem.dockers[elem.dockers.length - 1].y);
			}
			lastDocker.refresh();
			
			/* add new dockers except of the first and last */
			var dockersToAdd = elem.dockers.slice(1,-1);
			dockersToAdd.each(function(dockerPoint){
				var newDocker = shape.createDocker(undefined, dockerPoint);
				newDocker.parent = shape;
				newDocker.bounds.centerMoveTo(dockerPoint.x, dockerPoint.y);
				/*newDocker.setReferencePoint(dockerPoint);*/
				newDocker.update();
			});
		}		
	}
});
/**
 * Copyright (c) 2009
 * Sven Wagner-Boysen, Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.BPMN2_0 = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade){
		this.facade = facade;
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDockerDocked.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.pool', this.handleLayoutPool.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.subprocess', this.handleSubProcess.bind(this));
		
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));
		
		//this.facade.registerOnEvent('layout.bpmn11.lane', this.handleLayoutLane.bind(this));
	},
	
	/**
	 * Force to update every pool
	 */
	afterLoad: function(){
		this.facade.getCanvas().getChildNodes().each(function(shape){
			if (shape.getStencil().id().endsWith("Pool")) {
				this.handleLayoutPool({
					shape: shape
				});
			}
		}.bind(this))
	},
	
	/**
	 * If a pool is selected and contains no lane,
	 * a lane is created automagically
	 */
	onSelectionChanged: function(event) {
		if(event.elements && event.elements.length === 1) {
			var shape = event.elements[0];
			if(shape.getStencil().idWithoutNs() === "Pool") {
				if(shape.getChildNodes().length === 0) {
					// create a lane inside the selected pool
					var option = {
							type:"http://b3mn.org/stencilset/bpmn2.0#Lane",
							position:{x:0,y:0},
							namespace:shape.getStencil().namespace(),
							parent:shape
					};
					this.facade.createShape(option);
					this.facade.getCanvas().update();
				}
			}
		}
	},
	
	hashedSubProcesses: {},
	
	handleSubProcess : function(option) {
		
		var sh = option.shape;
		
		if (!this.hashedSubProcesses[sh.resourceId]) {
			this.hashedSubProcesses[sh.resourceId] = sh.bounds.clone();
			return;
		}
		
		var offset = sh.bounds.upperLeft();
		offset.x -= this.hashedSubProcesses[sh.resourceId].upperLeft().x;
		offset.y -= this.hashedSubProcesses[sh.resourceId].upperLeft().y;
		
		this.hashedSubProcesses[sh.resourceId] = sh.bounds.clone();
		
		this.moveChildDockers(sh, offset);
		
	},
	
	moveChildDockers: function(shape, offset){
		
		if (!offset.x && !offset.y) {
			return;
		} 
		
		// Get all nodes
		shape.getChildNodes(true)
			// Get all incoming and outgoing edges
			.map(function(node){
				return [].concat(node.getIncomingShapes())
						.concat(node.getOutgoingShapes())
			})
			// Flatten all including arrays into one
			.flatten()
			// Get every edge only once
			.uniq()
			// Get all dockers
			.map(function(edge){
				return edge.dockers.length > 2 ? 
						edge.dockers.slice(1, edge.dockers.length-1) : 
						[];
			})
			// Flatten the dockers lists
			.flatten()
			.each(function(docker){
				if (docker.isChanged){ return }
				docker.bounds.moveBy(offset);
			})
	},
	
	/**
	 * DragDocker.Docked Handler
	 *
	 */	
	handleDockerDocked: function(options) {
		var edge = options.parent;
		var edgeSource = options.target;
		
		if(edge.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#SequenceFlow") {
			var isGateway = edgeSource.getStencil().groups().find(function(group) {
					if(group == "Gateways") 
						return group;
				});
			if(!isGateway && (edge.properties["oryx-conditiontype"] == "Expression"))
				// show diamond on edge source
				edge.setProperty("oryx-showdiamondmarker", true);
			else 
				// do not show diamond on edge source
				edge.setProperty("oryx-showdiamondmarker", false);
			
			// update edge rendering
			//edge.update();
			
			this.facade.getCanvas().update();
		}
	},
	
	/**
	 * PropertyWindow.PropertyChanged Handler
	 */
	handlePropertyChanged: function(option) {
		
		var shapes = option.elements;
		var propertyKey = option.key;
		var propertyValue = option.value;
		
		var changed = false;
		shapes.each(function(shape){
			if((shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#SequenceFlow") &&
				(propertyKey === "oryx-conditiontype")) {
				
				if(propertyValue != "Expression")
					// Do not show the Diamond
					shape.setProperty("oryx-showdiamondmarker", false);
				else {
					var incomingShapes = shape.getIncomingShapes();
					
					if(!incomingShapes) {
						shape.setProperty("oryx-showdiamondmarker", true);
					}
					
					var incomingGateway = incomingShapes.find(function(aShape) {
						var foundGateway = aShape.getStencil().groups().find(function(group) {
							if(group == "Gateways") 
								return group;
						});
						if(foundGateway)
							return foundGateway;
					});
					
					if(!incomingGateway) 
						// show diamond on edge source
						shape.setProperty("oryx-showdiamondmarker", true);
					else
						// do not show diamond
						shape.setProperty("oryx-showdiamondmarker", false);
				}
				
				changed = true;
			}
		});
		
		if(changed) {this.facade.getCanvas().update();}
		
	},
	
	hashedPoolPositions : {},
	hashedLaneDepth : {},
	hashedBounds : {},
	
	/**
	 * Handler for layouting event 'layout.bpmn2_0.pool'
	 * @param {Object} event
	 */
	handleLayoutPool: function(event){
		
		var pool = event.shape;
		var selection = this.facade.getSelection(); 
		var currentShape = selection.first();
		
		currentShape = currentShape || pool;
		
		this.currentPool = pool;
		
		// Check if it is a pool or a lane
		if (!(currentShape.getStencil().id().endsWith("Pool") || currentShape.getStencil().id().endsWith("Lane"))) {
			return;
		}
		
		if (!this.hashedBounds[pool.resourceId]) {
			this.hashedBounds[pool.resourceId] = {};
		}
		
		// Find all child lanes
		var lanes = this.getLanes(pool);
		
		if (lanes.length <= 0) {
			return
		}
		
		// Show/hide caption regarding the number of lanes
		if (lanes.length === 1 && this.getLanes(lanes.first()).length <= 0) {
			// TRUE if there is a caption
			lanes.first().setProperty("oryx-showcaption", lanes.first().properties["oryx-name"].trim().length > 0);
			var rect = lanes.first().node.getElementsByTagName("rect");
			rect[0].setAttributeNS(null, "display", "none");
		} else {
			lanes.invoke("setProperty", "oryx-showcaption", true);
			lanes.each(function(lane){
				var rect = lane.node.getElementsByTagName("rect");
				rect[0].removeAttributeNS(null, "display");
			})
		}
		
		
		
		var allLanes = this.getLanes(pool, true);
		
		var deletedLanes = [];
		var addedLanes = [];
		
		// Get all new lanes
		var i=-1;
		while (++i<allLanes.length) {
			if (!this.hashedBounds[pool.resourceId][allLanes[i].resourceId]){
				addedLanes.push(allLanes[i])
			}
		}
		
		if (addedLanes.length > 0){
			currentShape = addedLanes.first();
		}
		
		
		// Get all deleted lanes
		var resourceIds = $H(this.hashedBounds[pool.resourceId]).keys();
		var i=-1;
		while (++i<resourceIds.length) {
			if (!allLanes.any(function(lane){ return lane.resourceId == resourceIds[i]})){
				deletedLanes.push(this.hashedBounds[pool.resourceId][resourceIds[i]]);
				selection = selection.without(function(r){ return r.resourceId == resourceIds[i] });
			}
		}		
				
		var height, width;
		
		if (deletedLanes.length > 0 || addedLanes.length > 0) {
			
			// Set height from the pool
			height = this.updateHeight(pool);
			// Set width from the pool
			width = this.adjustWidth(lanes, pool.bounds.width());	
			
			pool.update();
		}
		
		/**
		 * Set width/height depending on the pool
		 */
		else if (pool == currentShape) {
			
			// Set height from the pool
			height = this.adjustHeight(lanes, undefined, pool.bounds.height());
			// Set width from the pool
			width = this.adjustWidth(lanes, pool.bounds.width());		
		}
		
		/**‚
		 * Set width/height depending on containing lanes
		 */		
		else {
			// Get height and adjust child heights
			height = this.adjustHeight(lanes, currentShape);
			// Set width from the current shape
			width = this.adjustWidth(lanes, currentShape.bounds.width()+(this.getDepth(currentShape,pool)*30));
		}
		

		this.setDimensions(pool, width, height);
		
		
		
		// Update all dockers
		this.updateDockers(allLanes, pool);
		
		this.hashedBounds[pool.resourceId] = {};
		
		var i=-1;
		while (++i < allLanes.length) {
			// Cache positions
			this.hashedBounds[pool.resourceId][allLanes[i].resourceId] = allLanes[i].absoluteBounds();
			
			this.hashedLaneDepth[allLanes[i].resourceId] = this.getDepth(allLanes[i], pool);
			
			this.forceToUpdateLane(allLanes[i]);
		}
		
		this.hashedPoolPositions[pool.resourceId] = pool.bounds.clone();
		
		
		// Update selection
		//this.facade.setSelection(selection);		
	},
	forceToUpdateLane: function(lane){
		
		if (lane.bounds.height() !== lane._svgShapes[0].height) {	
			lane.isChanged = true;
			lane.isResized = true;
			lane._update();
		}
	},
	
	getDepth: function(child, parent){
		
		var i=0;
		while(child && child.parent && child !== parent){
			child = child.parent;
			++i
		}
		return i;
	},
	
	updateDepth: function(lane, fromDepth, toDepth){
		
		var xOffset = (fromDepth - toDepth) * 30;
		
		lane.getChildNodes().each(function(shape){
			shape.bounds.moveBy(xOffset, 0);
			
			[].concat(children[j].getIncomingShapes())
					.concat(children[j].getOutgoingShapes())
					
		})
		
	},
	
	setDimensions: function(shape, width, height){
		var isLane = shape.getStencil().id().endsWith("Lane");
		// Set the bounds
		shape.bounds.set(
				isLane ? 30 : shape.bounds.a.x, 
				shape.bounds.a.y, 
				width	? shape.bounds.a.x + width - (isLane?30:0) : shape.bounds.b.x, 
				height 	? shape.bounds.a.y + height : shape.bounds.b.y
			);
	},

	setLanePosition: function(shape, y){
		shape.bounds.moveTo(30, y);
	},
		
	adjustWidth: function(lanes, width) {
		
		// Set width to each lane
		(lanes||[]).each(function(lane){
			this.setDimensions(lane, width);
			this.adjustWidth(this.getLanes(lane), width-30);
		}.bind(this));
		
		return width;
	},
	
	
	adjustHeight: function(lanes, changedLane, propagateHeight){
		
		var oldHeight = 0;
		if (!changedLane && propagateHeight){
			var i=-1;
			while (++i<lanes.length){	
				oldHeight += lanes[i].bounds.height();		
			}
		}
		
		var i=-1;
		var height = 0;
		
		// Iterate trough every lane
		while (++i<lanes.length){
			
			if (lanes[i] === changedLane) {
				// Propagate new height down to the children
				this.adjustHeight(this.getLanes(lanes[i]), undefined, lanes[i].bounds.height());
				
				lanes[i].bounds.set({x:30, y:height}, {x:lanes[i].bounds.width()+30, y:lanes[i].bounds.height()+height})
								
			} else if (!changedLane && propagateHeight) {
				
				var tempHeight = (lanes[i].bounds.height() * propagateHeight) / oldHeight;
				// Propagate height
				this.adjustHeight(this.getLanes(lanes[i]), undefined, tempHeight);
				// Set height propotional to the propagated and old height
				this.setDimensions(lanes[i], null, tempHeight);
				this.setLanePosition(lanes[i], height);
			} else {
				// Get height from children
				var tempHeight = this.adjustHeight(this.getLanes(lanes[i]), changedLane, propagateHeight);
				if (!tempHeight) {
					tempHeight = lanes[i].bounds.height();
				}
				this.setDimensions(lanes[i], null, tempHeight);
				this.setLanePosition(lanes[i], height);
			}
			
			height += lanes[i].bounds.height();
		}
		
		return height;
		
	},
	
	
	updateHeight: function(root){
		
		var lanes = this.getLanes(root);
		
		if (lanes.length == 0){
			return root.bounds.height();
		}
		
		var height = 0;
		var i=-1;
		while (++i < lanes.length) {
			this.setLanePosition(lanes[i], height);
			height += this.updateHeight(lanes[i]);
		}
		
		this.setDimensions(root, null, height);
		
		return height;
	},
	
	getOffset: function(lane, includePool, pool){
		
		var offset = {x:0,y:0};
		
		
		/*var parent = lane; 
		 while(parent) {
		 				
			
			var offParent = this.hashedBounds[pool.resourceId][parent.resourceId] ||(includePool === true ? this.hashedPoolPositions[parent.resourceId] : undefined);
			if (offParent){
				var ul = parent.bounds.upperLeft();
				var ulo = offParent.upperLeft();
				offset.x += ul.x-ulo.x;
				offset.y += ul.y-ulo.y;
			}
			
			if (parent.getStencil().id().endsWith("Pool")) {
				break;
			}
			
			parent = parent.parent;
		}	*/
		
		var offset = lane.absoluteXY();
		
		var hashed = this.hashedBounds[pool.resourceId][lane.resourceId] ||(includePool === true ? this.hashedPoolPositions[lane.resourceId] : undefined);
		if (hashed) {
			offset.x -= hashed.upperLeft().x; 	
			offset.y -= hashed.upperLeft().y;		
		} else {
			return {x:0,y:0}
		}		
		return offset;
	},
	
	getNextLane: function(shape){
		while(shape && !shape.getStencil().id().endsWith("Lane")){
			if (shape instanceof ORYX.Core.Canvas) {
				return null;
			}
			shape = shape.parent;
		}
		return shape;
	},
	
	getParentPool: function(shape){
		while(shape && !shape.getStencil().id().endsWith("Pool")){
			if (shape instanceof ORYX.Core.Canvas) {
				return null;
			}
			shape = shape.parent;
		}
		return shape;
	},
	updateDockers: function(lanes, pool){
		
		var absPool = pool.absoluteBounds();
		var oldPool = (this.hashedPoolPositions[pool.resourceId]||absPool).clone();
		
		var i=-1, j=-1, k=-1, l=-1, docker;
		var dockers = {};
		
		while (++i < lanes.length) {
			
			if (!this.hashedBounds[pool.resourceId][lanes[i].resourceId]) {
				continue;
			}
			
			var children = lanes[i].getChildNodes();
			var absBounds = lanes[i].absoluteBounds();
			var oldBounds = (this.hashedBounds[pool.resourceId][lanes[i].resourceId]||absBounds);
			//oldBounds.moveBy((absBounds.upperLeft().x-lanes[i].bounds.upperLeft().x), (absBounds.upperLeft().y-lanes[i].bounds.upperLeft().y));
			var offset = this.getOffset(lanes[i], true, pool);
			var xOffsetDepth = 0;

			var depth = this.getDepth(lanes[i], pool);
			if ( this.hashedLaneDepth[lanes[i].resourceId] !== undefined &&  this.hashedLaneDepth[lanes[i].resourceId] !== depth) {
				xOffsetDepth = (this.hashedLaneDepth[lanes[i].resourceId] - depth) * 30;
				offset.x += xOffsetDepth;
			}
			
			j=-1;
			
			while (++j < children.length) {
				
				if (xOffsetDepth) {
					children[j].bounds.moveBy(xOffsetDepth, 0);
				}
				
				if (children[j].getStencil().id().endsWith("Subprocess")) {
					this.moveChildDockers(children[j], offset);
				}
				
				var edges = [].concat(children[j].getIncomingShapes())
					.concat(children[j].getOutgoingShapes())
					// Remove all edges which are included in the selection from the list
					.findAll(function(r){ return r instanceof ORYX.Core.Edge })

				k=-1;
				while (++k < edges.length) {			
					
					if (edges[k].getStencil().id().endsWith("MessageFlow")) {
						this.layoutEdges(children[j], [edges[k]], offset);
						continue;
					}
					
					l=-1;
					while (++l < edges[k].dockers.length) {
						
						docker = edges[k].dockers[l];
						
						if (docker.getDockedShape()||docker.isChanged){
							continue;
						}
					
					
						pos = docker.bounds.center();
						
						// Check if the modified center included the new position
						var isOverLane = oldBounds.isIncluded(pos);
						// Check if the original center is over the pool
						var isOutSidePool = !oldPool.isIncluded(pos);
						var previousIsOverLane = l == 0 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l-1].bounds.center());
						var nextIsOverLane = l == edges[k].dockers.length-1 ? isOverLane : oldBounds.isIncluded(edges[k].dockers[l+1].bounds.center());
						
						
						// Check if the previous dockers docked shape is from this lane
						// Otherwise, check if the docker is over the lane OR is outside the lane 
						// but the previous/next was over this lane
						if (isOverLane){
							dockers[docker.id] = {docker: docker, offset:offset};
						} 
						/*else if (l == 1 && edges[k].dockers.length>2 && edges[k].dockers[l-1].isDocked()){
							var dockedLane = this.getNextLane(edges[k].dockers[l-1].getDockedShape());
							if (dockedLane != lanes[i])
								continue;
							dockers[docker.id] = {docker: docker, offset:offset};
						}
						// Check if the next dockers docked shape is from this lane
						else if (l == edges[k].dockers.length-2 && edges[k].dockers.length>2 && edges[k].dockers[l+1].isDocked()){
							var dockedLane = this.getNextLane(edges[k].dockers[l+1].getDockedShape());
							if (dockedLane != lanes[i])
								continue;
							dockers[docker.id] = {docker: docker, offset:offset};
						}
												
						else if (isOutSidePool) {
							dockers[docker.id] = {docker: docker, offset:this.getOffset(lanes[i], true, pool)};
						}*/
						
					
					}
				}
						
			}
		}
		
		// Set dockers
		i=-1;
		var keys = $H(dockers).keys();
		while (++i < keys.length) {
			dockers[keys[i]].docker.bounds.moveBy(dockers[keys[i]].offset);
		}
	},
	
	moveBy: function(pos, offset){
		pos.x += offset.x;
		pos.y += offset.y;
		return pos;
	},
	
	getHashedBounds: function(shape){
		return this.currentPool && this.hashedBounds[this.currentPool.resourceId][shape.resourceId] ? this.hashedBounds[this.currentPool.resourceId][shape.resourceId] : shape.bounds.clone();
	},
	
	/**
	 * Returns a set on all child lanes for the given Shape. If recursive is TRUE, also indirect children will be returned (default is FALSE)
	 * The set is sorted with first child the lowest y-coordinate and the last one the highest.
	 * @param {ORYX.Core.Shape} shape
	 * @param {boolean} recursive
	 */
	getLanes: function(shape, recursive){
		var lanes = shape.getChildNodes(recursive||false).findAll(function(node) { return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#Lane"); });
		lanes = lanes.sort(function(a, b){
					// Get y coordinate
					var ay = Math.round(a.bounds.upperLeft().y);
					var by = Math.round(b.bounds.upperLeft().y);
					
					// If equal, than use the old one
					if (ay == by) {
						ay = Math.round(this.getHashedBounds(a).upperLeft().y);
						by = Math.round(this.getHashedBounds(b).upperLeft().y);
					}
					return  ay < by ? -1 : (ay > by ? 1 : 0)
				}.bind(this))
		return lanes;
	}
	
};
	
ORYX.Plugins.BPMN2_0 = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2_0);/** * Copyright (c) 2009 * Philipp Giese * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.BPMN2CONVERSATION = {	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DRAGDOCKER_DOCKED, this.handleDockerDocked.bind(this));				this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SHAPE_MENU_CLOSE, this.handleDragDrop.bind(this));	},		checkForMultiInstance: function(shape) {				var incomingShapes = shape.getIncomingShapes();		var outgoingShapes = shape.getOutgoingShapes();		var miProp = shape.properties["oryx-multiinstance"];				if (incomingShapes) {			incomingShapes.find(function(aShape){				if (aShape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink") {					if (miProp) 						aShape.setProperty("oryx-showforkend", true);					else 						aShape.setProperty("oryx-showforkend", false);				}			});		}				if (outgoingShapes) {			outgoingShapes.find(function(aShape){				if (aShape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink") {					if (miProp) 						aShape.setProperty("oryx-showforkstart", true);					else 						aShape.setProperty("oryx-showforkstart", false);				}			});		}	},		/**	 * DragDocker.Docked Handler	 *	 */		handleDockerDocked: function(options) {		var edge = options.parent;		var edgeSource = options.target;				if(edge.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink") {			if(edgeSource.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {				this.checkForMultiInstance(edgeSource);								this.facade.getCanvas().update();			}		}	},		/**	 * PropertyWindow.PropertyChanged Handler	 */	handlePropertyChanged: function(option) {				var shapes = option.elements;		var changed = false;		shapes.each(function(shape) {			if (shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {												this.checkForMultiInstance(shape);				changed = true;			}		}.bind(this));					if(changed) this.facade.getCanvas().update();	},		handleDragDrop: function(option) {				var source = option.source;		var destination = option.destination;		var changed = false;				source.each(function(shape) {			// a Communication node was dragged from a participant node			if(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {				this.checkForMultiInstance(shape);				changed = true;			}		}.bind(this));				destination.each(function(shape) {			// a connection is drawn towards a participant node			if(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Communication"){				var outgoingEdges = shape.getOutgoingShapes();								// we have to check the drawn edge if its ending in an Participant Node				if(outgoingEdges) {					outgoingEdges.each(function(aShape) {						var edgeTarget = aShape.getTarget();												if(edgeTarget) {							if(edgeTarget.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {								this.checkForMultiInstance(edgeTarget);								changed = true;							}						}					}.bind(this));				}			}									if(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0conversation#Participant") {				this.checkForMultiInstance(shape);				changed = true;			}		}.bind(this));				if(changed) this.facade.getCanvas().update();	}};ORYX.Plugins.BPMN2CONVERSATION = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2CONVERSATION);/**
 * Copyright (c) 2009
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
   @namespace Oryx name space for plugins
   @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	

/**
 * This plugin provides methodes to layout the choreography diagrams of BPMN 2.0.
 * 
 * @class ORYX.Plugins.Bpmn2_0Choreography
 * @extends ORYX.Plugins.AbstractPlugin
 * @param {Object} facade
 * 		The facade of the Editor
 */
ORYX.Plugins.Bpmn2_0Choreography = {
	
	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;
		
		/* Register on event ORYX.CONFIG.EVENT_STENCIL_SET_LOADED and ensure that
		 * the stencil set extension is loaded.
		 */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_STENCIL_SET_LOADED, 
										this.handleStencilSetLoaded.bind(this));
		
		/**
		 * FF 3.0 Bugfixing: Check if all events are loaded
		 */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, function(){
			if (!this._eventsRegistered) {
				this.handleStencilSetLoaded({});
				this.afterLoad();
			}
		}.bind(this));
		
		this.participantSize = 20;
		this.extensionSizeForMarker = 10;
		this.choreographyTasksMeta = new Hash();
		
		/* Disable the layout callback until the diagram is loaded. */
		this._isLayoutEnabled = false;
	},
	
	
	/**
	 * Check if the 'http://oryx-editor.org/stencilsets/extensions/bpmn2.0choreography#'
	 * stencil set extension is loaded and thus register or unregisters on the 
	 * appropriated events.
	 */
	handleStencilSetLoaded : function(event) {
		
		/* Enable layout callback */
		if(event.lazyLoaded) {
			this._isLayoutEnabled = true;
		}
		
		if(this.isStencilSetExtensionLoaded('http://oryx-editor.org/stencilsets/extensions/bpmn2.0choreography#')) {
			this.registerPluginOnEvents();
		} else {
			this.unregisterPluginOnEvents();
		}
	},
	
	/**
	 * Register this plugin on the events.
	 */
	registerPluginOnEvents: function() {
		this._eventsRegistered = true;
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.addParticipantsOnCreation.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.choreography.task', this.handleLayoutChoreographyTask.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.choreography.subprocess.expanded', this.handleLayoutChoreographySubprocessExpanded.bind(this));
		this.facade.registerOnEvent('layout.bpmn2_0.choreography.subprocess.collapsed', this.handleLayoutChoreographySubprocessCollapsed.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));

//		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.handlePropertyChanged.bind(this));
	},
	
	/**
	 * Unregisters this plugin from the events.
	 */
	unregisterPluginOnEvents: function() {
//		this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		//this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_SHAPEADDED, this.addParticipantsOnCreation.bind(this));
//		this.facade.unregisterOnEvent('layout.bpmn2_0.choreography.task', this.handleLayoutChoreographyTask.bind(this));
//		this.facade.unregisterOnEvent('layout.bpmn2_0.choreography.subprocess.expanded', this.handleLayoutChoreographySubprocessExpanded.bind(this));
//		this.facade.unregisterOnEvent('layout.bpmn2_0.choreography.subprocess.collapsed', this.handleLayoutChoreographySubprocessCollapsed.bind(this));
		this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_LOADED, this.afterLoad.bind(this));
	},
	
	/**
	 * Init the meta values for the layout mechanism of the choreography task 
	 * and enables the layout callback
	 * 
	 * @param {Object} event
	 * 		The event object
	 */
	afterLoad : function(event) {
		
		//if(this._isLayoutEnabled) {return;}
		/* Enable the layout callback for choreography activities */
		this._isLayoutEnabled = true;
		
		/* Initialize layout meta values for each choreography task */
		this.facade.getCanvas().getChildNodes(true).each(function(shape){
			if (!(shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#ChoreographyTask" ||
				shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#ChoreographySubprocessCollapsed" ||
				shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#ChoreographySubprocessExpanded")) {
				return;
			}

			var participantsOnTop = new Array();
			var participantsOnBottom = new Array();
			
			var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(shape);
			
			/* Get participants */
			var participants = shape.getChildNodes(false).findAll(function(node) {
				return node.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant";
			}); 
			
			/* Sort participants from up to bottom */
			participants = participants.sort(function(a,b) {
				var ay = Math.round(a.absoluteBounds().upperLeft().y);
				var by = Math.round(b.absoluteBounds().upperLeft().y);
				return  ay < by ? -1 : (ay > by ? 1 : 0);
			});
			
			/* Determine participants on top and bottom side */
			var expectedYValue = 0;
			var participantsExtendedOnTop = 0;
			var participantsExtendedOnBottom = 0;
			participants.each(function(participant) {
				/* Disable Resizing */
				participant.isResizable = false;
				
				var extended = (participant.properties['oryx-multiple_instance'] === "" ? 
						false : participant.properties['oryx-multiple_instance']);
				if(participant.bounds.upperLeft().y == expectedYValue) {
					participantsOnTop.push(participant);
					expectedYValue = participant.bounds.lowerRight().y;
					if (extended) {
						participantsExtendedOnTop++;
					}
				} else {
					/* Participant is member of the bottom band */
					participantsOnBottom.push(participant);
					if (extended) {
						participantsExtendedOnBottom++;
					}
				}
			});
			
			/* Initialize meta values */
			choreographyTaskMeta.numOfParticipantsOnTop = participantsOnTop.length;
			choreographyTaskMeta.numOfParticipantsOnBottom = participantsOnBottom.length;
			choreographyTaskMeta.numOfParticipantsExtendedOnBottom = participantsExtendedOnBottom;
			choreographyTaskMeta.numOfParticipantsExtendedOnTop = participantsExtendedOnTop;
			
			choreographyTaskMeta.bottomYStartValue = (participantsOnBottom.first() ? 
					participantsOnBottom.first().bounds.upperLeft().y : shape.bounds.height());
					
			choreographyTaskMeta.topYEndValue = (participantsOnTop.last() ? 
					participantsOnTop.last().bounds.lowerRight().y : 0);
			
			choreographyTaskMeta.center = choreographyTaskMeta.topYEndValue +
				(choreographyTaskMeta.bottomYStartValue - choreographyTaskMeta.topYEndValue) / 2;
			
			choreographyTaskMeta.oldHeight = shape.bounds.height();
			choreographyTaskMeta.oldBounds = shape.bounds.clone();
			
			choreographyTaskMeta.topParticipants = participantsOnTop;
			choreographyTaskMeta.bottomParticipants = participantsOnBottom;
			
			shape.isChanged = true;
		}.bind(this));
		
		/* Update to force marker positioning */
		this.facade.getCanvas().update();
	},
	
	/**
	 * Handler for 'layout.bpmn2_0.choreography.subprocess.expanded'
	 * Applies the layout for an expanded subprocess. e.g. positioning of the 
	 * text field.
	 * 
	 * @param {Object} event
	 * 		The layout event.
	 */
	handleLayoutChoreographySubprocessExpanded : function(event) {
		if(!this._isLayoutEnabled) {return;}
		
		var choreographyTask = event.shape;
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		var heightDelta = choreographyTask.bounds.height() / choreographyTask._oldBounds.height();
	
		/* Handle text field position */
		var textField = choreographyTask._labels[choreographyTask.getId() + 'text_name'];
		if(textField) {
			var top = choreographyTaskMeta.topYEndValue + 5;

			/* Consider changed in update cycle */
			if(choreographyTask.isResized && heightDelta) {
				textField.y = top / heightDelta;
			} else {
				textField.y = top;
			}
			
		}
	},
	
	
	/**
	 * Handler for 'layout.bpmn2_0.choreography.subprocess.collapsed'
	 * Applies the layout for a collapsed subprocess. 
	 * e.g. plus marker
	 * 
	 * @param {Object} event
	 * 		The layout event.
	 */
	handleLayoutChoreographySubprocessCollapsed : function(event) {
		if(!this._isLayoutEnabled) {return;}
		
		var choreographyTask = event.shape;
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		
		/* Calculate position of the "plus" marker of the subprocess */
		var plusMarker = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'plus_marker';
		});
		
		var plusMarkerBorder = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'plus_marker_border';
		});
		
		if(plusMarker && plusMarkerBorder) {
				plusMarker._isYLocked = true;
				plusMarker.y = choreographyTaskMeta.bottomYStartValue - 12;
				
				plusMarkerBorder._isYLocked = true;
				plusMarkerBorder.y = choreographyTaskMeta.bottomYStartValue - 14;
		}
	},
	
	/**
	 * When a choreography task is created, two participants automatically will
	 * be added (one initiating and one returning)
	 * 
	 * @param {Object} event
	 * 		The ORYX.CONFIG.EVENT_SHAPEADDED event
	 */
	addParticipantsOnCreation: function(event) {
		if(!this._isLayoutEnabled) {return;}
		var shape = event.elements[0];
		if(shape&&event.elements.length===1&&shape._stencil&&
			!shape.initialParticipantsAdded && 
			(shape.getStencil().id() === 
				"http://b3mn.org/stencilset/bpmn2.0#ChoreographyTask" ||
			shape.getStencil().id() === 
				"http://b3mn.org/stencilset/bpmn2.0#ChoreographySubprocessCollapsed" ||
			shape.getStencil().id() === 
				"http://b3mn.org/stencilset/bpmn2.0#ChoreographySubprocessExpanded")	){
		
			var hasParticipants = shape.getChildNodes().find(function(node) {
				return (node.getStencil().id() === 
							"http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant");
			});
			
			if(hasParticipants) {return;}
			
			/* Insert initial participants */
			var participant1 = {
				type:"http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant",
				position:{x:0,y:0},
				namespace:shape.getStencil().namespace(),
				parent:shape
			};
			var shapeParticipant1 = this.facade.createShape(participant1);
			shapeParticipant1.setProperty('oryx-initiating', true);
			var propEvent = {
				elements 	: [shapeParticipant1],
				key 		: "oryx-initiating",
				value		: true
			};
			this.handlePropertyChanged(propEvent);
			
			var participant2 = {
				type:"http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant",
				position:{x:0,y:shape.bounds.lowerRight().y},
				namespace:shape.getStencil().namespace(),
				parent:shape
			};
			this.facade.createShape(participant2);
			this.facade.getCanvas().update();
			this.facade.setSelection([shape]);
			shape.initialParticipantsAdded = true;
		}
	},
	
	/**
	 * Initialize the meta data object for the choreography task if necessary and
	 * return it.
	 * 
	 * @param {Object} choregraphyTask
	 * 		The choreography task
	 * @return {Object} choreographyTaskMetaData
	 * 		Positioning values to handle child participants.
	 */
	addOrGetChoreographyTaskMeta: function(choreographyTask) {
		if(!this.choreographyTasksMeta[choreographyTask.getId()]) {
			
			/* Initialize meta values */			
			this.choreographyTasksMeta[choreographyTask.getId()] = new Object();
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsOnTop = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsOnBottom = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsExtendedOnBottom = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].numOfParticipantsExtendedOnTop = 0;
			
			this.choreographyTasksMeta[choreographyTask.getId()].bottomYStartValue = 
				choreographyTask.bounds.height();
			this.choreographyTasksMeta[choreographyTask.getId()].topYEndValue = 0;
			this.choreographyTasksMeta[choreographyTask.getId()].center = 
				choreographyTask.bounds.height() / 2;
			
			this.choreographyTasksMeta[choreographyTask.getId()].oldHeight = 
				choreographyTask.bounds.height();
			this.choreographyTasksMeta[choreographyTask.getId()].oldBounds = 
				choreographyTask.bounds.clone();
			
			/* Ensure the side of participants while resizing */
			this.choreographyTasksMeta[choreographyTask.getId()].topParticipants = new Array();
			this.choreographyTasksMeta[choreographyTask.getId()].bottomParticipants = new Array();
			
		}
		return this.choreographyTasksMeta[choreographyTask.getId()];
	},
	
	/**
	 * Adjust the meta values, if the choreography task is resized.
	 * 
	 * @param {Object} choreographyTask
	 * @param {Object} choreographyTaskMeta
	 */
	handleResizingOfChoreographyTask: function(choreographyTask, choreographyTaskMeta) {
		if(choreographyTask.bounds.height() == choreographyTaskMeta.oldHeight) {return;}
		
		/* Ensure that the choreography task is not too small in height */
		
		var minimumHeight = choreographyTaskMeta.numOfParticipantsOnTop 
							* this.participantSize + 
							choreographyTaskMeta.numOfParticipantsExtendedOnTop *
							this.extensionSizeForMarker +
							choreographyTaskMeta.numOfParticipantsOnBottom 
							* this.participantSize +
							choreographyTaskMeta.numOfParticipantsExtendedOnBottom *
							this.extensionSizeForMarker 
							+ 40;
		if(minimumHeight > choreographyTask.bounds.height()) {
			var ul = choreographyTask.bounds.upperLeft();
			var oldUl = choreographyTaskMeta.oldBounds.upperLeft();
			var lr = choreographyTask.bounds.lowerRight();
			var oldLr = choreographyTaskMeta.oldBounds.lowerRight();
			
			if(ul.y != oldUl.y) {
				/* Resized on top side */
				choreographyTask.bounds.set(ul.x, lr.y - minimumHeight, lr.x, lr.y);
			} else if(lr.y != oldLr.y) {
				/* Resized on bottom side */
				choreographyTask.bounds.set(ul.x, ul.y, lr.x, ul.y + minimumHeight);
			}
		}
		
		/* Adjust the y coordinate for the starting position of the bottom participants */
		var yAdjustment = choreographyTaskMeta.oldHeight - choreographyTask.bounds.height();
		choreographyTaskMeta.bottomYStartValue -= yAdjustment;
		
		/* Signals it was resized */
		return true;
	},
	
	/**
	 * Handler for layouting event 'layout.bpmn2_0.choreography.task'
	 * 
	 * @param {Object} event
	 * 		The layout event
	 */
	handleLayoutChoreographyTask: function(event) {
		if(!this._isLayoutEnabled) {return;}
		
		var choreographyTask = event.shape;
		var isNew = !this.choreographyTasksMeta[choreographyTask.getId()];
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		
		var isResized = this.handleResizingOfChoreographyTask(choreographyTask, choreographyTaskMeta);

		var oldCountTop = choreographyTaskMeta.numOfParticipantsOnTop;
		var oldCountBottom = choreographyTaskMeta.numOfParticipantsOnBottom;
		
		/* ------- Handle participants on top side  ------- */
		
		if(isResized) {
			/* Do not calculate the position of a paraticipant if it was only a resizing */
			var participants = choreographyTaskMeta.topParticipants;
		} else {
			var participants = this.getParticipants(choreographyTask,true,false);
			
			if(!participants) {return;}
			this.ensureParticipantsParent(choreographyTask, participants);
		}
		
		var numOfParticipantsExtended = 0;

		/* Put participants into the right position */
		participants.each(function(participant, i) {
			
			/* Disable resizing by the user interface */
			participant.isResizable = false;
			
			participant.setProperty('oryx-corners', "None");
			var isExtended = this.setBoundsOfParticipantDependOnProperties(
													participant,
													i,
													numOfParticipantsExtended,
													choreographyTask.bounds.width(),
													0);
			
			/* Count extended participants */										
			if(isExtended) {numOfParticipantsExtended++;}
													
//			participant.bounds.set(0, i * this.participantSize, 
//								choreographyTask.bounds.width(), 
//								this.participantSize +  i * this.participantSize);
			
			/* The first participants gets rounded corners */
			if(i == 0) {
				participant.setProperty('oryx-corners', "Top");
			}
			
			this.adjustTopBackground(participant);
		}.bind(this));
		
		/* Resize choreography task to top side */
		var resizeFactor = participants.length - 
									choreographyTaskMeta.numOfParticipantsOnTop;
		var resizeFactorExtended = numOfParticipantsExtended -
							choreographyTaskMeta.numOfParticipantsExtendedOnTop;
		
		var bounds = choreographyTask.bounds;
		var ul = bounds.upperLeft();
		var lr = bounds.lowerRight();
		
		if (!isNew)
			bounds.set(ul.x, 
					ul.y - resizeFactor * this.participantSize 
					- resizeFactorExtended * this.extensionSizeForMarker, lr.x, lr.y);
		
		/* Set new top and bottom border values */
		choreographyTaskMeta.topYEndValue = 
							participants.length * this.participantSize 
						+	numOfParticipantsExtended * this.extensionSizeForMarker;
		
		
		/* Set new meta value for top participant band */	
		choreographyTaskMeta.numOfParticipantsExtendedOnTop = numOfParticipantsExtended;
		choreographyTaskMeta.numOfParticipantsOnTop = participants.length;
		choreographyTaskMeta.topParticipants = participants;
		
		
		/* ----- Handle participants on bottom side --------- */
		if(isResized) {
			/* Do not calculate the position of a paraticipant if it was only a resizing */
			var participants = choreographyTaskMeta.bottomParticipants;
		} else {
			var participants = this.getParticipants(choreographyTask,false,true);
			
			if(!participants) {return;}
			this.ensureParticipantsParent(choreographyTask, participants);
		}
		
				
		if (isNew){
			choreographyTaskMeta.bottomYStartValue = (bounds.height() - 
				(participants.length != 0 ? 
					eval(participants.map(function(p){ return this.participantSize + (this.isExtended(p)?this.extensionSizeForMarker:0) }.bind(this)).join("+")) :
					0));
		} else {
			choreographyTaskMeta.bottomYStartValue += 
				resizeFactor * this.participantSize + 
				resizeFactorExtended * this.extensionSizeForMarker;
		}
		
		var bottomStartYValue = choreographyTaskMeta.bottomYStartValue;
		var numOfParticipantsExtended = 0;
		
		/* Put participants into the right position */
		participants.each(function(participant, i) {
			
			/* Disable resizing by the user interface */
			participant.isResizable = false;
			
			participant.setProperty('oryx-corners', "None");
			
			var isExtendedParticipant = 
				this.setBoundsOfParticipantDependOnProperties(participant, 
								i,
								numOfParticipantsExtended,
								choreographyTask.bounds.width(),
								bottomStartYValue);
			
			/* Count extended participants */
			if(isExtendedParticipant) {numOfParticipantsExtended++;}
			
//			participant.bounds.set(0, bottomStartYValue + 
//														 i * this.participantSize, 
//								choreographyTask.bounds.width(), 
//								bottomStartYValue +
//								this.participantSize +  i * this.participantSize);
			
			/* The last participants gets rounded corners */
			if(i == participants.length - 1) {
				participant.setProperty('oryx-corners', "Bottom");
			}
			
			this.adjustTopBackground(participant);
			
		}.bind(this));
		
		/* Resize choreography task to top bottom side */
		
		var resizeFactor = participants.length - 
								choreographyTaskMeta.numOfParticipantsOnBottom;
		var resizeFactorExtended = numOfParticipantsExtended - 
						choreographyTaskMeta.numOfParticipantsExtendedOnBottom;
		
		var bounds = choreographyTask.bounds;
		var ul = bounds.upperLeft();
		var lr = bounds.lowerRight();
		
		if (!isNew)
		bounds.set( ul.x, 
					ul.y, 
					lr.x, 
					lr.y + resizeFactor * this.participantSize 
					+ resizeFactorExtended * this.extensionSizeForMarker);
		
		/* Store new meta values */
		choreographyTaskMeta.numOfParticipantsExtendedOnBottom = numOfParticipantsExtended;
		choreographyTaskMeta.numOfParticipantsOnBottom = participants.length;
		choreographyTaskMeta.bottomParticipants = participants;
		
		/* Check if participants has changed */
		var participantsHasChanged = 	oldCountTop !== choreographyTaskMeta.numOfParticipantsOnTop ||
										oldCountBottom !==choreographyTaskMeta.numOfParticipantsOnBottom;	
		
		/* Handle positioning of sub elements */
		this.ensureCenterPositionOfMagnets(choreographyTask, isResized, participantsHasChanged);
		this.adjustTextFieldAndMarkerPosition(choreographyTask);
		
		choreographyTaskMeta.oldHeight = bounds.height();
		choreographyTaskMeta.oldBounds = bounds.clone();
	},
	
	/**
	 * Return TRUE if the participant is extended (has the attribute muliple instance)
	 * @param {ORYX.Core.Node} participant
	 */
	isExtended: function(participant){
		return (!participant || participant.properties['oryx-multiple_instance'] === "" ? 
					false : !!participant.properties['oryx-multiple_instance']);
	},
	
	/**
	 * Resizes the participant depending on value of the multi-instances 
	 * property.
	 * 
	 * @param {ORYX.Core.Node} participant
	 * 		The concerning participant
	 * @param {Integer} numParticipantsBefore
	 * 		Number of participants before current
	 * @param {Integer} numParticipantsExtendedBefore
	 *		Number of participants extended in size before current
	 * @param {Float} width
	 * 		The width of the participant
	 * @param {Integer} yOffset
	 * 		Offset for the position of the bottom participants
	 */
	setBoundsOfParticipantDependOnProperties: function(	participant, 
														numParticipantsBefore, 
														numParticipantsExtendedBefore,
														width,
														yOffset) {
		var extended = this.isExtended(participant);
		var ulY = yOffset + 
			numParticipantsBefore * this.participantSize + 
			numParticipantsExtendedBefore * this.extensionSizeForMarker;
		var lrY = yOffset + this.participantSize +
			numParticipantsBefore * this.participantSize + 
			(extended ? (numParticipantsExtendedBefore + 1) * this.extensionSizeForMarker : 
				numParticipantsExtendedBefore * this.extensionSizeForMarker);
		
		participant.bounds.set(	0, 
			ulY, 
			width, 
			lrY);
			
		/* Is a multi-instance participant */
		return extended;
	},
	
	/**
	 * Set the y coordinate for the text field and multiple instance marker 
	 * position in order to ensure that the text or marker is not hidden 
	 * by a participant.
	 * 
	 * @param {ORYX.Core.Node} choreographyTask
	 * 		The choreography task.
	 */
	adjustTextFieldAndMarkerPosition: function(choreographyTask) {
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		var heightDelta = choreographyTask.bounds.height() / choreographyTask._oldBounds.height();
		
		/* Handle text field position */
		var textField = choreographyTask._labels[choreographyTask.getId() + 'text_name'];
		if(textField) {
			var center = choreographyTaskMeta.topYEndValue +
				(choreographyTaskMeta.bottomYStartValue - choreographyTaskMeta.topYEndValue) / 2;

			/* Consider changed in update cycle */
			if(choreographyTask.isResized && heightDelta) {
				textField.y = center / heightDelta;
			} else {
				textField.y = center;
			}
			
		}
		
		/* Handle MI and loop marker position */
		
		var loopMarker = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'loop_path';
		});
		if(loopMarker) {
				loopMarker._isYLocked = true;
				loopMarker.y = choreographyTaskMeta.bottomYStartValue - 7;
		}
		
		var miMarker = choreographyTask._svgShapes.find(function(svgShape) {
			return svgShape.element.id == choreographyTask.getId() + 'mi_path';
		}); 
		if(miMarker) {
			miMarker._isYLocked = true;
			miMarker.y = choreographyTaskMeta.bottomYStartValue - 11;
		}
		
	},
	
	/**
	 * The magnets of choreography activity were placed in the middle of both
	 * participant bands.
	 * 
	 * @param {ORYX.Core.Node} choreographyTask
	 * 		The choregraphy task containing the magnets
	 * @param {boolean} isResized
	 * 		Flag indicating a resizing of the task
	 * @param {boolean} participantsHasChanged
	 * 		Flag indicating if a new participants has been added or 
	 * 		changed the position (e.g.from top to bottom).
	 * 
	 */
	ensureCenterPositionOfMagnets: function(choreographyTask, isResized, participantsHasChanged) {
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(choreographyTask);
		var center = choreographyTaskMeta.topYEndValue + 
					(choreographyTaskMeta.bottomYStartValue 
								- choreographyTaskMeta.topYEndValue) / 2;
		
		var yAdjustment = center - choreographyTaskMeta.center;
		
		var heightDelta = choreographyTask.bounds.height() / 
							choreographyTaskMeta.oldBounds.height();
		if(!yAdjustment && !heightDelta) {return;}
		
		/* Find magnets that should be positioned relativly to the center */
		var magnets = choreographyTask.magnets.findAll(function(magnet) {
			return (!magnet.anchorTop && !magnet.anchorBottom)
		});
		
		/* Move magnets */
		magnets.each(function(magnet) {
			var x = magnet.bounds.center().x;
			var y = (magnet.bounds.center().y + yAdjustment) / heightDelta
			magnet.bounds.centerMoveTo(x,y);
		});
		
		/* Also move dockers */
		var absoluteTopYEndValue = choreographyTask.absoluteBounds().upperLeft().y 
									+ choreographyTaskMeta.topYEndValue;
		var absoluteBottomYStartValue = choreographyTask.absoluteBounds().upperLeft().y 
									+ choreographyTaskMeta.bottomYStartValue;
		var dockers = new Array();
		
		choreographyTask.incoming.each(function(seqFlow) {
			if(!(seqFlow instanceof ORYX.Core.Edge)) {return;}
			var docker = seqFlow.dockers.last();
			if(absoluteTopYEndValue <= docker.bounds.center().y 
				&& docker.bounds.center().y <= absoluteBottomYStartValue ) {
				dockers.push(docker);
			}
		});
		
		choreographyTask.outgoing.each(function(seqFlow) {
			if(!(seqFlow instanceof ORYX.Core.Edge)) {return;}
			var docker = seqFlow.dockers.first();
			if(absoluteTopYEndValue <= docker.bounds.center().y 
				&& docker.bounds.center().y <= absoluteBottomYStartValue ) {
				dockers.push(docker);
			}
		});
		
		if (participantsHasChanged&&choreographyTask.initialParticipantsAdded){
			dockers.each(function(dockerShape) {
				var ref = dockerShape.referencePoint;
				dockerShape.setReferencePoint({x:ref.x,y:(ref.y + yAdjustment) / heightDelta});
			});
		}

		
		/* Update center */
		choreographyTaskMeta.center = center;
	},
	
	/**
	 * Ensure that the parent of the participant is the choreography task.
	 * 
	 * @param {Object} shape
	 * 		The choreography task
	 * @param {Object} participants
	 * 		The participants
	 */
	ensureParticipantsParent: function(shape, participants) {
		if(!shape || !participants) {return;}
		
		participants.each(function(participant) {
			if(participant.parent.getId() == shape.getId()) {return;}
			
			
			
			
			/* Set ChoreographyTask as Parent */
			participant.parent.remove(participant);
			shape.add(participant);
		});
	},
	
	/**
	 * Returns the participants of a choreography task ordered by theire position.
	 * 
	 * @param {Object} shape
	 * 		The choreography task
	 * @param {Object} onTop
	 * 		Flag to get the participants from the top side of the task.
	 * @param {Object} onBottom
	 * 		Flag to get the participants from the bottom side of the task.
	 * @return {Array} participants;
	 * 		The child participants
	 */
	getParticipants: function(shape, onTop, onBottom) {
		if(shape.getStencil().id() !== "http://b3mn.org/stencilset/bpmn2.0#ChoreographyTask" &&
			shape.getStencil().id() !== "http://b3mn.org/stencilset/bpmn2.0#ChoreographySubprocessCollapsed" &&
			shape.getStencil().id() !== "http://b3mn.org/stencilset/bpmn2.0#ChoreographySubprocessExpanded") {
			return null;
		}
		
		var choreographyTaskMeta = this.addOrGetChoreographyTaskMeta(shape);
		var center = shape.absoluteBounds().upperLeft().y +
			 choreographyTaskMeta.topYEndValue +
			(choreographyTaskMeta.bottomYStartValue - choreographyTaskMeta.topYEndValue) / 2;
		
		/* Get participants of top side */
		var participantsTop = shape.getChildNodes(true).findAll(function(node) { 
			return (onTop && 
					node.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant" &&
					node.absoluteBounds().center().y <= center &&
					this.isParticipantOfShape(shape, node)); 
		}.bind(this));
		
		/* Get participants of bottom side */
		var participantsBottom = shape.getChildNodes(true).findAll(function(node) { 
			return (onBottom && 
					node.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant" &&
					node.absoluteBounds().center().y > center && 
					this.isParticipantOfShape(shape, node)); 
		}.bind(this));
		
		var participants = participantsTop.concat(participantsBottom);
		
		participants = participants.sort(function(a,b) {
			var ay = Math.round(a.absoluteBounds().upperLeft().y);
			var by = Math.round(b.absoluteBounds().upperLeft().y);
			return  ay < by ? -1 : (ay > by ? 1 : 0);
		});
		
		return participants;
	},
	
	/**
	 * Checks if the participant belongs to the shape. Used to detect choreography
	 * tasks inside an expanded choreography subprocess.
	 * 
	 * @param {ORYX.Core.Node} shape
	 * 		The choreography element
	 * 
	 * @param {ORYX.Core.Node} participant
	 * 		The participant node
	 * 
	 * @return {boolean} 
	 * 		True if the participant is a direct child of the shape and is not
	 * 		contained in aother choreography task or subprocess
	 */
	isParticipantOfShape: function(shape, participant) {
		var participantsParent = participant.parent;
		
		/* Get a non-participant parent of the participant */
		while(participantsParent.getStencil().id() === 
				"http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant") {
			participantsParent = participantsParent.parent;			
		}
		
		/* The detected parent should be the shape */
		
		return participantsParent.getId() === shape.getId();
	},
	
	adjustTopBackground: function(shape){
		var pos = shape.properties["oryx-corners"];
		var bg = $(shape.getId()+"roundedBgRect");
		if (!bg){ return }
		
		if(pos==="Top") {
			bg.setAttributeNS(null, "fill", "url(#"+shape.getId()+"background_top) white");
		} else {
			var bgColor = shape.properties["oryx-color"];
			bg.setAttributeNS(null, "fill", bgColor);
		}	
	},
	
	/**
	 * PropertyWindow.PropertyChanged Handler
	 * 
	 * It sets the correct color of the elements of a participant depending on
	 * either initiating or returning nature.
	 * 
	 * @param {Object} event
	 * 		The property changed event
	 */
	handlePropertyChanged: function(event) {
		var shapes = event.elements;
		var propertyKey = event.key || event.name;
		var propertyValue = event.value;
		
		var changed = false;
		shapes.each(function(shape) {
			if (shape.getStencil().id() === "http://b3mn.org/stencilset/bpmn2.0#ChoreographyParticipant" &&
			propertyKey === "oryx-initiating") {
			
				if (!propertyValue) {
					shape.setProperty("oryx-color", "#acacac");
				}
				else {
					shape.setProperty("oryx-color", "#ffffff");
				}
				
				changed = true;
			}
		})
		
		/* Update visualisation if necessary */
		if(changed) {
			this.facade.getCanvas().update();
		}
	}
	
};

ORYX.Plugins.Bpmn2_0Choreography = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.Bpmn2_0Choreography);
/**
 * Copyright (c) 2009
 * Philipp Giese, Sven Wagner-Boysen
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/**
   @namespace Oryx name space for plugins
   @name ORYX.Plugins
*/
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	
/**
 * This plugin provides methodes to serialize and deserialize a BPMN 2.0 diagram.
 * 
 * @class ORYX.Plugins.Bpmn2_0Serialization
 * @extends ORYX.Plugins.AbstractPlugin
 * @param {Object} facade
 * 		The facade of the Editor
 */
ORYX.Plugins.BPMN2_0Serialization = {
	bpmnSerializationHandlerUrl: ORYX.CONFIG.ROOT_PATH + "bpmn2_0serialization",
	bpmnDeserializationHandlerUrl : ORYX.CONFIG.ROOT_PATH + "bpmn2_0deserialization",
	bpmn2XpdlSerializationHandlerUrl : ORYX.CONFIG.ROOT_PATH + "bpmn2xpdlserialization",
	
	construct: function(facade) {
	
		this.facade = facade;
	
		/* BPMN 2.0 XML */
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.show,
			'functionality'		: this.showBpmnXml.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.showDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.download,
			'functionality'		: this.downloadBpmnXml.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.downloadDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		/* XPDL 2.2 */
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.xpdlShow,
			'functionality'		: this.showXpdl.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.xpdlShowDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization.xpdlDownload,
			'functionality'		: this.downloadXpdl.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/export2.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.xpdlDownloadDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
		
		/* Import BPMN 2.0 XML */
		
		this.facade.offer({
			'name'				: ORYX.I18N.Bpmn2_0Serialization['import'],
			'functionality'		: this.showImportDialog.bind(this),
			'group'				: 'Export',
            dropDownGroupIcon : ORYX.PATH + "images/import.png",
			'icon' 				: ORYX.PATH + "images/source.png",
			'description'		: ORYX.I18N.Bpmn2_0Serialization.importDesc,
			'index'				: 0,
			'minShape'			: 0,
			'maxShape'			: 0
		});
	},
	
	showBpmnXml: function() {	
		//var options = JSON.stringify({action : 'transform'});
		
		this.generateBpmnXml( function( response ) {
			var json = response.evalJSON();
			this.showSchemaValidationEvent(json.validationEvents);
			this.openXMLWindow(json.xml);
		}.bind(this),
		this.bpmnSerializationHandlerUrl);
	},
	
	downloadBpmnXml: function() {	
		//var options = JSON.stringify({action : 'transform'});
		this.generateBpmnXml(
			function ( response ) {
				var json = response.evalJSON();
				this.showSchemaValidationEvent(json.validationEvents);
				this.openDownloadWindow("model.bpmn", json.xml);
			}.bind(this),
			this.bpmnSerializationHandlerUrl);
	},
	
	/**
	 * Show the results of the schema validation in a message box, if it is
	 * enabled in the configuration.
	 */
	showSchemaValidationEvent : function(validationEvents) {
		if(validationEvents && ORYX.CONFIG.BPMN20_SCHEMA_VALIDATION_ON) {
			this._showErrorMessageBox("Validation", validationEvents);
		}
	},
	
	/**
	 * Calls the serialization to XPDL 2.2 and shows the result in a XML-Window.
	 */
	showXpdl: function() {
		this.generateBpmnXml( function( xml ) {
			this.openXMLWindow(xml);
		}.bind(this),
		this.bpmn2XpdlSerializationHandlerUrl);
	},
	
	/**
	 * Calls the serialization to XPDL 2.2 and offers the result as a file
	 * download.
	 */
	downloadXpdl: function() {
		this.generateBpmnXml(
			function ( xml ) {
				this.openDownloadWindow("model.xpdl", xml);
			}.bind(this),
			this.bpmn2XpdlSerializationHandlerUrl);
	},
	
	generateBpmnXml: function( bpmnHandleFunction, handlerUrl ) {
		var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:"Serialization of BPMN 2.0 model"});
		loadMask.show();
		
		var jsonString = this.facade.getSerializedJSON();
		this._sendRequest(
				handlerUrl,
				'POST',
				{ 'data' : jsonString },
				function( response ) { 
					bpmnHandleFunction( response );  
					loadMask.hide();
				}.bind(this),
				function(transport) { 
					loadMask.hide();
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2_0Serialization.serialFailed);
					ORYX.log.warn("Serialization of BPMN 2.0 model failed: " + transport.responseText);
				}.bind(this)
			);
	},
	
	/**
     * Opens a upload dialog.
     *
     */
    showImportDialog: function(successCallback){
    
        var form = new Ext.form.FormPanel({
            baseCls: 'x-plain',
            labelWidth: 50,
            defaultType: 'textfield',
            items: [{
                text: ORYX.I18N.Bpmn2_0Serialization.selectFile,
                style: 'font-size:12px;margin-bottom:10px;display:block;',
                anchor: '100%',
                xtype: 'label'
            }, {
                fieldLabel: ORYX.I18N.Bpmn2_0Serialization.file,
                name: 'subject',
                inputType: 'file',
                style: 'margin-bottom:10px;display:block;',
                itemCls: 'ext_specific_window_overflow'
            }, {
                xtype: 'textarea',
                hideLabel: true,
                name: 'msg',
                anchor: '100% -63'
            }]
        });
        
        // Create the panel
        var dialog = new Ext.Window({
            autoCreate: true,
            layout: 'fit',
            plain: true,
            bodyStyle: 'padding:5px;',
            title: ORYX.I18N.Bpmn2_0Serialization.name,
            height: 350,
            width: 500,
            modal: true,
            fixedcenter: true,
            shadow: true,
            proxyDrag: true,
            resizable: true,
            items: [form],
            buttons: [{
                text: ORYX.I18N.Bpmn2_0Serialization.btnImp,
                handler: function(){
                
                    var loadMask = new Ext.LoadMask(Ext.getBody(), {
                        msg: ORYX.I18N.Bpmn2_0Serialization.progress
                    });
                    loadMask.show();
                    
                    window.setTimeout(function(){
                        var bpmnXml = form.items.items[2].getValue();
						try {
							this._sendRequest(
								this.bpmnDeserializationHandlerUrl,
								'POST',
								{ 'data' : bpmnXml },
								function( json ) { 
		                            this.facade.importJSON(json, true);
		                            dialog.close();
								}.bind(this),
								function(transport) { 
									loadMask.hide();
									this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2_0Serialization.serialFailed);
									ORYX.log.warn("Serialization of BPMN 2.0 model failed: " + transport.responseText);
								}.bind(this)
							); 
						} 
                        catch (error) {
                            Ext.Msg.alert(ORYX.I18N.Bpmn2_0Serialization.error, error.message);
                        }
                        finally {
                            loadMask.hide();
                        }
                    }.bind(this), 100);
                    
                }.bind(this)
            }, {
                text: ORYX.I18N.Bpmn2_0Serialization.btnClose,
                handler: function(){
                    dialog.close();
                }.bind(this)
            }]
        });
        
        // Show the panel
        dialog.show();
        
        // Adds the change event handler to 
        form.items.items[1].getEl().dom.addEventListener('change', function(evt){
            var text = evt.target.files[0].getAsText('UTF-8');
            form.items.items[2].setValue(text);
        }, true)
        
    },
	
	_sendRequest: function( url, method, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(url, {
           method			: method,
           asynchronous	: false,
           parameters		: params,
		   onSuccess		: function(transport) {
				
				suc = true;
				
				if(successcallback){
					successcallback( transport.responseText );
				}
				
			}.bind(this),
			
			onFailure : function(transport) {

				if(failedcallback){
					failedcallback(transport);
					
				} else {
					Ext.Msg.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Bpmn2Bpel.transfFailed);
					ORYX.log.warn("Serialization of BPMN 2.0 model failed: " + transport.responseText);	
				}
				
			}.bind(this)		
		});
		
		return suc;		
	},
	
	_showErrorMessageBox: function(title, msg){
        Ext.MessageBox.show({
           title: title,
           msg: msg,
           buttons: Ext.MessageBox.OK,
           icon: Ext.MessageBox.ERROR
       });
	}
};

ORYX.Plugins.BPMN2_0Serialization = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN2_0Serialization);/**
 * Copyright (c) 2009
 * Helen Kaltegaertner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
 * Enables exporting and importing current model in JSON.
 */
ORYX.Plugins.TBPMSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	canvasId: "ext-gen56",
	
    construct: function(facade, ownPluginData){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        
        this.facade.offer({
            name: ORYX.I18N.TBPMSupport.imp.name,
            functionality: this.showImportDialog.bind(this),
            group: ORYX.I18N.TBPMSupport.imp.group,
            //dropDownGroupIcon: ORYX.PATH + "images/tbpm.png",
			icon: ORYX.PATH + "images/page_white_picture.png",
            description: ORYX.I18N.TBPMSupport.imp.desc,
            index: 3,
            minShape: 0,
            maxShape: 0
        });
        
        ownPluginData.properties.each( function(property) {			
			if (property.name == "tbpm_recognition_service") {
				this.tbpmImportServletURL = property.value;
			}
		}.bind(this));
    },
    
    /**
     * Opens a upload dialog.
     *
     */
    showImportDialog: function(successCallback){
        this.form = new Ext.form.FormPanel({
            baseCls: 'x-plain',
            labelWidth: 50,
            defaultType: 'textfield',
            fileUpload : true,
		  	enctype : 'multipart/form-data',
            items: [{
                text: ORYX.I18N.TBPMSupport.imp.selectFile,
                style: 'font-size:12px;margin-bottom:10px;display:block;',
                anchor: '100%',
                xtype: 'label'
            }, {
                fieldLabel: ORYX.I18N.TBPMSupport.imp.file,
                name: 'subject',
                inputType: 'file',
                style: 'margin-bottom:10px;display:block;width:95%',
                itemCls: 'ext_specific_window_overflow'
            }]
        });
        
        // Create the panel
        this.dialog = new Ext.Window({
            autoCreate: true,
            layout: 'fit',
            plain: true,
            bodyStyle: 'padding:5px;',
            title: ORYX.I18N.TBPMSupport.imp.name,
            height: 150,
            width: 500,
            modal: true,
            fixedcenter: true,
            shadow: true,
            proxyDrag: true,
            resizable: true,
            items: [this.form],
            buttons: [{
                text: ORYX.I18N.TBPMSupport.imp.btnImp,
                handler: this.uploadImage.bind(this)
            }, {
                text: ORYX.I18N.TBPMSupport.imp.btnClose,
                handler: function(){
                    this.dialog.close();
                }.bind(this)
            }]
        });
        
        this.dialog.on('hide', function(){
			this.dialog.destroy(true);
			delete this.dialog;
		}.bind(this));
        
        // Show the panel
        this.dialog.show();        
    },
    uploadImage: function(button, event) {    	
		this.form.form.submit({	
    				url: this.tbpmImportServletURL, 
    				clientValidation: true,
    				waitMsg:'Processing picture...',
    				method: "POST",
    				
    				success: function(form, action) {
						this.dialog.hide();
						this.showConfirmDialog(action.response.responseText);
				    }.bind(this),
    			    
    			    // invokes failure handler even i case of successful response (no idea why)
    				failure: function(form, action){
    			    	this.dialog.hide();
    					this.showConfirmDialog(action.response.responseText);
    			    	
    					//"real" failure callback 
    			    	//this.dialog.hide();
    				}.bind(this)
    	});
        
    },  
    
    /*
     * show image with highlighted shapes
     * import model and image layer if image confirmed
     */
    showConfirmDialog: function(json){
    	var obj = Ext.util.JSON.decode(json);
    	imgUri = obj.uri;
    	
    	var confirmDialog = new Ext.Window({
    		autoCreate: true,
    		layout: 'fit',
    		width: 600,
    	    height: 500,
    	    bodyStyle: 'padding:5px;',
    	    autoScroll: true,
    	    modal: true,
            fixedcenter: true,
            shadow: true,
            proxyDrag: true,
            resizable: true,
    	    title: ORYX.I18N.TBPMSupport.imp.confirm,
    	    html: '<div style="width:100%;">' +
            			'<img src="'+ imgUri + '" style="width:550px;"></img>'+
            		'</div>',
    	    
    	    buttons: [{
                text: ORYX.I18N.TBPMSupport.imp.btnImp,
                handler: function() {
    	    		confirmDialog.close();
    	    		this.processImport(imgUri, obj.model, obj.width, obj.height);
    	    	}.bind(this)
            }, {
                text: ORYX.I18N.TBPMSupport.imp.btnClose,
                handler: function(){
                    confirmDialog.close();
                }.bind(this)
            }]
    	});
    	
    	confirmDialog.show();
    },
    /*
     * import json and resizre canvas if necessary
     */
    processImport: function(imgUri, model, width, height){
    	var canvas = this.facade.getCanvas();
    	this.addImageLayer(imgUri);
    	this.importShapes(model);
    	if (canvas.bounds.width() < width)
    		canvas.setSize({width: width + 50, height: canvas.bounds.height()});
    	if (canvas.bounds.height() < height)
    		canvas.setSize({height: height + 50, width: canvas.bounds.width()});
    	// update the canvas
		canvas.update();
    },
    
    /*
     * show transparent Layer with image
     * 
     */
    addImageLayer: function(imgUri){  
    	this.facade.getCanvas().properties["oryx-photo"] = imgUri;
		$(this.canvasId).style.background = "url(" + imgUri + ") no-repeat scroll 0% 0%";
    },
    
    /*
     * generate detected shapes
     */
    importShapes: function(json){
    	this.facade.importJSON(json, true);
		$A($$('rect')).each( 
			function(rect) {
				if (rect.id.endsWith("bg_frame")){
					rect.setAttributeNS(null,"fill","None");
					rect.setAttributeNS(null,"stroke-width","4");
				}
			}.bind(this)
		)
		
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_TBPM_BACKGROUND_UPDATE});
    }

   
});/**
 * Copyright (c) 2006
 * Helen Kaltegaertner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.TBPMShapeConnector = Clazz.extend({

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;
		this.active = false;
		this.sourceNode = null;

		this.facade.offer({
			name:			ORYX.I18N.TBPMShapeconnctor.name,
			functionality: 	this.enableConnector.bind(this),
			group: 			ORYX.I18N.TBPMShapeconnctor.group,
			//dropDownGroupIcon: ORYX.PATH + "images/tbpm.png",
			icon: 			ORYX.PATH + "images/pencil_go.png",
			description: 	ORYX.I18N.TBPMShapeconnctor.desc,
			index: 			1,
            toggle: 		true,
			minShape: 		0,
			maxShape: 		0});
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));
	},
	
	enableConnector: function(button, pressed) {
		this.connectButton = button;
		if (!pressed){
        	this.active = false;
        	this.sourceNode = null;
        }
		else {
			this.active = true;
			this.facade.raiseEvent({
				type:ORYX.CONFIG.EVENT_LOADING_STATUS,
				text:ORYX.I18N.TBPMShapeconnctor.usage
			});
		}
	},	
	/**
	 * MouseDown Handler
	 *
	 */	
	handleMouseDown: function(event, uiObj) {
		if (this.active && uiObj instanceof ORYX.Core.Node) {
            if (this.sourceNode){	
	            if (! this.createEdge( this.sourceNode, uiObj))
	            	return;
	            this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });
            }
        	this.sourceNode = uiObj
		}
		else if (this.active) {
			if (this.connectButton){
				this.connectButton.toggle();
			}
		}
	},
    
	createEdge: function(source, target){

		// Create a new Stencil		
		var ssn 	= this.facade.getStencilSets().keys()[0];						
		var stencil = ORYX.Core.StencilSet.stencil(ssn + "SequenceFlow");
		var isValid = this.facade.getRules().canConnect({
			sourceShape: source,
			edgeStencil: stencil,
			targetShape: target
		});	
		//if(!isValid)
		//	return null;
		
		var command = new ORYX.Plugins.TBPMShapeConnector.CreateEdge(source, target, stencil, this.facade);
        
		this.facade.executeCommands([command]);		
		return command.edge;
					
	},
});
ORYX.Plugins.TBPMShapeConnector.CreateEdge = ORYX.Core.Command.extend({
    construct: function(source, target, stencil, facade){
        this.source          	= source;
        this.target       		= target;
        this.stencil      		= stencil;
        this.facade             = facade;
                
    },          
    execute: function(){
		console.log("execute");
    	var edge = new ORYX.Core.Edge({'eventHandlerCallback':this.facade.raiseEvent}, this.stencil);
		edge.dockers.first().setDockedShape( this.source );
		edge.dockers.first().setReferencePoint({x: this.source.bounds.width() / 2.0, y: this.source.bounds.height() / 2.0});
		//shape.dockers.first().update()

		edge.dockers.last().setDockedShape( this.target );
		edge.dockers.last().setReferencePoint({x: this.target.bounds.width() / 2.0, y: this.target.bounds.height() / 2.0});
		
		// Add the shape to the canvas
		this.facade.getCanvas().add(edge);
        this.facade.getCanvas().update();		
        this.edge = edge;
    },
    rollback: function(){
        this.facade.deleteShape(this.edge);
        this.facade.getCanvas().update();	
		this.facade.updateSelection();
        
    }
});/**
 * Copyright (c) 2009
 * Helen Kaltegaertner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

/**
 * Enables exporting and importing current model in JSON.
 */
ORYX.Plugins.TBPMCanvasMode = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,	
	canvasId: "ext-gen56",
	fill: "#ffffcc",
	edited: "RGBA(255,255,255,0.8)",
	shapeTransform: false,
	
    construct: function(){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
        /*
        if ( $(this.canvasId).getStyle("backgroundImage") ){
        	this.background = $(this.canvasId).getStyle("background");
        }
        else
        	this.background = null;
        
        this.background = $(this.canvasId).style.background;
        
        */
        this.facade.offer({
			name:			ORYX.I18N.TBPMCanvasMode.name,
			functionality: 	this.enableToggle.bind(this),
			group: 			ORYX.I18N.TBPMCanvasMode.group,
			//dropDownGroupIcon: ORYX.PATH + "images/tbpm.png",
			icon: 			ORYX.PATH + "images/shape_move_backwards.png",
			description: 	ORYX.I18N.TBPMCanvasMode.desc,
			index: 			1,
            toggle: 		true,
			minShape: 		0,
			maxShape: 		0});
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_TBPM_BACKGROUND_UPDATE, this.enableShapeTransform.bind(this));
    },
    
    enableShapeTransform: function(){
    	if (!this.shapeTransform){
    		this.shapeTransform = true;
    		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPERTY_CHANGED, this.updateShapeSVG.bind(this));
		}
    },
    
    updateShapeSVG: function(event){
    	if (this.shapeTransform){
			var shape = event.elements[0];
			if (shape && event.name == "oryx-name" && !shape.isEdited ){
				shape._svgShapes.each(function(svgShape){
					if (svgShape.element.id && svgShape.element.id.endsWith("bg_frame")){
						svgShape.element.isEdited = true;	// for check before mode change
						shape.isEdited = true;		// for check after PROPERTY_CHANGED						
						svgShape.element.setAttributeNS(null,"fill",this.edited);
					}
				}.bind(this));
			}
			shape.refresh();
			this.facade.getCanvas().update();
		}
    },
    
    enableToggle: function(button, pressed) {

    	if (pressed && $(this.canvasId).getStyle("backgroundImage")){
    		
    		$(this.canvasId).style.background = "";
			$A($$('rect')).each( 
				function(rect) {
    				if (rect.id.endsWith("bg_frame")){
    					rect.setAttributeNS(null,"fill",this.fill);
    					rect.setAttributeNS(null,"stroke-width","1");
    				}
				}.bind(this)
    		)
			
    		this.shapeTransform = false;
    		
    	}
		else if (!pressed && this.facade.getCanvas().properties["oryx-photo"]){
			$(this.canvasId).style.background = 
				"url(" + this.facade.getCanvas().properties["oryx-photo"] + ") no-repeat scroll 0% 0%";;
			$A($$('rect')).each( 
				function(rect) {
					if (rect.id.endsWith("bg_frame")){
						if (rect.isEdited)
							rect.setAttributeNS(null,"fill",this.edited);
						else
							rect.setAttributeNS(null,"fill","None");
						rect.setAttributeNS(null,"stroke-width","4");
					}
				}.bind(this)
			);
			this.shapeTransform = true;				
		}
	}
   
});/**
 * Copyright (c) 2009
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins) { ORYX.Plugins = {} }
if(!ORYX.Plugins.Layouter) { ORYX.Plugins.Layouter = {} }

new function(){
	
	/**
	 * Edge layouter is an implementation to layout an edge
	 * @class ORYX.Plugins.Layouter.EdgeLayouter
	 * @author Willi Tscheschner
	 */
	ORYX.Plugins.Layouter.EdgeLayouter = ORYX.Plugins.AbstractLayouter.extend({
		
		/**
		 * Layout only Edges
		 */
		layouted : [	"http://b3mn.org/stencilset/bpmn1.1#SequenceFlow", 
						"http://b3mn.org/stencilset/bpmn1.1#MessageFlow",
						"http://b3mn.org/stencilset/bpmn2.0#MessageFlow",
						"http://b3mn.org/stencilset/bpmn2.0#SequenceFlow", 
						"http://b3mn.org/stencilset/bpmn2.0conversation#ConversationLink",
						"http://b3mn.org/stencilset/epc#ControlFlow",
						"http://www.signavio.com/stencilsets/processmap#ProcessLink",
						"http://www.signavio.com/stencilsets/organigram#connection"],
		
		/**
		 * Layout a set on edges
		 * @param {Object} edges
		 */
		layout: function(edges){
			edges.each(function(edge){
				this.doLayout(edge)
			}.bind(this))
		},
		
		/**
		 * Layout one edge
		 * @param {Object} edge
		 */
		doLayout: function(edge){
			// Get from and to node
			var from 	= edge.getIncomingNodes()[0]; 
			var to 		= edge.getOutgoingNodes()[0];
			
			// Return if one is null
			if (!from || !to) { return }
			
			var positions = this.getPositions(from, to, edge);
		
			if (positions.length > 0){
				this.setDockers(edge, positions[0].a, positions[0].b);
			}
				
		},
		
		/**
		 * Returns a set on positions which are not containt either 
		 * in the bounds in from or to.
		 * @param {Object} from Shape where the edge is come from
		 * @param {Object} to Shape where the edge is leading to
		 * @param {Object} edge Edge between from and to
		 */
		getPositions : function(from, to, edge){
			
			// Get absolute bounds
			var ab = from.absoluteBounds();
			var bb = to.absoluteBounds();
			
			// Get center from and to
			var a = ab.center();
			var b = bb.center();
			
			var am = ab.midPoint();
			var bm = bb.midPoint();
		
			// Get first and last reference point
			var first = Object.clone(edge.dockers.first().referencePoint);
			var last = Object.clone(edge.dockers.last().referencePoint);
			// Get the absolute one
			var aFirst = edge.dockers.first().getAbsoluteReferencePoint();
			var aLast = edge.dockers.last().getAbsoluteReferencePoint(); 
			
			// IF ------>
			// or  |
			//     V
			// Do nothing
			if (Math.abs(aFirst.x-aLast.x) < 1 || Math.abs(aFirst.y-aLast.y) < 1) {
				return []
			}
			
			// Calc center position, between a and b
			// depending on there weight
			var m = {}
			m.x = a.x < b.x ? 
					(((b.x - bb.width()/2) - (a.x + ab.width()/2))/2) + (a.x + ab.width()/2): 
					(((a.x - ab.width()/2) - (b.x + bb.width()/2))/2) + (b.x + bb.width()/2);

			m.y = a.y < b.y ? 
					(((b.y - bb.height()/2) - (a.y + ab.height()/2))/2) + (a.y + ab.height()/2): 
					(((a.y - ab.height()/2) - (b.y + bb.height()/2))/2) + (b.y + bb.height()/2);
								
								
			// Enlarge both bounds with 10
			ab.widen(5); // Wide the from less than 
			bb.widen(20);// the to because of the arrow from the edge
								
			var positions = [];
			var off = this.getOffset.bind(this);
			
			// Checks ----+
			//            |
			//            V
			if (!ab.isIncluded(b.x, a.y)&&!bb.isIncluded(b.x, a.y)) {
				positions.push({
					a : {x:b.x+off(last,bm,"x"),y:a.y+off(first,am,"y")},
					z : this.getWeight(from, a.x < b.x ? "r" : "l", to, a.y < b.y ? "t" : "b", edge)
				});
			}
						
			// Checks | 
			//        +--->
			if (!ab.isIncluded(a.x, b.y)&&!bb.isIncluded(a.x, b.y)) {
				positions.push({
					a : {x:a.x+off(first,am,"x"),y:b.y+off(last,bm,"y")},
					z : this.getWeight(from, a.y < b.y ? "b" : "t", to, a.x < b.x ? "l" : "r", edge)
				});
			}
						
			// Checks  --+
			//           |
			//           +--->
			if (!ab.isIncluded(m.x, a.y)&&!bb.isIncluded(m.x, b.y)) {
				positions.push({
					a : {x:m.x,y:a.y+off(first,am,"y")},
					b : {x:m.x,y:b.y+off(last,bm,"y")},
					z : this.getWeight(from, "r", to, "l", edge, a.x > b.x)
				});
			}
			
			// Checks | 
			//        +---+
			//            |
			//            V
			if (!ab.isIncluded(a.x, m.y)&&!bb.isIncluded(b.x, m.y)) {
				positions.push({
					a : {x:a.x+off(first,am,"x"),y:m.y},
					b : {x:b.x+off(last,bm,"x"),y:m.y},
					z : this.getWeight(from, "b", to, "t", edge, a.y > b.y)
				});
			}	
			
			// Sort DESC of weights
			return positions.sort(function(a,b){ return a.z < b.z ? 1 : (a.z == b.z ? -1 : -1)});
		},
		
		/**
		 * Returns a offset for the pos to the center of the bounds
		 * 
		 * @param {Object} val
		 * @param {Object} pos2
		 * @param {String} dir Direction x|y
		 */
		getOffset: function(pos, pos2, dir){
			return pos[dir] - pos2[dir];
		},
		
		/**
		 * Returns a value which shows the weight for this configuration
		 * 
		 * @param {Object} from Shape which is coming from
		 * @param {String} d1 Direction where is goes
		 * @param {Object} to Shape which goes to
		 * @param {String} d2 Direction where it comes to
		 * @param {Object} edge Edge between from and to
		 * @param {Boolean} reverse Reverse the direction (e.g. "r" -> "l")
		 */
		getWeight: function(from, d1, to, d2, edge, reverse){
			
			d1 = (d1||"").toLowerCase();
			d2 = (d2||"").toLowerCase();
			
			if (!["t","r","b","l"].include(d1)){ d1 = "r"}
			if (!["t","r","b","l"].include(d2)){ d1 = "l"}
			
			// If reverse is set
			if (reverse) {
				// Reverse d1 and d2
				d1 = d1=="t"?"b":(d1=="r"?"l":(d1=="b"?"t":(d1=="l"?"r":"r")))
				d2 = d2=="t"?"b":(d2=="r"?"l":(d2=="b"?"t":(d2=="l"?"r":"r")))
			}
			
					
			var weight = 0;
			// Get rules for from "out" and to "in"
			var dr1 = this.facade.getRules().getLayoutingRules(from, edge)["out"];
			var dr2 = this.facade.getRules().getLayoutingRules(to, edge)["in"];

			var fromWeight = dr1[d1];
			var toWeight = dr2[d2];


			/**
			 * Return a true if the center 1 is in the same direction than center 2
			 * @param {Object} direction
			 * @param {Object} center1
			 * @param {Object} center2
			 */
			var sameDirection = function(direction, center1, center2){
				switch(direction){
					case "t": return Math.abs(center1.x - center2.x) < 2 && center1.y < center2.y
					case "r": return center1.x > center2.x && Math.abs(center1.y - center2.y) < 2
					case "b": return Math.abs(center1.x - center2.x) < 2 && center1.y > center2.y
					case "l": return center1.x < center2.x && Math.abs(center1.y - center2.y) < 2
					default: return false;
				}
			}

			// Check if there are same incoming edges from 'from'
			var sameIncomingFrom = from
								.getIncomingShapes()
								.findAll(function(a){ return a instanceof ORYX.Core.Edge})
								.any(function(e){ 
									return sameDirection(d1, e.dockers[e.dockers.length-2].bounds.center(), e.dockers.last().bounds.center());
								});

			// Check if there are same outgoing edges from 'to'
			var sameOutgoingTo = to
								.getOutgoingShapes()
								.findAll(function(a){ return a instanceof ORYX.Core.Edge})
								.any(function(e){ 
									return sameDirection(d2, e.dockers[1].bounds.center(), e.dockers.first().bounds.center());
								});
			
			// If there are equivalent edges, set 0
			//fromWeight = sameIncomingFrom ? 0 : fromWeight;
			//toWeight = sameOutgoingTo ? 0 : toWeight;
			
			// Get the sum of "out" and the direction plus "in" and the direction 						
			return (sameIncomingFrom||sameOutgoingTo?0:fromWeight+toWeight);
		},
		
		/**
		 * Removes all current dockers from the node 
		 * (except the start and end) and adds two new
		 * dockers, on the position a and b.
		 * @param {Object} edge
		 * @param {Object} a
		 * @param {Object} b
		 */
		setDockers: function(edge, a, b){
			if (!edge){ return }
			
			// Remove all dockers (implicit,
			// start and end dockers will not removed)
			edge.dockers.each(function(r){
				edge.removeDocker(r);
			});
			
			// For a and b (if exists), create
			// a new docker and set position
			[a, b].compact().each(function(pos){
				var docker = edge.createDocker(undefined, pos);
				docker.bounds.centerMoveTo(pos);
			});
			
			// Update all dockers from the edge
			edge.dockers.each(function(docker){
				docker.update()
			})
			
			// Update edge
			//edge.refresh();
			edge._update(true);
			
		}
	});
	
	
}()
/**
 * Copyright (c) 2009
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if (!ORYX) 
	ORYX = new Object();
if (!ORYX.Plugins) 
	ORYX.Plugins = new Object();

ORYX.Plugins.EPCLayouter = ORYX.Plugins.AbstractPlugin.extend({
	facade: undefined,
	construct: function(facade){
		this.facade = facade;
		this.facade.offer({
			'name' : "Layout-EPC",
			'description' : "Layout EPC Model",
			'functionality' : this.layout.bind(this),
			'group' : "Layout",
			'icon' : ORYX.PATH + "images/auto_layout.png",
			'index' : 1,
			'minShape' : 0,
			'maxShape' : 0
		});
	},
	layout: function(){
		
		this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
			text: ORYX.I18N.Layouting.doing
        });
		
		
		new Ajax.Request(ORYX.CONFIG.EPC_LAYOUTER, {
			method : 'POST',
			asynchronous : false,
			parameters : {
				data: this.facade.getSerializedJSON()
			},
			onFailure: function(request){
				Ext.Msg.alert("Layouting Error", "Error while layouting:!\n" + request.responseText);
            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			},
			onSuccess: function(request){

				/*Ext.Msg.alert("Oryx", "New Layout arrived:!\n" + request.responseText);*/
				
				var setLayoutCommandClass = ORYX.Core.Command.extend({
					construct: function(layoutArray, plugin){
						this.layoutArray = layoutArray;
						this.plugin = plugin;
						this.oldLayoutArray = [];
					},
					execute: function(){
						this.layoutArray.each(function(elem){
							/* get shape */
							var shape = this.plugin.facade.getCanvas().getChildShapeByResourceId(elem.id);
							
							/* save old layout for undo*/
							var oldLayout = {
								id : elem.id,
								bounds : shape.bounds.clone()
							};
							this.oldLayoutArray.push(oldLayout);
							
							/* set new bounds */
							var bound = elem.bounds.split(" ");
							shape.bounds.set(bound[0],bound[1],bound[2],bound[3]);
							
							/* set new dockers */
							if(elem.dockers != null){
								this.plugin.setDockersBad(shape,elem.dockers);
							}
							
							shape.update();
						}.bind(this));
						
						this.plugin.facade.getCanvas().update();
						this.plugin.facade.updateSelection();					
						
					},
					rollback: function(){
						this.oldLayoutArray.each(function(elem){
							var shape = this.plugin.facade.getCanvas().getChildShapeByResourceId(elem.id);
							shape.bounds.set(elem.bounds);
							shape.update();
						}.bind(this));
						
						this.plugin.facade.getCanvas().update();
						this.plugin.facade.updateSelection();	
					}
				});
				
				
				var resp = request.responseText.evalJSON();
				if (resp instanceof Array && resp.size() > 0) {
					/* create command */
					var command = new setLayoutCommandClass(resp, this);
					/* execute command */
					this.facade.executeCommands([command]);
				}
            	this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			}.bind(this)
		})
	},
	setDockersBad: function(shape, dockers){
		var dockersString = "";
		dockers.each(function(p){
			dockersString += p.x + " " + p.y + " ";
		});
		dockersString += " # ";
		shape.deserialize([{
								prefix: 'oryx',
								name: 'dockers',
								value: dockersString
							}]);
	},
	setDockersGood: function(shape, dockers){
		if(elem.dockers.length == 1){
			/* docked event */
			
		}else{
			
			/* clear all except of the first and last dockers */
			var dockers = shape.getDockers().slice(1,-1);
			dockers.each(function(docker){
				shape.removeDocker(docker);
			});
			
			/* set first and last docker */
			var firstDocker = shape.getDockers()[0];
			if (firstDocker.getDockedShape()) {
				firstDocker.setReferencePoint(elem.dockers[0]);
			}
			else {
				firstDocker.bounds.moveTo(elem.dockers[0].x,elem.dockers[0].y);
			}
			firstDocker.refresh();
			
			var lastDocker = shape.getDockers()[1];
			if (lastDocker.getDockedShape()) {
				lastDocker.setReferencePoint(elem.dockers[elem.dockers.length - 1]);
			}
			else {
				lastDocker.bounds.moveTo(elem.dockers[elem.dockers.length - 1].x, elem.dockers[elem.dockers.length - 1].y);
			}
			lastDocker.refresh();
			
			/* add new dockers except of the first and last */
			var dockersToAdd = elem.dockers.slice(1,-1);
			dockersToAdd.each(function(dockerPoint){
				var newDocker = shape.createDocker();
				newDocker.parent = shape;
				newDocker.bounds.centerMoveTo(dockerPoint.x, dockerPoint.y);
				/*newDocker.setReferencePoint(dockerPoint);*/
				newDocker.update();
			});
		}		
	}
});
/**
 * Copyright (c) 2007
 * Kerstin Pfitzner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


if(!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}


ORYX.Plugins.TransformationDownloadDialog = {

	construct: function() {
	},
	
	

	
	/**
	 * Opens a message dialog with the given title that shows
	 * the content. The dialog just shows a message and has a 
	 * "OK" button to be closed.
	 * 
	 * @param {String} title   The title of the dialog
	 * @param {String} content The content to be shown in the dialog
	 */
	openMessageDialog: function(title, content) {
		
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			title: title, 
			modal:true,
			height: 120,
			width: 400,
			collapsible:false,
			fixedcenter: true, 
			shadow:true, 
			resizable:true,
			proxyDrag: true,
			autoScroll:true,
			buttonAlign:"center",
            bodyStyle:'padding:10px',
            html:'<span class="ext-mb-text">' + content + '</span>'
                        
		});
		//dialog.addKeyListener(27, dialog.hide, dialog);
		dialog.addButton('OK', dialog.hide, dialog);
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});
		
		dialog.show();
	},
	
	
	/**
	 * Opens an error dialog that shows the given content.
	 * The error is shown in a text area.
	 * 
	 * @param {String} content The error to be shown
	 */
	openErrorDialog: function(content) {
		// Basic Dialog
		var text = new Ext.form.TextArea({
			id:'error-field',
			fieldLabel: ORYX.I18N.TransformationDownloadDialog.error,
			name: 'desc',
			height: 405,
			width: 633,
			preventScrollbars: true,
			value: content,
			readOnly:true
        });
		
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			title: ORYX.I18N.TransformationDownloadDialog.errorParsing, 
			modal:true,
			height: 450,
			width: 650,
			collapsible:false,
			fixedcenter: true, 
			shadow:true, 
			resizable:false,
			proxyDrag: true,
			autoScroll:false
		});
		//dialog.addKeyListener(27, dialog.hide, dialog);
		dialog.on('hide', function(){
			dialog.destroy(true);
			text.destroy(true);
			delete dialog;
			delete text;
		});
		text.render(dialog.body);
		
		dialog.show();
	},
	
	
	/**
	 * Opens a dialog that presents the results of a transformation.
	 * The dialog shows a list containing the resulting XML files.
	 * Each file can be shown in a new window or downloaded.
     *
	 * @param {Object} data The data to be shown in the dialog
	 * Format: array with three elements: 
	 *   * file - the file
	 *   * result - the content of file, may also be an error message.
	 *   * info - status of the result: "success" or "error"
	 */
	openResultDialog: function(data) {

		var ds = new Ext.data.Store({
	        proxy: new Ext.data.MemoryProxy(data),
	        reader: new Ext.data.ArrayReader({}, [
	               {name: 'file', type: 'string'},
	               {name: 'result', type: 'string'},
	               {name: 'info', type: 'string'}
	        	])
		});
		
		ds.load();

		// renderer
		var infoRenderer = function (val){
            if(val == "success"){
                return '<span style="color:green;">' + val + '</span>';
            }else if(val == "error"){
                return '<span style="color:red;">' + val + '</span>';
            }
            return val;
        };
	
		var cm = new Ext.grid.ColumnModel([
		    {id:'file',header: "File", width: 200, sortable: false, dataIndex: 'file', resizable: false},
		    {header: "Info", width: 75, sortable: false, dataIndex: 'info', renderer: infoRenderer, resizable: false} 
		]);
				
		var grid = new Ext.grid.GridPanel({
			store:ds,
	        cm: cm,
	        sm: new Ext.grid.RowSelectionModel({ 	singleSelect:true }),
			autoWidth: true
	    });
		
	    var toolbar = new Ext.Toolbar();
		
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			title: ORYX.I18N.TransformationDownloadDialog.transResult, 
			autoHeight: true, 
			width: 297, 
			modal:true,
			collapsible:false,
			fixedcenter: true, 
			shadow:true, 
			proxyDrag: true,
			resizable:false,
			items:[toolbar, grid]
		});
	
		dialog.on('hide', function(){
			dialog.destroy(true);
			grid.destroy(true);
			delete dialog;
			delete grid;
		});
		dialog.show();
		
		toolbar.add({
			icon: 'images/view.png', // icons can also be specified inline
	        cls: 'x-btn-icon',
    	    tooltip: ORYX.I18N.TransformationDownloadDialog.showFile,
			handler: function() {
				var ds = grid.getStore();
				var selection = grid.getSelectionModel().getSelected();
				if (selection == undefined) {
					return;
				}
				var show = selection.get("result");
				if (selection.get("info") == "success") {
					this.openXMLWindow(show);
				} else {
					this.openErrorWindow(show);
				}
			}.bind(this)
		});
		toolbar.add({
			icon: 'images/disk.png', // icons can also be specified inline
	        cls: 'x-btn-icon',
    	    tooltip: ORYX.I18N.TransformationDownloadDialog.downloadFile,
			handler: function() {
				var ds = grid.getStore();
				var selection = grid.getSelectionModel().getSelected();
				if (selection == undefined) {
					return;
				}
				this.openDownloadWindow(selection, false);
			}.bind(this)
		});
		toolbar.add({
			icon: 'images/disk_multi.png', // icons can also be specified inline
	        cls: 'x-btn-icon',
    	    tooltip: ORYX.I18N.TransformationDownloadDialog.downloadAll,
			handler: function() {
				var ds = grid.getStore();				
				this.openDownloadWindow(ds.getRange(0, ds.getCount()), true);
			}.bind(this)
		});			
		
		// Select the first row
		grid.getSelectionModel().selectFirstRow();
	},
	
	
	/**
	 * Opens a new window that shows the given XML content.
	 * 
	 * @param {Object} content The XML content to be shown.
	 */
	openXMLWindow: function(content) {
		var win = window.open(
		   'data:application/xml,' + encodeURIComponent([
		     content
		   ].join('\r\n')),
		   '_blank', "resizable=yes,width=600,height=600,toolbar=0,scrollbars=yes"
		);
	},
	
	
	/**
	 * Opens a window that shows the given text content.
	 * 
	 * @param {Object} content The text content to be shown.
	 */
	openErrorWindow: function(content) {
		var win = window.open(
		   'data:text/html,' + encodeURIComponent([
		     "<html><body><pre>" + content + "</pre></body></html>"
		   ].join('\r\n')),
		   '_blank', "resizable=yes,width=800,height=300,toolbar=0,scrollbars=yes"
		);
	},
	
	
	/**
	 * Creates a hidden form element to communicate parameter values
	 * to a php file.
	 * 
	 * @param {Object} name  The name of the hidden field
	 * @param {Object} value The value of the hidden field
	 */
	createHiddenElement: function(name, value) {
		var newElement = document.createElement("input");
		newElement.name=name;
		newElement.type="hidden";
		newElement.value = value;
		return newElement
	},
	
	
	/**
	 * Adds a file extension to the given file name. If the file
	 * has the name "topology" or "XPDL4Chor" an .xml extension will
	 * be added. Otherwise a .bpel extension will be added
	 * 
	 * @param {Object} file The file name to add the extension to.
	 */
	addFileExtension: function(file) {
		if ((file.toLowerCase() == "topology") || (file == "XPDL4Chor")) {
			return file + ".xml";
		} else {
			return file + ".bpel";
		}
	},
	
	
	/**
	 * Opens a download window for downloading the given content.
	 * 
	 * Creates a submit form to send the contents to the 
	 * Oryx Legacy File Download Servlet (MultiDownloader).
	 * 
	 * @param {Object} content The content to be downloaded. If it is a zip 
	 *                         file, then this should be an array of contents.
	 * @param {Object} zip     True, if it is a zip file, false otherwise
	 */
	openDownloadWindow: function(content, zip) {
		var win = window.open("");
		if (win != null) {
			win.document.open();
			win.document.write("<html><body>");
			var submitForm = win.document.createElement("form");
			win.document.body.appendChild(submitForm);
			
			if (zip) {
				for (var i = 0; i < content.length; i++) {
					var file = this.addFileExtension(content[i].get("file"));
					submitForm.appendChild( this.createHiddenElement("download_" + i, content[i].get("result")));
					submitForm.appendChild( this.createHiddenElement("file_" + i, file));
				}
			} else {
				var file = this.addFileExtension(content.get("file"));
				submitForm.appendChild( this.createHiddenElement("download", content.get("result")));
				submitForm.appendChild( this.createHiddenElement("file", file));
			}
			
			submitForm.method = "POST";
			win.document.write("</body></html>");
			win.document.close();
			submitForm.action= "download";
			submitForm.submit();
		}		
	},
	
		
	/**
	 * Determines if the result is an XML file or not.
	 * For this purpose it is determined if the given
	 * result starts with "<?xml".
	 * 
	 * @param {Object} result The result to be checked.
	 * @return "success" if it is an XML file, "error" otherwise
	 */
	getResultInfo: function(result) {
		if (!result) {
			return "error";
		} else if (result.substr(0, 5) == "<?xml") {
			return "success";
		}
		
		return "error";
	},

	
	/**
	 * Determines the process name for a given process
	 * string. 
	 * 
	 * @param {String} process The BPEL4Chor process.
	 */
	getProcessName: function(process) {
		var parser	= new DOMParser();
		var doc		= parser.parseFromString(process,"text/xml");
		var name 	= doc.documentElement.getAttribute("name");
		return name;
	}
}

ORYX.Plugins.TransformationDownloadDialog = Clazz.extend(ORYX.Plugins.TransformationDownloadDialog);/**
 * Copyright (c) 2010
 * Changhua Li
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/


if(!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}


ORYX.Plugins.TransformationDownloadDialogForBPEL4Chor = {
		
	construct: function() {
		arguments.callee.$.construct.apply(this, arguments);
	},
	/**
	 * Opens a dialog that presents the results of a transformation.
	 * The dialog shows a list containing the resulting XML files.
	 * Each file can be shown in a new window or downloaded.
     *
	 * @param {Object} data The data to be shown in the dialog
	 * Format: array with three elements: 
	 *   * file - the file
	 *   * result - the content of file, may also be an error message.
	 *   * info - status of the result: "success" or "error"
	 */
	openResultDialog: function(data) {

		var ds = new Ext.data.Store({
	        proxy: new Ext.data.MemoryProxy(data),
	        reader: new Ext.data.ArrayReader({}, [
	               {name: 'file', type: 'string'},
	               {name: 'result', type: 'string'},
	               {name: 'info', type: 'string'}
	        	])
		});
		
		ds.load();

		// renderer
		var infoRenderer = function (val){
            if(val == "success"){
                return '<span style="color:green;">' + val + '</span>';
            }else if(val == "error"){
                return '<span style="color:red;">' + val + '</span>';
            }
            return val;
        };
	
		var cm = new Ext.grid.ColumnModel([
		    {id:'file',header: "File", width: 200, sortable: false, dataIndex: 'file', resizable: false},
		    {header: "Info", width: 75, sortable: false, dataIndex: 'info', renderer: infoRenderer, resizable: false} 
		]);
				
		var grid = new Ext.grid.GridPanel({
			store:ds,
	        cm: cm,
	        sm: new Ext.grid.RowSelectionModel({ 	singleSelect:true }),
			autoWidth: true
	    });
		
	    var toolbar = new Ext.Toolbar();
		
		var dialog = new Ext.Window({ 
			autoCreate: true, 
			title: ORYX.I18N.TransformationDownloadDialog.transResult, 
			autoHeight: true, 
			width: 297, 
			modal:true,
			collapsible:false,
			fixedcenter: true, 
			shadow:true, 
			proxyDrag: true,
			resizable:false,
			items:[toolbar, grid]
		});
	
		dialog.on('hide', function(){
			dialog.destroy(true);
			grid.destroy(true);
			delete dialog;
			delete grid;
		});
		dialog.show();
		
		toolbar.add({
			icon: 'images/view.png', // icons can also be specified inline
	        cls: 'x-btn-icon',
    	    tooltip: ORYX.I18N.TransformationDownloadDialog.showFile,
			handler: function() {
				var ds = grid.getStore();
				var selection = grid.getSelectionModel().getSelected();
				if (selection == undefined) {
					return;
				}
				var show = selection.get("result");
				if (selection.get("info") == "success") {
					this.openXMLWindow(show);
				} else {
					this.openErrorWindow(show);
				}
			}.bind(this)
		});
		toolbar.add({
			icon: 'images/disk.png', // icons can also be specified inline
	        cls: 'x-btn-icon',
    	    tooltip: ORYX.I18N.TransformationDownloadDialog.downloadFile,
			handler: function() {
				var ds = grid.getStore();
				var selection = grid.getSelectionModel().getSelected();
				if (selection == undefined) {
					return;
				}
				this.openDownloadWindow(selection, false);
			}.bind(this)
		});
		toolbar.add({
			icon: 'images/disk_multi.png', // icons can also be specified inline
	        cls: 'x-btn-icon',
    	    tooltip: ORYX.I18N.TransformationDownloadDialog.downloadAll,
			handler: function() {
				var ds = grid.getStore();				
				this.openDownloadWindow(ds.getRange(0, ds.getCount()), true);
			}.bind(this)
		});			

		// Select the first row
		grid.getSelectionModel().selectFirstRow();

	},
	
	/**
	 * Opens a download window for downloading the given content.
	 * 
	 * Creates a submit form to send the contents to the 
	 * Oryx Legacy File Download Servlet (MultiDownloader).
	 * 
	 * @param {Object} content The content to be downloaded. If it is a zip 
	 *                         file, then this should be an array of contents.
	 * @param {Object} zip     True, if it is a zip file, false otherwise
	 */
	openDownloadWindow: function(content, zip) {
		var win = window.open("");
		if (win != null) {
			win.document.open();
			win.document.write("<html><body>");
			var submitForm = win.document.createElement("form");
			win.document.body.appendChild(submitForm);
			
			try {
				if (zip) {
					for (var i = 0; i < content.length; i++) {
						var file = this.addFileExtension(content[i].get("file"));
						if(file.include("-wsdl")){
							file = file.replace("-wsdl","");
						}	
						submitForm.appendChild( this.createHiddenElement("download_" + i, content[i].get("result")));
						submitForm.appendChild( this.createHiddenElement("file_" + i, file));
					}
				} else {
					var file = this.addFileExtension(content.get("file"));
					if(file.include("-wsdl")){
						file = file.replace("-wsdl","");
					}
					submitForm.appendChild( this.createHiddenElement("download", content.get("result")));
					submitForm.appendChild( this.createHiddenElement("file", file));
				}
			} catch (error){
				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
				Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
			}
			
			submitForm.method = "POST";
			win.document.write("</body></html>");
			win.document.close();
			submitForm.action= "download";
			submitForm.submit();
		}		
	},
	
	/**
	 * Adds a file extension to the given file name. If the file
	 * include the name "wsdl", an .wsdl extension will
	 * be added. Otherwise a .bpel extension will be added
	 * 
	 * @param {Object} file The file name to add the extension to.
	 */
	addFileExtension: function(file) {
		if (file.include("wsdl")) {
			return file + ".wsdl";
		} else {
			return file + ".bpel";
		}
	},
	
	/**
	 * Determines if the result is an XML file or not.
	 * For this purpose it is determined if the given
	 * result starts with "<?xml".
	 * 
	 * @param {Object} result The result to be checked.
	 * @return "success" if it is an XML file, "error" otherwise
	 */
	getResultInfo: function(result) {
		if (!result) {
			return "error";
		} else if (result.substr(0, 5) == "<?xml") {
			return "success";
		}
		
		return "error";
	},
	
	/**
	 * Determines the process name for a given bpel
	 * string. 
	 * 
	 * @param {String} process The BPEL process.
	 */
	getBPELName: function(bpel) {
		var parser	= new DOMParser();
		var doc		= parser.parseFromString(bpel,"text/xml");
		var name 	= doc.documentElement.getAttribute("name");
		return name;
	}
}	

ORYX.Plugins.TransformationDownloadDialogForBPEL4Chor = ORYX.Plugins.TransformationDownloadDialog.extend(ORYX.Plugins.TransformationDownloadDialogForBPEL4Chor);/** * Copyright (c) 2007 Kerstin Pfitzner * Copyright (c) 2009 Oliver Kopp * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Transforms a BPMNplus diagram to its XPDL4Chor representation and * calls a transformation web service to generate BPEL4Chor from the XPDL4Chor * representation. */ORYX.Plugins.Bpel4ChorTransformation = ORYX.Plugins.AbstractPlugin.extend({	dialogSupport: undefined,		/**	 * Offers the plugin functionality:	 * 	- generation of XPDL4Chor	 * 	- generation of BPEL4Chor	 * 	 * Registers for a ORYX.CONFIG.EVENT_PROPERTY_CHANGED event to react to changed	 * element properties.	 */	construct: function() {        // Call super class constructor        arguments.callee.$.construct.apply(this, arguments);				this.dialogSupport = new ORYX.Plugins.TransformationDownloadDialog();		        this.raisedEventIds = [];		this.facade.offer({			'name':ORYX.I18N.Bpel4ChorTransformation.exportBPEL,			'functionality': this.transformBPEL4Chor.bind(this),			'group': ORYX.I18N.Bpel4ChorTransformation.group,			dropDownGroupIcon: ORYX.PATH + "images/export2.png",			'icon': ORYX.PATH + "images/export_multi.png",			'description': ORYX.I18N.Bpel4ChorTransformation.exportBPELDesc,			'index': 1,			'minShape': 0,			'maxShape': 0});					this.facade.offer({			'name':ORYX.I18N.Bpel4ChorTransformation.exportXPDL,			'functionality': this.transformXPDL4Chor.bind(this),			'group': ORYX.I18N.Bpel4ChorTransformation.group,            dropDownGroupIcon: ORYX.PATH + "images/export2.png",			'icon': ORYX.PATH + "images/export.png",			'description': ORYX.I18N.Bpel4ChorTransformation.exportXPDLDesc,			'index': 0,			'minShape': 0,			'maxShape': 0});					this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.propertyChanged.bind(this));	},		// check if changed property does affect the transformability	/**	 * Reacts to a changed property in the property window, since this may cause	 * errors during the transformation.	 * 	 * If the name of a receiving activity was changed:	 *  - Determine all other receiving activities with an incoming message 	 *    flow to the same source activity 	 *  - If these receiving activities do not have the same name, print out	 *    a warning in a message dialog.	 *    	 * If the loop type of a receive task was changed:	 * 	- Check if the receive task is located directly after an event-based	 *    decision gateway	 *  - If so, print out a warning in a message dialog, because a looping 	 *    task is not allowed after an event-based decision gateway in BPMNplus	 * 	 * @param {Object} args 	 * 	- args.element: the changed shape	 *  - args.name:    the name of the changed property	 */	propertyChanged: function(args) {			var shapes = args.elements;				shapes.each(function(shape){			var stencil = shape.getStencil();			if (args.propId == "oryx-name") {				if ((stencil.id() == stencil.namespace() + "ReceiveTask") || 				 (stencil.id() == stencil.namespace() + "IntermediateMessageEvent") || 				 (stencil.id() == stencil.namespace() + "StartMessageEvent")) {										// get all receiving activities with same source					var receiving = new Hash();					shape.getIncomingShapes().each(function(edge) { 						if (edge.getStencil().id() == edge.getStencil().namespace() + "MessageFlow") {							var sources = edge.getIncomingShapes();							sources.each(function(source) {								// get target of all outgoing message flows								source.getOutgoingShapes().each(function(edgeSource) {									if (edgeSource.getStencil().id() == edgeSource.getStencil().namespace() + "MessageFlow") {										var list = receiving[source.resourceId];										if (list == undefined) {											list = new Array();										}										list = list.concat(edgeSource.getOutgoingShapes());										receiving[source.resourceId] = list;									}								});							});						}					});										var name = null					var values = receiving.values();					for (var i = 0; i < values.length; i++) {						var list = values[i];						for (var j = 0; j < list.length; j++) {							var shape = list[j];							if (name == undefined) {								name = list[j].properties["oryx-name"];							} else if (name != list[j].properties["oryx-name"]) {								this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.warning,									ORYX.I18N.Bpel4ChorTransformation.wrongValue.replace(/1/, name));								return;							}						}					}				}			} else if (args.propId == "oryx-looptype") {							// if parent of receive task is event-based decision gateway				// the loop type should be None to be transformable to BPEL4Chor				if (stencil.id() == stencil.namespace() + "ReceiveTask") {					// get incoming sequence flows					shape.getIncomingShapes().each(function(edge) { 						if (edge.getStencil().id() == edge.getStencil().namespace() + "SequenceFlow") {							// get source of sequence flows							var sources = edge.getIncomingShapes();							sources.each(function(source) {								if (source.getStencil().id() == stencil.namespace() + "Exclusive_Eventbased_Gateway") {									if (shape.properties["oryx-looptype"] != "None") {										this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.warning, ORYX.I18N.Bpel4ChorTransformation.loopNone);										 return;									}								}							});						}					});				}			}		});			},		/**	 * Checks if all edges have a source and a target element. 	 * If not print out an error in a message dialog.	 * 	 * The check is necessary because such edges would lead to a parser	 * error during the transformation.	 */	validate: function() {		// check if all edges have a source and a target		var edges = this.facade.getCanvas().getChildEdges();		var valid = true;		for (var i = 0; i < edges.size(); i++) {			var edge = edges[i];			var name = edge.getStencil().title();			var id = edge.id;			// TODO: highlight shapes			if (edge.getIncomingShapes().size() == 0) {				//this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.error, ORYX.I18N.Bpel4ChorTransformation.noSource.replace(/1/, name).replace(/2/, id));				this.showOverlay(edge, ORYX.I18N.Bpel4ChorTransformation.noSource.replace(/1/, name).replace(/2/, id));				valid = false;			} else if (edge.getOutgoingShapes().size() == 0) {//				this.dialogSupport.openMessageDialog(//					ORYX.I18N.Bpel4ChorTransformation.error, ORYX.I18N.Bpel4ChorTransformation.noTarget.replace(/1/, name).replace(/2/, id));				this.showOverlay(edge, ORYX.I18N.Bpel4ChorTransformation.noTarget.replace(/1/, name).replace(/2/, id));				valid = false;			}			}		return valid;	},		/**	 * Since canvas properties are not serialized they can not be	 * transformed using xslt. Thus, they will be added after the	 * xslt transformation using this method.	 * 	 * @param {Object} xpdl4chor The generated xpdl4chor document	 */	addCanvasProperties: function(xpdl4chor) {		// chor:TargetNamespace		var canvas = this.facade.getCanvas();		var targetNamespace = xpdl4chor.createAttribute("chor:TargetNamespace");		targetNamespace.value = canvas.properties["oryx-targetNamespace"];		xpdl4chor.documentElement.setAttributeNode(targetNamespace);				// Name		var name = xpdl4chor.createAttribute("Name");		name.value = canvas.properties["oryx-name"];		xpdl4chor.documentElement.setAttributeNode(name);				// Id		var idAttr = xpdl4chor.createAttribute("Id");		var id = canvas.properties["oryx-id"];		if (id == "") {			id = DataManager.__provideId();		}		idAttr.value = id;		xpdl4chor.documentElement.setAttributeNode(idAttr);				// PackageHeader.Created		var created = xpdl4chor.createElement("xpdl:Created");		var createdText = document.createTextNode(canvas.properties["oryx-creationdate"]);		created.appendChild(createdText);		var parent = xpdl4chor.documentElement.firstChild;		parent.appendChild(created);				// RedefinableHeader		var expressionLanguage = canvas.properties["oryx-expressionlanguage"];		var queryLanguage = canvas.properties["oryx-querylanguage"];				var header = xpdl4chor.createElement("xpdl:RedefinableHeader");		if (queryLanguage != "") {			var queryLangAttr = xpdl4chor.createAttribute("chor:QueryLanguage");			queryLangAttr.value = queryLanguage;			header.setAttributeNode(queryLangAttr);		}		if (expressionLanguage != "") {			var expressionLangAttr = xpdl4chor.createAttribute("chor:ExpressionLanguage");			expressionLangAttr.value = expressionLanguage;			header.setAttributeNode(expressionLangAttr);		}		// append header after first child (PackageHeader node)		xpdl4chor.documentElement.insertBefore(header, xpdl4chor.documentElement.firstChild.nextSibling);	},			/**	 * Builds up the data that will be shown in the result dialog of	 * the XPDL4Chor transformation.	 * 	 * @param {String} xpdl4chor The generated XPDL4Chor.	 */	buildXPDL4ChorData: function(xpdl4chor) {		var data = [		    ["XPDL4Chor", xpdl4chor, this.dialogSupport.getResultInfo(xpdl4chor)]		];				return data;	},			/**	 * Builds up the data that will be shown in the result dialog of	 * the BPEL4Chor transformation.	 * For this purpose the process names are determined and	 * it is checked if the topology and process were generated	 * successfully.	 * 	 * @param res - the result of the servlet 	 * @return {"data" : <data for the download dialog>, "errors": <data for syntax highlighting>}	 */	buildDisplayData: function(transformRes) {		var res = {			"data": [[]], // each element is a tuple (file, data, success)			"errors": [[]]  // each element is a record (shape, message)		}				var curError = 0;				for (var i = 0; i < transformRes.length; i++) {			var file;			if (transformRes[i].type == "PROCESS") {				file = transformRes[i].name;			} else {				file = transformRes[i].type.toLowerCase();			}						var success;			var transformResult;						if (transformRes[i].success) {				success = "success";				transformResult = transformRes[i].document;			} else {				success = "error";				transformResult = "";				for (var j=0; j<transformRes[i].errors.length; j++) {					var error = transformRes[i].errors[j];					transformResult = transformResult + error.message;					if (error.id) {						transformResult = transformResult + " (" + error.id + ")";					}					transformResult = transformResult + "\n";					res.errors[curError] = error;					curError++;				}			}						res.data[i] = [file, transformResult, success];		}				if (curError == 0) {			// no errors were found			// the array has to be defined, but empty			res.errors = []; 		}				return res;	},			/**	 * Analyzes the result of the servlet call.	 * 	 * If an fault occurred or the answer is undefined, the error is shown	 * using a message dialog.	 * 	 * If the first result starts with "ParserError" the error is shown using an 	 * error dialog. Otherwise the result is shown using the result dialog.	 * 	 * @param {Object} result - the result of the transformation servlet (JSON)	 */	displayResult: function(result) {		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});		var resultString = '(' + result + ')';		var resultObject;				try {			resultObject = eval(resultString);		} catch (e1) {			Ext.Msg.alert("Error during evaluation of result: " + e1 + "\r\n" + resultString);		}				var version = resultObject.version;		if (version != "1.0")			Ext.Msg.alert("Wrong version " + version + ". Converting nevertheless.");				if ((!resultObject.res) || (resultObject.res.length == 0)) {			this.dialogSupport.openMessageDialog(ORYX.I18N.TransformationDownloadDialog.error,ORYX.I18N.TransformationDownloadDialog.noResult);	    } else {			var displayData = this.buildDisplayData(resultObject.res);            displayData.errors.each(function(error){            	if (error.id == "undefined")            		return;            	                sh = this.facade.getCanvas().getChildShapeByResourceId(error.id);                if (!sh) {                	// id was not found. It is possible that the element is a process with its own id            		sh = this.facade.getCanvas().getChildShapes(true).find(function(shape) {            			processId = shape.properties["oryx-processid"];             			if (processId == "") {            				return (shape.resourceId + "_process" == error.id);            			} else {            				return (processId == error.id);            			}    				});                }                                if (sh) {                    this.showOverlay(sh, error.message);                }            }.bind(this));			this.dialogSupport.openResultDialog(displayData.data);		}	},			/**	 * Transforms the model to XPDL4Chor using the xslt stylesheet.	 * After that the web service for the transformation to BPEL4Chor	 * will be called.	 * 	 * @param {Object} xpdlOnly True, if only the XPDL4Chor should be 	 *                          generated, false otherwise	 */	transform: function(xpdlOnly) {				this.hideOverlays();				var valid = this.validate();	   	if (!valid) {			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});			Ext.Msg.alert("Transformation","input not valid");			// TODO: store the validation result and display it using this.displayResult(response.responseText);			return null;		}		var xsl = "";		source = ORYX.PATH + "xslt/BPMNplus2XPDL4Chor.xslt";			new Ajax.Request(source, {				asynchronous: false,				method: 'get',				onSuccess: function(transport){					xsl = transport.responseText				}.bind(this),				onFailure: (function(transport){					ORYX.Log.error("XSL load failed" + transport);				}).bind(this)			});		var xsltProcessor = new XSLTProcessor();						var ERDF = this.facade.getERDF();		var parser=new DOMParser();		var xslObject = parser.parseFromString(xsl, "text/xml");		xsltProcessor.importStylesheet(xslObject);		var doc=parser.parseFromString(ERDF,"text/xml");					try {			var xpdl4chor = xsltProcessor.transformToDocument(doc, document);		} catch (error) {			this.dialogSupport.openMessageDialog(ORYX.I18N.Bpel4ChorTransformation.error, ORYX.I18N.Bpel4ChorTransformation.noGen.replace(/1/, error.name).replace(/2/, error.message));			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});			return null;		}					this.addCanvasProperties(xpdl4chor);					var serialized = (new XMLSerializer()).serializeToString(xpdl4chor);		serialized = serialized.startsWith("<?xml") ? serialized : "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized;		if (xpdlOnly) {			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});							var data = this.buildXPDL4ChorData(serialized);			this.dialogSupport.openResultDialog(data);		} else {			var target = "http://" + location.host + ORYX.CONFIG.XPDL4CHOR2BPEL4CHOR_TRANSFORMATION_URL;			try {				Ext.Ajax.request({					method : "POST",					url : target,					params : {data: serialized},					success : function(response, options) {						this.displayResult(response.responseText);					}.bind(this)				});			} catch (e) {				Ext.Msg.alert("Error during call of transformation: " + e);			}		}	},		/**	 * Transform the model to its XPDL4Chor representation.	 */	transformXPDL4Chor: function() { 				this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.Bpel4ChorTransformation.loadingXPDL4ChorExport});		this.transform(true);	},  	/**  	 * Transform the model to its BPELChor representation.  	 */	transformBPEL4Chor: function(){ 	   		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE, text:ORYX.I18N.Bpel4ChorTransformation.loadingBPEL4ChorExport});		this.transform(false);			},	/**	 * Copied from validator.js	 */    showOverlay: function(shape, errorMsg){            var id = "syntaxchecker." + this.raisedEventIds.length;                var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {            "title": errorMsg,            "stroke-width": 5.0,            "stroke": "red",            "d": "M20,-5 L5,-20 M5,-5 L20,-20",            "line-captions": "round"        }]);                this.facade.raiseEvent({            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,            id: id,            shapes: [shape],            node: cross,            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"        });                this.raisedEventIds.push(id);    },	/**	 * Copied from validator.js	 */    hideOverlays: function(){        this.raisedEventIds.each(function(id){            this.facade.raiseEvent({                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,                id: id            });        }.bind(this));                this.raisedEventIds = [];    },    	});/**
 * Copyright (c) 2009
 * Kerstin Pfitzner, Oliver Kopp, Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
 */
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

	
/**
 * This plugin offers the layout callbacks used in the BPMNplus stencil set.
 * 
 * @class ORYX.Plugins.BPMNPlus
 * @extends Clazz
 * @param {Object} facade The editor facade for plugins.
 */
ORYX.Plugins.BPMNPlusLayout = {
	/** @lends ORYX.Plugins.BPMNPlusLayout.prototype */
	
	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;

		this.facade.registerOnEvent('layout.bpmnplus.pool', this.handleLayoutPool.bind(this));
		this.facade.registerOnEvent('layout.bpmnplus.poolset', this.handleLayoutPoolSet.bind(this));
	},
	
	/**
	 * 'layout.bpmnplus.pool' event handler
	 * 
	 * @param {Object} event
	 * 		The layout event.
	 */
	handleLayoutPool: function(event) {
		var shape = event.shape;
		var lanes = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmnplus#Lane");
		});
		
		if(lanes.length > 0) {
			lanes = lanes.sortBy(function(lane) {
				return lane.bounds.upperLeft().y;
			});
			
			var shapeWidth = shape.bounds.width();
			var shapeHeight = 0;
			lanes.each(function(lane) {
				var ul = lane.bounds.upperLeft();
				var lr = lane.bounds.lowerRight();
				ul.y = shapeHeight;
				lr.y = ul.y + lane.bounds.height();
				shapeHeight += lane.bounds.height();
				ul.x = 30;
				lr.x = shapeWidth;
				lane.bounds.set(ul, lr);
			});
			
			var upl = shape.bounds.upperLeft();
			shape.bounds.set(upl.x, upl.y, shape.bounds.lowerRight().x, upl.y + shapeHeight);
			
			// set label at the middle
			shape.getLabels().each(function(label) {
				label.y = shapeHeight / 2;
				label.x = 12;
			});
		}		
	},
	
	/**
	 * The event handler for the 'layout.bpmnplus.poolset' event
	 * 
	 * @param {Object} event
	 * 		The layout event to handle
	 */
	handleLayoutPoolSet: function(event) {
		var shape = event.shape;
		
		var lanes = shape.getChildNodes(false).findAll(function(node) {
			return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmnplus#Lane");
		});
		
		if(lanes.length > 0) {
		
			lanes = lanes.sortBy(function(lane) {
				return lane.bounds.upperLeft().y;
			});
			
			var shapeWidth = shape.bounds.width();
			var laneWidth = shapeWidth * 500 / 515;
			
			// calculate height based on the contained lanes
			var oldShapeHeight = 0;
			lanes.each(function(lane) {
				oldShapeHeight += lane.bounds.height();
			});
			
			// calculate new height based on the pool set shade
			var newShapeHeight = oldShapeHeight * 315 / 300;					
			var diff = newShapeHeight - oldShapeHeight;
			
			// calculate lane bounds
			var shapeHeight = diff;
			lanes.each(function(lane) {
				var ul = lane.bounds.upperLeft();
				var lr = lane.bounds.lowerRight();
				ul.y = shapeHeight;
				lr.y = ul.y + lane.bounds.height();
				shapeHeight += lane.bounds.height();
				ul.x = 30;
				lr.x = laneWidth;
				lane.bounds.set(ul, lr);
			});
			
			// calculate shape bounds
			var upl = shape.bounds.upperLeft();
			shape.bounds.set(upl.x, upl.y, shape.bounds.lowerRight().x, upl.y + shapeHeight);
			
			// set labels at the middle
			shape.getLabels().each(function(label) {
				label.y = shapeHeight / 2;
				label.x = 12;
			});
		}
	}
	
};

ORYX.Plugins.BPMNPlusLayout = Clazz.extend(ORYX.Plugins.BPMNPlusLayout);
/**
 * Copyright (c) 2008-2009
 * Kerstin Pfitzner, Oliver Kopp, Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * This plugin offers the serialize callbacks used in the BPMNplus stencil set.
 * 
 * @class ORYX.Plugins.BPMNPlus
 * @extends Clazz
 * @param {Object} facade The editor facade for plugins.
 */
ORYX.Plugins.BPMNPlusSerialization = {
	/** @lends ORYX.Plugins.BPMNPlusLayout.prototype */
	
	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade){
		this.facade = facade;
		
		this.facade.registerOnEvent("serialize.bpmnplus.pool", 
							this.handleSerializePool.bind(this));
		this.facade.registerOnEvent("serialize.bpmnplus.variable", 
							this.handleSerializeVariable.bind(this));
		this.facade.registerOnEvent("serialize.bpmnplus.dataobject", 
							this.handleSerializeDataObject.bind(this));
		this.facade.registerOnEvent("serialize.bpmnplus.attachedevent", 
							this.handleSerializeAttachedEvent.bind(this));
		this.facade.registerOnEvent("serialize.bpmnplus.unidirectedassociation", 
							this.handleSerializeUnidirectedAssociation.bind(this));
		this.facade.registerOnEvent("serialize.bpmnplus.directedassociation", 
							this.handleSerializeDirectedAssociation.bind(this));
		this.facade.registerOnEvent("serialize.bpmnplus.messageflow", 
							this.handleSerializeMessageFlow.bind(this));					
	},
	
	/**
	 * Handler to serialize the BPMN+ pool
	 * 
	 * @param {Object} event
	 * 		The serialize event
	 */
	handleSerializePool: function(event) {
		var shape = event.shape;
		var data = event.data;
		
		var poolId = shape.resourceId;
		var processId = shape.properties["oryx-processid"];
		if (processId == "") {
			processId = poolId + "_process";
			var processRec;
			for (var i = 0; i < data.length; i++) {
				if (data[i].name == "processid") {
					processRec = data[i];
					break;
				}
			}
			processRec.value=processId;
		}
		
		event.result = data;
	},
	
	/**
	 * The handler to serialize a bpmnplus variable
	 * 
	 * @param {Object} event
	 * 		The serialization event to handle
	 */
	handleSerializeVariable: function(event) {
		var shape = event.shape;
		var data = event.data;
		
		// serialize pool, poolSet, process and subProcess
		var parent = shape.getParentShape();
		var subProcess = false;
		while(parent.getParentShape != undefined) {
			if ((parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#Scope") || 
				(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#FaultHandler") ||
				(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#CompensationHandler") ||
				(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#TerminationHandler") ||
				(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#MessageHandler") ||
				(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#TimerHandler")) {
				// determine oryx-subprocess
				var id = parent.resourceId;
				if (id == "") {
					id = parent.resourceId;
					if (id == undefined) {
						id = "";
					}
				}
				if (!subProcess) {
					data.push({
						name:"subprocess",
					 	prefix:"oryx",				 
					 	value:id,
						type:"literal"
					});										
					subProcess = true;
				}
				parent = parent.getParentShape();					
			} else if (	(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#Pool") ||
						(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#PoolSet")) {
				// generate pool and process
				var name;
				if (parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#Pool") {
					name = "pool";
				} else {
					name = "poolset";
				}
				
				var poolId = parent.resourceId;
				if (poolId == "") {
					poolId = parent.resourceId;
					if (poolId == undefined) {
						poolId = "";
					}
				}
				
				data.push({
					name:name,
				 	prefix:"oryx",				 
				 	value:poolId,
					type:"literal"
				});
						
				if (!subProcess) {
					var processId = parent.properties["oryx-processid"];
					if (processId == "") {
						processId = poolId + "_process";
					}
					data.push({
						name:"process",
					 	prefix:"oryx",				 
					 	value:processId,
						type:"literal"
					});
				}
										
				break;
			} else {
				parent = parent.getParentShape();
			}
		}
		
		event.result =  data;
	},
	
	/**
	 * The handle to serialize any kind of data object
	 * 
	 * @param {Object} event
	 * 		The serialization event
	 */
	handleSerializeDataObject : function(event) {
		var shape = event.shape;
		var data = event.data;
		
		
		// serialize pool or poolSet
		var parent = shape.getParentShape();		
		while(parent.getParentShape != undefined) {
			if ((parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#Pool") ||
				(parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#PoolSet")) {
				// generate pool and process
				var name;
				if (parent.getStencil().id() == "http://b3mn.org/stencilset/bpmnplus#Pool") {
					name = "pool";
				} else {
					name = "poolset";
				}
				
				var poolId = parent.resourceId;
				if (poolId == "") {
					poolId = parent.resourceId;
					if (poolId == undefined) {
						poolId = "";
					}
				}
				
				data.push({
					name:name,
				 	prefix:"oryx",				 
				 	value:poolId,
					type:"literal"
				});													
										
				break;
			} else {
				parent = parent.getParentShape();
			}
		}
		
		event.result = data;
	},
	
	/**
	 * The handler to serialize attached events
	 * 
	 * @param {Object} event
	 * 		The serialization event
	 */
	handleSerializeAttachedEvent : function(event) {
		var shape = event.shape;
		var data = event.data;
		
		var attached;
		var incomingShapes = shape.getIncomingShapes();
		incomingShapes.each(function(next) { 
			var roles = next.getStencil().roles();						
			for (var i = 0; i < roles.length; i++) {
				if (roles[i] == next.getStencil().namespace() + "attachmentAllowed") {
					attached = next;
					break;
				}
			}
		});

		if (attached != undefined) {
			var attachedId = attached.resourceId;
			if (attachedId == "") {
				attachedId = attached.resourceId;
			}
			if (attachedId != undefined) {
				data.push({
					name:"target",
				 	prefix:"oryx",				 
				 	value:attachedId,
			 		type:"literal"
				});
			}
	 	}
		
		event.result = data;
	},
	
	/**
	 * The handler to serialize an unidirected association
	 * 
	 * @param {Object} event
	 * 		The serialization event
	 */
	handleSerializeUnidirectedAssociation : function(event) {
		var shape = event.shape;
		var data = event.data;
		
		var sources = shape.getIncomingShapes();
		var switched = false;
		if (sources.length > 0) {
			var source = sources[0];
			// determine oryx-source
			var type = source.getStencil().id();
			var id = source.resourceId;
			var name;
			if (type == "http://b3mn.org/stencilset/bpmnplus#StandardVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#FaultVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#MessageVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#CounterVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#ParticipantReferenceDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#ParticipantSetDataObject") {
				name = "target";
				switched = true;
			} else {
				name = "source";
			}
			data.push({
					name:"direction",
				 	prefix:"oryx",
				 	value:"None",
				 	type:"literal",
				});
			
			if (id != undefined) {
				data.push({
						name:name,
					 	prefix:"oryx",
					 	value:id,
					 	type:"literal"
				});
			}
		}

		// determine oryx-target
		var targets = shape.getOutgoingShapes();
		if (targets.length > 0) {
			var target = targets[0];
			var id = target.resourceId;
			var name;
			if (switched) {
				name = "source";
			} else {
				name = "target";
			}

			if (id != undefined) {
				data.push({
					name:name,
				 	prefix:"oryx",
				 	value:id,
				 	type:"literal"
				});
			}
		}
		
		event.result = data;
	},
	
	handleSerializeDirectedAssociation : function(event) {
		var shape = event.shape;
		var data = event.data;
		
		
		var sources = shape.getIncomingShapes();
		var switched = false;
		if (sources.length > 0) {
			var source = sources[0];
			// determine oryx-direction and oryx-source
			var type= source.getStencil().id();
			var id = source.resourceId;
			var name;
			if (type == "http://b3mn.org/stencilset/bpmnplus#StandardVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#FaultVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#MessageVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#CounterVariableDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#ParticipantReferenceDataObject" ||
				type == "http://b3mn.org/stencilset/bpmnplus#ParticipantSetDataObject") {
				data.push({
					name:"direction",
				 	prefix:"oryx",
				 	value:"To",
				 	type:"literal"
				});
				name = "target";
				switched = true;
			} else {
				data.push({
					name:"direction",
				 	prefix:"oryx",
				 	value:"From",
				 	type:"literal"
				});
				name="source";
			}
			if (id != undefined) {
				data.push({
						name:name,
					 	prefix:"oryx",
					 	value:id,
					 	type:"literal"
				});
			}
		}											
		
		// determine oryx-target
		var targets = shape.getOutgoingShapes();
		if (targets.length > 0) {
			var target = targets[0];
			var id = target.resourceId;
			if (id == "") {
				id = target.resourceId;
			}
			var name;
			if (switched) {
				name = "source";
			} else {
				name = "target";
			}
			if (id != undefined) {
				data.push({
					name:name,
				 	prefix:"oryx",
				 	value:id,
				 	type:"literal"
				});
			}
		}
		
		event.result = data;
	},
	
	/**
	 * The handler to serialize a message flow
	 * 
	 * @param {Object} event
	 * 		The serialization event
	 */
	handleSerializeMessageFlow: function(event) {
		var shape = event.shape;
		var data = event.data;
		
		var sources = shape.getIncomingShapes();
		if (sources.length > 0) {
			var source = sources[0];
			var id = source.resourceId;
			if (id != undefined) {
				data.push({
					name:"source",
				 	prefix:"oryx",
				 	value:id,
				 	type:"literal"
				});
			}
		}
		
		var targets = shape.getOutgoingShapes();
		if (targets.length > 0) {
			var target = targets[0];
			var id = target.resourceId;
			if (id != undefined) {
				data.push({
					name:"target",
				 	prefix:"oryx",
				 	value:id,
				 	type:"literal"
				});
			}
		}
		
		event.result = data;
	}
};

ORYX.Plugins.BPMNPlusSerialization = Clazz.extend(ORYX.Plugins.BPMNPlusSerialization);/**
 * Copyright (c) 2008
 * Zhen Peng
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	
ORYX.Plugins.BPELSupport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,

	dialogSupport: undefined,
	
	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {
		
		this.facade = facade;

		this.dialogSupport = new ORYX.Plugins.TransformationDownloadDialog();

	    this.facade.offer({
			'name':ORYX.I18N.BPELSupport.exp,
			'functionality': this.exportProcess.bind(this),
			'group': ORYX.I18N.BPELSupport.group,
			'icon': ORYX.PATH + "images/bpel_export_icon.png",
			'description': ORYX.I18N.BPELSupport.expDesc,
			'index': 0,
			'minShape': 0,
			'maxShape': 0
		});
			
        this.facade.offer({
			'name':ORYX.I18N.BPELSupport.imp,
			'functionality': this.importProcess.bind(this),
			'group': ORYX.I18N.BPELSupport.group,
			'icon': ORYX.PATH + "images/bpel_import_icon.png",
			'description': ORYX.I18N.BPELSupport.impDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0
		});
	},
	
	/***************************** export **********************************/
	
	exportProcess: function(){
	
		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously();
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },
    
    exportSynchronously: function() {

        var resource = location.href;
		
		
		try {
			
			var serialized_rdf = this.getRDFFromDOM();
			if (!serialized_rdf.startsWith("<?xml")) {
				serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
			}
			  
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.BPEL_EXPORT_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf
				},
                onSuccess: function(response){
					this.displayResult(response.responseText);
                }.bind(this)
			});
                	
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
    
	},
	
	
	/**
	 * Analyzes the result of the servlet call.
	 * 
	 * If an fault occured or the answer is undefined, the error is shown
	 * using a message dialog.
	 * 
	 * If the first result starts with "ParserError" the error is shown using an 
	 * error dialog. Otherwise the result is shown using the result dialog.
	 * 
	 * @param {Object} result - the result of the transformation servlet (JSON)
	 */
	displayResult: function(result) {
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});

		var resultString = '(' + result + ')';
		
		var resultObject;
		
		try {
			resultObject = eval(resultString);
		} catch (e1) {
			alert("Error during evaluation of result: " + e1 + "\r\n" + resultString);
		}
		
		if ((!resultObject.res) || (resultObject.res.length == 0)) {
			this.dialogSupport.openMessageDialog(ORYX.I18N.TransformationDownloadDialog.error,ORYX.I18N.TransformationDownloadDialog.noResult);
		} else if (resultObject.res[0].success == "false") {
			this.dialogSupport.openErrorDialog(resultObject.res[0].content);
		} else {
			var processes = new Array();
			for (var i = 0; i < resultObject.res.length; i++) {
				processes[i] = resultObject.res[i].content;
			}
			var data = this.buildTransData(processes);
			this.dialogSupport.openResultDialog(data);
		}
	},
	
	/**
	 * Builds up the data that will be shown in the result dialog of
	 * the BPEL transformation.
	 * For this purpose the process names are determined and
	 * it is checked if the process were generated
	 * successfully.
	 * 
	 * @param {String[]} processes The generated processes
	 */
	buildTransData: function(processes) {
		var data = [];
		
		for (var i = 0; i < processes.length; i++) {
			var name = this.dialogSupport.getProcessName(processes[i]);
			if (name == undefined) {
				name = "Process " + (i+1);
			}
			data[i] = [name, processes[i], this.dialogSupport.getResultInfo(processes[i])];
		}	
		
		return data;
	},

	/***************************** import **********************************/
	
	importProcess: function(){
		this.openUploadDialog ();
	},
	
	/**
	 * Opens a upload dialog.
	 * 
	 */
	openUploadDialog: function(){
		
		var form = new Ext.form.FormPanel({
			frame : 		true,
			bodyStyle:		'padding:5px;',
			defaultType : 	'textfield',
		  	labelAlign : 	'left',
		  	buttonAlign: 	'right',
		  	fileUpload : 	true,
		  	enctype : 		'multipart/form-data',
		  	items : [
		  	{
		    	text : 		ORYX.I18N.BPELSupport.selectFile, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
				xtype : 	'label'
		  	},{
		    	fieldLabel : 	ORYX.I18N.BPELSupport.file,
		    	inputType : 	'file',
				labelStyle :	'width:50px;',
				itemCls :		'ext_specific_window_overflow'
		  	}]
		});


		var displayPanel = new Ext.form.FormPanel({
			frame : 		true,
			bodyStyle:		'padding:5px;',
			defaultType : 	'textfield',
		  	labelAlign : 	'left',
		  	buttonAlign: 	'right',
		  	fileUpload : 	true,
		  	enctype : 		'multipart/form-data',
		  	items : [
		  	{
		    	text : 		ORYX.I18N.BPELSupport.content, 
				style : 	'font-size:12px;margin-bottom:10px;display:block;',
				xtype : 	'label'
		  	}, {
	            xtype: 'textarea',
	            width: '160',
	            height: '350',
	            hideLabel: true,
	            anchor: '100% -63'
	        }]
		});
		
		var dialog = new Ext.Window({ 
			autoCreate:     true, 
			title: 		ORYX.I18N.BPELSupport.impPanel, 
			height: 	'auto', 
			width: 		'auto', 
			modal:		true,
			collapsible:false,
			fixedcenter:true, 
			shadow:		true, 
			proxyDrag: 	true,
			resizable:	false,
			items: [form, displayPanel],
			buttons:[
				{
					text:ORYX.I18N.BPELSupport.impBtn,
					handler: function(){
						
							
						var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.BPELSupport.progressImp});
						loadMask.show();
												
						form.form.submit({
							// TODO according to http://www.extjs.com/deploy/dev/docs/output/Ext.form.BasicForm.html
							//      modification of the accept header should work like that. In practice, however, it doesn't
							headers: {
								accept: "application/json, text/plain, text/html"
							},
				      		url: ORYX.PATH + '/bpelimporter',
				      		timeout: 6,
				      		success: function(f,a){
								
								dialog.hide();
								// Get the json string					
								var json = a.result;
								
								//alert(json);
								
								// Load the json to the editor
								this.facade.importJSON(json.content,true);
								
								// update the canvas
								this.facade.getCanvas().update();
								
								// Hide the waiting panel
								loadMask.hide();
								
				      		}.bind(this),
							failure: function(f,a){
								dialog.hide();
								loadMask.hide();
								Ext.MessageBox.show({
		           					title: ORYX.I18N.BPELSupport.error,
		          	 				msg: ORYX.I18N.BPELSupport.impFailed + a.response.responseText.substring(a.response.responseText.indexOf("content:'")+9, a.response.responseText.indexOf("'}")),
		           					buttons: Ext.MessageBox.OK,
		           					icon: Ext.MessageBox.ERROR
		       					});
				      		}.bind(this)
				  		});
					}.bind(this)
				},{
					text:ORYX.I18N.BPELSupport.close,
					handler:function(){
						dialog.hide();
					}.bind(this)
				}
			]
		});

		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});
		
		dialog.show();
	
		// Adds the change event handler to file upload filed 
		form.items.items[1].getEl().dom.addEventListener('change',function(evt){
				var text = evt.target.files[0].getAsBinary();
				displayPanel.items.items[1].setValue( text );
			}, true)
	},
	
	loadERDF: function(erdfString){
								
		var parser = new DOMParser();			
		var doc    = parser.parseFromString(erdfString ,"text/xml");
		
		//alert(erdfString);
		this.facade.importERDF( doc );

	}

	
});
	/**
 * Copyright (c) 2008
 * Zhen Peng
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	
ORYX.Plugins.BPEL4ChorSupport = ORYX.Plugins.AbstractPlugin.extend({

	/**
	 * Offers the plugin functionality:
	 */
    construct: function(){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);

		this.dialogSupport = new ORYX.Plugins.TransformationDownloadDialog();
		
	    this.facade.offer({
			'name':ORYX.I18N.BPEL4ChorSupport.exp,
			'functionality': this.exportProcess.bind(this),
			'group': ORYX.I18N.JSONSupport.exp.group,
			dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon':  ORYX.PATH + "images/bpel4chor_export_icon.png",
			'description': ORYX.I18N.BPEL4ChorSupport.expDesc,
			'index': 0,
			'minShape': 0,
			'maxShape': 0
		});
			
        this.facade.offer({
			'name':ORYX.I18N.BPEL4ChorSupport.imp,
			'functionality': this.importProcess.bind(this),
			'group': ORYX.I18N.JSONSupport.imp.group,
			dropDownGroupIcon: ORYX.PATH + "images/import.png",
			'icon':  ORYX.PATH + "images/bpel4chor_import_icon.png",
			'description': ORYX.I18N.BPEL4ChorSupport.impDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': function(){ return false}
		});
	},
	
	/***************************** export **********************************/	
		
	exportProcess: function(){
	
		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously();
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },
    
    exportSynchronously: function() {

        var resource = location.href;
		
		
		try {
			var serialized_rdf = this.getRDFFromDOM();
			if (!serialized_rdf.startsWith("<?xml")) {
				serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
			}
			  
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.BPEL4CHOR_EXPORT_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf
				},
                onSuccess: function(response){
                	this.displayResult(response.responseText);
				}.bind(this)
			});
                	
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
    
	},
	
	
	/**
	 * Builds up the data that will be shown in the result dialog of
	 * the BPEL4Chor transformation.
	 * For this purpose the process names are determined and
	 * it is checked if the topology and process were generated
	 * successfully.
	 * 
	 * @param {String}   topology     The generated topology 
	 * @param {String}   grounding    The generated grounding 
	 * @param {String[]} processes    The generated processes
	 */
	buildTransData: function(topology, grounding, processes) {
		var data = [["topology", topology, this.dialogSupport.getResultInfo(topology)]];
		
		var counter = 1;
		
		//if (grounding.indexOf("operation")>0){
		if (grounding.indexOf("grounding")>0){
			data[1]= ["grounding", grounding, this.dialogSupport.getResultInfo(grounding)];
			counter++;
		};
		
		for (var i = 0; i < processes.length; i++) {
			var name = this.dialogSupport.getProcessName(processes[i]);
			if (name == undefined) {
				name = "Process " + (i+1);
			}
			data[i+counter] = [name, processes[i], this.dialogSupport.getResultInfo(processes[i])];
		}	
		
		return data;
	},
	
	
	/**
	 * Analyzes the result of the servlet call.
	 * 
	 * If an fault occured or the answer is undefined, the error is shown
	 * using a message dialog.
	 * 
	 * If the first result starts with "ParserError" the error is shown using an 
	 * error dialog. Otherwise the result is shown using the result dialog.
	 * 
	 * @param {Object} result - the result of the transformation servlet (JSON)
	 */
	displayResult: function(result) {
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});

		var resultString = '(' + result + ')';
		
		//alert (resultString);
		
		var resultObject;
		
		try {
			resultObject = eval(resultString);
		} catch (e1) {
			alert("Error during evaluation of result: " + e1 + "\r\n" + resultString);
		}
		
		if ((!resultObject.res) || (resultObject.res.length == 0)) {
			this.dialogSupport.openMessageDialog(ORYX.I18N.TransformationDownloadDialog.error,ORYX.I18N.TransformationDownloadDialog.noResult);
		} else if (resultObject.res[0].content.indexOf("Parser Error")>0) {
			this.dialogSupport.openErrorDialog(resultObject.res[0].content);
		} else {
			var topology = resultObject.res[0].content;
			var grounding = resultObject.res[1].content;
			var processes = new Array();
			for (var i = 2; i < resultObject.res.length; i++) {
				processes[i-2] = resultObject.res[i].content;
			}
			var data = this.buildTransData(topology,grounding,processes);
			
			this.dialogSupport.openResultDialog(data);
		}
	},
	
	/***************************** import **********************************/
	
	importProcess: function(){
		this.openUploadDialog ();
	},
	
	/**
	 * Opens a upload dialog.
	 */
	openUploadDialog: function(){
		
	},
	
	loadERDF: function(erdfString){
								
		var parser = new DOMParser();			
		var doc    = parser.parseFromString(erdfString ,"text/xml");
		
		alert(erdfString);
		this.facade.importERDF( doc );

	}
	
	
	
});
	/**
 * Copyright (c) 2010
 * Changhua Li
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
	
ORYX.Plugins.BPEL4Chor2BPELSupport = ORYX.Plugins.AbstractPlugin.extend({

	/**
	 * Offers the plugin functionality:
	 */
    construct: function(){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);

        this.dialog2BPELSupport = new ORYX.Plugins.TransformationDownloadDialogForBPEL4Chor();
        
	    this.facade.offer({
			'name':ORYX.I18N.BPEL4Chor2BPELSupport.exp,
			'functionality': this.exportProcess.bind(this),
			'group': ORYX.I18N.JSONSupport.exp.group,
			dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon':  ORYX.PATH + "images/bpel4chor2bpel_export_icon.png",
			'description': ORYX.I18N.BPEL4Chor2BPELSupport.expDesc,
			'index': 0,
			'minShape': 0,
			'maxShape': 0
		});
	},
	
	/***************************** export **********************************/	
		
	exportProcess: function(){
	
		// raise loading enable event
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE
        });
            
		// asynchronously ...
        window.setTimeout((function(){
			
			// ... save synchronously
            this.exportSynchronously();
			
			// raise loading disable event.
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_LOADING_DISABLE
            });
			
        }).bind(this), 10);

		return true;
    },
    
    exportSynchronously: function() {

        var resource = location.href;
		
		try {
			var serialized_rdf = this.getRDFFromDOM();

			if (!serialized_rdf.startsWith("<?xml")) {
				serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
			}
						
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.BPEL4CHOR2BPEL_EXPORT_URL, {
				method: 'POST',
				asynchronous: false,
				parameters: {
					resource: resource,
					data: serialized_rdf
				},
                onSuccess: function(response){
                	this.displayResult(response.responseText);
				}.bind(this)
			});
                	
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}
    
	},
	
	
	/**
	 * Builds up the data that will be shown in the result dialog of
	 * the BPEL4Chor to BPEL transformation.
	 * For this purpose the process and wsdl names are determined 
	 * it is checked if them were generated successfully.
	 * 
	 * @param {String[]} bpelArray    The generated process array of bpel processes
	 * @param {String[]} wsdlArray    The generated wsdl array of bpel processes 
	 */
	buildTransData: function(bpelArray, wsdlArray) {
		var data = new Array();
		for(var i = 0; i < bpelArray.length; i++){
			var name = this.dialog2BPELSupport.getBPELName(bpelArray[i]);
			if(name == undefined){
				name = "Process " + (i+1);
			}
			data[i] = [name, bpelArray[i], this.dialog2BPELSupport.getResultInfo(bpelArray[i])];
		}
		
		for(var i = 0; i < wsdlArray.length; i++){
			var name = this.dialog2BPELSupport.getBPELName(bpelArray[i]);	// name of wsdl file should be same with bpel file 
			name = name + "-wsdl";
			if(name == undefined){
				name = "WSDL " + (i+1);
			}
			data[i+bpelArray.length] = [name, wsdlArray[i], this.dialog2BPELSupport.getResultInfo(wsdlArray[i])];
		}
		return data;
	},	
	
	/**
	 * Analyzes the result of the servlet call.
	 * 
	 * If an fault occured or the answer is undefined, the error is shown
	 * using a message dialog.
	 * 
	 * If the first result starts with "ParserError" the error is shown using an 
	 * error dialog. Otherwise the result is shown using the result dialog.
	 * 
	 * @param {Object} result - the result of the transformation servlet (JSON)
	 */
	displayResult: function(result) {
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});

		var resultString = '(' + result + ')';
		
		//alert (resultString);
		
		var resultObject;
		
		try {
			resultObject = eval(resultString);
		} catch (e1) {
			alert("Error during evaluation of result: " + e1 + "\r\n" + resultString);
		}
		
		if ((!resultObject.res) || (resultObject.res.length == 0)) {
			this.dialog2BPELSupport.openMessageDialog(ORYX.I18N.TransformationDownloadDialog.error,ORYX.I18N.TransformationDownloadDialog.noResult);
		} else if (resultObject.res[0].contentBPEL.indexOf("Parser Error")>0) {
			this.dialog2BPELSupport.openErrorDialog(resultObject.res[0].contentBPEL);
		} else {
			var bpelArray = new Array();
			var wsdlArray = new Array();
			for (var i = 0; i < resultObject.res.length; i++) {
				bpelArray[i] = resultObject.res[i].contentBPEL;
				wsdlArray[i] = resultObject.res[i].contentWSDL;
			}
			var data = this.buildTransData(bpelArray, wsdlArray);
			
			//alert(data);
			
			this.dialog2BPELSupport.openResultDialog(data);
		}
	}
});
	/**
 * Copyright (c) 2008
 * Zhen Peng
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.BPELLayouting = Clazz.extend({

	facade: undefined,
	
	isEnabled : undefined,
	
	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;
		
		this.isEnabled = true;
		
		this.facade.offer({
			'name':ORYX.I18N.BPELSupport.enable,
			'functionality': this.enableBpelLayout.bind(this),
			'group': ORYX.I18N.BPELLayout.group,
			'icon': ORYX.PATH + "images/bpel_layout_enable.png",
			'description': ORYX.I18N.BPELLayout.enDesc,
			'index': 0,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': function(){ return !(this.isEnabled)}.bind(this)
		});
		
		this.facade.offer({
			'name':ORYX.I18N.BPELSupport.disable,
			'functionality': this.disableBpelLayout.bind(this),
			'group': ORYX.I18N.BPELLayout.group,
			'icon': ORYX.PATH + "images/bpel_layout_disable.png",
			'description': ORYX.I18N.BPELLayout.disDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': function(){ return this.isEnabled}.bind(this)
		});
	
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT_BPEL, this.handleLayoutEvent.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT_BPEL_VERTICAL, this.handleLayoutVerticalEvent.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT_BPEL_HORIZONTAL, this.handleLayoutHorizontalEvent.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT_BPEL_SINGLECHILD, this.handleSingleChildLayoutEvent.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LAYOUT_BPEL_AUTORESIZE, this.handleAutoResizeLayoutEvent.bind(this));
	},
	
	/**************************** plug-in control ****************************/
	
	disableBpelLayout : function(){
		
		this.isEnabled = false;
	},
	
	enableBpelLayout : function(){
		
		this.isEnabled = true;
		
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_ENABLE,text: 'Auto Layouting...'});
		
		//adjust all immediate child nodes(grand-children are adjusted recursively)
		nodes = this.facade.getCanvas().getChildNodes();
		for (var i = 0; i < nodes.size(); i++) {
			node = nodes[i];
			if (node.getStencil().id() == node.getStencil().namespace() + "process"){
				this._adjust_node(node);
			}
		}
		
		this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
	},
	
	_adjust_node : function (node){
		
		// handle children first
		// that means, the innermost children should be at first arranged,
		var nodes = node.getChildNodes();
		for (var i = 0; i < nodes.size(); i++) {
			this._adjust_node(nodes[i]);
		};
		
		// handle the current node
		this._handleLayoutEventAdapter (node);
		//alert (node.getStencil().id());
		
	},
	
	_handleLayoutEventAdapter : function(node){
		
		if (node.getStencil().id() == node.getStencil().namespace() + "process"
	 		|| node.getStencil().id() == node.getStencil().namespace() + "invoke" 
	    	|| node.getStencil().id() == node.getStencil().namespace() + "scope"){
	    		
			this._handleLayoutEvent (node);
			
		} else if (node.getStencil().id() == node.getStencil().namespace() + "assign"
			|| node.getStencil().id() == node.getStencil().namespace() + "eventHandlers"
			|| node.getStencil().id() == node.getStencil().namespace() + "faultHandlers"
			|| node.getStencil().id() == node.getStencil().namespace() + "compensationHandler"
			|| node.getStencil().id() == node.getStencil().namespace() + "terminationHandler"){
			
			this._handleLayoutVerticalEvent (node);
			
		} else if  (node.getStencil().id() == node.getStencil().namespace() + "if"
			|| node.getStencil().id() == node.getStencil().namespace() + "sequence"
			|| node.getStencil().id() == node.getStencil().namespace() + "pick"){
			
			this._handleLayoutHorizontalEvent (node);
			
		} else if (node.getStencil().id() == node.getStencil().namespace() + "onMessage"
			|| node.getStencil().id() == node.getStencil().namespace() + "if_branch"
			|| node.getStencil().id() == node.getStencil().namespace() + "else_branch"
			|| node.getStencil().id() == node.getStencil().namespace() + "while"
			|| node.getStencil().id() == node.getStencil().namespace() + "repeatUntil"
			|| node.getStencil().id() == node.getStencil().namespace() + "forEach"
			|| node.getStencil().id() == node.getStencil().namespace() + "onAlarm"
			|| node.getStencil().id() == node.getStencil().namespace() + "onEvent"
			|| node.getStencil().id() == node.getStencil().namespace() + "catch"
			|| node.getStencil().id() == node.getStencil().namespace() + "catchAll"){
			
			this._handleSingleChildLayoutEvent (node);
			
		} else if (node.getStencil().id() == node.getStencil().namespace() + "flow"){
			
			this._handleAutoResizeLayoutEvent (node);
		} else {
			// other shapes cannot contain any children shapes.
			return;
		}
	
	},
	
	
	/***************************** Event Handler *****************************/
	
	handleLayoutEvent: function(event) {
		this._handleLayoutEvent (event.shape);
	},
	
	handleLayoutVerticalEvent: function(event) {
		this._handleLayoutVerticalEvent (event.shape);
	},
	
	handleLayoutHorizontalEvent: function(event) {
		this._handleLayoutHorizontalEvent (event.shape);
	},
	
	handleSingleChildLayoutEvent: function(event) {
		this._handleSingleChildLayoutEvent (event.shape);
	},
	
	handleAutoResizeLayoutEvent: function(event) {
		this._handleAutoResizeLayoutEvent (event.shape);
	},
	
		
	/************************* Auto Layout Processes ****************************/
	
	/**
	 *  realize special BPEL layouting:
	 *  main activity: placed left,
	 *  Handler: placed right.
	 */
	_handleLayoutEvent: function(shape) {
		
		if (this.isEnabled == false) {
			return;
		}
		
     	var elements = shape.getChildShapes(false);
     	
     	// if Autolayout is not required, do nothing.
		if (!this._requiredAutoLayout (shape)){
     		return;
     	};
     	
		// If there are no elements
		if(!elements || elements.length == 0) {
			this._resetBounds(shape);
			this._update(shape);
			return;
		};
		
     	var eventHandlers = elements.find(function(node) {
				return (node.getStencil().id() == node.getStencil().namespace() + "eventHandlers");
			});
		
		var faultHandlers = elements.find(function(node) {
				return (node.getStencil().id() == node.getStencil().namespace() + "faultHandlers");
			});
			
		var compensationHandler = elements.find(function(node) {
				return (node.getStencil().id() == node.getStencil().namespace() + "compensationHandler");
			});	

		var terminationHandler = elements.find(function(node) {
				return (node.getStencil().id() == node.getStencil().namespace() + "terminationHandler");
			});
			
		var otherElements = elements.findAll(function(node){
				return (node !== eventHandlers && node !== faultHandlers 
				&& node !== compensationHandler && node !== terminationHandler)
			});
		
		var nextLeftBound = 30;
		var nextUpperBound = 30;
		
		// handle Activity
		if (otherElements){
			
			// Sort top-down
			otherElements = otherElements.sortBy(function(element){
				return element.bounds.upperLeft().y;
			});
			
			// move some certain elements to the last child position
			// if it "true" returns, that means, the arrangement of elements
			// is changed, we should sort all elements again
			if (this._moveSomeElementToLastPosition(otherElements)){
				// Sort again
				otherElements = otherElements.sortBy(function(element){
					return element.bounds.upperLeft().y;
				});
			}
			
			var lastUpperYPosition = 0;
			var elementWidth;
			var maxElementWidth = 0;
			
			// Arrange shapes like Layout-Vertical
			otherElements.each (function(element){
		
				var ul = element.bounds.upperLeft();
				var oldUlY = ul.y;
			
				ul.y = lastUpperYPosition + 30;
				lastUpperYPosition = ul.y + element.bounds.height();
			
				if (ul.y != oldUlY) {
					element.bounds.moveTo(30, ul.y);
				};
				
				elementWidth = element.bounds.width();
				if (elementWidth > maxElementWidth){
					maxElementWidth = elementWidth;
				}
			});
			
			nextLeftBound = 30 + maxElementWidth + 30;
		
		}
		
		var width;
		var maxWidth = 0;
		
		// handle EventHanlders
		if (eventHandlers){
			eventHandlers.bounds.moveTo(nextLeftBound, nextUpperBound);
			nextUpperBound = eventHandlers.bounds.lowerRight().y + 10;
			
			// record maximal width
			width = this._getRightestBoundOfAllChildren(eventHandlers)+ 30;
			if (width > maxWidth){
				maxWidth = width;
			}
		}
		// handle FaultHandlers
		if (faultHandlers){
			faultHandlers.bounds.moveTo(nextLeftBound, nextUpperBound);
			nextUpperBound = faultHandlers.bounds.lowerRight().y + 10;
			
			// record maximal width
			width = this._getRightestBoundOfAllChildren(faultHandlers)+ 30;
			if (width > maxWidth){
				maxWidth = width;
			}
		}
		// handle CompensationHandler
		if (compensationHandler){
			compensationHandler.bounds.moveTo(nextLeftBound, nextUpperBound);
			nextUpperBound = compensationHandler.bounds.lowerRight().y + 10;
			
			// record maximal width
			width = this._getRightestBoundOfAllChildren(compensationHandler)+ 30;
			if (width > maxWidth){
				maxWidth = width;
			}
		}
		
		// handle TerminationHandler
     	if (terminationHandler){
			terminationHandler.bounds.moveTo(nextLeftBound, nextUpperBound);
			
			// record maximal width
			width = this._getRightestBoundOfAllChildren(terminationHandler)+ 30;
			if (width > maxWidth){
				maxWidth = width;
			}
		}
		
		// resize all the handlers with the same width
		if (width > 0){
			var ul;
			var lr;
			
			if (eventHandlers){	
				width = eventHandlers.bounds.width();
				if (width !== maxWidth){
					ul = eventHandlers.bounds.upperLeft();
					lr = eventHandlers.bounds.lowerRight();
					eventHandlers.bounds.set(ul.x, ul.y, ul.x + maxWidth, lr.y);
					//eventHandlers._changed();
				}
			}

			if (faultHandlers){
				width = faultHandlers.bounds.width();
				if (width !== maxWidth){
					ul = faultHandlers.bounds.upperLeft();
					lr = faultHandlers.bounds.lowerRight();
					faultHandlers.bounds.set(ul.x, ul.y, ul.x + maxWidth, lr.y);
					//faultHandlers._changed();
				}
			}

			if (compensationHandler){
				width = compensationHandler.bounds.width();
				if (width !== maxWidth){
					ul = compensationHandler.bounds.upperLeft();
					lr = compensationHandler.bounds.lowerRight();
					compensationHandler.bounds.set(ul.x, ul.y, ul.x + maxWidth, lr.y);
					//compensationHandler._changed();
				}
			}
			
	     	if (terminationHandler){
				width = terminationHandler.bounds.width();
				if (width !== maxWidth){
					ul = terminationHandler.bounds.upperLeft();
					lr = terminationHandler.bounds.lowerRight();
					terminationHandler.bounds.set(ul.x, ul.y, ul.x + maxWidth, lr.y);
					//terminationHandler._changed();
				}
			}
		}
		
		this._autoResizeLayout(shape);
		
		this._update(shape);
		
		return;
		
	},
	
	_getRightestBoundOfAllChildren : function(shape){
		var elements = shape.getChildShapes(false);
     	
		// If there are no elements
		if(!elements || elements.length == 0) {
			// 160 is the default width of hanlders
			return 130;
		};
			
		// Sort left-right
		elements = elements.sortBy(function(element){
			return element.bounds.lowerRight().x;
		});
		
		return elements.last().bounds.lowerRight().x;
	},
	
	_handleLayoutVerticalEvent: function(shape) {
		
		if (this.isEnabled == false) {
			return;
		}
		
		var elements = shape.getChildShapes(false);
		
		// if Autolayout is not required, do nothing.
		if (!this._requiredAutoLayout (shape)){
     		return;
     	};
		
		// If there are no elements
		if(!elements || elements.length == 0) {
			this._resetBounds(shape);
			return;
		};
		
		// Sort top-down
		elements = elements.sortBy(function(element){
			return element.bounds.upperLeft().y;
		});
		
					
		// move some certain elements to the last child position
		// if it "true" returns, that means, the arrangement of elements
		// is changed, we should sort all elements again
		if (this._moveSomeElementToLastPosition(elements)){
			// Sort again
			elements = elements.sortBy(function(element){
				return element.bounds.upperLeft().y;
			});
		}
		
		var lastUpperYPosition = 0;
		// Arrange shapes
		elements.each(function(element){
		
			var ul = element.bounds.upperLeft();
			var oldUlY = ul.y;
			
			ul.y = lastUpperYPosition + 30;
			lastUpperYPosition = ul.y + element.bounds.height();
			
			if ((ul.y != oldUlY)) {
				element.bounds.moveTo(30, ul.y);
			}
		});
		
		this._autoResizeLayout(shape);
	
		return;
	},
	
	_handleLayoutHorizontalEvent: function(shape) {

		if (this.isEnabled == false) {
			return;
		}
		
		var elements = shape.getChildShapes(false);
		
		// if Autolayout is not required, do nothing.
		if (!this._requiredAutoLayout (shape)){
     		return;
     	};
		
		// If there are no elements
		if(!elements || elements.length == 0) {
			this._resetBounds(shape);
			return;
		};
					
		
		// Sort left-right
		elements = elements.sortBy(function(element){
			return element.bounds.upperLeft().x;
		});
		
		// move some certain elements to the last child position
		// if it "true" returns, that means, the arrangement of elements
		// is changed, we should sort all elements again
		if (this._moveSomeElementToLastPosition(elements)){
			// Sort again
			elements = elements.sortBy(function(element){
				return element.bounds.upperLeft().x;
			});
		}
		
		var lastLeftXPosition = 0;
		
		// Arrange shapes on rows (align left)
		elements.each(function(element){
		
			var ul = element.bounds.upperLeft();
			var oldUlX = ul.x;
			
			ul.x = lastLeftXPosition + 30;
			lastLeftXPosition = ul.x + element.bounds.width();

			if ((ul.x != oldUlX)) {
				element.bounds.moveTo(ul.x, 30);
			}
		});
		
		this._autoResizeLayout(shape);
			
		return;
	},
	
	
	
	_handleSingleChildLayoutEvent: function(shape) {
     	
		if (this.isEnabled == false) {
			return;
		}
		
		var elements = shape.getChildShapes(false);
		
		// if Autolayout is not required, do nothing.
		if (!this._requiredAutoLayout (shape)){
     		return;
     	};
		
		// If there are no elements
		if(!elements || elements.length == 0) {
			this._resetBounds(shape);
			return;
		};
		
		elements.first().bounds.moveTo(30, 30);
		
		this._autoResizeLayout(shape);
		
		return;
	},
	
	_handleAutoResizeLayoutEvent: function(shape) {
		
		if (this.isEnabled == false) {
			return;
		};
		
		var elements = shape.getChildShapes(false);
		
		// if Autolayout is not required, do nothing.
		if (!this._requiredAutoLayout (shape)){
     		return;
     	};
		
		elements.each(function(element){
		
			var ul = element.bounds.upperLeft();
			
			if ((ul.x < 30)) {
				element.bounds.moveTo(30, ul.y);
				ul = element.bounds.upperLeft();
			}
			
			if ((ul.y < 30)) {
				element.bounds.moveTo(ul.x, 30);
			}
		});
		
		this._autoResizeLayout(shape);
	},
	
	/**
	 * Resizes the shape to the bounds of the child shapes 
	 */
	_autoResizeLayout: function(shape) {
		
		var elements = shape.getChildShapes(false);
		
		if (elements.length > 0) {

		    elements = elements.sortBy(function(element){
				return element.bounds.lowerRight().x;
		    });
		    
			var rightBound = elements.last().bounds.lowerRight().x;
                 
		    elements = elements.sortBy(function(element){
				return element.bounds.lowerRight().y;
		    });
		    
			var lowerBound = elements.last().bounds.lowerRight().y;
			
			var ul = shape.bounds.upperLeft();
			var lr = shape.bounds.lowerRight();
			
			//handle "flow" specially.
			if (shape.getStencil().id() ==shape.getStencil().namespace() + "flow"){
			 	
			 	if (lr.x < ul.x + rightBound + 30){
			 		shape.bounds.set(ul.x, ul.y, ul.x + rightBound + 30, lr.y);
			 		lr.x = ul.x + rightBound + 30;
			 		//shape._changed();
			 	};
			 	
			 	if (lr.y < ul.y + lowerBound + 30){
			 		shape.bounds.set(ul.x, ul.y, lr.x, ul.y + lowerBound + 30);
			 		//shape._changed();
			 	};			 	
			 } else {
			 	if (lr.x != ul.x + rightBound + 30 || lr.y != ul.y + lowerBound + 30){
			 		shape.bounds.set(ul.x, ul.y, ul.x + rightBound + 30, ul.y + lowerBound + 30);
			 		//shape._changed();
			 	};
			 };
		};
		
		return;
	},
	
	_resetBounds: function (shape) {

		// all the shapes without children will be reseted
		var ul = shape.bounds.upperLeft();
		var lr = shape.bounds.lowerRight();
		
		if (shape.getStencil().id() == shape.getStencil().namespace() + "process"){
			if (shape.getStencil().namespace() == "http://b3mn.org/stencilset/bpel#"){
				if (lr.x != ul.x + 600 || lr.y != ul.y + 500){
					shape.bounds.set(ul.x, ul.y, ul.x + 600, ul.y + 500);
					//shape._changed();
				};
			} else if (shape.getStencil().namespace() == "http://b3mn.org/stencilset/bpel4chor#"){
				if (lr.x != ul.x + 690 || lr.y != ul.y + 200){
					shape.bounds.set(ul.x, ul.y, ul.x + 690, ul.y + 200);
					//shape._changed();
				};
			} else {
				return;
			}
		} else if (shape.getStencil().id() == shape.getStencil().namespace() + "flow"){
			if (lr.x != ul.x + 290 || lr.y != ul.y + 250){
				shape.bounds.set(ul.x, ul.y, ul.x + 290, ul.y + 250);
				//shape._changed();
			};
		} else if (this._isHandlers(shape)){
			if (lr.x != ul.x + 160 || lr.y != ul.y + 80){
				shape.bounds.set(ul.x, ul.y, ul.x + 160, ul.y + 80);
				//shape._changed();
			};
		} else {
			if (lr.x != ul.x + 100 || lr.y != ul.y + 80){
				shape.bounds.set(ul.x, ul.y, ul.x + 100, ul.y + 80);
				//shape._changed();
			};	
		};

	},
	
	_isHandlers: function (shape) {
	  	if (shape.getStencil().id() == shape.getStencil().namespace() + "eventHandlers"){
	  		return true;
	  	};
	  	
	  	if (shape.getStencil().id() == shape.getStencil().namespace() + "faultHandlers"){
	  		return true;
	  	};
	  	
	  	if (shape.getStencil().id() == shape.getStencil().namespace() + "compensationHandler"){
	  		return true;
	  	};
	  	
	  	if (shape.getStencil().id() == shape.getStencil().namespace() + "terminationHandler"){
	  		return true;
	  	};
		
	  	return false;
	},
	
	_requiredAutoLayout: function(shape) {
		
		var key = "oryx-autolayout";
		var autolayout = shape.properties[key];
		
		if (autolayout == null){
			return true;
		};
		
		if (autolayout){
			return true;
		};
		
		return false;
	},
	
	/**
	 * find a element with the role "lastChild", that means, this shape should be
	 * the last child of their parent, e.g.: "else" in "if-block". then move these elements
	 * to the last position of the set.
	 * 
	 * 
	 * @param {} elements : the set of all elements
	 * @pre      all the elements in set are already once arranged, so we just put the 
	 *           "lastChild" after the current last one. 
	 * @return   if the arrangement of elements is changed.
	 */
	_moveSomeElementToLastPosition: function (elements){
		var lastChild = elements.find(function(node) {
			 	return (Array.indexOf(node.getStencil().roles(), node.getStencil().namespace() + "lastChild")>= 0);
			});	
		
		// if there are not such element or it's already the last child,
		// do nothing.	
		if (!lastChild || lastChild == elements.last()){
			return false;
		}
		
		// move it after the current last child
		ulOfCurrentLastChild = elements.last().bounds.upperLeft();
		lastChild.bounds.moveTo(ulOfCurrentLastChild.x + 1, ulOfCurrentLastChild.y + 1);
		
		return true;
	},
	
	_update : function(shape){
		// update the canvas only if the current node is "process", with this we can
		// make sure that, each time just once update after all the nodes are arranged
		// and we must check, whether the node "process" changed is, if not, don't update,
		// otherwise, an endless loop may occur, if there are more than three nesting level 
		// in a shape.
		if (shape.getStencil().id() == shape.getStencil().namespace() + "process"
		&& shape.isChanged){
		//	this.facade.getCanvas().update();
		}
	}
});/**
 * Copyright (c) 2008-2009
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.Workflownets = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade){
		this.facade = facade;
		
		this.facade.registerOnEvent("Workflownets.Activity.serialize", this.handleSerialize.bind(this));
	},
	
	handleSerialize: function(event) {
		var shape = event.shape;
		var data = event.data;
		var numOfOutgoings = shape.getOutgoingShapes().length;
		data.push({
				  name:"numOfOutgoings",
				  prefix:"oryx",
				  value:numOfOutgoings,
				  type:"literal"
				  });
		
		event.result = data;
	},
};

ORYX.Plugins.Workflownets = Clazz.extend(ORYX.Plugins.Workflownets);

/**
 * Copyright (c) 2008
 * Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
Ext.ns("Oryx.Plugins");

ORYX.Plugins.BPMNImport = Clazz.extend({
    converterUrl: ORYX.CONFIG.ROOT_PATH + "bpmn2pn",
    
    // Offers the plugin functionality
    construct: function(facade){
    
        this.facade = facade;
       
        this.importBpmn();
    },
    
    /**
     * General helper method for parsing a param out of current location url
     * E.g. "http://oryx.org?param=value", getParamFromUrl("param") => "value"
     * @param {Object} name
     */
    getParamFromUrl: function(name){
        name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + name + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(window.location.href);
        if (results == null) {
            return null;
        }
        else {
            return results[1];
        }
    },
    
    /**
     * Posts rdf (BPNM) to server and loads erdf (Petri net) into canvas
     * @param {Object} bpmnRdf
     */
    bpmnToPn: function(bpmnRdf){
        Ext.Msg.updateProgress(0.66, ORYX.I18N.BPMN2PNConverter.progress.convertingModel);
        
       Ext.Ajax.request({
            url: this.converterUrl,
            method: 'POST',
            success: function(request){
    	   		try{
	                var parser = new DOMParser();
	                Ext.Msg.updateProgress(1.0, ORYX.I18N.BPMN2PNConverter.progress.renderingModel);
	                var doc = parser.parseFromString(request.responseText, "text/xml");
	                this.facade.importERDF(doc);
    	   		}catch(e){
    	   			Ext.Msg.alert("Rendering Failed :\n"+e);
    	   		}
                Ext.Msg.hide();
            }.createDelegate(this),
            failure: function(){
                Ext.Msg.alert(ORYX.I18N.BPMN2PNConverter.error, ORYX.I18N.BPMN2PNConverter.errors.server);
            },
            params: {
                rdf: bpmnRdf
            }
        });
        
    },
    
    /**
     * Loads rdf of given bpmn url
     */
    importBpmn: function(){
        var importBPMNUrl = this.getParamFromUrl("importBPMN");
        
        if(!importBPMNUrl) return; //return if no model to import is given
        
        Ext.Msg.progress(ORYX.I18N.BPMN2PNConverter.progress.status, 
                         ORYX.I18N.BPMN2PNConverter.progress.importingModel
        );
        Ext.Msg.updateProgress(0.33, ORYX.I18N.BPMN2PNConverter.progress.fetchingModel);
        
        Ext.Ajax.request({
            url: this.getRdfUrl(importBPMNUrl),
            success: function(request){
                var bpmnRdf = request.responseText;
                this.bpmnToPn(bpmnRdf);
            }.createDelegate(this),
            failure: function(request){
                Ext.Msg.alert(ORYX.I18N.BPMN2PNConverter.error, ORYX.I18N.BPMN2PNConverter.errors.noRights)
            },
            method: "GET"
        })
    },
    
    /**
     * getRdfUrl("http://localhost:8080/backend/poem/model/7/self") 
     * => "http://localhost:8080/backend/poem/model/7/rdf"
     * getRdfUrl("http://localhost:8080/backend/poem/model/7/rdf" => "http://localhost:8080/backend/poem/model/7/rdf")
     * @param {String} url
     */
    getRdfUrl: function(url){
        return url.replace(/\/self(\/)?$/, "/rdf")
    }
});

ORYX.Plugins.PNExport = Clazz.extend({
    // Offers the plugin functionality
    construct: function(facade){
    
        this.facade = facade;
       
        this.facade.offer({
            'name': ORYX.I18N.BPMN2PNConverter.name,
            'functionality': this.exportIt.bind(this),
            'group': ORYX.I18N.BPMN2PNConverter.group,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': ORYX.PATH + "images/page_white_convert.png",
            'description': ORYX.I18N.BPMN2PNConverter.desc,
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    exportIt: function(){
        //Throw error if model hasn't been saved before
    	var reqURI='';
		if(!location.hash.slice(1)){
            Ext.Msg.alert(ORYX.I18N.BPMN2PNConverter.error, ORYX.I18N.BPMN2PNConverter.errors.notSaved);
            return;
		}
		else{
			reqURI = '/backend/poem/'+(location.hash.slice(1).replace(/^\/?/,"").replace(/\/?$/,""))+"/rdf";
		}
        
        this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
        this.facade.raiseEvent({
            type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
            context: "bpmn2pn",
            onNoErrors: function(){
                this.openPetriNetEditor(reqURI);
            }.bind(this)
        });
    },
    
    /**
     * Opens petri net editor with bpmn model import
     * @methodOf: ORYX.Plugins.BPMNImport.prototype
     */
    openPetriNetEditor: function(importUrl){
        window.open("/backend/poem/new?stencilset=/stencilsets/petrinets/petrinet.json&importBPMN=" + importUrl);
    }
});/**
 * Copyright (c) 2009
 * Armin Zamani
 **/

if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.BPMN2YAWLMapper = ORYX.Plugins.AbstractPlugin.extend({
	stencilSetExtensionNamespace: "http://oryx-editor.org/stencilsets/extensions/bpmn4yawlSubset#",

	construct: function(){
		arguments.callee.$.construct.apply(this, arguments);
		
        this.active = false;
        this.raisedEventIds = [];
		
		this.facade.offer({
			'name': ORYX.I18N.BPMN2YAWLMapper.name,
			'functionality': this.perform.bind(this),
			'group': ORYX.I18N.BPMN2YAWLMapper.group,
			'icon': ORYX.PATH + 'images/door.png',
			'description': ORYX.I18N.BPMN2YAWLMapper.desc,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'index': 1,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': 		this._isStencilSetExtensionLoaded.bind(this)

		});
		
        this.facade.registerOnEvent(ORYX.Plugins.BPMN2YAWLMapper.RESET_ERRORS_EVENT, this.resetErrors.bind(this));
        this.facade.registerOnEvent(ORYX.Plugins.BPMN2YAWLMapper.SHOW_ERRORS_EVENT, this.doShowErrors.bind(this));
	},
	_isStencilSetExtensionLoaded: function() {
		return this.isStencilSetExtensionLoaded(this.stencilSetExtensionNamespace);
	},
	perform: function(button, pressed){
		this.resetErrors();
		this.checkSyntaxAndMapBPMNtoYAWL({
			onMappingSucceeded: function(){
			this.setActivated(false);

			Ext.Msg.alert("The BPMN to YAWL mapper succeeded and has created an YAWL file in your Eclipse directory");
		},
		onErrors: function(){
		},
		onFailure: function(){
			this.setActivated(false);
			Ext.Msg.alert("The connection to the server failed");
		}
		});
	},
	
	/**
     * Sets the activated state of the plugin
     * @param {Object} activated
     */
    setActivated: function(activated){
        if(activated === undefined){
            this.active = !this.active;
        } else {
            this.active = activated;
        }
    },
	
	checkSyntaxAndMapBPMNtoYAWL: function(options){
		Ext.applyIf(options || {}, {
	          showErrors: true,
	          ononMappingSucceeded: Ext.emptyFn,
	          onErrors: Ext.emptyFn,
	          onFailure: Ext.emptyFn
	        });
		
		var data = this.getRDFFromDOM();
		this.openDownload(ORYX.CONFIG.BPMN2YAWL_URL,data);
//		new Ajax.Request(ORYX.CONFIG.BPMN2YAWL_URL, {
//			method: 'POST',
//			asynchronous: false,
//			parameters : {
//				data: data
//			},
//			onSuccess: function(request){
//				var resp = request.responseText.evalJSON();
//				
//				Ext.Msg.hide();
//				
//				if (resp instanceof Object) {
//					resp = $H(resp)
//					if (resp.size() > 0) {
//						if(options.showErrors) this.showErrors(resp);
//						options.onErrors();
//					}
//					else {
//						Ext.Msg.alert("Mapping succeeded");
//						options.onMappingSucceeded();
//					}
//				}
//				else {
//					options.onFailure();
//				}
//			}.bind(this),
//			onFailure: function(){
//				Ext.Msg.hide();
//				options.onFailure();
//			}
//		});
	},
	
	/** Called on SHOW_ERRORS_EVENT.
     * 
     * @param {Object} event
     * @param {Object} args
     */
    doShowErrors: function(event, args){
        this.showErrors(event.errors);
    },
    
    /**
     * Shows overlays for each given error
     * @methodOf ORYX.Plugins.BPMN2YAWLMapper.prototype
     * @param {Hash|Object} errors
     * @example
     * showErrors({
     *     myShape1: "This has an error!",
     *     myShape2: "Another error!"
     * })
     */
    showErrors: function(errors){
        // If normal object is given, convert to hash
        if(!(errors instanceof Hash)){
            errors = new Hash(errors);
        }
        
        // Get all Valid ResourceIDs and collect all shapes
        errors.keys().each(function(value){
            var sh = this.facade.getCanvas().getChildShapeByResourceId(value);
            if (sh) {
                this.raiseOverlay(sh, errors[value]);
            }
        }.bind(this));
        //this.active = !this.active;
    },
    
    /**
     * Resets all (displayed) errors
     * @methodOf ORYX.Plugins.BPMN2YAWLMapper.prototype
     */
    resetErrors: function(){
        this.raisedEventIds.each(function(id){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: id
            });
        }.bind(this))
        
        this.raisedEventIds = [];
        this.active = false;
    },
    
    raiseOverlay: function(shape, errorMsg){
        var id = "syntaxchecker." + this.raisedEventIds.length;
        var crossId = ORYX.Editor.provideId();
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
        	"id":crossId,
        	"title": errorMsg,
            "stroke-width": 5.0,
            "stroke": "red",
            "d": "M20,-5 L5,-20 M5,-5 L20,-20",
            "line-captions": "round"
        }]);
        
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        this.raisedEventIds.push(id);
        
        return cross;
    },
	openDownload: function(url, content) {
		var win = window.open("");
		if (win != null) {
			win.document.open();
			win.document.write("<html><body>");
			var submitForm = win.document.createElement("form");
			win.document.body.appendChild(submitForm);
			
			var createHiddenElement = function(name, value) {
				var newElement = document.createElement("input");
				newElement.name=name;
				newElement.type="hidden";
				newElement.value = value;
				return newElement
			}
			
			submitForm.appendChild( createHiddenElement("data", content) );
			
			
			submitForm.method = "POST";
			win.document.write("</body></html>");
			win.document.close();
			submitForm.action= url;
			submitForm.submit();
			window.setTimeout(function(){
				win.close();
			}.bind(this), 1000);
		}		
	}
});

//Define the events
ORYX.Plugins.BPMN2YAWLMapper.RESET_ERRORS_EVENT = "resetErrors";
ORYX.Plugins.BPMN2YAWLMapper.SHOW_ERRORS_EVENT = "showErrors";/**
 * Copyright (c) 2009
 * Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
Ext.ns("Oryx.Plugins");

ORYX.Plugins.PetriNetSoundnessChecker = ORYX.Plugins.AbstractPlugin.extend({

    hideOverlays: function(){
        //TODO set in constructor!!!
        if(!this.overlayIds) 
            return;
    
        Ext.each(this.overlayIds, function(overlayId){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: overlayId
            });
        }.bind(this));
    },
    
    getChildShapesByResourceIds: function(resourceIds){
        var shapes = [];
    
        Ext.each(resourceIds, function(resourceId){
            shapes.push(this.facade.getCanvas().getChildShapeByResourceId(resourceId));
        }.bind(this));
        
        return shapes;
    },
    
    /**
       Show overlay on given shape.
       @methodOf ORYX.Plugins.AbstractPlugin.prototype
       @example
       showOverlay(
           myShape,
           { stroke: "green" },
           ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
               "title": "Click the element to execute it!",
               "stroke-width": 2.0,
               "stroke": "black",
               "d": "M0,-5 L5,0 L0,5 Z",
               "line-captions": "round"
           }])
       )
       @param {Oryx.XXX.Shape[]} shapes One shape or array of shapes the overlay should be put on
       @param {Oryx.XXX.Attributes} attributes some attributes...
       @param {Oryx.svg.node} svgNode The svg node which should be used as overlay
       @param {String} [svgNode="NW"] The svg node position where the overlay should be placed
    */
    showOverlay: function(shapes, attributes, svgNode, svgNodePosition ){
        if(!this.overlayIds){
            this.overlayIds = [];
        }
        
        if( !(shapes instanceof Array) ){
            shapes = [shapes]
        }
        
        // Define Shapes
        shapes = shapes.map(function(shape){
            var el = shape;
            if( typeof shape == "string" ){
                el = this.facade.getCanvas().getChildShapeByResourceId( shape );
                el = el || this.facade.getCanvas().getChildById( shape, true );
            }
            return el;
        }.bind(this)).compact();
        
        // Define unified id
        var overlayId = this.type + ORYX.Editor.provideId();
        this.overlayIds.push(overlayId);
        
        this.facade.raiseEvent({
            type        : ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id          : overlayId,
            shapes      : shapes,
            attributes  : attributes,
            node        : svgNode,
            nodePosition: svgNodePosition || "NW"
        });
        
    },

    // Offers the plugin functionality
    construct: function(facade){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
                
        this.facade.offer({
            'name': "Check soundness",//ORYX.I18N.BPMN2PNConverter.name,
            'functionality': this.showCheckerWindow.bind(this),
            'group': "Verification",
            'icon': ORYX.PATH + "images/checker_validation.png",
            'description': "Checks current Petri net for different soundness criteria.",
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    showCheckerWindow: function(){
        var plugin = this;
        
        var CheckNode = Ext.extend(Ext.tree.TreeNode, {
            constructor: function(config) {
                if(!config.icon && !this.icon)
                    config.icon = CheckNode.UNKNOWN_STATUS;

                CheckNode.superclass.constructor.apply(this, arguments);
                
                Ext.apply(this, config);
                
                if(this.clickHandler){
                    this.on('click', this.clickHandler.bind(this));
                }
            },

            setIcon: function(status) {
                this.ui.getIconEl().src = status;
            },
            getIcon: function(status) {
                return this.ui.getIconEl().src;
            },
            reset: function(){
                plugin.hideOverlays();
                this.hideMarking();
                // Reset syntax errors
                plugin.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
            },
            hideMarking: function(){
                if(!plugin.marking)
                    return;
            
                for(place in plugin.marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    if(placeShape)//place can be null if removed
                        placeShape.setProperty("oryx-numberoftokens", 0);
                }
                // Show changes
                plugin.facade.getCanvas().update();
                
                plugin.marking = undefined;
            },
            showMarking: function(marking){
                plugin.marking = marking;
            
                for(place in marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    placeShape.setProperty("oryx-numberoftokens", marking[place]);
                }
                // Show changes
                plugin.facade.getCanvas().update();
            },
            showErrors: function(errors){
                // Remove all old error nodes
                Ext.each(this.childNodes, function(child){
                    if(child && child.itemCls === 'error')
                        child.remove();
                });
                
                // Show Unknown status on child nodes
                Ext.each(this.childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
                
                // Show errors
                Ext.each(errors, function(error){
                    this.insertBefore(new CheckNode({
                        icon: CheckNode.ERROR_STATUS,
                        text: error,
                        itemCls: 'error'
                    }), this.childNodes[0]);
                }.bind(this));
            },
            showOverlayWithStep: function(shapeIds){
                Ext.each(shapeIds, function(shapeId, index){
                    plugin.showOverlay(
                        plugin.facade.getCanvas().getChildShapeByResourceId(shapeId), 
                        {
                            fill: "#FB7E02"//orange
                        },
                        ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                            "style": "font-size: 16px; font-weight: bold;"
                        }, (index + 1)+"."]),
                        "SE" //position in south east
                    );
                });
            },
            showOverlay: function(shapes){
                if(shapes.length === 0)
                    return;

                if(! shapes[0] instanceof ORYX.Core.Node)
                    shapes = plugin.getChildShapesByResourceIds(shapes)
            
                plugin.showOverlay(
                    shapes, 
                    {
                        fill: "#FB7E02"//orange
                    }
                );
            }
        });
        CheckNode.UNKNOWN_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'asterisk_yellow.png';
        CheckNode.ERROR_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'exclamation.png';
        CheckNode.OK_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'accept.png';
        CheckNode.LOADING_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'loading.gif';
        
        var DeadLocksNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Termination Criteria</b>: Makes sure that any process instance that starts in the initial state will eventually reach the final state. If any dead locks are detected, click to show one counter example.';
            
                DeadLocksNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
            
                if(this.deadLocks.length == 0) return;
                
                var deadLock = node.deadLocks[0];
                this.showOverlayWithStep(deadLock.path);
                this.showMarking(deadLock.marking);
            },
            update: function(deadLocks){
                this.deadLocks = deadLocks;
                this.setIcon(this.deadLocks.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There is '+(this.deadLocks.length == 0 ? 'no' : 'a')+' path that leads to a deadlock.');
            }
        });
        
        var ImproperTerminatingsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Proper Termination Criteria</b>: The final state is the only state reachable from the initial state in which there is a token in the final place. If any improper terminating states are detected, click to show one counter example.';
            
                ImproperTerminatingsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
            
                if(node.improperTerminatings.length == 0) return;
                
                var improperTerminating = node.improperTerminatings[0];
                this.showOverlayWithStep(improperTerminating.path);
                this.showMarking(improperTerminating.marking);
            },
            update: function(improperTerminatings){
                this.improperTerminatings = improperTerminatings;
                
                this.setIcon(this.improperTerminatings.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.improperTerminatings.length +' markings covering the final marking.');
            }
        });
        
        var DeadTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>No Dead Transitions Criteria</b>: Each transition can contribute to at least one process instance. Click to see all dead transitions.';
            
                DeadTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.deadTransitions);
            },
            update: function(deadTransitions){
                this.deadTransitions = deadTransitions;
                
                this.setIcon(this.deadTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.deadTransitions.length +' dead transitions.');
            }
        });
        
        var NotParticipatingTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Transition Participation Criteria</b>: Each transition participates in at least one process instance that starts in the initial state and reaches the final state. Click to see all transitions not participating in any process instance.';
            
                NotParticipatingTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.notParticipatingTransitions);
            },
            update: function(notParticipatingTransitions){
                this.notParticipatingTransitions = notParticipatingTransitions;
                
                this.setIcon(this.notParticipatingTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.notParticipatingTransitions.length +' transitions that cannot participate in a properly terminating firing sequence.');
            }
        });
        
        this.checkerWindow = new Ext.Window({
            title: 'Soundness Checker',
            autoScroll: true,
            width: '500',
            tbar: [
                {
                    text: 'Check', 
                    handler: function(){
                        this.checkerWindow.check();
                    }.bind(this)
                },
                {
                    text: 'Hide Errors', 
                    handler: function(){
                        this.checkerWindow.getTree().getRootNode().reset();
                    }.bind(this)
                },
                '->',
                {
                    text: 'Close', 
                    handler: function(){
                        this.checkerWindow.close();
                    }.bind(this)
                }
            ],
            getTree: function(){
                return this.items.get(0);
            },
            check: function(renderAll){
                this.prepareCheck(renderAll);
                this.checkSyntax(this.checkSoundness.bind(this));
            },
            prepareCheck: function(renderAll){//call with renderAll=true if showing for the first time
                var root = this.getTree().getRootNode();
                
                root.reset();
                
                // Set loading status to all child nodes
                Ext.each(root.childNodes, function(childNode){
                    if(renderAll)//this expands all nodes so they're rendered a first time
                        childNode.expand(true);
                    childNode.collapse(true); //collapse deeply
                    childNode.setIcon(CheckNode.LOADING_STATUS);
                });
            },
            checkSyntax: function(callback){
                plugin.facade.raiseEvent({
                    type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
                    onErrors: function(){
                        Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!")
                        this.turnLoadingIntoUnknownStatus();
                    }.bind(this),
                    onNoErrors: function(){
                        callback();
                    }
                });
            },
            // All child nodes with loading status get unknown status
            turnLoadingIntoUnknownStatus: function(){
                Ext.each(this.getTree().getRootNode().childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
            },
            checkSoundness: function(){
                var root = this.getTree().getRootNode();
                
                // Check for structural soundness (no server request needed and return, if any has been found       
                if(! root.findChild("id", "structuralSound").check()){
                    this.turnLoadingIntoUnknownStatus();
                    return;
                }
                
                // Check other soundness criteria which needs server requests
                Ext.Ajax.request({
                    url: ORYX.CONFIG.ROOT_PATH + 'checksoundness',
                    method: 'POST',
                    success: function(request){
                        var res = Ext.decode(request.responseText);
                        
                        root.showErrors(res.errors);
                        
                        if(res.errors.length === 0){
                            root.findChild("id", "sound").check(res);
                            root.findChild("id", "weakSound").check(res);
                            root.findChild("id", "relaxedSound").check(res);
                        }
                    },
                    failure: function(){
                    },
                    params: {
                        data: plugin.getSerializedDOM()
                    }
                });
                
            },
            items: [new Ext.tree.TreePanel({
                useArrows: true,
                autoScroll: true,
                rootVisible: false,
                animate: true,
                containerScroll: true,
                
                root: new CheckNode({
                    text: 'Checks',
                    id: 'source',
                    expanded: true
                }),
                listeners: {
                    render: function(treePanel){
                        var structuralSoundNode = new CheckNode({
                            text: 'Structural Sound (Workflow Net)',
                            id: 'structuralSound',
                            /* Returns false when any error has been found */
                            check: function(){
                                this.checkInitialNode.update();
                                this.checkFinalNode.update();
                                this.checkConnectedNode.update(this.checkInitialNode.initialNodes, this.checkFinalNode.finalNodes);
                                
                                if(this.checkInitialNode.hasErrors() || this.checkFinalNode.hasErrors() || this.checkConnectedNode.hasErrors()){
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                    return false;
                                } else {
                                    this.setIcon(CheckNode.OK_STATUS);
                                    return true;
                                }
                            },
                            checkInitialNode: new CheckNode({
                                qtip: 'There must be exactly one initial place, which is the only place without any incoming edges.',
                                update: function(){
                                    this.initialNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getIncomingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.initialNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.initialNodes.length + ' initial places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.initialNodes);
                                },
                                hasErrors: function(){
                                    return this.initialNodes.length !== 1;
                                }
                            }),
                            checkFinalNode: new CheckNode({
                                qtip: 'There must be exactly one final place, which is the only place without any outgoing edges.',
                                update: function(){
                                    this.finalNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getOutgoingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.finalNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.finalNodes.length + ' final places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.finalNodes);
                                },
                                hasErrors: function(){
                                    return this.finalNodes.length !== 1;
                                }
                            }),
                            checkConnectedNode: new CheckNode({
                                qtip: 'Each node in the process model is on the path from the initial node to the final node.',
                                update: function(initialNodes, finalNodes){
                                    //Step through without semantic knowledge
                                    if(initialNodes.length !== 1 || finalNodes.length !== 1){
                                        this.setText("There must be exactly one initial and final place to perform further checks!");
                                        this.setIcon(CheckNode.UNKNOWN_STATUS);
                                        return;
                                    }
                                    
                                    this.notParticipatingNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape instanceof ORYX.Core.Node)
                                            this.notParticipatingNodes.push(shape);
                                    }.bind(this));
                                    
                                    this.passedNodes = [];
                                    
                                    this.findNotParticipatingNodes(initialNodes[0]);
                                    
                                    this.setText(this.notParticipatingNodes.length + ' nodes that aren\'t on any path from beginning to end found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.notParticipatingNodes);
                                },
                                findNotParticipatingNodes: function(currentNode){
                                    this.passedNodes.push(currentNode);
                                    this.notParticipatingNodes.remove(currentNode);
                                    
                                    Ext.each(currentNode.getOutgoingShapes(), function(nextNode){
                                        if(!this.passedNodes.include(nextNode)){
                                            this.findNotParticipatingNodes(nextNode);
                                        };
                                    }.bind(this));
                                },
                                hasErrors: function(){
                                    return this.notParticipatingNodes.length !== 0;
                                }
                            })
                        });
                        structuralSoundNode.appendChild([
                            structuralSoundNode.checkInitialNode,
                            structuralSoundNode.checkFinalNode,
                            structuralSoundNode.checkConnectedNode
                        ]);
                    
                        var soundNode = new CheckNode({
                            text: 'Sound',
                            id: 'sound',
                            check: function(res){
                                if (res.isSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.deadTransitionsNode.update(res.deadTransitions);
                                this.improperTerminatingsNode.update(res.improperTerminatings);
                                this.deadLocksNode.update(res.deadLocks);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            improperTerminatingsNode: new ImproperTerminatingsNode({}),
                            deadLocksNode: new DeadLocksNode({})
                        });
                        soundNode.appendChild([
                            soundNode.deadTransitionsNode,
                            soundNode.improperTerminatingsNode,
                            soundNode.deadLocksNode
                        ]);
                        
                        var weakSoundNode = new CheckNode({
                            text: 'Weak Sound',
                            id: 'weakSound',
                            check: function(res){
                                if (res.isWeakSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }

                                this.improperTerminatingsNode.update(res.improperTerminatings);
                                this.deadLocksNode.update(res.deadLocks);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            improperTerminatingsNode: new ImproperTerminatingsNode({}),
                            deadLocksNode: new DeadLocksNode({})
                        });
                        weakSoundNode.appendChild([
                            weakSoundNode.improperTerminatingsNode,
                            weakSoundNode.deadLocksNode
                        ]);
                        
                        var relaxedSoundNode = new CheckNode({
                            text: 'Relaxed Sound',
                            id: 'relaxedSound',
                            check: function(res){
                                if (res.isRelaxedSound) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.notParticipatingTransitionsNode.update(res.notParticipatingTransitions);
                            },
                            notParticipatingTransitionsNode: new NotParticipatingTransitionsNode({})
                        });
                        relaxedSoundNode.appendChild([
                            relaxedSoundNode.notParticipatingTransitionsNode
                        ]);
                        
                        treePanel.getRootNode().appendChild([structuralSoundNode, soundNode, weakSoundNode, relaxedSoundNode]);
                        
                    }
                }
            })],
            listeners: {
                close: function(window){
                    this.checkerWindow.getTree().getRootNode().reset();
                }.bind(this)
            }
        });
        
        this.checkerWindow.show();
        this.checkerWindow.check(true);
    }
});/**
 * Copyright (c) 2010 Philipp Berger, Kai Schlichting
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
Ext.ns("Oryx.Plugins");

ORYX.Plugins.LolaPetriNetSoundnessChecker = ORYX.Plugins.AbstractPlugin.extend({

    hideOverlays: function(){
        // TODO set in constructor!!!
        if(!this.overlayIds) 
            return;
    
        Ext.each(this.overlayIds, function(overlayId){
            this.facade.raiseEvent({
                type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
                id: overlayId
            });
        }.bind(this));
    },
    
    getChildShapesByResourceIds: function(resourceIds){
        var shapes = [];
    
        Ext.each(resourceIds, function(resourceId){
            shapes.push(this.facade.getCanvas().getChildShapeByResourceId(resourceId));
        }.bind(this));
        
        return shapes;
    },
    
    /**
	 * Show overlay on given shape.
	 * 
	 * @methodOf ORYX.Plugins.AbstractPlugin.prototype
	 * @example showOverlay( myShape, { stroke: "green" },
	 *          ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
	 *          "title": "Click the element to execute it!", "stroke-width":
	 *          2.0, "stroke": "black", "d": "M0,-5 L5,0 L0,5 Z",
	 *          "line-captions": "round" }]) )
	 * @param {Oryx.XXX.Shape[]}
	 *            shapes One shape or array of shapes the overlay should be put
	 *            on
	 * @param {Oryx.XXX.Attributes}
	 *            attributes some attributes...
	 * @param {Oryx.svg.node}
	 *            svgNode The svg node which should be used as overlay
	 * @param {String}
	 *            [svgNode="NW"] The svg node position where the overlay should
	 *            be placed
	 */
    showOverlay: function(shapes, attributes, svgNode, svgNodePosition ){
        if(!this.overlayIds){
            this.overlayIds = [];
        }
        
        if( !(shapes instanceof Array) ){
            shapes = [shapes]
        }
        
        // Define Shapes
        shapes = shapes.map(function(shape){
            var el = shape;
            if( typeof shape == "string" ){
                el = this.facade.getCanvas().getChildShapeByResourceId( shape );
                el = el || this.facade.getCanvas().getChildById( shape, true );
            }
            return el;
        }.bind(this)).compact();
        
        // Define unified id
        var overlayId = this.type + ORYX.Editor.provideId();
        this.overlayIds.push(overlayId);
        
        this.facade.raiseEvent({
            type        : ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id          : overlayId,
            shapes      : shapes,
            attributes  : attributes,
            node        : svgNode,
            nodePosition: svgNodePosition || "NW"
        });
        
    },

    // Offers the plugin functionality
    construct: function(facade){
        // Call super class constructor
        arguments.callee.$.construct.apply(this, arguments);
                
        this.facade.offer({
            'name': "Check soundness",// ORYX.I18N.BPMN2PNConverter.name,
            'functionality': this.showCheckerWindow.bind(this),
            'group': "Verification",
            'icon': ORYX.PATH + "images/soundness_checker/accept.png",
            'description': "Checks current Petri net for different soundness criteria with LoLA.",
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    showCheckerWindow: function(){
        var plugin = this;
        
        var CheckNode = Ext.extend(Ext.tree.TreeNode, {
            constructor: function(config) {
                if(!config.icon && !this.icon)
                    config.icon = CheckNode.UNKNOWN_STATUS;

                CheckNode.superclass.constructor.apply(this, arguments);
                
                Ext.apply(this, config);
                
                if(this.clickHandler){
                    this.on('click', this.clickHandler.bind(this));
                }
            },

            setIcon: function(status) {
                this.ui.getIconEl().src = status;
            },
            getIcon: function(status) {
                return this.ui.getIconEl().src;
            },
            reset: function(){
                plugin.hideOverlays();
                this.hideMarking();
                // Reset syntax errors
                plugin.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
            },
            hideMarking: function(){
                if(!plugin.marking)
                    return;
            
                for(place in plugin.marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    if(placeShape)// place can be null if removed
                        placeShape.setProperty("oryx-numberoftokens", 0);
                }
                // Show changes
                plugin.facade.getCanvas().update();
                
                plugin.marking = undefined;
            },
            showMarking: function(marking){
                plugin.marking = marking;
            
                for(place in marking){
                    var placeShape = plugin.facade.getCanvas().getChildShapeByResourceId(place);
                    placeShape.setProperty("oryx-numberoftokens", marking[place]);
                }
                // Show changes
                plugin.facade.getCanvas().update();
            },
            showErrors: function(errors){
                // Remove all old error nodes
                Ext.each(this.childNodes, function(child){
                    if(child && child.itemCls === 'error')
                        child.remove();
                });
                
                // Show Unknown status on child nodes
                Ext.each(this.childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise
					// structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
                
                // Show errors
                Ext.each(errors, function(error){
                    this.insertBefore(new CheckNode({
                        icon: CheckNode.ERROR_STATUS,
                        text: error,
                        itemCls: 'error'
                    }), this.childNodes[0]);
                }.bind(this));
            },
            showOverlayWithStep: function(shapeIds){
                Ext.each(shapeIds, function(shapeId, index){
                    plugin.showOverlay(
                        plugin.facade.getCanvas().getChildShapeByResourceId(shapeId), 
                        {
                            fill: "#FB7E02"// orange
                        },
                        ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                            "style": "font-size: 16px; font-weight: bold;"
                        }, (index + 1)+"."]),
                        "SE" // position in south east
                    );
                });
            },
            /*
             * incoming list of marking resourceId:#tokens
             */
            showOverlayMarking: function(shapeIdsToMark){
                Ext.each(shapeIdsToMark, function(shapeIdToMark, index){
                	var split = shapeIdToMark.split(":");
                    plugin.showOverlay(
                        plugin.facade.getCanvas().getChildShapeByResourceId(split[0].trim()), 
                        {
                            fill: "#FB7E02"// orange
                        },
                        ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['text', {
                            "style": "font-size: 16px; font-weight: bold;"
                        }, (split[1])]),
                        "SE" // position in south east
                    );
                });
            },
            showOverlay: function(shapes){
                if(shapes.length === 0)
                    return;

                if(! shapes[0] instanceof ORYX.Core.Node)
                    shapes = plugin.getChildShapesByResourceIds(shapes)
            
                plugin.showOverlay(
                    shapes, 
                    {
                        fill: "#FB7E02"// orange
                    }
                );
            }
        });
        CheckNode.UNKNOWN_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'asterisk_yellow.png';
        CheckNode.ERROR_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'exclamation.png';
        CheckNode.OK_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'accept.png';
        CheckNode.LOADING_STATUS = ORYX.PATH + 'images/soundness_checker/' + 'loading.gif';
        
        var LivenessNode = Ext.extend(CheckNode, {
            constructor: function(config) {
//            config.qtip = '<b>AGEF Criteria</b>: Makes sure that any process instance that starts in the initial state will eventually reach the final state.';
            config.qtip = '<b>Weak Termination</b>: Makes sure that from any state, reachable from the initial state, the final state well eventually be reached.';
                // If any dead locks are detected, click to show one counter example.';            
                LivenessNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                this.showOverlayMarking(this.marking);
            },
            update: function(res){
            	this.marking = res.counter?res.counter.split(","):[];
                this.setIcon(res.liveness? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
//                this.setText('The net is '+(res.liveness?  'not' : '')+' AGEF final place.');
                this.setText('There is '+(res.liveness?  'no' : 'a')+' marking from which one cannot reach the final state.');
            }
        });
        
        var BoundednessNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Boundedness Criteria</b>: There are not unbounded places in the net. If any unbounded places are detected, click to show one counter example.';
            
                BoundednessNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                this.showOverlay(this.unboundedplaces);
            },
            update: function(res){
            	this.unboundedplaces  = res.unboundedplaces ;
            	if(res.boundedness){
            		this.unboundedplaces=[];
            	}
                
                this.setIcon(res.boundedness? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.unboundedplaces.length +' unbounded places.');
            }
        });
        
        var DeadTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>No Dead Transitions Criteria</b>: Each transition can contribute to at least one process instance. Click to see all dead transitions.';
            
                DeadTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.deadTransitions);
            },
            update: function(res){
                this.deadTransitions = res.deadtransitions ;
              	if(res.quasiliveness ){
            		this.deadTransitions=[];
            	}
                
                this.setIcon(this.deadTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.deadTransitions.length +' dead transitions.');
            }
        });
        
        var NotParticipatingTransitionsNode = Ext.extend(CheckNode, {
            constructor: function(config) {
                config.qtip = '<b>Transition Participation Criteria</b>: Each transition participates in at least one process instance that starts in the initial state and reaches the final state. Click to see all transitions not participating in any process instance.';
            
                NotParticipatingTransitionsNode.superclass.constructor.apply(this, arguments);
            },
            clickHandler: function(node){
                node.reset();
                
                this.showOverlay(this.notParticipatingTransitions);
            },
            update: function(res){
//            	res.transitioncover 
                this.notParticipatingTransitions = res.uncoveredtransitions;
                
                this.setIcon(this.notParticipatingTransitions.length == 0 ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                this.setText('There are ' + this.notParticipatingTransitions.length +' transitions that cannot participate in a properly terminating firing sequence.');
            }
        });
        
        var service_tech_site_banner = new Object;
        service_tech_site_banner.html='<a href="http://www.service-technology.org/">'+
        '<img src="images/service_tech_site_banner.png" width="400" style="position: relative; left: 35px;"/></a>';
        
        this.checkerWindow = new Ext.Window({
            title: 'Soundness Checker powered by service-technology.org',
            autoScroll: true,
            width: '500',
            tbar: [
                {
                    text: 'Check', 
                    handler: function(){
                        this.checkerWindow.check();
                    }.bind(this)
                },
                {
                    text: 'Hide Errors', 
                    handler: function(){
                        this.checkerWindow.getTree().getRootNode().reset();
                    }.bind(this)
                },
                '->',
                {
                    text: 'Close', 
                    handler: function(){
                        this.checkerWindow.close();
                    }.bind(this)
                }
            ],
            getTree: function(){
                return this.items.get(0);
            },
            check: function(renderAll){
                this.prepareCheck(renderAll);
                this.checkSyntax(this.checkSoundness.bind(this), this.reRender.bind(this));
            },
            reRender: function(){
            	window.setTimeout(function(){
            		this.getResizeEl().beforeAction();
            		this.getResizeEl().sync(true);
            	}.bind(this), 70); 

            },
            prepareCheck: function(renderAll){// call with renderAll=true if
												// showing for the first time
                var root = this.getTree().getRootNode();
                
                root.reset();
                
                // Set loading status to all child nodes
                Ext.each(root.childNodes, function(childNode){
                    if(renderAll)// this expands all nodes so they're
									// rendered a first time
                        childNode.expand(true);
                    childNode.collapse(true); // collapse deeply
                    childNode.setIcon(CheckNode.LOADING_STATUS);
                });
            },
            checkSyntax: function(callback, finshedCallback){
                plugin.facade.raiseEvent({
                    type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
                    onErrors: function(){
                        Ext.Msg.alert("Syntax Check", "Some syntax errors have been found, please correct them!")
                        this.turnLoadingIntoUnknownStatus();
                        finshedCallback();

                    }.bind(this),
                    onNoErrors: function(){
                        callback();
                        finshedCallback();
                    }
                });
            },
            // All child nodes with loading status get unknown status
            turnLoadingIntoUnknownStatus: function(){
                Ext.each(this.getTree().getRootNode().childNodes, function(childNode){
                    // Only change icon if it is in loading state (otherwise
					// structural soundness icon would be replaced)
                    if(childNode.getIcon().search(CheckNode.LOADING_STATUS) > -1){
                        childNode.setIcon(CheckNode.UNKNOWN_STATUS);
                    }
                });
            },
            checkSoundness: function(){
                var root = this.getTree().getRootNode();
                
                // Check for structural soundness (no server request needed and
				// return, if any has been found
                if(! root.findChild("id", "structuralSound").check()){
                    this.turnLoadingIntoUnknownStatus();
                    return;
                }
                var serialized_rdf = plugin.getRDFFromDOM();
    			if (!serialized_rdf.startsWith("<?xml")) {
    				serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;
    			}
                // Check other soundness criteria which needs server requests
                Ext.Ajax.request({
                    url: ORYX.CONFIG.ROOT_PATH + 'lola',
                    method: 'POST',
                    success: function(request){
                        var res = Ext.decode(request.responseText);
                        
                        root.showErrors(res.errors);
                        
                        if(res.errors.length === 0){
                            root.findChild("id", "sound").check(res);
                            root.findChild("id", "weakSound").check(res);
                            root.findChild("id", "relaxedSound").check(res);
                        }
                    }.bind(this),
                    failure: function(){

                    }.bind(this),
                    params: {
                        data: serialized_rdf
                    }
                });
                
            },
            items: [new Ext.tree.TreePanel({
                useArrows: true,
                autoScroll: true,
                rootVisible: false,
                animate: true,
                containerScroll: true,
                
                root: new CheckNode({
                    text: 'Checks',
                    id: 'source',
                    expanded: true
                }),
                listeners: {
                    render: function(treePanel){
                        var structuralSoundNode = new CheckNode({
                            text: 'Structural Sound (Workflow Net)',
                            id: 'structuralSound',
                            /* Returns false when any error has been found */
                            check: function(){
                                this.checkInitialNode.update();
                                this.checkFinalNode.update();
                                this.checkConnectedNode.update(this.checkInitialNode.initialNodes, this.checkFinalNode.finalNodes);
                                
                                if(this.checkInitialNode.hasErrors() || this.checkFinalNode.hasErrors() || this.checkConnectedNode.hasErrors()){
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                    return false;
                                } else {
                                    this.setIcon(CheckNode.OK_STATUS);
                                    return true;
                                }
                            },
                            checkInitialNode: new CheckNode({
                                qtip: 'There must be exactly one initial place, which is the only place without any incoming edges.',
                                update: function(){
                                    this.initialNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getIncomingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.initialNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.initialNodes.length + ' initial places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.initialNodes);
                                },
                                hasErrors: function(){
                                    return this.initialNodes.length !== 1;
                                }
                            }),
                            checkFinalNode: new CheckNode({
                                qtip: 'There must be exactly one final place, which is the only place without any outgoing edges.',
                                update: function(){
                                    this.finalNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape.getOutgoingShapes().length == 0 && shape.getStencil().id().search(/Place/) > -1){
                                            this.finalNodes.push(shape);
                                        }
                                    }.bind(this));
                                    
                                    this.setText(this.finalNodes.length + ' final places found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.finalNodes);
                                },
                                hasErrors: function(){
                                    return this.finalNodes.length !== 1;
                                }
                            }),
                            checkConnectedNode: new CheckNode({
                                qtip: 'Each node in the process model is on the path from the initial node to the final node.',
                                update: function(initialNodes, finalNodes){
                                    // Step through without semantic knowledge
                                    if(initialNodes.length !== 1 || finalNodes.length !== 1){
                                        this.setText("There must be exactly one initial and final place to perform further checks!");
                                        this.setIcon(CheckNode.UNKNOWN_STATUS);
                                        return;
                                    }
                                    
                                    this.notParticipatingNodes = [];
                                    Ext.each(plugin.facade.getCanvas().getChildShapes(), function(shape){
                                        if(shape instanceof ORYX.Core.Node)
                                            this.notParticipatingNodes.push(shape);
                                    }.bind(this));
                                    
                                    this.passedNodes = [];
                                    
                                    this.findNotParticipatingNodes(initialNodes[0]);
                                    
                                    this.setText(this.notParticipatingNodes.length + ' nodes that aren\'t on any path from beginning to end found.');
                                    
                                    this.setIcon(!this.hasErrors() ? CheckNode.OK_STATUS : CheckNode.ERROR_STATUS);
                                },
                                clickHandler: function(node){
                                    node.reset();
                                
                                    this.showOverlay(this.notParticipatingNodes);
                                },
                                findNotParticipatingNodes: function(currentNode){
                                    this.passedNodes.push(currentNode);
                                    this.notParticipatingNodes.remove(currentNode);
                                    
                                    Ext.each(currentNode.getOutgoingShapes(), function(nextNode){
                                        if(!this.passedNodes.include(nextNode)){
                                            this.findNotParticipatingNodes(nextNode);
                                        };
                                    }.bind(this));
                                },
                                hasErrors: function(){
                                    return this.notParticipatingNodes.length !== 0;
                                }
                            })
                        });
                        structuralSoundNode.appendChild([
                            structuralSoundNode.checkInitialNode,
                            structuralSoundNode.checkFinalNode,
                            structuralSoundNode.checkConnectedNode
                        ]);
                    
                        var soundNode = new CheckNode({
                            text: 'Sound',
                            id: 'sound',
                            check: function(res){
                                if (res.soundness) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                
                                this.deadTransitionsNode.update(res);
                                this.boundednessNode.update(res);
                                this.livenessNode.update(res);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),
                            boundednessNode: new BoundednessNode({}),
                            livenessNode: new LivenessNode({}),

                        });
                        soundNode.appendChild([
                            soundNode.deadTransitionsNode,
                            soundNode.boundednessNode,
                            soundNode.livenessNode
                        ]);
                        
                        var weakSoundNode = new CheckNode({
                            text: 'Weak Sound',
                            id: 'weakSound',
                            check: function(res){
                                if (res.weaksoundness) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }

                                this.boundednessNode.update(res);
                                this.livenessNode.update(res);
                            },
                            boundednessNode: new BoundednessNode({}),
                            livenessNode: new LivenessNode({}),
                        });
                        weakSoundNode.appendChild([
                            weakSoundNode.boundednessNode,
                            weakSoundNode.livenessNode
                        ]);
                        
                        var relaxedSoundNode = new CheckNode({
                            text: 'Relaxed Sound',
                            id: 'relaxedSound',
                            check: function(res){
                                if (res.relaxedsoundness) {
                                    this.setIcon(CheckNode.OK_STATUS);
                                }
                                else {
                                    this.setIcon(CheckNode.ERROR_STATUS);
                                    this.expand();
                                }
                                this.deadTransitionsNode.update(res);
                                this.notParticipatingTransitionsNode.update(res);
                            },
                            deadTransitionsNode: new DeadTransitionsNode({}),

                            notParticipatingTransitionsNode: new NotParticipatingTransitionsNode({})
                        });
                        relaxedSoundNode.appendChild([
                            relaxedSoundNode.notParticipatingTransitionsNode,
							relaxedSoundNode.deadTransitionsNode

                        ]);
                        
                        treePanel.getRootNode().appendChild([structuralSoundNode, soundNode, weakSoundNode, relaxedSoundNode]);
                        
                    }
                }
            }),service_tech_site_banner],
            listeners: {
                close: function(window){
                    this.checkerWindow.getTree().getRootNode().reset();
                }.bind(this)
            }
        });


        this.checkerWindow.show();
        this.checkerWindow.check(true);
    }
});/**
 * Copyright (c) 2010
 * Sven Wagner-Boysen
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.PetriNet = {

	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade){
		this.facade = facade;
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
	},
	
	/**
	 * Checks if the number of tokens on a place has changed. Up to four the 
	 * tokens are visualized as drawings, otherwise a number gets displayed.
	 */
	handlePropertyChanged: function(option) {
		var shapes = option.elements;
		var propertyKey = option.key;
		var propertyValue = option.value;
		
		var changed = false;
		shapes.each(function(shape){
			if((shape.getStencil().id() === "http://b3mn.org/stencilset/petrinet#Place") &&
				(propertyKey === "oryx-numberoftokens")) {
				
				/* Visualize number of Tokens */
				if(propertyValue == 0) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "0");
				} else if(propertyValue == 1) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "1");
				} else if(propertyValue == 2) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "2");
				} else if(propertyValue == 3) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "3");
				} else if(propertyValue == 4) {
					shape.setProperty("oryx-numberoftokens_text", "");
					shape.setProperty("oryx-numberoftokens_drawing", "4");
				} else {
					var tokens = parseInt(propertyValue, 10);
					if(tokens && tokens > 0) {
						shape.setProperty("oryx-numberoftokens_text", "" + tokens);
						shape.setProperty("oryx-numberoftokens_drawing", "0");
					} else {
						shape.setProperty("oryx-numberoftokens_text", "");
						shape.setProperty("oryx-numberoftokens_drawing", "0");
					}
				}
				changed = true;
			}
		});
		
		if(changed) {this.facade.getCanvas().update();}
	}
};
	
ORYX.Plugins.PetriNet = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.PetriNet);
	
/**
 * Copyright (c) 2008
 * Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
Ext.ns("Oryx.Plugins");

ORYX.Plugins.BPMNImport = Clazz.extend({
    converterUrl: ORYX.CONFIG.ROOT_PATH + "bpmn2pn",
    
    // Offers the plugin functionality
    construct: function(facade){
    
        this.facade = facade;
       
        this.importBpmn();
    },
    
    /**
     * General helper method for parsing a param out of current location url
     * E.g. "http://oryx.org?param=value", getParamFromUrl("param") => "value"
     * @param {Object} name
     */
    getParamFromUrl: function(name){
        name = name.replace(/[\[]/, "\\\[").replace(/[\]]/, "\\\]");
        var regexS = "[\\?&]" + name + "=([^&#]*)";
        var regex = new RegExp(regexS);
        var results = regex.exec(window.location.href);
        if (results == null) {
            return null;
        }
        else {
            return results[1];
        }
    },
    
    /**
     * Posts rdf (BPNM) to server and loads erdf (Petri net) into canvas
     * @param {Object} bpmnRdf
     */
    bpmnToPn: function(bpmnRdf){
        Ext.Msg.updateProgress(0.66, ORYX.I18N.BPMN2PNConverter.progress.convertingModel);
        
       Ext.Ajax.request({
            url: this.converterUrl,
            method: 'POST',
            success: function(request){
    	   		try{
	                var parser = new DOMParser();
	                Ext.Msg.updateProgress(1.0, ORYX.I18N.BPMN2PNConverter.progress.renderingModel);
	                var doc = parser.parseFromString(request.responseText, "text/xml");
	                this.facade.importERDF(doc);
    	   		}catch(e){
    	   			Ext.Msg.alert("Rendering Failed :\n"+e);
    	   		}
                Ext.Msg.hide();
            }.createDelegate(this),
            failure: function(){
                Ext.Msg.alert(ORYX.I18N.BPMN2PNConverter.error, ORYX.I18N.BPMN2PNConverter.errors.server);
            },
            params: {
                rdf: bpmnRdf
            }
        });
        
    },
    
    /**
     * Loads rdf of given bpmn url
     */
    importBpmn: function(){
        var importBPMNUrl = this.getParamFromUrl("importBPMN");
        
        if(!importBPMNUrl) return; //return if no model to import is given
        
        Ext.Msg.progress(ORYX.I18N.BPMN2PNConverter.progress.status, 
                         ORYX.I18N.BPMN2PNConverter.progress.importingModel
        );
        Ext.Msg.updateProgress(0.33, ORYX.I18N.BPMN2PNConverter.progress.fetchingModel);
        
        Ext.Ajax.request({
            url: this.getRdfUrl(importBPMNUrl),
            success: function(request){
                var bpmnRdf = request.responseText;
                this.bpmnToPn(bpmnRdf);
            }.createDelegate(this),
            failure: function(request){
                Ext.Msg.alert(ORYX.I18N.BPMN2PNConverter.error, ORYX.I18N.BPMN2PNConverter.errors.noRights)
            },
            method: "GET"
        })
    },
    
    /**
     * getRdfUrl("http://localhost:8080/backend/poem/model/7/self") 
     * => "http://localhost:8080/backend/poem/model/7/rdf"
     * getRdfUrl("http://localhost:8080/backend/poem/model/7/rdf" => "http://localhost:8080/backend/poem/model/7/rdf")
     * @param {String} url
     */
    getRdfUrl: function(url){
        return url.replace(/\/self(\/)?$/, "/rdf")
    }
});

ORYX.Plugins.PNExport = Clazz.extend({
    // Offers the plugin functionality
    construct: function(facade){
    
        this.facade = facade;
       
        this.facade.offer({
            'name': ORYX.I18N.BPMN2PNConverter.name,
            'functionality': this.exportIt.bind(this),
            'group': ORYX.I18N.BPMN2PNConverter.group,
            dropDownGroupIcon: ORYX.PATH + "images/export2.png",
			'icon': ORYX.PATH + "images/page_white_convert.png",
            'description': ORYX.I18N.BPMN2PNConverter.desc,
            'index': 3,
            'minShape': 0,
            'maxShape': 0
        });
    },
    
    exportIt: function(){
        //Throw error if model hasn't been saved before
    	var reqURI='';
		if(!location.hash.slice(1)){
            Ext.Msg.alert(ORYX.I18N.BPMN2PNConverter.error, ORYX.I18N.BPMN2PNConverter.errors.notSaved);
            return;
		}
		else{
			reqURI = '/backend/poem/'+(location.hash.slice(1).replace(/^\/?/,"").replace(/\/?$/,""))+"/rdf";
		}
        
        this.facade.raiseEvent({type: ORYX.Plugins.SyntaxChecker.RESET_ERRORS_EVENT});
        this.facade.raiseEvent({
            type: ORYX.Plugins.SyntaxChecker.CHECK_FOR_ERRORS_EVENT,
            context: "bpmn2pn",
            onNoErrors: function(){
                this.openPetriNetEditor(reqURI);
            }.bind(this)
        });
    },
    
    /**
     * Opens petri net editor with bpmn model import
     * @methodOf: ORYX.Plugins.BPMNImport.prototype
     */
    openPetriNetEditor: function(importUrl){
        window.open("/backend/poem/new?stencilset=/stencilsets/petrinets/petrinet.json&importBPMN=" + importUrl);
    }
});/**
 * Copyright (c) 2008 - 2009
 * Matthias Weidlich
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * Transforms a BPEL process into its BPMN representation.
 * 
 */
ORYX.Plugins.BPEL2BPMN = Clazz.extend({

	facade: undefined,

	/**
	 * Offers the plugin functionality:
	 * 
	 */
	construct: function(facade) {
		this.facade = facade;
		
		this.facade.offer({
			'name':"Transform BPEL into BPMN",
			'functionality': this.transform.bind(this),
			'group': 			'Export',
            dropDownGroupIcon: ORYX.PATH + "images/import.png",
			'description': "Transform a BPEL process into its BPMN representation",
			'index': 1,
			'minShape': 0,
			'maxShape': 0});
			
	},

	
	/**
	 * Trigger the actual BPEL 2 BPMN transformation.
	 */
	transform: function(){
		this.openUploadDialog();
	},
	
	/**
	 * Opens a upload dialog.
	 * (adapted from the epcSupport plugin)
	 * 
	 */
	openUploadDialog: function(){
		
		var form = new Ext.form.FormPanel({
			frame : false,
			defaultType : 'textfield',
		 	waitMsgTarget : true,
		  	labelAlign : 'left',
		  	buttonAlign: 'right',
		  	fileUpload : true,
		  	enctype : 'multipart/form-data',
		  	style: 'font-size:12px;',
		  	items : [
		  	{
		    	fieldLabel : 'File',
		    	inputType : 'file',
			  	style: 'font-size:12px;',
				allowBlank: false
		  	}]
		});
		
		var errorMsg = new Ext.Panel({style: 'font-size:12px;', autoScroll: true});
		
		var dialog;

		dialog = new Ext.Window({ 
			autoCreate: true, 
			title: 'Upload BPEL File', 
			height: 240, 
			width: 400, 
			modal:true,
			collapsible:false,
			fixedcenter: true, 
			shadow:true, 
		  	style: 'font-size:12px;',
			proxyDrag: true,
			resizable:true,
			items: [new Ext.form.Label({text: "Select a BPEL (.bpel) file and transform it to BPMN.", style: 'font-size:12px;'}),form, errorMsg],
			buttons:[{
				text:"Submit",
				handler: function()
				{
					form.form.submit({
			      		clientValidation: false,
						url: ORYX.PATH + '/bpel2bpmn',
			      		waitMsg: "Transforming...",
			      		success: function(f,a){
							/*
							 * The XML that comes from the server is escaped. Therefore we need to replace the escape symbols once again.
							 */
							var myString = a.response.responseText.replace(/&lt;/g,'<').replace(/&gt;/g,'>');
							
							if (myString) {
							
								var resultObject = myString.evalJSON();
								
								var eRDF = resultObject.content;
								var successfulValidation = resultObject.successValidation;
								var validationError = resultObject.validationError;
								
								/*
								 * In case the BPEL file complied to the schema the dialog is hidden.
								 */
								if (successfulValidation) {
									dialog.hide();
								}
								else {
									/*
									 * In case the BPEL file did not comply to the schema the dialog remains open.
									 */
									errorMsg.body.dom.innerHTML = '<p style="background-color: transparent;">Your BPEL file does not comply with the XML schema definition. <br /> <br />Error message: ' + validationError + '</p>';
								}
								
								/*
								 * In all cases we try to import the resulting eRDF.
								 */
								eRDF = '<?xml version="1.0" encoding="utf-8"?><html xmlns="http://www.w3.org/1999/xhtml" xmlns:b3mn="http://b3mn.org/2007/b3mn" xmlns:ext="http://b3mn.org/2007/ext" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:atom="http://b3mn.org/2007/atom+xhtml"><head profile="http://purl.org/NET/erdf/profile"><link rel="schema.dc" href="http://purl.org/dc/elements/1.1/" /><link rel="schema.dcTerms" href="http://purl.org/dc/terms/ " /><link rel="schema.b3mn" href="http://b3mn.org" /><link rel="schema.oryx" href="http://oryx-editor.org/" /><link rel="schema.raziel" href="http://raziel.org/" /><base href="http://localhost:8080/backend/poem/new" /></head><body>'
									+eRDF+'</body></html>';
								var parser	= new DOMParser();			
								this.facade.importERDF(parser.parseFromString(eRDF ,"text/xml"));
							}
							else {
								/*
								 * Something went totally wrong. No chance to recover.
								 */
								Ext.MessageBox.show({
		           					title: 'Error',
		          	 				msg: 'The BPEL file could not be imported.',
		           					buttons: Ext.MessageBox.OK,
		           					icon: Ext.MessageBox.ERROR
		       					});
							}							
			      		}.bind(this),
						failure: function(f,a){
							dialog.hide();
							Ext.MessageBox.show({
	           					title: 'Error',
	          	 				msg: a.response.responseText.substring(a.response.responseText.indexOf("content:'")+9, a.response.responseText.indexOf("'}")),
	           					buttons: Ext.MessageBox.OK,
	           					icon: Ext.MessageBox.ERROR
	       					});
			      		}.bind(this)
			  		});
			  	}.bind(this)
			}]
		});
		dialog.on('hide', function(){
			dialog.destroy(true);
			delete dialog;
		});
		dialog.show();
	},
});/** * Copyright (c) 2009 * Falko Menge * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Transforms a BPMNplus diagram to its XPDL4Chor representation and * calls a transformation web service to generate BPEL4Chor from the XPDL4Chor * representation. */ORYX.Plugins.BPMN2XHTML = ORYX.Plugins.AbstractPlugin.extend({		construct: function() {		arguments.callee.$.construct.apply(this, arguments);			this.facade.offer({			'name'				: ORYX.I18N.BPMN2XHTML.XHTMLExport,			'functionality'		: this.transform.bind(this),			'group'				: ORYX.I18N.BPMN2XHTML.group,            dropDownGroupIcon   : ORYX.PATH + "images/export2.png",			'icon'				: ORYX.PATH + "images/page_white_world.png",			'description'		: ORYX.I18N.BPMN2XHTML.XHTMLExport,			'index'				: 99998,			'minShape'			: 0,			'maxShape'			: 0		});				this.facade.offer({			'name'				: ORYX.I18N.BPMN2XHTML.XHTMLExport,			'functionality'		: this.showXHTML.bind(this),			'group'				: ORYX.I18N.BPMN2XHTML.group,            dropDownGroupIcon   : ORYX.PATH + "images/export2.png",			'icon'				: ORYX.PATH + "images/report.png",						'description'		: ORYX.I18N.BPMN2XHTML.XHTMLExport,			'index'				: 99999,			'minShape'			: 0,			'maxShape'			: 0		});				},	showXHTML: function() {//		var xslt		= ORYX.PATH + "xslt/BPMN2XHTML-extended.xslt"; //		var transformed = this.doTransform( this.getRDFFromDOM(), xslt );//		var win = window.open("data:application/xhtml+xml," +//				transformed, //				"_blank", //				"resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");				//this.generateXHTML(this.openXMLWindow.bind(this));				window.open(ORYX.PATH + "/testcase-BPMN2XHTML-extended.xhtml", "_blank", "resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");	},	generateXHTML: function( xhtmlHandleFunction ) {				var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:"Transforming BPMN to XHTML"});		loadMask.show();				var rdfString = this.getRDFFromDOM();		this._sendRequest(				ORYX.PATH + '/bpmn2xhtml',				'POST',				{ 'data' : rdfString },				function( arg ) { 					xhtmlHandleFunction( arg );  					loadMask.hide();				}.bind(this),				function() { 					loadMask.hide(); 					this._showErrorMessageBox("Oryx", ORYX.I18N.Bpmn2Bpel.transfFailed);					ORYX.log.warn("Transformation to XHTML failed: " + transport.responseText);				}.bind(this)			);	},	_sendRequest: function( url, method, params, successcallback, failedcallback ){		var suc = false;		new Ajax.Request(url, {           method			: method,           asynchronous	: false,           parameters		: params,		   onSuccess		: function(transport) {								suc = true;								if(successcallback){					successcallback( transport.responseText );				}							}.bind(this),						onFailure : function(transport) {				if(failedcallback){					failedcallback();									} else {					Ext.Msg.alert("Oryx", ORYX.I18N.Bpmn2Bpel.transfFailed);					ORYX.log.warn("Transformation to XHTML failed: " + transport.responseText);					}							}.bind(this)				});				return suc;			},		_showErrorMessageBox: function(title, msg){        Ext.MessageBox.show({           title: title,           msg: msg,           buttons: Ext.MessageBox.OK,           icon: Ext.MessageBox.ERROR       });	},	// unused: only XHTML without interaction diagram	transform: function() {				var xslt		= ORYX.PATH + "xslt/BPMN2XHTML.xslt"; 		var transformed = this.doTransform( this.getRDFFromDOM(), xslt );		//var transformed = this.getRDFFromDOM();				//this.openDownloadWindow( window.document.title + ".xml", transformed );				//var win = window.open("data:text/xml," +		var win = window.open("data:application/xhtml+xml," +				transformed, 				"_blank", 				"resizable=yes,width=640,height=480,toolbar=0,scrollbars=yes");			}	});/** * Copyright (c) 2009 * Falko Menge * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();/** * Transforms a BPMNplus diagram to its XPDL4Chor representation and * calls a transformation web service to generate BPEL4Chor from the XPDL4Chor * representation. */ORYX.Plugins.BPMN2DTRPXMI = ORYX.Plugins.AbstractPlugin.extend({		stencilSetExtensionSuffix: '/bpmn-design-thinking-subset#',	construct: function() {		arguments.callee.$.construct.apply(this, arguments);			this.facade.offer({			'name'				: ORYX.I18N.BPMN2DTRPXMI.DTRPXMIExport,			'functionality'		: this.transform.bind(this),			'group'				: ORYX.I18N.BPMN2DTRPXMI.group,            dropDownGroupIcon   : ORYX.PATH + "images/export2.png",			'icon'				: ORYX.PATH + "images/page_white_code_red.png",			'description'		: ORYX.I18N.BPMN2DTRPXMI.DTRPXMIExportDescription,			'index'				: 1,			'minShape'			: 0,			'maxShape'			: 0,			'isEnabled': 		this.isStencilSetExtensionLoaded.bind(this)		});	},	isStencilSetExtensionLoaded: function() {		return this.facade.getStencilSets().values().any(			function(ss){ 				return ss.extensions().keys().any(					function(extensionKey) {						return extensionKey.endsWith(this.stencilSetExtensionSuffix);					}.bind(this)				);			}.bind(this)		);	},	transform: function() {				var xslt		= ORYX.PATH + "xslt/BPMN2DTRP-XMI.xslt"; 		var transformed = this.doTransform( this.getRDFFromDOM(), xslt );		//var transformed = this.getRDFFromDOM();				this.openDownloadWindow( window.document.title + ".xmi", transformed );			}	});/**
 * Copyright (c) 2008-2009, Steffen Ryll
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.QueryEvaluator = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.QueryEvaluator.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.QueryEvaluator.group,
            'icon': ORYX.PATH + "images/xforms_export.png",
            'description': ORYX.I18N.QueryEvaluator.desc,
            'index': 0,
			'toggle': true,
            'minShape': 0,
            'maxShape': 0
        });
		
    },
    
	showOverlay: function(button, pressed){

		if (!pressed) {
			
/*			this.raisedEventIds.each(function(id){
				this.facade.raiseEvent({
						type: 	ORYX.CONFIG.EVENT_OVERLAY_HIDE,
						id: 	id
					});
			}.bind(this))
*/
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
		
		var optionsPopup = new Ext.Window({
			layout      : 'fit',
            width       : 500,
            height      : 350,
            closable	: true,
            plain       : true,
			modal		: true,
			id			: 'optionsPopup',
			
			buttons: [{
				text	: 'Submit',
				handler	: function(){
					// set options
					options = formPanel.getForm().getValues(false);
					
					optionsPopup.close();
					this.issueQuery(options);
				}.bind(this)
			}, {
                text     : 'Abort',
                handler  : function(){
                    optionsPopup.close();
                }.bind(this)
            }]

		})
		
		var modelIdField = new Ext.form.TextField({
			fieldLabel	: 'Model ID',
			name		: 'modelID',
			grow		: true,
//			hideLabel	: true
		});
		modelIdField.hide();
		
		var checkListener = function(field, checked){
			// keep checked states of all relevant fields in this array 
			if (!this.fieldStates) {
				this.fieldStates = [];
			}
			var found = false;
			var mustShowField = false;
			var i, f;
			for (i = 0; i < this.fieldStates.length; i++){
				f =  this.fieldStates[i];
				// update field entry
				if (f.field === field) {
					found = true;
					f.checked = checked;
				}
				// and at the same time check whether at least one field is checked
				mustShowField = mustShowField || f.checked;
			}
			if (!found) {
				// was not used before, so add to array
				this.fieldStates.push({
					field	: field,
					checked	: checked
				});
				mustShowField = true;
			}
			// change field visibility, if necessary
			if (mustShowField){
				modelIdField.show();
			} else {
				modelIdField.hide();
			}
		}
		
		var formPanel = new Ext.form.FormPanel({
			frame		: true,
			title		: 'Query options',
			bodyStyle	: 'padding:0 10px 0;',
			items		: [{
				// create a radio button group
				xtype		: 'fieldset',
            	autoHeight	: true,
				columns		: 1,
				allowBlank	: false,
				defaultType	: 'radio',
				items		: [
                    {
						boxLabel	: 'Process query', 
						fieldLabel	: 'Query Type', 
						name		: 'command', 
						inputValue	: 'processQuery', 
						checked: true},
					{
					// this is edited by Ahmed Awad on 28.07.09 to reflect compliance checking in the Oryx editor
						boxLabel	: 'Process Compliance Query', 
						labelSeparator: '', 
						name		: 'command', 
						inputValue	: 'processComplianceQuery', 
						//listeners	: {
						//	'check': checkListener.bind(this)
						//} 
					},
                    {
						boxLabel	: 'Run query against specific model', 
						labelSeparator: '',
						name		: 'command',
						inputValue	: 'runQueryAgainstModel',
						listeners	: {
							'check': checkListener.bind(this)
						}
					},
					{
						boxLabel	: 'Run compliance query against specific model', 
						labelSeparator: '',
						name		: 'command',
						inputValue	: 'runComplianceQueryAgainstModel',
						listeners	: {
							'check': checkListener.bind(this)
						}
					},
 //                   {
//						boxLabel	: 'Process MultiQuery', 
//						labelSeparator: '', 
//						name		: 'command', 
//						inputValue	: 'processMultiQuery'},
					{
						xtype		: 'checkbox',
						fieldLabel	: 'Stop after first match in a model was found',
						name		: 'stopAtFirstMatch',
						checked		: true,
					}
                ]
			}]
		});
		formPanel.add(modelIdField);
		
		optionsPopup.add(formPanel);
		optionsPopup.show();
		
		button.toggle();
	},
	
	issueQuery : function(options){

		try {
			var serialized_rdf = this.getRDFFromDOM();
//			serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;

			this.facade.raiseEvent({
	            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
				text: "Processing query"  //ORYX.I18N.Save.saving
	        });
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.QUERYEVAL_URL, {
				method: 'POST',
				asynchronous: true,
				parameters: {
					resource	: location.href,
					command		: options.command,
					modelID		: options.modelID,
					stopAtFirstMatch: options.stopAtFirstMatch,
					data		: serialized_rdf
				},
                onSuccess: function(response){
                    this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_LOADING_DISABLE
					});
					
					var respXML = response.responseXML;
                    var root = respXML.firstChild;
                    var processList = new Array();
                    var nodecnt, graph;
                    var pchildren = root.getElementsByTagName("ProcessGraph");
                    
                    // puts all matching process models into array processList with model ID 
                    // and model elements
					for (nodecnt = 0; nodecnt < pchildren.length; nodecnt++) {
                        graph = pchildren.item(nodecnt);
                        var graphID = graph.getAttributeNode("modelID").nodeValue;
                        
                        processList.push({
							id 			: graphID,
							elements 	: this.processResultGraph(graph),
							metadata    : '',
							description	: this.processMatchDescription(graph) //Ahmed Awad on 28.07.09
						});
                        
                    }
					try {
						this.processProcessList(processList);
					} catch (error) {
						Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
					}
                }.bind(this),
				
				onFailure: function(response){
					this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_LOADING_DISABLE
					});
					Ext.Msg.alert(ORYX.I18N.Oryx.title, "Server encountered an error (" + response.statusText + ").\n"
						+ response.responseText);
				}.bind(this)
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}

	},
	
    processResultGraph: function(xmlNode){
        var graphElements = new Array();
		
		for (var k = 0; k < xmlNode.childNodes.length; k++) {
            var node = xmlNode.childNodes.item(k);
            if (!(node instanceof Text)) {
                if (node.hasAttribute("id")) { // it is a node
					graphElements.push({
						nodeType : node.nodeName,
						nodeId : node.getAttributeNode("id").nodeValue
					});
					
				} else if ((node.hasAttribute("from"))
						&& node.hasAttribute("to")) { // it is an edge
					graphElements.push({
						edgeType : node.nodeName,
						from : node.getAttributeNode("from").nodeValue,
						to : node.getAttributeNode("to").nodeValue
					});
				}
            }
        }
		return graphElements;
    },
	// Added by Ahmed Awad on 28.07.09 to extract the diagnosis and the match meta data
	processMatchDescription: function(xmlNode){
        var metadata = new Array();
		
		for (var k = 0; k < xmlNode.childNodes.length; k++) {
            var node = xmlNode.childNodes.item(k);
            if ((node.nodeName === "diagnosis")) {
                
					metadata.push({
						diagnosis : node.textContent
					});
					
				} else if ((node.nodeName === "match")) { // it is an edge
					metadata.push({
						match : node.textContent
					});
				}
            
        }
		return metadata;
    },
	/**
	 * 
	 * @param {Array} processList; 
	 * 		elements' fields: id location identifier for process
	 * 						  elements array of graph nodes/edges
	 */
	processProcessList: function(processList){
		if(processList.length == 0) {
			Ext.Msg.alert(ORYX.I18N.Oryx.title, "Found no matching processes!");
			return;
		}
		
		this.isRendering = true;
		
		// load process model meta data
		processList.each(this.getModelMetaData.bind(this));
		
		// transform array of objects into array of arrays
		var data = [];
		processList.each(function( pair ){
/*			var stencilset = pair.value.type;
			// Try to display stencilset title instead of uri
			this.facade.modelCache.getModelTypes().each(function(type){
				if (stencilset == type.namespace) {
					stencilset = type.title;
					return;
				}
			}.bind(this));
*/			
			data.push( [ pair.id, pair.metadata.thumbnailUri + "?" + Math.random(), unescape(pair.metadata.title), pair.metadata.type, pair.metadata.author, pair.elements, pair.description ] )  // Modified by Ahmed
		}.bind(this));

		
		// following is mostly UI logic
		var myProcsPopup = new Ext.Window({
			layout      : 'fit',
            width       : 500,
            height      : 300,
            closable	: true,
            plain       : true,
			modal		: true,
			autoScroll  : true, // Added by Ahmed Awad on 30.07.2009
			title       : 'Query Result',
			id			: 'procResPopup',
			
			buttons: [{
                text     : 'Close',
                handler  : function(){
                    myProcsPopup.close();
                }.bind(this)
            }]

		});
		
		var tableModel = new Ext.data.SimpleStore({
			fields: [
				{name: 'id'}, //, type: 'string', mapping: 'metadata.id'},
				{name: 'icon'}, //, mapping: 'metadata.icon'},
				{name: 'title'}, //, mapping: 'metadata.title'},
				{name: 'type'}, //, mapping: 'metadata.type'},
				{name: 'author'}, //, mapping: 'metadata.author'},
				{name: 'elements'}, //, type: 'array', mapping: 'elements'},
				{name: 'description'}, // Added by Ahmed Awad
			],
			data : data
		});
		
		var iconPanel = new Ext.Panel({
			border	: false,
			autoScroll : true, // Added by Ahmed Awad
	        items	: new this.dataGridPanel({
				store       : tableModel, 
				listeners   :{
					dblclick:this._onDblClick.bind(this)
				}
			})
	    });
		this.setPanelStyle();
		
		myProcsPopup.add(iconPanel);
		
		this.isRendering = false;
		
		myProcsPopup.show();
	},
	
	getModelMetaData : function(processEntry) {
		var metaUri = processEntry.id.replace(/\/rdf$/, '/meta');
		new Ajax.Request(metaUri, 
			 {
				method			: "get",
				asynchronous 	: false,
				onSuccess		: function(transport) {
					processEntry.metadata = transport.responseText.evalJSON();
				}.bind(this),
				onFailure		: function() {
					Ext.MessageBox.alert(ORYX.I18N.Oryx.title, "Error loading model meta data.");
				}.bind(this)
			});
		
	},
	
	_onDblClick: function(dataGrid, index, node, e){
		
		// Select the new range
		dataGrid.selectRange(index, index);

		// Get uri and matched element data from the clicked model
		var modelId 	= dataGrid.getRecord( node ).data.id;
		var matchedElements = dataGrid.getRecord( node ).data.elements;
		var description = dataGrid.getRecord( node ).data.description; // Added by Ahmed Awad on 30.07.09
		// convert object to JSOn representation
		var elementsAsJson = Ext.encode(matchedElements);
		var descriptionAsJson = Ext.encode(description); // Added by Ahmed Awad on 30.07.09
		// escape JSON string to become URI-compliant
		var encodedJson = encodeURIComponent(elementsAsJson);
		var encodedDescription = encodeURIComponent(descriptionAsJson);
		
		// remove the last URI segment, append editor's 'self' and json of model elements
		var slashPos = modelId.lastIndexOf("/");
		//var uri	= modelId.substr(0, slashPos) + "/self" + "?matches=" + encodedJson;
 	    var uri	= modelId.substr(0, slashPos) + "/self" + "?matches=" + encodedJson+"&description="+encodedDescription;
		// Open the model in Editor
		var editor = window.open( uri );
		window.setTimeout(
	        function() {
                if(!editor || !editor.opener || editor.closed) {
                        Ext.MessageBox.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Oryx.editorOpenTimeout).setIcon(Ext.MessageBox.QUESTION);
                }
	        }, 5000);			
		
	},
	
	dataGridPanel : Ext.extend(Ext.DataView, {
		multiSelect		: true,
		//simpleSelect	: true, 
	    cls				: 'iconview',
	    itemSelector	: 'dd',
	    overClass		: 'over',
		selectedClass	: 'selected',
	    tpl : new Ext.XTemplate(
        '<div>',
			'<dl class="repository_iconview">',
	            '<tpl for=".">',
					'<dd >',
					'<div class="image">',
					 '<img src="{icon}" title="{title}" /></div>',
		            '<div><span class="title" title="{[ values.title.length + (values.type.length*0.8) > 30 ? values.title : "" ]}" >{[ values.title.truncate(30 - (values.type.length*0.8)) ]}</span><span class="author" unselectable="on">({type})</span></div>',
		            '<div><span class="type">{author}</span></div>',
					'</dd>',
	            '</tpl>',
			'</dl>',
        '</div>'
	    )
	}), 
	
	setPanelStyle : function() {
		var styleRules = '\
.repository_iconview dd{\
	width		: 200px;\
	height		: 105px;\
	padding		: 10px;\
	border		: 1px solid #EEEEEE;\
	font-family	: tahoma,arial,sans-serif;\
	font-size	: 9px;\
	display		: block;\
	margin		: 5px;\
	text-align	: left;\
	float		: left;\
}\
.repository_iconview dl {\
	width		: 100%;\
	max-width	: 1000px;\
}\
.repository_iconview dd.over{\
	background-color	: #fff5e1;\
}\
.repository_iconview dd.selected{\
	border-color: #FC8B03;\
}\
.repository_iconview dd img{\
	max-width	: 190px;\
	max-height	: 70px;\
}\
.repository_iconview dd .image{\
	width	: 200px;\
	height	: 80px;\
	padding-bottom	: 10px;\
	text-align		: center;\
	vertical-align	: middle;\
	display	:table-cell;\
}\
.repository_iconview dd .title{\
	font-weight	: bold;\
	font-size	: 11px;\
	color		: #555555;\
}\
.repository_iconview dd .author{\
	margin-left	: 5px;\
}';
		Ext.util.CSS.createStyleSheet(styleRules, 'queryResultStyle');
	},
    
});
/**
 * Copyright (c) 2010 Ahmed Awad and Emilian Pascalau
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.QueryVariant = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.QueryVariant.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.QueryVariant.group,
            'icon': ORYX.PATH + "stencilsets/bpmnqvar/bpmnqvar.png",
            'description': ORYX.I18N.QueryVariant.tooltip,
            'index': 0,
			'toggle': false,
            'minShape': 0,
            'maxShape': 0
        });
		
    },
    
	showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.issueQuery(options);
	},
	
	issueQuery : function(options){
		
		try {
			var serialized_rdf = this.getRDFFromDOM();
//			serialized_rdf = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>" + serialized_rdf;

			this.facade.raiseEvent({
	            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
				text: "Processing partial process model"  //ORYX.I18N.Save.saving
	        });
			// Send the request to the server.
			new Ajax.Request(ORYX.CONFIG.QUERYVARIANTEVAL_URL, {
				method: 'POST',
				asynchronous: true,
				parameters: {
					resource	: location.href,
					command		: options.command,
					modelID		: options.modelID,
					stopAtFirstMatch: options.stopAtFirstMatch,
				//data		: serialized_rdf
				data : location.href
				},
                onSuccess: function(response){
                    this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_LOADING_DISABLE
					});
					
					var respXML = response.responseXML;

                    var root=respXML.firstChild;
                    var pg=root.getElementsByTagName("ProcessGraph");
					var source = location.href.substring(0,location.href.substring(8).indexOf("/")+8);
					//alert(source);
					var uri = source+"/backend/poem/new?stencilset=/stencilsets/bpmn1.1/bpmn1.1.json";
					editor = window.open( uri );
					editor.oryxCreator1283772618640 = self;
					editor.oryxCreator1283772618640.variant=respXML;
					
					
                }.bind(this),
				
				onFailure: function(response){
					this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_LOADING_DISABLE
					});
					Ext.Msg.alert(ORYX.I18N.Oryx.title, "Server encountered an error (" + response.statusText + ").\n"
						+ response.responseText);
				}.bind(this)
			});
			
		} catch (error){
			this.facade.raiseEvent({type:ORYX.CONFIG.EVENT_LOADING_DISABLE});
			Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
	 	}

	},
	
    processResultGraph: function(xmlNode){
        var graphElements = new Array();
		
		for (var k = 0; k < xmlNode.childNodes.length; k++) {
            var node = xmlNode.childNodes.item(k);
            if (!(node instanceof Text)) {
                if (node.hasAttribute("id")) { // it is a node
                	Ext.Msg.alert(node.getAttributeNode("id").nodeValue);
					graphElements.push({
						nodeType : node.getAttributeNode("type").nodeValue,
						nodeId : node.getAttributeNode("id").nodeValue,
						nodeLabel : node.getAttributeNode("label").nodeValue,
						nodeType2 : node.getAttributeNode("type2").nodeValue
					});
					
				} else if ((node.hasAttribute("from"))
						&& node.hasAttribute("to")) { // it is an edge
					graphElements.push({
						edgeType : node.getAttributeNode("type").nodeValue,
						from : node.getAttributeNode("from").nodeValue.substring(3),
						to : node.getAttributeNode("to").nodeValue.substring(3)
					});
				}
            }
        }
		return graphElements;
    },
	// Added by Ahmed Awad on 28.07.09 to extract the diagnosis and the match meta data
	processMatchDescription: function(xmlNode){
        var metadata = new Array();
		
		for (var k = 0; k < xmlNode.childNodes.length; k++) {
            var node = xmlNode.childNodes.item(k);
            if ((node.nodeName === "diagnosis")) {
                
					metadata.push({
						diagnosis : node.textContent
					});
					
				} else if ((node.nodeName === "match")) { // it is an edge
					metadata.push({
						match : node.textContent
					});
				}
            
        }
		return metadata;
    },
	/**
	 * 
	 * @param {Array} processList; 
	 * 		elements' fields: id location identifier for process
	 * 						  elements array of graph nodes/edges
	 */
	processProcessList: function(processList){
		if(processList.length == 0) {
			Ext.Msg.alert(ORYX.I18N.Oryx.title, "Found no matching processes!");
			return;
		}
		
		this.isRendering = true;
		
		// load process model meta data
		processList.each(this.getModelMetaData.bind(this));
		
		// transform array of objects into array of arrays
		var data = [];
		processList.each(function( pair ){
/*			var stencilset = pair.value.type;
			// Try to display stencilset title instead of uri
			this.facade.modelCache.getModelTypes().each(function(type){
				if (stencilset == type.namespace) {
					stencilset = type.title;
					return;
				}
			}.bind(this));
*/			
			data.push( [ pair.id, pair.metadata.thumbnailUri + "?" + Math.random(), unescape(pair.metadata.title), pair.metadata.type, pair.metadata.author, pair.elements, pair.description ] )  // Modified by Ahmed
		}.bind(this));

		
		// following is mostly UI logic
		var myProcsPopup = new Ext.Window({
			layout      : 'fit',
            width       : 500,
            height      : 300,
            closable	: true,
            plain       : true,
			modal		: true,
			autoScroll  : true, // Added by Ahmed Awad on 30.07.2009
			title       : 'Query Result',
			id			: 'procResPopup',
			
			buttons: [{
                text     : 'Close',
                handler  : function(){
                    myProcsPopup.close();
                }.bind(this)
            }]

		});
		
		var tableModel = new Ext.data.SimpleStore({
			fields: [
				{name: 'id'}, //, type: 'string', mapping: 'metadata.id'},
				{name: 'icon'}, //, mapping: 'metadata.icon'},
				{name: 'title'}, //, mapping: 'metadata.title'},
				{name: 'type'}, //, mapping: 'metadata.type'},
				{name: 'author'}, //, mapping: 'metadata.author'},
				{name: 'elements'}, //, type: 'array', mapping: 'elements'},
				{name: 'description'}, // Added by Ahmed Awad
			],
			data : data
		});
		
		var iconPanel = new Ext.Panel({
			border	: false,
			autoScroll : true, // Added by Ahmed Awad
	        items	: new this.dataGridPanel({
				store       : tableModel, 
				listeners   :{
					dblclick:this._onDblClick.bind(this)
				}
			})
	    });
		this.setPanelStyle();
		
		myProcsPopup.add(iconPanel);
		
		this.isRendering = false;
		
		myProcsPopup.show();
	},
	
	getModelMetaData : function(processEntry) {
		var metaUri = processEntry.id.replace(/\/rdf$/, '/meta');
		new Ajax.Request(metaUri, 
			 {
				method			: "get",
				asynchronous 	: false,
				onSuccess		: function(transport) {
					processEntry.metadata = transport.responseText.evalJSON();
				}.bind(this),
				onFailure		: function() {
					Ext.MessageBox.alert(ORYX.I18N.Oryx.title, "Error loading model meta data.");
				}.bind(this)
			});
		
	},
	
	_onDblClick: function(dataGrid, index, node, e){
		
		// Select the new range
		dataGrid.selectRange(index, index);

		// Get uri and matched element data from the clicked model
		var modelId 	= dataGrid.getRecord( node ).data.id;
		var matchedElements = dataGrid.getRecord( node ).data.elements;
		var description = dataGrid.getRecord( node ).data.description; // Added by Ahmed Awad on 30.07.09
		// convert object to JSOn representation
		var elementsAsJson = Ext.encode(matchedElements);
		var descriptionAsJson = Ext.encode(description); // Added by Ahmed Awad on 30.07.09
		// escape JSON string to become URI-compliant
		var encodedJson = encodeURIComponent(elementsAsJson);
		var encodedDescription = encodeURIComponent(descriptionAsJson);
		
		// remove the last URI segment, append editor's 'self' and json of model elements
		var slashPos = modelId.lastIndexOf("/");
		//var uri	= modelId.substr(0, slashPos) + "/self" + "?matches=" + encodedJson;
 	    var uri	= modelId.substr(0, slashPos) + "/self" + "?matches=" + encodedJson+"&description="+encodedDescription;
		// Open the model in Editor
		var editor = window.open( uri );
		window.setTimeout(
	        function() {
                if(!editor || !editor.opener || editor.closed) {
                        Ext.MessageBox.alert(ORYX.I18N.Oryx.title, ORYX.I18N.Oryx.editorOpenTimeout).setIcon(Ext.MessageBox.QUESTION);
                }
	        }, 5000);			
		
	},
	
	dataGridPanel : Ext.extend(Ext.DataView, {
		multiSelect		: true,
		//simpleSelect	: true, 
	    cls				: 'iconview',
	    itemSelector	: 'dd',
	    overClass		: 'over',
		selectedClass	: 'selected',
	    tpl : new Ext.XTemplate(
        '<div>',
			'<dl class="repository_iconview">',
	            '<tpl for=".">',
					'<dd >',
					'<div class="image">',
					 '<img src="{icon}" title="{title}" /></div>',
		            '<div><span class="title" title="{[ values.title.length + (values.type.length*0.8) > 30 ? values.title : "" ]}" >{[ values.title.truncate(30 - (values.type.length*0.8)) ]}</span><span class="author" unselectable="on">({type})</span></div>',
		            '<div><span class="type">{author}</span></div>',
					'</dd>',
	            '</tpl>',
			'</dl>',
        '</div>'
	    )
	}), 
	
	setPanelStyle : function() {
		var styleRules = '\
.repository_iconview dd{\
	width		: 200px;\
	height		: 105px;\
	padding		: 10px;\
	border		: 1px solid #EEEEEE;\
	font-family	: tahoma,arial,sans-serif;\
	font-size	: 9px;\
	display		: block;\
	margin		: 5px;\
	text-align	: left;\
	float		: left;\
}\
.repository_iconview dl {\
	width		: 100%;\
	max-width	: 1000px;\
}\
.repository_iconview dd.over{\
	background-color	: #fff5e1;\
}\
.repository_iconview dd.selected{\
	border-color: #FC8B03;\
}\
.repository_iconview dd img{\
	max-width	: 190px;\
	max-height	: 70px;\
}\
.repository_iconview dd .image{\
	width	: 200px;\
	height	: 80px;\
	padding-bottom	: 10px;\
	text-align		: center;\
	vertical-align	: middle;\
	display	:table-cell;\
}\
.repository_iconview dd .title{\
	font-weight	: bold;\
	font-size	: 11px;\
	color		: #555555;\
}\
.repository_iconview dd .author{\
	margin-left	: 5px;\
}';
		Ext.util.CSS.createStyleSheet(styleRules, 'queryResultStyle');
	},
    
});
/**
 * Copyright (c) 2010 Emilian Pascalau and Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.CreateProcessVariant = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    // processGraph:undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
				
        this.createModel();
		
    },
    
    createModel:function(){
    	
    	   	
        if(oryxCreator1283772618640){
    			
            var respXML=oryxCreator1283772618640.variant;
    				
            var root=respXML.firstChild;
            var pg=root.getElementsByTagName("ProcessGraph");
            var processGraphElements=pg.item(0).childNodes;
                
            var posx=-30;
            var processGraphXML=new Array();
            var processGraphShape=new Array();
                
            for(var i=0;i<processGraphElements.length;i++){
                
                var ce=processGraphElements[i];
                if(ce.nodeName=="Activity" || ce.nodeName=="Gateway" || ce.nodeName=="Event" ){
                    posx=posx+150;
                	
                    var shape=this.drawNode(ce,posx);
                    processGraphXML.push(ce);
                    processGraphShape.push(shape);
                }
                	
                //it is assumed that all sequenceFlows are at the end
                if(ce.nodeName=="SequenceFlow"){
                    var fId=this.getSequenceFlowFrom(ce);
                		
                    var from=this.getShapeById(fId,processGraphXML,processGraphShape);
                    //                		alert(from);
                    //
                		
                    var tId=this.getSequenceFlowTo(ce);
                		
                    var to=this.getShapeById(tId,processGraphXML,processGraphShape);
                    //                		alert(to);
                		
                    shape=this.drawSequenceFlow(from,to);
                		
                    processGraphXML.push(ce);
                    processGraphShape.push(shape);
                		
                }
                	
            }
                
        // alert(processGraphXML.length);
        // alert(processGraphShape.length);
                
    

        // this.drawShape();
                
        }
    	
    },
    
    drawNode:function(element, posX){

        var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        if(element.nodeName=="Activity"){
    	
    							
            stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
    		
            //    	var option = {
            //				type:"http://b3mn.org/stencilset/bpmn1.1#Task",
            //				position:pos,
            //				namespace:parentShape.getStencil().namespace(),
            //				parent:parentShape
            //		};
            //newShape=this.facade.createShape(option);
    	
            newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
    	
            //    	newShape.resourceId=element.getAttributeNode("id").nodeValue;
            var label=element.getAttributeNode("label").nodeValue;
            // alert(label);
    
            newShape.setProperty("oryx-name",label);
            this.facade.getCanvas().add(newShape);
        //this.facade.getCanvas().update();
        }
    	
        // deal with Events
        if(element.nodeName=="Event"){
        	
            var type2=element.getAttributeNode("type2").nodeValue;
            var type2LastChar=type2[type2.length-1];
            var eventType=type2.substring(0,type2.length-1);
            
//            alert("eventType "+eventType);

            
    		
            if(type2LastChar==1){
    		
                if(eventType=="MessageEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "StartMessageEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }
                else
                if(eventType=="TimerEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "StartTimerEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="ConditionalEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "StartConditionalEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="SignalEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "StartSignalEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="MultipleEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "StartMultipleEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                {
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "StartEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }
            }
    		
            if(type2LastChar==2){

               
                if(eventType=="MessageEventCatching"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateMessageEventCatching");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="MessageEventThrowing"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateMessageEventThrowing");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="TimerEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateTimerEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="ErrorEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateErrorEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="CancelEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateCancelEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="CompensationEventCatching"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateCompensationEventCatching");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="CompensationEventThrowing"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateCompensationEventThrowing");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="ConditionalEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateConditionalEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="SignalEventCatching"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateSignalEventCatching");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="SignalEventThrowing"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateSignalEventThrowing");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="MultipleEventCatching"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateMultipleEventCatching");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="MultipleEventThrowing"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateMultipleEventThrowing");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="LinkEventCatching"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateLinkEventCatching");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="LinkEventThrowing"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateLinkEventThrowing");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                {
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "IntermediateEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }

                
            }
    		
            if(type2LastChar==3){

              
                if(eventType=="MessageEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndMessageEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="ErrorEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndErrorEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="CancelEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndCancelEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="CompensationEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndCompensationEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="SignalEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndSignalEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="MultipleEvent"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndMultipleEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                if(eventType=="Terminate"){
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndTerminateEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);
                }else
                {
                    stencil = ORYX.Core.StencilSet.stencil(ssn + "EndEvent");
                    newShape=new ORYX.Core.Node({
                        'eventHandlerCallback':this.facade.raiseEvent
                    },stencil);                    
                }              
            	
            }  		
    		
            // var label=element.getAttributeNode("label").nodeValue;
            // newShape.setProperty("oryx-name",label);
            this.facade.getCanvas().add(newShape);
    		
        }
    	
        // deal with gateways
        if(element.nodeName=="Gateway"){
            var type2=element.getAttributeNode("type2").nodeValue;
    		
    		
    		
            if(type2.indexOf("XOR")>=0){
   		
                stencil = ORYX.Core.StencilSet.stencil(ssn + "Exclusive_Databased_Gateway");
                newShape=new ORYX.Core.Node({
                    'eventHandlerCallback':this.facade.raiseEvent
                },stencil);
            	
            }
    	

            if(type2.indexOf("OR")>=0 && type2.indexOf("XOR")==-1){
        		
            	
                stencil = ORYX.Core.StencilSet.stencil(ssn + "OR_Gateway");
                newShape=new ORYX.Core.Node({
                    'eventHandlerCallback':this.facade.raiseEvent
                },stencil);
            	
            }
    		
            if(type2.indexOf("AND")>=0 ){
        		          	
                stencil = ORYX.Core.StencilSet.stencil(ssn + "AND_Gateway");
                newShape=new ORYX.Core.Node({
                    'eventHandlerCallback':this.facade.raiseEvent
                },stencil);
            	
            }
    		
            // var label=element.getAttributeNode("label").nodeValue;
            // newShape.setProperty("oryx-name",label);
            this.facade.getCanvas().add(newShape);
    		
        }
    	
   	
        return newShape;
    	
    },
    
    getSequenceFlowFrom:function(sequenceFlow){
        var efrom=sequenceFlow.getAttributeNode("from").nodeValue;
    	
        var pos=efrom.indexOf("#");
        var type=efrom.substring(0,pos);
        var shapeId=efrom.substring(pos,efrom.length);
    	
        var from={};
        from['type']=type;
        from['shapeId']=shapeId;
    	
        //    	return from;
        return shapeId;
    },
    
    getSequenceFlowTo:function(sequenceFlow){
        var eto=sequenceFlow.getAttributeNode("to").nodeValue;
        ;
    	
        var pos=eto.indexOf("#");
        var type=eto.substring(0,pos);
        var shapeId=eto.substring(pos,eto.length);
    	
        var to={};
        to['type']=type;
        to['shapeId']=shapeId;
    	
        //    	return to;
        return shapeId;
    	
    },
    
    getShapeById:function(id,processGraphXML,processGraphShape){
        var pos=-1;
    	
        for(var k=0;k<processGraphXML.length;k++){
            var ce=processGraphXML[k];
            var ok=false;
            var ceId=ce.getAttributeNode("id").nodeValue;
            if (ceId==id){
                pos=k;
                ok=true;
            }
            if(ok) break;
    		
        }
        return processGraphShape[pos];
    },
    
    //from and to are shapes
    drawSequenceFlow:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "SequenceFlow");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        ;
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2008-2009, Steffen Ryll
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.QueryResultHighlighter = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	isHighlighted: false,
	
	construct: function(facade){
	
		this.facade = facade;
		
		this.raisedEventIds = [];
		this.raisedHighlightEventIds = [];
		
		this.facade.offer({
			'name': "Query result highlighter",
			'functionality': this.buttonClick.bind(this),
			'group': ORYX.I18N.QueryEvaluator.group,
			'icon': ORYX.PATH + "images/xforms_export.png",
			'description': "This plugin highlights model parts which were matched by a query.",
			'index': 1,
			'toggle': true,
			'minShape': 0,
			'maxShape': 0,
			'isEnabled': 	 this._isQueryResultThere.bind(this)
		});
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.highlightMatches.bind(this));
		
	},
	_isQueryResultThere: function(){
		var parameters = window.location.search;
		var PARAMKEY = "matches=";
		
		var paramStart = parameters.indexOf(PARAMKEY) + PARAMKEY.length;
		return (paramStart > PARAMKEY.length);

	},

	highlightMatches : function() {
		var elements = this.deserializeMatches();
		
		if (!elements) {
			return;
		}
		var maaatch=null;
		var diagnosis=null;
		var description = this.deserializeDescription();
		
		
		if (description)
		{
			description.each(function (item) {
				if (item.match)
				{
					maaatch = item.match;
				}
				if (item.diagnosis)
				{
					diagnosis = item.diagnosis;
				}
			})
			
			
		}
		else
		{
			maaatch = "pattern";
			diagnosis = "";
		}
		var color = "orange";
		var colorHex = "#FFFF00";
        if (diagnosis === "complies"){
        	color = "green";
        	colorHex = "#00FF00";
        }
        else if (diagnosis === "violation scenario")
        {
        	color = "red";
        	colorHex = "#FF0000";
        }
        else // either this is a does not comply or an ordinary query
        {
        	color = "orange";
        	colorHex = "#FF6600";
        }
		try {
			elements.each(function (item) {
				if (item.nodeType != null && item.nodeId != null) {
					var shape = this.getShapeById(item.nodeId);
				} else if (item.edgeType != null) {
					var shape = this.getEdgeByFromAndTo(item.from, item.to)
				} else return; // unknown element type
				
				if (!shape) return;
				
				//this.highlightSelectedTask(shape);
				// Commented by Ahmed Awad 30.07.09
				//this.raiseOverlay(shape,color,colorHex, "Moeep! Error when raising an overlay.");
				// Added by Ahmed Awad
				if (shape instanceof ORYX.Core.Node)
                {
        	       shape.setProperty("oryx-bgcolor",colorHex);
        	       shape.refresh();
                }
			}.bind(this));
		} catch (e) {
			Ext.MessageBox.alert(ORYX.I18N.Oryx.title, "Something went wrong while applying highlighting to shapes: " + e);
		}
		
		this.isHighlighted = true;
		//Ext.MessageBox.alert(ORYX.I18N.Oryx.title, "Finished highlighting!");
	},

	raiseOverlay: function(shape,color,colorHex, errorMsg){
        var id = "queryhighlighter." + this.raisedEventIds.length;
        // Added by Ahmed Awad to change the color of the matched node
        if (shape instanceof ORYX.Core.Node)
        {
        	shape.setProperty("oryx-bgcolor",colorHex);
        	shape.refresh();
        }
        
//     
        var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, ['path', {
            	"title": errorMsg,
            	"stroke-width": 5.0,
            	"stroke": color,
            	"d": "M20,-5 L5,-20 M5,-5 L20,-20",
            	"line-captions": "round"
        	}]);
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_OVERLAY_SHOW,
            id: id,
            shapes: [shape],
            node: cross,
            nodePosition: shape instanceof ORYX.Core.Edge ? "START" : "NW"
        });
        
        this.raisedEventIds.push(id);
        
        return cross;
    },
	
	removeHighlighting: function(shape, errorMsg){
        this.raisedEventIds.each(function(id) {
	        this.facade.raiseEvent({
	            type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
	            id: id
	        });
		}.bind(this));
        
		this.raisedEventIds = [];
		
		this.raisedHighlightEventIds.each(function(id) {
	        this.facade.raiseEvent({
	            type: ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
	            id: id
	        });
		}.bind(this));
        
		this.raisedHighlightEventIds = [];
    },
	
	highlightSelectedTask: function(shape){ //edge marking of selected/ given task
		if(!(shape instanceof ORYX.Core.Shape)) return;
		this.facade.raiseEvent({
			type:			ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
			highlightId:	shape.id,
			elements:		[shape],
			color:			'#FF0000'
		});
		this.raisedHighlightEventIds.push(task.id);
	},

	buttonClick: function(button, pressed) {
		if (this.isHighlighted) {
			this.removeHighlighting();
			this.isHighlighted = false;
		} else {
			this.highlightMatches();
			this.isHighlighted = true;
		}

		// skip buttons toggle if both aren't in sync. This is because we can't set the buttons to pressed initially 
		if (this.isHighlighted && !pressed) {		
			button.toggle();
		}
/*		if ((this.isHighlighted && !pressed)|| (!this.isHighlighted && pressed)) {		
			button.toggle();
		}
*/
	},
	
	/**
	 * returns an object (or array), which was passed in the URL query part 
	 * in JSON+URL-encoded form
	 */
	deserializeMatches : function() {
		var parameters = window.location.search;
		var PARAMKEY = "matches=";
		
		var paramStart = parameters.indexOf(PARAMKEY) + PARAMKEY.length;
		if (paramStart < PARAMKEY.length) {
			return null; // no highlighting info found
		}
		var paramEnd = parameters.indexOf("&", paramStart); // delimiter from potential other parameters
		
		var paramComponents = parameters.substring(paramStart, 
			(paramEnd > paramStart ? paramEnd : parameters.length ));
		
		try {
			var matchedElementsJson = decodeURIComponent(paramComponents);
			var matchedElements = Ext.decode(matchedElementsJson);
		} catch (e) {
			Ext.MessageBox.alert(ORYX.I18N.Oryx.title, "I found highlighting information from BPMN-Q, but they could not be understood: " + e);
			return null;
		}
		
		return matchedElements;
	},
	// Added by Ahmed Awad
	deserializeDescription : function() {
		var parameters = window.location.search;
		var PARAMKEY = "description=";
		
		var paramStart = parameters.indexOf(PARAMKEY) + PARAMKEY.length;
		if (paramStart < PARAMKEY.length) {
			return null; // no highlighting info found
		}
		var paramEnd = parameters.indexOf("&", paramStart); // delimiter from potential other parameters
		
		var paramComponents = parameters.substring(paramStart, 
			(paramEnd > paramStart ? paramEnd : parameters.length ));
		
		try {
			var descriptionJson = decodeURIComponent(paramComponents);
			var description = Ext.decode(descriptionJson);
		} catch (e) {
			Ext.MessageBox.alert(ORYX.I18N.Oryx.title, "I found description information from BPMN-Q, but they could not be understood: " + e);
			return null;
		}
		
		return description;
	},
	getShapeById: function(resourceId) {
		var shapes = this.facade.getCanvas().getChildShapeByResourceId(resourceId);
/*		var task;
		for (var index = 0; index < shapes.length; index++) {
    		if (shapes[index].properties["oryx-activitytype"] == "Task") {
				if (shapes[index].properties["oryx-id"] == taskId) {
					task = shapes[index];
					break;
				}
			}
    	} */
		return shapes;
	},
	
	getEdgeByFromAndTo: function(fromId, toId) {
		fromId = fromId.replace(/^.*#/, '');
		toId = toId.replace(/^.*#/, '');
		
		var edges = this.facade.getCanvas().getChildEdges(true);
		
		var suspectEdge = edges.find(function(edge) {
			return edge.incoming != null
			  && edge.incoming[0] != null
			  && edge.incoming[0].resourceId == fromId
			  && edge.outgoing != null
			  && edge.outgoing[0] != null
			  && edge.outgoing[0].resourceId == toId;
		}.bind(this));
		
		return suspectEdge;
	}

});
/**
 * Copyright (c) 2009, Andreas Meyer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.ResourcesSoDAdd = Clazz.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.ResourcesSoDAdd.name,
            'functionality': this.defineSoD.bind(this),
            'group': ORYX.I18N.ResourcesSoDAdd.group,
            'dropDownGroupIcon': ORYX.PATH + "images/sod.png",
            'icon': ORYX.PATH + "images/sod+.png",
            'description': ORYX.I18N.ResourcesSoDAdd.desc,
            'index': 1,
            'toggle': false,
            'minShape': 2,
            'maxShape': 0
        });
		
    },
    
    defineSoD: function(){
    	//variable declaration
    	var selectedElements = this.facade.getSelection(); //all selected elements
    	var taskElements = []; //all selected tasks
    	var selectedTasks; //new tasks to be separated
    	var i = 0; //counter
    	var len = selectedElements.length; //number of selected elements
    	
    	//get only selected tasks
    	for (var index = 0; index < len; index++) {
    		var item = selectedElements[index];
    		if(item.properties["oryx-activitytype"] == "Task") {
    			taskElements[i] = item;
				if(taskElements[i].properties["oryx-id"] == "") {
					taskElements[i].setProperty("oryx-id", taskElements[i].id);
				}
    			if(i == 0) { //get ids of tasks to be separated
					selectedTasks = taskElements[i].properties["oryx-id"];
    			} else {
    				selectedTasks = selectedTasks + "; " + taskElements[i].properties["oryx-id"];
    			}
    			i++;
    		}
    	}
		
    	if(taskElements.length > 1) {
			for (var taskCounter = 0; taskCounter < taskElements.length; taskCounter++) {
    		//variable declaration
        	var savedSeparationsData = []; //already saved separations
        	var savedBindingsData = false; //already saved bindings
        	
        	//check whether other separations are defined for current task
        	if(taskElements[taskCounter].properties["oryx-separationofduties"] != "") {
        		savedSeparationsData = this.separationsCheck(taskElements[taskCounter], selectedTasks);
        		if (savedSeparationsData[3] == true) {
	        		break;
	        	}
        	} else {
				savedSeparationsData[1] = 0; //total number of separation entries is 0 as field is empty
				savedSeparationsData[2] = 0; //highest id used is 0 as no id is used
			}
        	
        	//check whether a contradicting binding is defined for current task
        	if(taskElements[taskCounter].properties["oryx-bindingsofduties"] != ("")) {
        		savedBindingsData = this.bindingsCheck(taskElements[taskCounter], selectedTasks);
	        	if (savedBindingsData == true) {
	        		break;
	        	}
        	}
        	
        	//write entry
	    	this.writeEntry(savedSeparationsData, selectedTasks, taskElements[taskCounter]);
    		}
		} else {
			alert("Please select at least two tasks to define constraints for.");
		}
    },
    
    separationsCheck: function(taskElement, selectedTasks) { //check for existing separations with same tasks
		var returnValue = [];
		//get previous separation of duties assignments
		var elementIds = []; //collection of used ids for saved separations
		var taskIds = []; //collection of saved task ids
		var totalCount = 0; //number of defined separations for a specific task
    	var highestId = 1; //next element id for separations of a specific task
    	var j = 0; //counter
    	var m = 0; //counter
    	var n = 0; //counter
		var separations = taskElement.properties["oryx-separationofduties"]; //get saved separations
    	separations = separations.toString();
    	//store saved separations including task ids
    	var savedSeparations = separations.substring(0,separations.indexOf(']'));
    	//extract number of entries and element ids of these entries
    	while(separations.indexOf(',') > -1) {
    		if(j%2 == 1) { //get element ids as integer
    			elementIds[m] = parseInt(separations.substring((separations.indexOf('"')) + 1));
    			m++;
		    	separations = separations.substring((separations.indexOf(',')) + 1);
    		} else if(j == 0) { //get total count as integer
    			totalCount = parseInt(separations.substring((separations.indexOf(':')) + 1));
    			separations = separations.substring((separations.indexOf(',')) + 1);
    		} else { //get task ids of separations
    			separations = separations.substring((separations.indexOf('"')) + 1);
    			taskIds[n] = separations.substring(0,separations.indexOf('"'));
    			n++;
    			separations = separations.substring((separations.indexOf(',')) + 1);
    		}
	        j++;
    	}
    	if(separations.indexOf('"') > -1) {
    		taskIds[n] = separations.substring((separations.indexOf('"')) + 1);
    	} else {
    		taskIds[n] = separations; //get last task ids entry
    	}
    	taskIds[n]= taskIds[n].substring(0,taskIds[n].indexOf('"'));
    	
        //check whether entry does already exist
        var separatedTasksCopy = selectedTasks; //working copy
        var singleTaskIdsInsertedSeparation = []; //task ids of new separations
        var singleTaskIdsSavedSeparations = []; //task ids of saved separations
		
        var y = 0; //counter
        
		var equal = false; //duplicate existing?
        
        //extract task ids of newly entered separation tasks
    	while(separatedTasksCopy.indexOf(';') > -1) {
    		singleTaskIdsInsertedSeparation[y] = separatedTasksCopy.substring(0, separatedTasksCopy.indexOf(';'));
    		separatedTasksCopy = separatedTasksCopy.substring((separatedTasksCopy.indexOf(';'))+2);
	        y++;
        }
    	singleTaskIdsInsertedSeparation[y] = separatedTasksCopy;
        
        //extract task ids of stored separation tasks
        for(var index = 0; index < taskIds.length; index++) {
        	var z = 0; //counter
			var equalCounter = 0;
			while(taskIds[index].indexOf(';') > -1) {
        		singleTaskIdsSavedSeparations[z] = taskIds[index].substring(0, taskIds[index].indexOf(';'));
        		taskIds[index] = taskIds[index].substring((taskIds[index].indexOf(';'))+2);
		        z++;
	        }
        	singleTaskIdsSavedSeparations[z] = taskIds[index];
        	z++;
        	
			//compare all collected tasks/ task ids
        	if(singleTaskIdsInsertedSeparation.length == singleTaskIdsSavedSeparations.length) {
        		for(var x = 0; x < singleTaskIdsSavedSeparations.length; x++) {
        			for(var w = 0; w < singleTaskIdsInsertedSeparation.length; w++) {
        				if(singleTaskIdsInsertedSeparation[w] == singleTaskIdsSavedSeparations[x]) {
        					equal = true;
        					break;
        				}
        				equal = false;
        			}
        			if(equal == false) { //one item of set 1 not found in set 2
    					break;
    				}
        		}
        	} else if(singleTaskIdsInsertedSeparation.length > singleTaskIdsSavedSeparations.length) {
        		for(var x = 0; x < singleTaskIdsSavedSeparations.length; x++) {
        			for(var w = 0; w < singleTaskIdsInsertedSeparation.length; w++) {
						if (singleTaskIdsInsertedSeparation[w] == singleTaskIdsSavedSeparations[x]) {
							equalCounter++;
							break;
						}
					}
					if(equalCounter == singleTaskIdsSavedSeparations.length) { //all saved tasks are found in new entries
						var result = this.deleteSeparationEntry(taskElement, (index+1)); //delete existing entry to write new entry later and following updating the entry
						savedSeparations = result[0];
						totalCount = result[1];
						equalCounter = 0;
						break;
					}
				}
				equal = false;
        	} else {
        		for(var x = 0; x < singleTaskIdsInsertedSeparation.length; x++) {
        			for(var w = 0; w < singleTaskIdsSavedSeparations.length; w++) {
        				if(singleTaskIdsSavedSeparations[w] == singleTaskIdsInsertedSeparation[x]) {
        					equal = true;
        					break;
        				}
        				equal = false;
        			}
        			if(equal == false) { //one item of smaller set not found in bigger set
    					break;
    				}
        		}
        	}
			singleTaskIdsSavedSeparations.splice(0,singleTaskIdsSavedSeparations.length);
        	//entry does exist, that's why no new one needs to be done
	        if(equal == true) {
	        	break;
	        }
        }
		
    	//get highest element id
    	for(var index = 0; index < elementIds.length; index++) {
    		if(elementIds[index] > highestId) {
    			highestId = elementIds[index];
    		}
    	}
    	returnValue[0] = savedSeparations;
    	returnValue[1] = totalCount;
    	returnValue[2] = highestId;
    	returnValue[3] = equal;
    	return returnValue;
    },
    
    bindingsCheck: function(taskElement, selectedTasks) { //check for existing bindings with same tasks
    	var returnValue;
		//get previous binding of duties assignments
		var boundTaskIds = []; //collection of saved task ids
    	var l = 0; //counter
    	var q = 0; //counter
		var bindings = taskElement.properties["oryx-bindingsofduties"]; //get saved bindings
    	bindings = bindings.toString();
    	//extract number of entries and element ids of these entries
    	while(bindings.indexOf(',') > -1) {
    		if(l%2 == 1) { //ignore element ids
		    	bindings = bindings.substring((bindings.indexOf(',')) + 1);
    		} else if(l == 0) { //ignore totalCount
    			bindings = bindings.substring((bindings.indexOf(',')) + 1);
    		} else {
    			bindings = bindings.substring((bindings.indexOf('"')) + 1);
    			boundTaskIds[q] = bindings.substring(0,bindings.indexOf('"'));
    			q++;
    			bindings = bindings.substring((bindings.indexOf(',')) + 1);
    		}
	        l++;
    	}
    	if(bindings.indexOf('"') > -1) {
    		boundTaskIds[q] = bindings.substring((bindings.indexOf('"')) + 1);
    	} else {
    		boundTaskIds[q] = bindings; //never reached?
    	}
    	boundTaskIds[q]= boundTaskIds[q].substring(0,boundTaskIds[q].indexOf('"'));
    	
        //check whether entry does already exist
        var boundTasksCopy = selectedTasks; //working copy
        var singleTaskIdsInsertedBinding = []; ////task ids of new bindings
        var singleTaskIdsSavedBinding = []; //task ids of saved bindings
        var s = 0; //counter
        var t = 0; //counter
        var duplicate = false; //duplicate existing?
        
        //extract task ids of newly entered separation tasks
    	while(boundTasksCopy.indexOf(';') > -1) {
    		singleTaskIdsInsertedBinding[s] = boundTasksCopy.substring(0, boundTasksCopy.indexOf(';'));
    		boundTasksCopy = boundTasksCopy.substring((boundTasksCopy.indexOf(';'))+2);
	        s++;
        }
    	singleTaskIdsInsertedBinding[s] = boundTasksCopy;
        
        //extract task ids of stored bound tasks
        for(var index = 0; index < boundTaskIds.length; index++) {
        	while(boundTaskIds[index].indexOf(';') > -1) {
        		singleTaskIdsSavedBinding[t] = boundTaskIds[index].substring(0, boundTaskIds[index].indexOf(';'));
        		boundTaskIds[index] = boundTaskIds[index].substring((boundTaskIds[index].indexOf(';'))+2);
		        t++;
	        }
        	singleTaskIdsSavedBinding[t] = boundTaskIds[index];
        	
	        var check = 0;
        	if(singleTaskIdsInsertedBinding.length >= singleTaskIdsSavedBinding.length) {
        		for(var x = 0; x < singleTaskIdsSavedBinding.length; x++) {
        			for(var w = 0; w < singleTaskIdsInsertedBinding.length; w++) {
        				if(singleTaskIdsInsertedBinding[w] == singleTaskIdsSavedBinding[x]) {
        					check++;
        					if(check == 2) {
        						duplicate = true;
        					}
        					break;
        				}
        				duplicate = false;
        			}
        			if(duplicate == true) { //two items of set 1 found in set 2 --> contradicting
    					break;
    				}
        		}
        	} else {
        		for(var x = 0; x < singleTaskIdsInsertedBinding.length; x++) {
        			for(var w = 0; w < singleTaskIdsSavedBinding.length; w++) {
        				if(singleTaskIdsSavedBinding[w] == singleTaskIdsInsertedBinding[x]) {
        					check++;
        					if(check == 2) {
        						duplicate = true;
        					}
        					break;
        				}
        				duplicate = false;
        			}
        			if(duplicate == true) { //two items of set 1 found in set 2 --> contradicting
    					break;
    				}
        		}
        	}

	        if(duplicate == true) { //entry does exist, delete?
				var bodDelete = confirm("Do you want to delete the existing contradicting binding for allowing this separation constraint to be entered? Otherwise, this separation constraint will be discarded.");
				if(bodDelete == true) {
					this.findBindingEntry(selectedTasks);
					duplicate = false;
				}
	        	break;
	        }
        }//end check whether binding entry does already exist
    	
        returnValue = duplicate;
        return returnValue;
    },
    
    writeEntry: function(savedSeparationsData, selectedTasks, taskElement) { //create JSON object and write to task attributes
    	if(savedSeparationsData[1] > 0) { //saved entries do exist
    		savedSeparationsData[1]++; //number of entries
    		savedSeparationsData[2]++; //highestId needs to be higher than all found ids 
    		savedSeparationsData[0] = savedSeparationsData[0].substring((savedSeparationsData[0].indexOf(':'))+2);
    		savedSeparationsData[0] = "{'totalCount':" + savedSeparationsData[1] + savedSeparationsData[0] + ", {sodId:\"" + savedSeparationsData[2] + "\", SeparatedTasks:\"" + selectedTasks + "\"}]}";
    	} else { //first entry to be done
    		savedSeparationsData[1] = 1;
    		savedSeparationsData[2]++; //highestId needs to be higher than all found ids
    		savedSeparationsData[0] = "{'totalCount':" + savedSeparationsData[1] + ", 'items':[{sodId:\"" + savedSeparationsData[2] + "\", SeparatedTasks:\"" + selectedTasks + "\"}]}";
    	}
    	taskElement.setProperty("oryx-separationofduties", savedSeparationsData[0]);
    },
	
	deleteSeparationEntry: function(taskElement, elementId) { //delete given entry from given task from separation contraints
		var returnValue = [];
		var separations = taskElement.properties["oryx-separationofduties"]; //get saved separations
		var keptSeparations;
		var temp;
		var totalCount = parseInt(separations.substring((separations.indexOf(':')) + 1));
		totalCount = totalCount - 1;
		if(totalCount > 0)  {
			separations = separations.substring(separations.indexOf('[')); //{'totalCount':3, 'items':
			keptSeparations = separations.substring(0,separations.indexOf('{')); //[
			separations = separations.substring(separations.indexOf('{')); //[
			temp = separations.substring(0,(separations.indexOf('"')) + 1); //{sodId:"
			separations = separations.substring((separations.indexOf('"')) + 1); //{sodId:"
			while(parseInt(separations) != elementId) {
				keptSeparations = keptSeparations + temp + separations.substring(0,(separations.indexOf('{')) - 2); //'id'", SeparatedTasks:"task_a; task_b"}
				separations = separations.substring((separations.indexOf('{')) - 2); //'id'", SeparatedTasks:"task_a; task_b"}
				temp = separations.substring(0,((separations.indexOf('"')) + 1)); //, {sodId:"
				separations = separations.substring((separations.indexOf('"')) + 1); //, {sodId:"
			}
			separations = separations.substring((separations.indexOf('}'))+3); //'sodId'", SeparatedTasks:"task_c; task_d; task_e"} or //{sodId:"'id'", SeparatedTasks:"task_c; task_d; task_e"},_
			var entry = "{'totalCount':" + totalCount + ", 'items':" + keptSeparations + separations + "]}";
			taskElement.setProperty("oryx-separationofduties", entry);
			
			entry = entry.toString();
			entry = entry.substring(0,entry.indexOf(']'));
		
		} else {
			var entry = "";
			taskElement.setProperty("oryx-separationofduties", entry);
		}
		
		returnValue[0] = entry;
		returnValue[1] = totalCount;
		return returnValue;
	},
	
	findBindingEntry: function(taskIds) { //find binding entry with given task ids to be deleted at all affected tasks
		var taskIdsCopy = taskIds;
		var singleTaskIds = [];
		var s = 0;
		
		//extract task ids of affected tasks
    	while(taskIdsCopy.indexOf(';') > -1) {
    		singleTaskIds[s] = taskIdsCopy.substring(0, taskIdsCopy.indexOf(';'));
    		taskIdsCopy = taskIdsCopy.substring((taskIdsCopy.indexOf(';'))+2);
	        s++;
        }
    	singleTaskIds[s] = taskIdsCopy;
		
		taskIdsCopy = taskIds + ";";
		for (var m = 0; m < singleTaskIds.length; m++) { //go through all affected tasks
			var currentTask = this.getTaskById(singleTaskIds[m]);
			var bindings = currentTask.properties["oryx-bindingsofduties"]; //get saved bindings
			var boundTaskIds = [];
			var totalCount = 0;
			var i = 0; //counter
			var j = 0; //counter
			while(bindings.indexOf(',') > -1) {
	    		if(i%2 == 1) { //get element ids as integer
			    	bindings = bindings.substring((bindings.indexOf(',')) + 1);
	    		} else if(i == 0) { //get totalCount
	    			totalCount = parseInt(bindings.substring((bindings.indexOf(':')) + 1));
					bindings = bindings.substring((bindings.indexOf(',')) + 1);
	    		} else { //get task ids
	    			bindings = bindings.substring((bindings.indexOf('"')) + 1);
	    			boundTaskIds[j] = bindings.substring(0,bindings.indexOf('"'));
	    			j++;
	    			bindings = bindings.substring((bindings.indexOf(',')) + 1);
	    		}
		        i++;
	    	}
			//transform id string into array - one constraint set equals one array entry
	    	if(bindings.indexOf('"') > -1) {
	    		boundTaskIds[j] = bindings.substring((bindings.indexOf('"')) + 1);
	    	} else {
	    		boundTaskIds[j] = bindings; //never reached??
	    	}
	    	boundTaskIds[j]= boundTaskIds[j].substring(0,boundTaskIds[j].indexOf('"'));
						
			var singleTaskIdsStoredBinding = [];
			
			//check each binding entry
			for (var index = 0; index < boundTaskIds.length; index++) {
				var boundTasksCopy = boundTaskIds[index];
				var t = 0; //counter
				//extract task ids of stored elements
				while (boundTasksCopy.indexOf(';') > -1) {
					singleTaskIdsStoredBinding[t] = boundTasksCopy.substring(0, boundTasksCopy.indexOf(';'));
					boundTasksCopy = boundTasksCopy.substring((boundTasksCopy.indexOf(';')) + 2);
					t++;
				}
				singleTaskIdsStoredBinding[t] = boundTasksCopy;
				
				if (singleTaskIds.length >= singleTaskIdsStoredBinding.length) {
					var equalCounter = 0;
					for (var x = 0; x < singleTaskIdsStoredBinding.length; x++) {
						for (var y = 0; y < singleTaskIds.length; y++) {
							if (singleTaskIdsStoredBinding[x] == singleTaskIds[y]) {
								equalCounter++;
								break;
							}
						}
						if (equalCounter == singleTaskIdsStoredBinding.length) { //entry found
							this.deleteBindingEntry(currentTask, (index+1)); //delete entry
							break;
						}
					}
				}
				singleTaskIdsStoredBinding.splice(0,singleTaskIdsStoredBinding.length);
			}
		}
	},
	
	deleteBindingEntry: function(taskElement, elementId) { //delete defined entry in given task
		var bindings = taskElement.properties["oryx-bindingsofduties"]; //get saved bindings
		var keptBindings;
		var temp;
		var totalCount = parseInt(bindings.substring((bindings.indexOf(':')) + 1));
		totalCount = totalCount - 1;
		if(totalCount > 0)  { //remove specified entry
			bindings = bindings.substring(bindings.indexOf('[')); //{'totalCount':3, 'items':
			keptBindings = bindings.substring(0,bindings.indexOf('{')); //[
			bindings = bindings.substring(bindings.indexOf('{')); //[
			temp = bindings.substring(0,(bindings.indexOf('"')) + 1); //{bodId:"
			bindings = bindings.substring((bindings.indexOf('"')) + 1); //{bodId:"
			while(parseInt(bindings) != elementId) {
				keptBindings = keptBindings + temp + bindings.substring(0,(bindings.indexOf('{')) - 2); //'id'", BoundTasks:"task_a; task_b"}
				bindings = bindings.substring((bindings.indexOf('{')) - 2); //'id'", BoundTasks:"task_a; task_b"}
				temp = bindings.substring(0,((bindings.indexOf('"')) + 1)); //, {bodId:"
				bindings = bindings.substring((bindings.indexOf('"')) + 1); //, {bodId:"
			}
			bindings = bindings.substring((bindings.indexOf('}'))+3); //'bodId'", BoundTasks:"task_c; task_d; task_e"} or //{bodId:"'id'", BoundTasks:"task_c; task_d; task_e"},_
			var entry = "{'totalCount':" + totalCount + ", 'items':" + keptBindings + bindings + "]}";
			taskElement.setProperty("oryx-bindingsofduties", entry);
			
			entry = entry.toString();
			entry = entry.substring(0,entry.indexOf(']'));
		
		} else { //remove last entry
			var entry = "";
			taskElement.setProperty("oryx-bindingsofduties", entry);
		}
	},
	
	getTaskById: function(taskId){
		var shapes = this.facade.getCanvas().getChildShapes(true);
		var task;
		for (var index = 0; index < shapes.length; index++) {
    		if (shapes[index].properties["oryx-activitytype"] == "Task") {
				if (shapes[index].properties["oryx-id"] == taskId) {
					task = shapes[index];
					break;
				}
			}
    	}
		return task;
	}
});/**
 * Copyright (c) 2009, Andreas Meyer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.ResourcesSoDShow = Clazz.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedOverlayEventIds = [];
		this.raisedHighlightEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.ResourcesSoDShow.name,
            'functionality': this.showSoD.bind(this),
            'group': ORYX.I18N.ResourcesSoDShow.group,
			'dropDownGroupIcon': ORYX.PATH + "images/sod.png",
            'icon': ORYX.PATH + "images/sod_view.png",
            'description': ORYX.I18N.ResourcesSoDShow.desc,
            'index': 2,
            'toggle': true,
            'minShape': 1,
            'maxShape': 1
        });
		
    },
    
	showSoD: function(){
		this.removeHighlightsAndOverlays();
		var selectedElements = this.facade.getSelection();
 		if(selectedElements[0].properties["oryx-activitytype"] == "Task") {
			this.highlightSelectedTask(selectedElements[0]);
			this.prepareOverlays(selectedElements[0]);
		} else {
			alert("Please select a task to show the related Separation of Duties constraints.");
		}
	},
	
	highlightSelectedTask: function(task){ //edge marking of selected/ given task
		if(!(task instanceof ORYX.Core.Shape)) return;
		this.facade.raiseEvent({
			type:			ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
			highlightId:	task.properties["oryx-id"],
			elements:		[task],
			color:			'#FF0000'
		});
		this.raisedHighlightEventIds.push(task.properties["oryx-id"]);
	},
	
	showOverlaysForSeparations: function(task, elementId) { //colour given task red
		if(!(task instanceof ORYX.Core.Shape)) return;
		//colour element
		var attr = {fill: "#FF0000", stroke:"white", "stroke-width": 1};
		this.facade.raiseEvent({
			type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
			id: 			task.properties["oryx-id"],
			shapes: 		[task],
			attributes: 	attr
		});
		//calculate node position
		var appearanceCounter = 0;
		var nodePosition;
		var x; //x coordinate for text
		var y; //y coordinate for text
		var cx; //x coordinate for circle center
		var cy; //y coordinate for circle center
		for(index = 0; index < this.raisedOverlayEventIds.length; index++) {
			if (task.properties["oryx-id"] == this.raisedOverlayEventIds[index]) {
				appearanceCounter++;
			} 
		}
		switch(appearanceCounter) { //avoid overlappings of dependency markers as long as not more than 8 exist
			case 0:		nodePosition = 'NW';
						x = 9;
						y = 17;
						cx = 13;
						cy = 13;
						break;
			case 1:		nodePosition = 'NE';
						x = -17;
						y = 17;
						cx = -13;
						cy = 13;
						break;
			case 2:		nodePosition = 'SW';
						x = 9;
						y = -9;
						cx = 13;
						cy = -13;
						break;
			case 3:		nodePosition = 'SE';
						x = -17;
						y = -9;
						cx = -13;
						cy = -13;
						break;
			case 4:		nodePosition = 'N';
						x = -4;
						y = 17;
						cx = 0;
						cy = 13;
						break;
			case 5:		nodePosition = 'S';
						x = -4;
						y = -9;
						cx = 0;
						cy = -13;
						break;
			case 6:		nodePosition = 'W';
						x = 9;
						y = 4;
						cx = 13;
						cy = 0;
						break;
			case 7:		nodePosition = 'E';
						x = -17;
						y = 4;
						cx = -13;
						cy = 0;
						break;
			case 8: 	alert("There exist more Separation of Duties constraints for task " + task.properties["oryx-id"] + ", but they will not be illustrated by a number in that task's rectangle.");
						break;
			default:	break;
		}
		if(elementId >= 10) { //keep marker centered based on single-digit or double-digit entry
			x = x - 4;
		}
		if(appearanceCounter < 8) { //skip number representation, if task occurs too often
			//create circle of marker
			var circle = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, 
				['circle', {"cx":cx, "cy":cy, "r":"10", "stroke":"white", "fill":"white", "stroke-width":"2"}]
			);
			this.facade.raiseEvent({
				type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id: 			task.properties["oryx-id"],
				shapes: 		[task],
				node:			circle,
				nodePosition:	nodePosition
			});
			//create text/ number of marker
			var text = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, 
				['text', {"x":x, "y":y, "style": "font-size: 12px;"}, elementId]
			);
			this.facade.raiseEvent({
				type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id: 			task.properties["oryx-id"],
				shapes: 		[task],
				node:			text,
				nodePosition:	nodePosition
			});
		}
		this.raisedOverlayEventIds.push(task.properties["oryx-id"]);
	},
	
	prepareOverlays: function(task) { //identify tasks to be coloured as a constraint exist with given and initiate colouring
		if(task.properties["oryx-separationofduties"] != "") {
			var jsonObject = task.properties["oryx-separationofduties"].evalJSON();
			var items = jsonObject.items.toArray();
			var overlayTask;
			for(var index = 0; index < items.length; index++) {
				var taskIds = items[index].SeparatedTasks;
				while(taskIds.indexOf(';') > -1) {
					//overlayTask = this.facade.getCanvas().getChildById(taskIds.substring(0,taskIds.indexOf(';')));
					overlayTask = this.getTaskById(taskIds.substring(0,taskIds.indexOf(';')));
					taskIds = taskIds.substring((taskIds.indexOf(';')) + 2);
					this.showOverlaysForSeparations(overlayTask, index+1);
				}
				overlayTask = this.getTaskById(taskIds);
				//initiate colouring
				this.showOverlaysForSeparations(overlayTask, index+1);
			}
		} else {
			alert("No Separation of Duties Constraints are defined for this task");
		}
	},
	
	removeHighlightsAndOverlays: function(){
		var allShapes = this.facade.getCanvas().getChildShapes(true);
		var allShapeIds = [];
		var i = 0;
		//get all tasks of canvas
		for (var index = 0; index < allShapes.length; index++) {
    		if (allShapes[index].properties["oryx-activitytype"] == "Task") {
				allShapeIds[i] = allShapes[index].properties["oryx-id"];
				i++;
			}
    	}
		
		//remove highlights
		allShapeIds.each(function(id){
			this.facade.raiseEvent({
					type: 	ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
					highlightId: 	id
				});
		}.bind(this))
		this.raisedHighlightEventIds = [];
		
		//remove overlays 
		allShapeIds.each(function(id){
			this.facade.raiseEvent({
					type: 	ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id: 	id
				});
		}.bind(this))
		this.raisedOverlayEventIds = [];
	},
	
	getTaskById: function(taskId){
		var shapes = this.facade.getCanvas().getChildShapes(true);
		var task;
		for (var index = 0; index < shapes.length; index++) {
    		if (shapes[index].properties["oryx-activitytype"] == "Task") {
				if (shapes[index].properties["oryx-id"] == taskId) {
					task = shapes[index];
					break;
				}
			}
    	}
		return task;
	}
});/**
 * Copyright (c) 2009, Andreas Meyer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.ResourcesBoDAdd = Clazz.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.ResourcesBoDAdd.name,
            'functionality': this.defineBoD.bind(this),
            'group': ORYX.I18N.ResourcesBoDAdd.group,
            'dropDownGroupIcon': ORYX.PATH + "images/bod.png",
            'icon': ORYX.PATH + "images/bod+.png",
            'description': ORYX.I18N.ResourcesBoDAdd.desc,
            'index': 3,
            'toggle': false,
            'minShape': 2,
            'maxShape': 0
        });
		
    },
    
	defineBoD: function(){
    	//variable declaration
    	var selectedElements = this.facade.getSelection(); //all selected elements
    	var taskElements = []; //all selected tasks
    	var selectedTasks; //new tasks to be separated
    	var i = 0; //counter
    	var len = selectedElements.length; //number of selected elements
    	
    	//get only selected tasks
    	for (var index = 0; index < len; index++) {
    		var item = selectedElements[index];
    		if(item.properties["oryx-activitytype"] == "Task") {
    			taskElements[i] = item;
				if(taskElements[i].properties["oryx-id"] == "") {
					taskElements[i].setProperty("oryx-id", taskElements[i].id);
				}
    			if(i == 0) { //get ids of tasks to be bound
    				selectedTasks = taskElements[i].properties["oryx-id"];
    			} else {
    				selectedTasks = selectedTasks + "; " + taskElements[i].properties["oryx-id"];
    			}
    			i++;
    		}
    	}
    	
		if (taskElements.length > 1) {
			for (var taskCounter = 0; taskCounter < taskElements.length; taskCounter++) {
				//variable declaration
				var savedBindingsData = [];	//already saved bindings
				var savedSeparationsData = false; //already saved separations
				
				//check whether other bindings are defined for current task
				if (taskElements[taskCounter].properties["oryx-bindingsofduties"] != "") {
					savedBindingsData = this.bindingsCheck(taskElements[taskCounter], selectedTasks);
					if (savedBindingsData[3] == true) {
						break;
					}
				} else {
					savedBindingsData[1] = 0; //total number of binding entries is 0 as field is empty
					savedBindingsData[2] = 0; //highest id used is 0 as no id is used
				}
				
				//check whether a contradicting separation is defined for current task
				if (taskElements[taskCounter].properties["oryx-separationofduties"] != ("")) {
					savedSeparationsData = this.separationsCheck(taskElements[taskCounter], selectedTasks);
					if (savedSeparationsData == true) {
						break;
					}
				}
				
				//write entry
				this.writeEntry(savedBindingsData, selectedTasks, taskElements[taskCounter]);
			}
		} else {
			alert("Please select at least two tasks to define constraints for.");
		}
    },
    
    bindingsCheck: function(taskElement, selectedTasks) { //check for existing bindings with same tasks
		var returnValue = [];
		//get previous binding of duties assignments
		var elementIds = []; //collection of used ids for saved separations
		var taskIds = []; //collection of saved task ids
		var totalCount = 0; //number of defined bindings for a specific task
    	var highestId = 1; //next element id for bindings of a specific task
    	var j = 0; //counter
    	var m = 0; //counter
    	var n = 0; //counter
		var bindings = taskElement.properties["oryx-bindingsofduties"]; //get saved bindings
    	bindings = bindings.toString();
    	//store saved bindings including task ids
    	var savedBindings = bindings.substring(0,bindings.indexOf(']'));
    	//extract number of entries and element ids of these entries
    	while(bindings.indexOf(',') > -1) {
    		if(j%2 == 1) { //get element ids as integer
    			elementIds[m] = parseInt(bindings.substring((bindings.indexOf('"')) + 1));
    			m++;
		    	bindings = bindings.substring((bindings.indexOf(',')) + 1);
    		} else if(j == 0) { //get total count as integer
    			totalCount = parseInt(bindings.substring((bindings.indexOf(':')) + 1));
    			bindings = bindings.substring((bindings.indexOf(',')) + 1);
    		} else { //get task ids of bindings
    			bindings = bindings.substring((bindings.indexOf('"')) + 1);
    			taskIds[n] = bindings.substring(0,bindings.indexOf('"'));
    			n++;
    			bindings = bindings.substring((bindings.indexOf(',')) + 1);
    		}
	        j++;
    	}
    	if(bindings.indexOf('"') > -1) {
    		taskIds[n] = bindings.substring((bindings.indexOf('"')) + 1);
    	} else {
    		taskIds[n] = bindings; //get last task ids entry
    	}
    	taskIds[n]= taskIds[n].substring(0,taskIds[n].indexOf('"'));
    	
        //check whether entry does already exist
        var boundTasksCopy = selectedTasks; //working copy
        var singleTaskIdsInsertedBinding = []; //task ids of new bindings
        var singleTaskIdsSavedBindings = []; //task ids of saved bindings
		
        var y = 0; //counter
        
		var equal = false; //duplicate existing?
        
        //extract task ids of newly entered binding tasks
    	while(boundTasksCopy.indexOf(';') > -1) {
    		singleTaskIdsInsertedBinding[y] = boundTasksCopy.substring(0, boundTasksCopy.indexOf(';'));
    		boundTasksCopy = boundTasksCopy.substring((boundTasksCopy.indexOf(';'))+2);
	        y++;
        }
    	singleTaskIdsInsertedBinding[y] = boundTasksCopy;
        
        //extract task ids of stored binding tasks
        for(var index = 0; index < taskIds.length; index++) {
        	var z = 0; //counter
			var equalCounter = 0;
			while(taskIds[index].indexOf(';') > -1) {
        		singleTaskIdsSavedBindings[z] = taskIds[index].substring(0, taskIds[index].indexOf(';'));
        		taskIds[index] = taskIds[index].substring((taskIds[index].indexOf(';'))+2);
		        z++;
	        }
        	singleTaskIdsSavedBindings[z] = taskIds[index];
        	z++;
        	
			//compare all collected tasks/ task ids
        	if(singleTaskIdsInsertedBinding.length == singleTaskIdsSavedBindings.length) {
        		for(var x = 0; x < singleTaskIdsSavedBindings.length; x++) {
        			for(var w = 0; w < singleTaskIdsInsertedBinding.length; w++) {
        				if(singleTaskIdsInsertedBinding[w] == singleTaskIdsSavedBindings[x]) {
        					equal = true;
        					break;
        				}
        				equal = false;
        			}
        			if(equal == false) { //one item of set 1 not found in set 2
    					break;
    				}
        		}
        	} else if(singleTaskIdsInsertedBinding.length > singleTaskIdsSavedBindings.length) {
        		for(var x = 0; x < singleTaskIdsSavedBindings.length; x++) {
        			for(var w = 0; w < singleTaskIdsInsertedBinding.length; w++) {
						if (singleTaskIdsInsertedBinding[w] == singleTaskIdsSavedBindings[x]) {
							equalCounter++;
							break;
						}
					}
					if(equalCounter == singleTaskIdsSavedBindings.length) { //all saved tasks are found in new entries
						var result = this.deleteBindingEntry(taskElement, (index+1)); //delete existing entry to write new entry later and following updating the entry
						savedBindings = result[0];
						totalCount = result[1];
						equalCounter = 0;
						break;
					}
				}
				equal = false;
        	} else {
        		for(var x = 0; x < singleTaskIdsInsertedBinding.length; x++) {
        			for(var w = 0; w < singleTaskIdsSavedBindings.length; w++) {
        				if(singleTaskIdsSavedBindings[w] == singleTaskIdsInsertedBinding[x]) {
        					equal = true;
        					break;
        				}
        				equal = false;
        			}
        			if(equal == false) { //one item of smaller set not found in bigger set
    					break;
    				}
        		}
        	}
			singleTaskIdsSavedBindings.splice(0,singleTaskIdsSavedBindings.length);
        	//entry does exist, that's why no new one needs to be done
	        if(equal == true) {
	        	break;
	        }
        }
		
    	//get highest element id
    	for(var index = 0; index < elementIds.length; index++) {
    		if(elementIds[index] > highestId) {
    			highestId = elementIds[index];
    		}
    	}
    	returnValue[0] = savedBindings;
    	returnValue[1] = totalCount;
    	returnValue[2] = highestId;
    	returnValue[3] = equal;
    	return returnValue;
    },
    
    separationsCheck: function(taskElement, selectedTasks) { //check for existing separation with same tasks
    	var returnValue;
		//get previous binding of duties assignments
		var boundTaskIds = []; //collection of saved task ids
    	var l = 0; //counter
    	var q = 0; //counter
		var separations = taskElement.properties["oryx-separationofduties"]; //get saved separations
    	separations = separations.toString();
    	//extract number of entries and element ids of these entries
    	while(separations.indexOf(',') > -1) {
    		if(l%2 == 1) { //ignore element ids
		    	separations = separations.substring((separations.indexOf(',')) + 1);
    		} else if(l == 0) { //ignore totalCount
    			separations = separations.substring((separations.indexOf(',')) + 1);
    		} else {
    			separations = separations.substring((separations.indexOf('"')) + 1);
    			boundTaskIds[q] = separations.substring(0,separations.indexOf('"'));
    			q++;
    			separations = separations.substring((separations.indexOf(',')) + 1);
    		}
	        l++;
    	}
    	if(separations.indexOf('"') > -1) {
    		boundTaskIds[q] = separations.substring((separations.indexOf('"')) + 1);
    	} else {
    		boundTaskIds[q] = separations; //never reached?
    	}
    	boundTaskIds[q]= boundTaskIds[q].substring(0,boundTaskIds[q].indexOf('"'));
    	
        //check whether entry does already exist
        var separatedTasksCopy = selectedTasks; //working copy
        var singleTaskIdsInsertedSeparation = []; ////task ids of new separations
        var singleTaskIdsSavedSeparations = []; //task ids of saved separations
        var s = 0; //counter
        var t = 0; //counter
        var duplicate = false; //duplicate existing?
        
        //extract task ids of newly entered separation tasks
    	while(separatedTasksCopy.indexOf(';') > -1) {
    		singleTaskIdsInsertedSeparation[s] = separatedTasksCopy.substring(0, separatedTasksCopy.indexOf(';'));
    		separatedTasksCopy = separatedTasksCopy.substring((separatedTasksCopy.indexOf(';'))+2);
	        s++;
        }
    	singleTaskIdsInsertedSeparation[s] = separatedTasksCopy;
        
        //extract task ids of stored bound tasks
        for(var index = 0; index < boundTaskIds.length; index++) {
        	while(boundTaskIds[index].indexOf(';') > -1) {
        		singleTaskIdsSavedSeparations[t] = boundTaskIds[index].substring(0, boundTaskIds[index].indexOf(';'));
        		boundTaskIds[index] = boundTaskIds[index].substring((boundTaskIds[index].indexOf(';'))+2);
		        t++;
	        }
        	singleTaskIdsSavedSeparations[t] = boundTaskIds[index];
        	
	        var check = 0;
        	if(singleTaskIdsInsertedSeparation.length >= singleTaskIdsSavedSeparations.length) {
        		for(var x = 0; x < singleTaskIdsSavedSeparations.length; x++) {
        			for(var w = 0; w < singleTaskIdsInsertedSeparation.length; w++) {
        				if(singleTaskIdsInsertedSeparation[w] == singleTaskIdsSavedSeparations[x]) {
        					check++;
        					if(check == 2) {
        						duplicate = true;
        					}
        					break;
        				}
        				duplicate = false;
        			}
        			if(duplicate == true) { //two items of set 1 found in set 2 --> contradicting
    					break;
    				}
        		}
        	} else {
        		for(var x = 0; x < singleTaskIdsInsertedSeparation.length; x++) {
        			for(var w = 0; w < singleTaskIdsSavedSeparations.length; w++) {
        				if(singleTaskIdsSavedSeparations[w] == singleTaskIdsInsertedSeparation[x]) {
        					check++;
        					if(check == 2) {
        						duplicate = true;
        					}
        					break;
        				}
        				duplicate = false;
        			}
        			if(duplicate == true) { //two items of set 1 found in set 2 --> contradicting
    					break;
    				}
        		}
        	}
        	
	        if(duplicate == true) { //entry does exist, delete?
				var bodDelete = confirm("Do you want to delete the existing contradicting separation for allowing this binding constraint to be entered? Otherwise, this binding constraint will be discarded.");
				if(bodDelete == true) {
					this.findSeparationEntry(selectedTasks);
					duplicate = false;
				}
	        	break;
	        }
        }//end check whether separation entry does already exist
    	
        returnValue = duplicate;
        return returnValue;
    },
    
    writeEntry: function(savedBindingsData, selectedTasks, taskElement) { //create JSON object and write to task attributes
    	if(savedBindingsData[1] > 0) { //saved entries do exist
    		savedBindingsData[1]++; //number of entries
    		savedBindingsData[2]++; //highestId needs to be higher than all found ids 
    		savedBindingsData[0] = savedBindingsData[0].substring((savedBindingsData[0].indexOf(':'))+2);
    		savedBindingsData[0] = "{'totalCount':" + savedBindingsData[1] + savedBindingsData[0] + ", {bodId:\"" + savedBindingsData[2] + "\", BoundTasks:\"" + selectedTasks + "\"}]}";
    	} else { //first entry to be done
    		savedBindingsData[1] = 1;
    		savedBindingsData[2]++; //highestId needs to be higher than all found ids
    		savedBindingsData[0] = "{'totalCount':" + savedBindingsData[1] + ", 'items':[{bodId:\"" + savedBindingsData[2] + "\", BoundTasks:\"" + selectedTasks + "\"}]}";
    	}
    	taskElement.setProperty("oryx-bindingsofduties", savedBindingsData[0]);
    },
	
	deleteBindingEntry: function(taskElement, elementId) { //delete given entry from given task from binding contraints
		var returnValue = [];
		var bindings = taskElement.properties["oryx-bindingsofduties"]; //get saved separations
		var keptBindings;
		var temp;
		var totalCount = parseInt(bindings.substring((bindings.indexOf(':')) + 1));
		totalCount = totalCount - 1;
		if(totalCount > 0)  {
			bindings = bindings.substring(bindings.indexOf('[')); //{'totalCount':3, 'items':
			keptBindings = bindings.substring(0,bindings.indexOf('{')); //[
			bindings = bindings.substring(bindings.indexOf('{')); //[
			temp = bindings.substring(0,(bindings.indexOf('"')) + 1); //{bodId:"
			bindings = bindings.substring((bindings.indexOf('"')) + 1); //{bodId:"
			while(parseInt(bindings) != elementId) {
				keptBindings = keptBindings + temp + bindings.substring(0,(bindings.indexOf('{')) - 2); //'id'", BoundTasks:"task_a; task_b"}
				bindings = bindings.substring((bindings.indexOf('{')) - 2); //'id'", BoundTasks:"task_a; task_b"}
				temp = bindings.substring(0,((bindings.indexOf('"')) + 1)); //, {bodId:"
				bindings = bindings.substring((bindings.indexOf('"')) + 1); //, {bodId:"
			}
			bindings = bindings.substring((bindings.indexOf('}'))+3); //'bodId'", BoundTasks:"task_c; task_d; task_e"} or //{bodId:"'id'", BoundTasks:"task_c; task_d; task_e"},_
			var entry = "{'totalCount':" + totalCount + ", 'items':" + keptBindings + bindings + "]}";
			taskElement.setProperty("oryx-bindingsofduties", entry);
			
			entry = entry.toString();
			entry = entry.substring(0,entry.indexOf(']'));
		
		} else {
			var entry = "";
			taskElement.setProperty("oryx-bindingsofduties", entry);
		}
		
		returnValue[0] = entry;
		returnValue[1] = totalCount;
		return returnValue;
	},
	
	findSeparationEntry: function(taskIds) { //find separation entry with given task ids to be deleted at all affected tasks
		var taskIdsCopy = taskIds;
		var singleTaskIds = [];
		var s = 0;
		
		//extract task ids of affected tasks
    	while(taskIdsCopy.indexOf(';') > -1) {
    		singleTaskIds[s] = taskIdsCopy.substring(0, taskIdsCopy.indexOf(';'));
    		taskIdsCopy = taskIdsCopy.substring((taskIdsCopy.indexOf(';'))+2);
	        s++;
        }
    	singleTaskIds[s] = taskIdsCopy;
		
		taskIdsCopy = taskIds + ";";
		for (var m = 0; m < singleTaskIds.length; m++) { //go through all affected tasks
			var currentTask = this.getTaskById(singleTaskIds[m]);
			var separations = currentTask.properties["oryx-separationofduties"]; //get saved separations
			var separatedTaskIds = [];
			var totalCount = 0;
			var i = 0; //counter
			var j = 0; //counter
			while(separations.indexOf(',') > -1) {
	    		if(i%2 == 1) { //get element ids as integer
			    	separations = separations.substring((separations.indexOf(',')) + 1);
	    		} else if(i == 0) { //get totalCount
	    			totalCount = parseInt(separations.substring((separations.indexOf(':')) + 1));
					separations = separations.substring((separations.indexOf(',')) + 1);
	    		} else { //get task ids
	    			separations = separations.substring((separations.indexOf('"')) + 1);
	    			separatedTaskIds[j] = separations.substring(0,separations.indexOf('"'));
	    			j++;
	    			separations = separations.substring((separations.indexOf(',')) + 1);
	    		}
		        i++;
	    	}
			//transform id string into array - one constraint set equals one array entry
	    	if(separations.indexOf('"') > -1) {
	    		separatedTaskIds[j] = separations.substring((separations.indexOf('"')) + 1);
	    	} else {
	    		separatedTaskIds[j] = separations; //never reached??
	    	}
	    	separatedTaskIds[j]= separatedTaskIds[j].substring(0,separatedTaskIds[j].indexOf('"'));
						
			var singleTaskIdsStoredSeparation = [];
			
			//check each separation entry
			for (var index = 0; index < separatedTaskIds.length; index++) {
				var separatedTasksCopy = separatedTaskIds[index];
				var t = 0; //counter
				//extract task ids of stored elements
				while (separatedTasksCopy.indexOf(';') > -1) {
					singleTaskIdsStoredSeparation[t] = separatedTasksCopy.substring(0, separatedTasksCopy.indexOf(';'));
					separatedTasksCopy = separatedTasksCopy.substring((separatedTasksCopy.indexOf(';')) + 2);
					t++;
				}
				singleTaskIdsStoredSeparation[t] = separatedTasksCopy;
				
				if (singleTaskIds.length >= singleTaskIdsStoredSeparation.length) {
					var equalCounter = 0;
					for (var x = 0; x < singleTaskIdsStoredSeparation.length; x++) {
						for (var y = 0; y < singleTaskIds.length; y++) {
							if (singleTaskIdsStoredSeparation[x] == singleTaskIds[y]) {
								equalCounter++;
								break;
							}
						}
						if (equalCounter == singleTaskIdsStoredSeparation.length) { //entry found
							this.deleteSeparationEntry(currentTask, (index+1)); //delete entry
							break;
						}
					}
				}
				singleTaskIdsStoredSeparation.splice(0,singleTaskIdsStoredSeparation.length);
			}
		}
	},
	
	deleteSeparationEntry: function(taskElement, elementId) { //delete defined entry in given task
		var separations = taskElement.properties["oryx-separationofduties"]; //get saved separations
		var keptSeparations;
		var temp;
		var totalCount = parseInt(separations.substring((separations.indexOf(':')) + 1));
		totalCount = totalCount - 1;
		if(totalCount > 0)  { //remove specified entry
			separations = separations.substring(separations.indexOf('[')); //{'totalCount':3, 'items':
			keptSeparations = separations.substring(0,separations.indexOf('{')); //[
			separations = separations.substring(separations.indexOf('{')); //[
			temp = separations.substring(0,(separations.indexOf('"')) + 1); //{sodId:"
			separations = separations.substring((separations.indexOf('"')) + 1); //{sodId:"
			while(parseInt(separations) != elementId) {
				keptSeparations = keptSeparations + temp + separations.substring(0,(separations.indexOf('{')) - 2); //'id'", SeparatedTasks:"task_a; task_b"}
				separations = separations.substring((separations.indexOf('{')) - 2); //'id'", SeparatedTasks:"task_a; task_b"}
				temp = separations.substring(0,((separations.indexOf('"')) + 1)); //, {sodId:"
				separations = separations.substring((separations.indexOf('"')) + 1); //, {sodId:"
			}
			separations = separations.substring((separations.indexOf('}'))+3); //'sodId'", SeparatedTasks:"task_c; task_d; task_e"} or //{sodId:"'id'", SeparatedTasks:"task_c; task_d; task_e"},_
			var entry = "{'totalCount':" + totalCount + ", 'items':" + keptSeparations + separations + "]}";
			taskElement.setProperty("oryx-separationofduties", entry);
			
			entry = entry.toString();
			entry = entry.substring(0,entry.indexOf(']'));
		
		} else { //remove last entry 
			var entry = "";
			taskElement.setProperty("oryx-separationofduties", entry);
		}
	},
	
	getTaskById: function(taskId){
		var shapes = this.facade.getCanvas().getChildShapes(true);
		var task;
		for (var index = 0; index < shapes.length; index++) {
    		if (shapes[index].properties["oryx-activitytype"] == "Task") {
				if (shapes[index].properties["oryx-id"] == taskId) {
					task = shapes[index];
					break;
				}
			}
    	}
		return task;
	}
});/**
 * Copyright (c) 2009, Andreas Meyer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.ResourcesBoDShow = Clazz.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedOverlayEventIds = [];
		this.raisedHighlightEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.ResourcesBoDShow.name,
            'functionality': this.showBoD.bind(this),
            'group': ORYX.I18N.ResourcesBoDShow.group,
			'dropDownGroupIcon': ORYX.PATH + "images/bod.png",
            'icon': ORYX.PATH + "images/bod_view.png",
            'description': ORYX.I18N.ResourcesBoDShow.desc,
            'index': 4,
            'toggle': true,
            'minShape': 1,
            'maxShape': 1
        });
		
    },
    
	showBoD: function(){
		this.removeHighlightsAndOverlays();
		var selectedElements = this.facade.getSelection();
 		if(selectedElements[0].properties["oryx-activitytype"] == "Task") {
			this.highlightSelectedTask(selectedElements[0]);
			this.prepareOverlays(selectedElements[0]);
		} else {
			alert("Please select a task to show the related Binding of Duties constraints.");
		}
	},
	
	highlightSelectedTask: function(task){ //edge marking of selected/ given task
		if(!(task instanceof ORYX.Core.Shape)) return;
		this.facade.raiseEvent({
			type:			ORYX.CONFIG.EVENT_HIGHLIGHT_SHOW, 
			highlightId:	task.properties["oryx-id"],
			elements:		[task],
			color:			'#28BB25'
		});
		this.raisedHighlightEventIds.push(task.id);
	},
	
	showOverlaysForSeparations: function(task, elementId) { //colour given task green
		if(!(task instanceof ORYX.Core.Shape)) return;
		//set overlay attributes
		var attr = {fill: "#28BB25", stroke:"white", "stroke-width": 1};
		this.facade.raiseEvent({
			type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
			id: 			task.properties["oryx-id"],
			shapes: 		[task],
			attributes: 	attr
		});
		//calculate node position
		var appearanceCounter = 0;
		var nodePosition;
		var x; //x coordinate for text
		var y; //y coordinate for text
		var cx; //x coordinate for circle center
		var cy; //y coordinate for circle center
		for(index = 0; index < this.raisedOverlayEventIds.length; index++) {
			if (task.properties["oryx-id"] == this.raisedOverlayEventIds[index]) {
				appearanceCounter++;
			} 
		}
		switch(appearanceCounter) { //avoid overlappings of dependency markers as long as not more than 8 exist
			case 0:		nodePosition = 'NW';
						x = 9;
						y = 17;
						cx = 13;
						cy = 13;
						break;
			case 1:		nodePosition = 'NE';
						x = -17;
						y = 17;
						cx = -13;
						cy = 13;
						break;
			case 2:		nodePosition = 'SW';
						x = 9;
						y = -9;
						cx = 13;
						cy = -13;
						break;
			case 3:		nodePosition = 'SE';
						x = -17;
						y = -9;
						cx = -13;
						cy = -13;
						break;
			case 4:		nodePosition = 'N';
						x = -4;
						y = 17;
						cx = 0;
						cy = 13;
						break;
			case 5:		nodePosition = 'S';
						x = -4;
						y = -9;
						cx = 0;
						cy = -13;
						break;
			case 6:		nodePosition = 'W';
						x = 9;
						y = 4;
						cx = 13;
						cy = 0;
						break;
			case 7:		nodePosition = 'E';
						x = -17;
						y = 4;
						cx = -13;
						cy = 0;
						break;
			case 8: 	alert("There exist more Binding of Duties constraints for task " + task.properties["oryx-id"] + ", but they will not be illustrated by a number in that task's rectangle.");
						break;
			default:	break;
		}
		if(elementId >= 10) { //keep marker centered based on single-digit or double-digit entry
			x = x - 4;
		}
		if(appearanceCounter < 8) { //skip number representation, if task occurs too often
			//create circle of marker
			var circle = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, 
				['circle', {"cx":cx, "cy":cy, "r":"10", "stroke":"white", "fill":"white", "stroke-width":"2"}]
			);
			this.facade.raiseEvent({
				type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id: 			task.properties["oryx-id"],
				shapes: 		[task],
				node:			circle,
				nodePosition:	nodePosition
			});
			//create text/ number of marker
			var text = ORYX.Editor.graft("http://www.w3.org/2000/svg", null, 
				['text', {"x":x, "y":y, "style": "font-size: 12px;"}, elementId]
			);
			this.facade.raiseEvent({
				type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id: 			task.properties["oryx-id"],
				shapes: 		[task],
				node:			text,
				nodePosition:	nodePosition
			});
		}
		this.raisedOverlayEventIds.push(task.properties["oryx-id"]);
	},
	
	prepareOverlays: function(task) { //identify tasks to be coloured as a constraint exist with given and initiate colouring
		if(task.properties["oryx-bindingsofduties"] != "") {
			var jsonObject = task.properties["oryx-bindingsofduties"].evalJSON();
			var items = jsonObject.items.toArray();
			var overlayTask;
			for(var index = 0; index < items.length; index++) {
				var taskIds = items[index].BoundTasks;
				while(taskIds.indexOf(';') > -1) {
//					overlayTask = this.facade.getCanvas().getChildById(taskIds.substring(0,taskIds.indexOf(';')));
					overlayTask = this.getTaskById(taskIds.substring(0,taskIds.indexOf(';')));
					taskIds = taskIds.substring((taskIds.indexOf(';')) + 2);
					this.showOverlaysForSeparations(overlayTask, index+1);
				}
				overlayTask = this.getTaskById(taskIds);
				//initiate colouring
				this.showOverlaysForSeparations(overlayTask, index+1);
			}
		} else {
			alert("No Binding of Duties Constraints are defined for this task");
		}
	},
	
	removeHighlightsAndOverlays: function(){
		var allShapes = this.facade.getCanvas().getChildShapes(true);
		var allShapeIds = [];
		var i = 0;
		//get all tasks of canvas
		for (var index = 0; index < allShapes.length; index++) {
    		if (allShapes[index].properties["oryx-activitytype"] == "Task") {
				allShapeIds[i] = allShapes[index].properties["oryx-id"];
				i++;
			}
    	}
		
		//remove highlights
		allShapeIds.each(function(id){
			this.facade.raiseEvent({
					type: 	ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
					highlightId: 	id
				});
		}.bind(this))
		this.raisedHighlightEventIds = [];
		
		//remove overlays 
		allShapeIds.each(function(id){
			this.facade.raiseEvent({
					type: 	ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id: 	id
				});
		}.bind(this))
		this.raisedOverlayEventIds = [];
	},
	
	getTaskById: function(taskId){
		var shapes = this.facade.getCanvas().getChildShapes(true);
		var task;
		for (var index = 0; index < shapes.length; index++) {
    		if (shapes[index].properties["oryx-activitytype"] == "Task") {
				if (shapes[index].properties["oryx-id"] == taskId) {
					task = shapes[index];
					break;
				}
			}
    	}
		return task;
	}
});/**
 * Copyright (c) 2009, Andreas Meyer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.ResourceAssignment = Clazz.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.ResourceAssignment.name,
            'functionality': this.assignResource.bind(this),
            'group': ORYX.I18N.ResourceAssignment.group,
           // 'dropDownGroupIcon': ORYX.PATH + "images/hr.png",
            'icon': ORYX.PATH + "images/hr.png",
            'description': ORYX.I18N.ResourceAssignment.desc,
            'index': 0,
            'toggle': false,
            'minShape': 1,
            'maxShape': 0
        });
		
    },
    
	assignResource: function(){
    	//variable declaration
    	var selectedElements = this.facade.getSelection(); //all selected elements
    	var taskElements = []; //all selected tasks
    	var checkedValues = []; //values checked in resource selection dialog
    	var i = 0; //counter
    	var len = selectedElements.length; //number of selected elements
    	
    	//get only selected tasks
    	for (var index = 0; index < len; index++) {
    		var item = selectedElements[index];
    		if(item.properties["oryx-activitytype"] == "Task") {
    			taskElements[i] = item;
				if(taskElements[i].properties["oryx-id"] == "") {
					taskElements[i].setProperty("oryx-id", taskElements[i].id);
				}
    			i++;
    		}
    	}

    	//get allocation type and resources to be possibly assigned to the current task
		var allocationTypeData = this.handleAllocationTypeData(taskElements[0].properties["oryx-id"]);
		if(allocationTypeData[0] != null) { //skip following if no resource/ role is selected
			var resourceData = allocationTypeData[0];
			var allocationType = allocationTypeData[1];
			
			if(resourceData != "--automatic execution--") { //skip following if automatic execution shall take place
				//Dialog to select resources respectively roles
				var resourceSelection = new Ext.Window({
					frame: true,
					title: 'Please choose resources for assignment',
					width: 600,
					modal: true,
					closable: false,
					plain: true,
					items: {
						xtype: 'checkbox',
						boxLabel: resourceData.resource[0].resource,
						name: 'checkbox0'
					},
					buttons: [{
						text: 'Select',
						handler: function() {
							resourceSelection.close();
							checkedValues = this.getCheckedValues(resourceSelection);
							this.writeAssignments(checkedValues, taskElements, allocationType);
						}.bind(this)
					},{
						text: 'Close',
						handler: function() {
							resourceSelection.close();
						}.bind(this)
					}]
				});
				var checkbox;
				var checkboxName;
				//add one checkbox for each entry (resource, role) to dialog window
				for (var index = 1; index < resourceData.resource.length; index++) {
					checkboxName = "checkbox" + index;
					checkbox = new Ext.form.Checkbox ({
					boxLabel: resourceData.resource[index].resource,
					name: checkboxName
					});
					resourceSelection.add(checkbox);
				}
				resourceSelection.show();
			} else { //automatic execution
				checkedValues[0] = resourceData;
				this.writeAssignments(checkedValues, taskElements, allocationType);
			}
		}
    },
	
	getResourceData: function(allocationType) { //Ajax request to get resource/ role information from servlet
		var resp;
		//get Resource List
		new Ajax.Request(ORYX.CONFIG.ROOT_PATH + 'resourceList', {
			method: 'POST',
			asynchronous: false,
			parameters: {
				allocation: allocationType
			},
			onSuccess: function(request){
				resp = request.responseText.evalJSON();
				returnValue = resp;
			}.bind(this)
    	});
		return resp;
	},
	
	getCheckedValues: function(resourceSelection) { //identify check elements and return the value
		var selectedValues = [];
		var j = 0;
		for (var index = 0; index < resourceSelection.items.items.length; index++) {
			if(resourceSelection.items.items[index].checked == true) {
				selectedValues[j] = resourceSelection.items.items[index].boxLabel;
				j++;
			}
		}
		return selectedValues;
	},
	
	writeAssignments: function(newResources, taskElements, allocationType) { //create and write JSON object to task attributes
		for (var taskCounter = 0; taskCounter < taskElements.length; taskCounter++) {
			var jsonObjectString;
			var currentTask = taskElements[taskCounter];
			if (currentTask.properties["oryx-resourceassignments"] != "") { //assignments existing?
				var jsonObject = currentTask.properties["oryx-resourceassignments"].evalJSON();
				var totalCount = parseInt(jsonObject.totalCount) + newResources.length;
				var items = jsonObject.items.toArray();
				//eliminate duplicates
				for (var m = 0; m < newResources.length; m++) {
					for (var n = 0; n < items.length; n++) {
						if (items[n].assignmentName == newResources[m]) {
							if (items[n].assignmentType == allocationType) { //same allocation type, otherwise resources are not equal
								//remove duplicate
								newResources.splice(m, 1);
								totalCount--;
								m--;
								break;
							}
						}
					}
				}
				
				//write existing assignments
				jsonObjectString = "{'totalCount':" + totalCount + ", 'items':[{assignmentType:\"" + items[0].assignmentType + "\", assignmentName:\"" + items[0].assignmentName + "\"}";
				for (var c = 1; c < items.length; c++) {
					jsonObjectString = jsonObjectString + ", {assignmentType:\"" + items[c].assignmentType + "\", assignmentName:\"" + items[c].assignmentName + "\"}";
				}
				//write new assignments
				for (var c = 0; c < newResources.length; c++) {
					jsonObjectString = jsonObjectString + ", {assignmentType:\"" + allocationType + "\", assignmentName:\"" + newResources[c] + "\"}";
				}
				jsonObjectString = jsonObjectString + "]}";
			}
			else { //no existing assignments
				//write new assignments
				jsonObjectString = "{'totalCount':" + newResources.length + ", 'items':[{assignmentType:\"" + allocationType + "\", assignmentName:\"" + newResources[0] + "\"}";
				for (var c = 1; c < newResources.length; c++) {
					jsonObjectString = jsonObjectString + ", {assignmentType:\"" + allocationType + "\", assignmentName:\"" + newResources[c] + "\"}";
				}
				jsonObjectString = jsonObjectString + "]}";
			}
			//complete allocation by writing final entry
			currentTask.setProperty("oryx-resourceassignments", jsonObjectString);
			
		}
	},
	
	handleAllocationTypeData: function(taskId) { //ask for type of allocation via a prompt and collect resource information to return it
		var returnValue = [];
		var resourceData;
		//get possible new assignments for current task
		var promptResult = prompt("for task " + taskId + "\n1: direct, \n2: role, \n3: org, \n4: auto");
		if(promptResult != "1" && promptResult != "2" && promptResult != "3" && promptResult != "4" && promptResult != null) {
			alert("wrong entry, please try again");
			returnValue = this.handleAllocationTypeData(taskId);
		} else {
			if(promptResult == "1") {
				resourceData = this.getResourceData("direct");
				promptResult = "Single User";
				//promptResult = "Direct Allocation";
			} else if(promptResult == "2") {
				resourceData = this.getResourceData("functional");
				promptResult = "Functional Role";
				//promptResult = "Functional-Role-based Allocation";
			} else if(promptResult == "3") {
				resourceData = this.getResourceData("organisational");
				promptResult = "Organisational Role";
				//promptResult = "Organisational-Role-based Allocation";
			} else if(promptResult == "4") {
				resourceData = "--automatic execution--";
				promptResult = "Automatic Execution";
				//promptResult = "Automatic Execution";
			} else if(promptResult == null) {
				resourceData = null;
			}
			returnValue[0] = resourceData;
			returnValue[1] = promptResult;
		}
		return returnValue;
	},
    
    getSavedAssignmentsData: function(taskElement) {
    	var returnValue = [];
    	var elementIds = []; //collection of used ids for saved assignments
		var totalCount = 0; //number of defined separations for a specific task
    	var highestId = 1; //next element id for separations of a specific task
    	var j = 0; //counter
    	var m = 0; //counter
		var assignments = taskElement.properties["oryx-resourceassignments"]; //get saved assignments
		assignments = assignments.toString();
    	//store saved assignments including task ids
    	var savedAssignmentsString = assignments.substring(0,assignments.indexOf(']'));
    	//extract number of entries and element ids of these entries
    	while(assignments.indexOf(',') > -1) {
    		if(j%2 == 1) { //get element ids as integer
    			elementIds[m] = parseInt(assignments.substring((assignments.indexOf('"')) + 1));
    			m++;
    			assignments = assignments.substring((assignments.indexOf(',')) + 1);
    		} else if(j == 0) { //get total count as integer
    			totalCount = parseInt(assignments.substring((assignments.indexOf(':')) + 1));
    			assignments = assignments.substring((assignments.indexOf(',')) + 1);
    		} else { //task ids are already saved in "savedSeparations", so that these entries can be discarded
    			assignments = assignments.substring((assignments.indexOf(',')) + 1);
    		}
	        j++;
    	}
    	
    	//get highest element id
    	for(var index = 0; index < elementIds.length; index++) {
    		if(elementIds[index] > highestId) {
    			highestId = elementIds[index];
    		}
    	}
    	returnValue[0] = savedAssignmentsString;
    	returnValue[1] = totalCount;
    	returnValue[2] = highestId;
    	return returnValue;
    }
});/**
 * Copyright (c) 2009, Andreas Meyer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.ClearSodBodHighlights = Clazz.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
		this.active 		= false;
		this.raisedEventIds = [];
		
        this.facade.offer({
            'name': ORYX.I18N.ClearSodBodHighlights.name,
            'functionality': this.removeHighlightsAndOverlays.bind(this),
            'group': ORYX.I18N.ClearSodBodHighlights.group,
            'icon': ORYX.PATH + "images/sod_bod_view_clear.png",
            'description': ORYX.I18N.ClearSodBodHighlights.desc,
            'index': 5,
            'toggle': false,
            'minShape': 0,
            'maxShape': 0
        });
		
    },
    
	removeHighlightsAndOverlays: function(){
		var allShapes = this.facade.getCanvas().getChildShapes(true);
		var allShapeIds = [];
		var i = 0;
		//get all tasks of canvas
		for (var index = 0; index < allShapes.length; index++) {
    		if (allShapes[index].properties["oryx-activitytype"] == "Task") {
				if (allShapes[index].properties["oryx-id"] != "") {
					allShapeIds[i] = allShapes[index].properties["oryx-id"];
					i++;
				}
			}
    	}
		
		//remove highlights
		allShapeIds.each(function(id){
			this.facade.raiseEvent({
					type: 	ORYX.CONFIG.EVENT_HIGHLIGHT_HIDE,
					highlightId: 	id
				});
		}.bind(this))
		
		//remove overlays 
		allShapeIds.each(function(id){
			this.facade.raiseEvent({
					type: 	ORYX.CONFIG.EVENT_OVERLAY_HIDE,
					id: 	id
				});
		}.bind(this))
	}
});
/**
 * Copyright (c) 2008
 * Willi Tscheschner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();


/**
 * Implements a mapping from EPC Models to BPMN Models
 *
 *
 */
ORYX.Plugins.EPC2BPMN = Clazz.extend({

    facade: undefined,
    
	EPC_NAMESPACE: 'http://b3mn.org/stencilset/epc#',
	BPMN1_0_NAMESPACE: 'http://b3mn.org/stencilset/bpmn#',
	BPMN1_1_NAMESPACE: 'http://b3mn.org/stencilset/bpmn1.1#',
    
	
    // Offers the plugin functionality
    construct: function(facade){
		
        this.facade = facade;
        Facade = facade;
        
		this.isBPMN1_0 = this.facade.getStencilSets().keys().include(this.BPMN1_0_NAMESPACE);
		this.isBPMN1_1 = this.facade.getStencilSets().keys().include(this.BPMN1_1_NAMESPACE);
		
		if( !this.isBPMN1_0 && !this.isBPMN1_1){ return }
		
		this.facade.offer({
            'name': "EPC to BPMN transform",
            'functionality': this.startTransform.bind(this),
            'group': "epc",
            'icon': ORYX.PATH + "images/epc_export.png",
            'description': "Import from EPC",
            'index': 1,
            'minShape': 0,
            'maxShape': 0
        });
        
    },
    
    
    /**
     * Transforming from EPC to BPMN
     */
    startTransform: function(){
	
		this.showPanel( this.sendRequest.bind(this) );
	
	},
	
	/**
	 * Sends the Request out to the EPC-Model with the given url in the options
	 * 
	 * @param {Object} options
	 */
	sendRequest: function(options){

		var waitingpanel = new Ext.Window({id:'oryx-loading-panel_epc2bpmn',bodyStyle:'padding: 8px',title:'Oryx',width:230,height:55,modal:true,resizable:false,closable:false,frame:true,html:'<span style="font-size:11px;">Please wait while importing...</span>'})
		waitingpanel.show()
		
		if( !options || !options.url ){ return }


		//this.facade.raiseEvent({ type: ORYX.CONFIG.EVENT_LOADING_ENABLE,text: 'Import' });
				
		var url = "./engineproxy?url=" + options.url;
				
        new Ajax.Request( url , {
            method: 'GET',
            onSuccess: function(request){
				
				// asynchronously ...
	            window.setTimeout((function(){
	         
			 		try{
						this.doTransform( request.responseText, options);
					} catch(e) {
						Ext.Msg.alert(ORYX.I18N.Oryx.title,"An Error is occured while importing!");
					}
					
					Ext.getCmp("oryx-loading-panel_epc2bpmn").close();

					// If autolayout is needed, it will be calles 'asychronly'
					if (options.autolayout) {
						window.setTimeout((function(){
							this.facade.raiseEvent({type: ORYX.CONFIG.EVENT_AUTOLAYOUT_LAYOUT});
						}).bind(this), 100);
					}
	            }).bind(this), 100);
		

			}.bind(this),
			onFailure: function(request){
				
				// Disable the loading panel
				this.facade.raiseEvent({ type: ORYX.CONFIG.EVENT_LOADING_DISABLE});	
				
				Ext.Msg.alert(ORYX.I18N.Oryx.title, "Request to server failed!");
			
			}.bind(this)
        });
		   
    },
    
	/**
	 * 
	 * Does actually the Tranformation with an given ERDS-String and some advanced options
	 * 
	 * @param {Object} erdfString
	 * @param {Object} options
	 */
    doTransform: function( erdfString , options){

		var elements = this.parseToObject( erdfString );
		
		var shapes = [];
		
		if( !elements ){
			return 
		}
		var getEPCElementById = function(id){ return elements.find(function(el){ return el.id == id })}
		var deleteShape = function(thisEpc){
							var fShape = shapes.find(function(sh){ return sh.epc == thisEpc });
							if( fShape ){
								fShape.shape.parent.remove( fShape.shape );
								shapes = shapes.without( fShape )
							}
						}	
		var eventsMappingsThrow 	= options && options.events_throw ? options.events_throw.split(";").compact().without("").without(" ").collect(function(s){return s.toLowerCase()}) : [];
		var eventsMappingsCatch		= options && options.events_catch ? options.events_catch.split(";").compact().without("").without(" ").collect(function(s){return s.toLowerCase()}) : [];

		var isIncludedInMappingEventThrow	= function(s){ return eventsMappingsThrow.any(function(map){return map.split(" ").all(function(word){ return s.toLowerCase().include(word) })})}
		var isIncludedInMappingEventCatch	= function(s){ return eventsMappingsCatch.any(function(map){return map.split(" ").all(function(word){ return s.toLowerCase().include(word) })})}
		
		
		
		// ------------------------------------------
		// 1. Rule: Map - Function --> Task
		//
		
		// 
		var functions = elements.findAll(function(el){ return el.type.endsWith("Function")})
		functions.each(function(epc){
			// Create a new Task
			var shape = this.createElement("Task", epc, true);
			// Map Title -> Name
			shape.setProperty(	"oryx-name", 			epc.title);
			// Map Description -> Documentation
			shape.setProperty(	"oryx-documentation", 	epc.description);
			
			shapes.push({shape: shape, epc:epc})
		}.bind(this))
		
		
		// ------------------------------------------
		// 2. Rule: Events
		//
		
		// 			
		var events = elements.findAll(function(el){ return el.type.endsWith("Event")})
		
		// ------------------------------------------
		// 2a. Rule: Map - Events without an incoming edge --> StartEvent
		//
		
		// 
		var startevents	= events.findAll(function(ev){ return !elements.any(function(el){ return el.outgoing && el.outgoing.any(function(out){ return out.slice(1) == ev.id }) }) })
		startevents.each(function(epc){		
		
			// If its inculded in the mapping, set the type to StartMessageEvent, otherwise is it a StartEvent
			var startEventType = isIncludedInMappingEventCatch(epc.title) ? "StartMessageEvent" : "StartEvent";
			
			// Create a new Task
			var shape = this.createElement(startEventType, epc, true);
			// Map Title, Description -> Documentation
			if( startEventType == "StartMessageEvent"){
				shape.setProperty(	"oryx-message", epc.title );
			} else {
				shape.setProperty(	"oryx-documentation", epc.title + " - "+ epc.description);			
			}
			shapes.push({shape: shape, epc:epc})
		}.bind(this));		
		
		
		// ------------------------------------------
		// 2b. Rule: Map - Events without an outgoing edge --> EndEvent
		//
		
				
		// 		
		var endevents	= events.findAll(function(ev){ return !ev.outgoing })
		endevents.each(function(epc){

			// If its inculded in the mapping, set the type to StartMessageEvent, otherwise is it a StartEvent
			var endEventType = this.isBPMN1_1 && isIncludedInMappingEventThrow(epc.title) ? "MessageEndEvent" : "EndEvent";
			
			// Create a new Task
			var shape = this.createElement(endEventType, epc, true);
			
			//var fcTitle = deletePreviousFunction( epc )
			
			// Map Title, Description -> Documentation			
			if( endEventType == "MessageEndEvent"){
				shape.setProperty(	"oryx-message", epc.title );
			} else {
				shape.setProperty(	"oryx-documentation", epc.title + " - "+ epc.description);			
			}

			// Set the end event type of message
			if(  this.isBPMN1_0 && isIncludedInMappingEventThrow(epc.title)){
				shape.setProperty(	"oryx-result", "Message");
				shape.setProperty(	"oryx-message", epc.title );
			}
			shapes.push({shape: shape, epc:epc})
			
		}.bind(this));	


		// ------------------------------------------
		// extention Rule: Map - Events to Message Events which are defined in the advance settings
		//
		
		// 	
		var intermediateEvents		= [].without.apply(events, startevents.concat(endevents))
		intermediateEventsCatch		= intermediateEvents.findAll(function(epc){ return isIncludedInMappingEventCatch(epc.title)})
		intermediateEventsCatch.each(function(epc){
			var type = this.isBPMN1_1 ? "IntermediateMessageEventCatching" : "IntermediateMessageEvent";
			// Create a new Task
			var shape = this.createElement(type, epc, true);
			// Map Title -> Message
			shape.setProperty(	"oryx-message", epc.title );
			//shape.setProperty(	"oryx-message", epc.title + " - "+ epc.description);

			shapes.push({shape: shape, epc:epc})
			
		}.bind(this));
			

		intermediateFunctionsThrow		= functions.findAll(function(epc){ return isIncludedInMappingEventThrow(epc.title)})
		intermediateFunctionsThrow.each(function(epc){
			
			deleteShape( epc )
			
			var type = this.isBPMN1_1 ? "IntermediateMessageEventThrowing" : "IntermediateMessageEvent";
			
			var fEdge = epc.outgoing ? getEPCElementById( epc.outgoing[0].slice(1) ) : null;
			if( fEdge && fEdge.outgoing){
				var fEvent = getEPCElementById(fEdge.outgoing[0].slice(1));
				if(fEvent && fEvent.type.endsWith("Event") && !fEvent.outgoing && isIncludedInMappingEventThrow(fEvent.title)){
					deleteShape( fEvent );
					type = this.isBPMN1_1 ? "MessageEndEvent" : "EndEvent";
				}
			}
			
			// Create a new Task
			var shape = this.createElement(type, epc, true);
			
			// Map Title -> Message
			shape.setProperty(	"oryx-message", epc.title );
			//shape.setProperty(	"oryx-message", epc.title + " - "+ epc.description);
			
			if(  this.isBPMN1_0 && type == "EndEvent"){
				shape.setProperty(	"oryx-result", "Message");
			}
			
			shapes.push({shape: shape, epc:epc})
					
		}.bind(this));						
		// ------------------------------------------
		// 3. Rule: Map - Connector --> Gateway
		//
		
		// 	
		var connectors	= elements.findAll(function(el){ return el.type.endsWith("Connector") })
		connectors.each(function(epc){
			
			// Set the BPMN Type
			var type = "Exclusive_Databased_Gateway";
			if(epc.type.endsWith("AndConnector")){ 		type = "AND_Gateway"; } 
			else if(epc.type.endsWith("OrConnector")){ 	type = "OR_Gateway";  }
			
			if( type == "Exclusive_Databased_Gateway" && epc.outgoing && epc.outgoing.all(function(out){  return intermediateEventsCatch.include(getEPCElementById(getEPCElementById(out.slice(1)).outgoing[0].slice(1))) })){
				type = "Exclusive_Eventbased_Gateway";
			}
			// Create a new Task
			var shape = this.createElement(type, epc, true);

			shapes.push({shape: shape, epc:epc})
		}.bind(this))				


				
		// ------------------------------------------
		// 2c. Rule: Map - Events directly after an Split Connectors (except AND-Connector) --> Conditions on the Edges after the Gateway
		//
		
		// 	
		connectors.each(function(epc){
			if(epc.outgoing && epc.outgoing.length > 1 && !epc.type.endsWith("AndConnector")){

				epc.outgoing.each(function(out){
					var next = getEPCElementById(out.slice(1));
					// If its an edge
					if( next.type.endsWith("ControlFlow") && next.outgoing){
						
						next.outgoing.each(function(out2){
							var nextnext = getEPCElementById(out2.slice(1));
							if(nextnext.type.endsWith("Event")){
								next["expression"] = nextnext.title
							}
						})
						
					}					
				})
			}
		}.bind(this))	
		
				

		// ------------------------------------------
		// 5. Rule: Map - Data --> Data Object		
		//
		
		// 	
		var datas = elements.findAll(function(el){ return el.type.endsWith("Data")})
		datas.each(function(epc){
			// Create a new Task
			var shape = this.createElement("DataObject", epc, true);
			// Map Title -> Name
			shape.setProperty(	"oryx-name", 			epc.title);
			// Map Description -> Documentation
			shape.setProperty(	"oryx-documentation", 	epc.description);
			
			shapes.push({shape: shape, epc:epc})
		}.bind(this))


		// ------------------------------------------
		// 6. Rule: Map - System --> Annotation		
		//
		
		// 					
		var systems = elements.findAll(function(el){ return el.type.endsWith("System")})
		systems.each(function(epc){
			// Create a new Task
			var shape = this.createElement("TextAnnotation", epc, true);
			// Map Title -> Text
			shape.setProperty(	"oryx-text", "Used System: " + epc.title);
						
			shapes.push({shape: shape, epc:epc})
		}.bind(this))



		// ------------------------------------------
		// 7. Rule: Map - ProcessLink --> Sub-Process
		//
		
		// 
		var processlinks = elements.findAll(function(el){ return el.type.endsWith("ProcessInterface")})
		processlinks.each(function(epc){
			
			var type = this.isBPMN1_1 ? "collapsedSubprocess" : "Subprocess";
			// Create a new Task
			var shape = this.createElement(type, epc, true);
			// Map Title -> Name
			shape.setProperty(	"oryx-name", 			epc.title);
			// Map Description -> Documentation
			shape.setProperty(	"oryx-documentation", 	epc.description);
			// Map URL -> SubProcessRef
			shape.setProperty(	"raziel-entry",		 	epc.refuri);
			
			shapes.push({shape: shape, epc:epc})
		}.bind(this))		
	
		

		// ------------------------------------------
		// 4. Rule: Map - Organization/Position --> Pool
		//
		
		// 
		var organizations 		= options.organization ? elements.findAll(function(el){ return el.type.endsWith("Organization") || el.type.endsWith("Position")}) : [];
		var organizationNames 	= organizations.collect(function(epc){ return epc.title }).uniq().sort();
		organizations			= organizationNames.collect(function(name){ return organizations.findAll(function(epc){ return epc.title == name}) });
		
		if( organizations.length > 0 ){
			
			var pool 		= this.createElement("Pool");
			
			var lanes 		= [];
			var addedShapes	= [];
			
			organizations.each(function(epcs){
				// Create a new Task
				var lane = this.createElement("Lane");
				// Map Title -> Name
				lane.setProperty(	"oryx-name", epcs[0].title);
				pool.add( lane );
				lanes.push({shape: lane, epc:epcs[0]});
				
				epcs.each(function(epc){

					var prevFunctions = epc.outgoing ? epc.outgoing.collect(function(out){ return getEPCElementById(out.slice(1)).outgoing[0].slice(1) }) : [];
				
					var allRelatedFunctions = shapes.findAll(function(shape){ return shape.epc.type.endsWith("Function") || shape.epc.type.endsWith("ProcessInterface") })
					allRelatedFunctions = allRelatedFunctions.findAll(function(shape){ return  prevFunctions.include(shape.epc.id) || (shape.epc.outgoing && shape.epc.outgoing.any(function(out){ return getEPCElementById(out.slice(1)).outgoing.first().slice(1) == epc.id}))})
					
					allRelatedFunctions.each(function(shape){
						lane.add(shape.shape)
						addedShapes.push(shape)
					})
											
				});
			}.bind(this));	
			
			var notAddedShapes = [].without.apply(shapes, addedShapes);

			// Get all function which are not added to a pool yet
			var notAddedFunctions = notAddedShapes.findAll(function(shape){ return shape.epc.type.endsWith("Function")  || shape.epc.type.endsWith("ProcessInterface") });
			if( notAddedFunctions.length > 0 ){
				// Create a new empty pool
				var emptyLane	= this.createElement("Lane");
				pool.add( emptyLane );
				// Add all functions to this pool
				notAddedFunctions.each(function(shape){
					emptyLane.add( shape.shape )
					addedShapes.push(shape);				
				})			
			}

			var notAddedShapes = [].without.apply(shapes, addedShapes);			
			
			// Finds all shapes which are in the 'notAddedShapes'-Array 
			// but aren't in the 'addedShapes'-Array
			var findNextShapesWhichAreNotAdded = function(outgoings){
				
				if( !outgoings ){ return [] }
				
				var res = [];
				
				outgoings.each(function(out){
					// Find one following shape
					var sh = shapes.find(function(el){ return el.epc.id == out.slice(1) })
					
					if (sh) {
						// Lookup in the addedShapes array
						if (addedShapes.indexOf(sh) >= 0) {
							throw $break
						}
						
						if (notAddedShapes.indexOf(sh) >= 0) {
							res.push(sh)
						}
						
						res = res.concat( findNextShapesWhichAreNotAdded( sh.epc.outgoing ) )
					} else {
						res = res.concat( findNextShapesWhichAreNotAdded( getEPCElementById(out.slice(1)).outgoing ) );
					}
					
				});

				return res;
			}

			// Go thru all added shapes (mainly Functions) 
			// and find all following shapes which are not in the added shapes array
			// and add these to the same pool like this
			addedShapes.each(function(shape){
				var nextShapes = findNextShapesWhichAreNotAdded(shape.epc.outgoing)
				
				nextShapes.each(function(nextShape){
					shape.shape.parent.add( nextShape.shape )
					notAddedShapes = notAddedShapes.without( nextShape );	
				})
			});		


			var findNextShapeWhichIsAdded = function(outgoings){
				
				if( !outgoings ){ return [] }
				var res;
				
				outgoings.each(function(out){
					var sh = shapes.find(function(el){ return el.epc.id == out.slice(1) })
					
					if (sh) {
						// Lookup in the addedShapes array
						if (addedShapes.indexOf(sh) >= 0) {
							res = sh;
							throw $break
						}
						res = findNextShapeWhichIsAdded( sh.epc.outgoing );
					} else {
						res = findNextShapeWhichIsAdded( getEPCElementById(out.slice(1)).outgoing );
					}
					
				});

				return res;
			}			
			// For every shapes which couldn't be a following shape
			// (like a start event) add these to this following shape.
			notAddedShapes.each(function(shape){
				
				var nextShape = findNextShapeWhichIsAdded( shape.epc.outgoing );
				if( nextShape ){
					nextShape.shape.parent.add( shape.shape )
					addedShapes.push( shape );						
				}
			})
			
		
		}
		
					
		// --------------------------
		// Generate all Edges
		//
		
		// Function for finding the following shape which is already instanceiated
		var findFollowingShape = function(edge){
			if( !edge || !edge.outgoing){ return null }
			
			var nextElement = edge
			var nextShape;
			
			while(!nextShape){
				
				// Get the following shape
				nextElement = elements.find(function(el){ return nextElement.outgoing && nextElement.outgoing.any(function(out){ return out.slice(1) == el.id } )})
				// Look up if there is an instanciated shape
				nextShape 	= shapes.find(function(el){ return el.epc === nextElement })
				
				if( !nextElement || !nextElement.outgoing){
					break
				}
			}
			
			return nextShape
		}

		
		var edges = []
		// Push all edges to the array which come up in the available shapes		
		shapes.each(function(from){ 
			if(from.epc.outgoing){
				from.epc.outgoing.each(function(out){
					var edge = elements.find(function(epc){ return ( epc.type.endsWith("ControlFlow") || epc.type.endsWith("Relation") ) && epc.id == out.slice(1)}) 
					var next = findFollowingShape( edge );
					if( edge && next){				
						edges.push({
							from: 	from, 
							edge:	edge,
							to: 	next
						})
					}				
				})				
			}				
		})	
		
		// Create all the edges
		edges.each(function(edge){
			// Create a new Edge
			var shape
			if( edge.edge.type.endsWith("Relation") ) {
				if(edge.edge.informationflow.toLowerCase() == "true"){
					shape = this.createElement("Association_Unidirectional", edge.edge);				
				} else {
					shape = this.createElement("Association_Undirected", edge.edge);					
				}
			} else {
				shape = this.createElement("SequenceFlow", edge.edge);
			}
			
			var from 	= edge.from.shape;
			var to 		= edge.to.shape;
			// Set the docker
			shape.dockers.first().setDockedShape( from );
			shape.dockers.first().setReferencePoint({x: from.bounds.width() / 2.0, y: from.bounds.height() / 2.0});
			//shape.dockers.first().update()

			shape.dockers.last().setDockedShape( to );
			shape.dockers.last().setReferencePoint({x: to.bounds.width() / 2.0, y: to.bounds.height() / 2.0});
			//shape.dockers.last().update()
			
			// If there is an expression, it will be setted
			if( edge.edge.expression ){
				shape.setProperty("oryx-conditionexpression", edge.edge.expression)
			}
			
			shapes.push({shape: shape, epc:edge.edge})
		}.bind(this))		


		// --------------------------
		// UPDATE
		//		
		this.facade.getCanvas().update();
		
	},
	
	/**
	 * Creates a BPMN-Shape with the given type
	 * 
	 * @param {Object} bpmnType
	 * @param {Object} epcElement
	 * @param {Object} setBounds
	 */
	createElement: function(bpmnType, epcElement, setBounds, alternativeBPMNType){

		// Create a new Stencil		
		var ssn 	= this.facade.getStencilSets().keys()[0];						
		var stencil = ORYX.Core.StencilSet.stencil(ssn + bpmnType);
	
		if( !stencil && alternativeBPMNType ){
			stencil = ORYX.Core.StencilSet.stencil(ssn + alternativeBPMNType);
		}

		if( !stencil ){
			return null;
		}
			
		// Create a new Shape
		var newShape = (stencil.type() == "node") ?
										new ORYX.Core.Node(
											{'eventHandlerCallback':this.facade.raiseEvent },
											stencil) :
										new ORYX.Core.Edge(
											{'eventHandlerCallback':this.facade.raiseEvent },
											stencil);

		// Add the shape to the canvas
		this.facade.getCanvas().add(newShape);
		
		if( epcElement && epcElement.bounds && setBounds){
			// Set the bounds
			newShape.bounds.centerMoveTo( epcElement.bounds.center )
		}
		
		return newShape;
					
	},
	
	/**
	 * Parsed the given ERDF-String to a Array with the individual
	 * EPC-Objects
	 * 
	 * @param {Object} erdfString
	 */
	parseToObject: function ( erdfString ){

		var parser	= new DOMParser();			
		var doc		= parser.parseFromString( erdfString ,"text/xml");

		var getElementByIdFromDiv = function(id){ return $A(doc.getElementsByTagName('div')).find(function(el){return el.getAttribute("id")== id})}

		// Get the oryx-editor div
		var editorNode 	= getElementByIdFromDiv('oryxcanvas');
		editorNode 		= editorNode ? editorNode : getElementByIdFromDiv('oryx-canvas123');

		var hasEPC = editorNode ? $A(editorNode.childNodes).any(function(node){return node.nodeName.toLowerCase() == "a" && node.getAttribute('rel') == 'oryx-stencilset' && node.getAttribute('href').endsWith('epc/epc.json')}) : null;

		if( !hasEPC ){
			this.throwErrorMessage('Imported model is not an EPC model!');
			return null
		}


		// Get all ids from the canvas node for rendering
		var renderNodes = $A(editorNode.childNodes).collect(function(el){ return el.nodeName.toLowerCase() == "a" && el.getAttribute('rel') == 'oryx-render' ? el.getAttribute('href').slice(1) : null}).compact()
		// Collect all nodes from the ids
		renderNodes = renderNodes.collect(function(el){return getElementByIdFromDiv(el)});

		// Function for extract all eRDF-Attributes and give them back as an Object
		var parseAttribute = function(node){
		    var res = {}
			// Set the resource id
			if(node.getAttribute("id")){
				res["id"] = node.getAttribute("id");
			}
			
			// Set all attributes
		    $A(node.childNodes).each( function(node){ 
				if( node.nodeName.toLowerCase() == "span" && node.getAttribute('class')){
		            var key = node.getAttribute('class').slice(5);
					res[key] = node.firstChild ? node.firstChild.nodeValue : '';
		        	if( key == "bounds" ){
						var ba = $A(res[key].split(",")).collect(function(el){return Number(el)})
						res[key] = {a:{x:ba[0], y:ba[1]},b:{x:ba[2], y:ba[3]},center:{x:ba[0]+((ba[2]-ba[0])/2),y:ba[1]+((ba[3]-ba[1])/2)}}
					}
				} else if( node.nodeName.toLowerCase() == "a" && node.getAttribute('rel')){
		            var key = node.getAttribute('rel').split("-")[1];
					if( !res[key] ){
						res[key] = [];
					}
					
		            res[key].push( node.getAttribute('href') )
		        }
		    })
		    return res
		}

		// Collect all Attributes out of the Nodes
		return renderNodes.collect(function(el){return parseAttribute(el)});
				
	},
	
	/**
	 * 
	 * @param {Object} message
	 */
	throwErrorMessage: function(message){
		Ext.Msg.alert( ORYX.I18N.Oryx.title, message )
	},
	
	/** ********************************************************
	 * 
	 * UI-WINDOW
	 * 
	 * ********************************************************
	 * 
	 * Shows the Popup Window where u can specify the url
	 * and some advanced parameter
	 * 
	 * @param {Object} callback
	 */
	showPanel: function( callback ){
			
		Ext.QuickTips.init();
		
		var mainForm = new Ext.form.FormPanel({
						id:				'transform-epc-bpmn-id-main',
					    labelWidth: 	40,
					    defaultType: 	'textfield',
					    bodyStyle:		'padding:5px',
					    defaults: 		{width: 300, msgTarget: 'side'},
					    items: [{
								text:'For the import and transformation from EPC to BPMN please set the URL to the EPC model.', 
								xtype:'label',
								style:'padding-bottom:10px;display:block',
								width:"100%"
							},{
								fieldLabel: 'URL',
								name: 		'last',
								//vtype: 		'url',
								allowBlank: false
							}]
					});
		
		
		var advanceForm = new Ext.form.FormPanel({
					    id:				'transform-epc-bpmn-id-advance',
					    collapsed:		true,
					    labelWidth: 	30,
					    defaultType: 	'textfield',
					    bodyStyle:		'padding:15px',
						defaults:		{width: 300,msgTarget: 'side',labelSeparator:''},
					    items: [{
								text:	'Event-Mapping',
								xtype: 	'label',
								cls:	'transform-epc-bpmn-title'
					        },{
								text:	'If u like to transform indivual event from EPC to event in BPMN, please give keyword regarding to these (separated with a \';\').',
								xtype: 	'label',
								width:	'100%',
								style:	'margin-bottom:10px;display:block;'
					        },{
								labelStyle: 'background:transparent url(stencilsets/bpmn/icons/intermediate-message.png) no-repeat scroll 0px -1px;width:30px;height:20px',
					            name: 	'events_catch'
					        },{
								labelStyle: !this.isBPMN1_0 ? 'background:transparent url(stencilsets/bpmn/icons/intermediate-message.png) no-repeat scroll 0px -30px;width:30px;height:20px' : 'display:none',
					            name: 	'events_throw',
								style:	this.isBPMN1_0 ? "display:none;" : ""
					        },{
								text:	'Organization',
								xtype: 	'label',
								style:	'margin-top:10px;display:block;',
								cls:	'transform-epc-bpmn-title'
					        },{
								text:	'Should the organizational units and roles maped to a pool/lane? (Required Auto-Layout)',
								xtype: 	'label',
								width:	'100%',
								style:	'margin-bottom:10px;display:block;'
					        },{
								boxLabel: 'Organization',
								name: 	'autolayout',
								id:		'transform-epc-bpmn-id-organization',
								xtype:	'checkbox',
								labelStyle:	'width:30px;height:20px'
					        },{
								text:	'Auto-Layout',
								xtype: 	'label',
								style:	'margin-top:10px;display:block;',
								cls:	'transform-epc-bpmn-title'
					        },{
								text:	'By enable the autolayout, the model will be auto layouted afterwards with the AutoLayout Plugin. (Needs a while)',
								xtype: 	'label',
								width:	'100%',
								style:	'margin-bottom:10px;display:block;'
					        },{
								boxLabel: 'Auto-Layout',
								name: 	'autolayout',
								id:		'transform-epc-bpmn-id-autolayout',
								xtype:	'checkbox',
								labelStyle:	'width:30px;height:20px'
					        }]
					});

		Ext.getCmp('transform-epc-bpmn-id-organization').on('check', function(obj, check){
			if(check){
				Ext.getCmp('transform-epc-bpmn-id-autolayout').setValue( true );
				Ext.getCmp('transform-epc-bpmn-id-autolayout').disable();
			} else {
				Ext.getCmp('transform-epc-bpmn-id-autolayout').enable();
			}
		})
		
		
		var groupButton = {
			            text:			'Advanced Settings',
			            xtype:			'button',
			            enableToggle:	true,
						cls:			'transform-epc-bpmn-group-button',
			            handler:function(d){
			                var d = Ext.getCmp('transform-epc-bpmn-id-advance');
			                if(d.collapsed){
			                    d.expand();
			                } else {
			                    d.collapse();
			                }
			            }
			        }
					
		
		var windowPanel = new Ext.Window({
					    title:			ORYX.I18N.Oryx.title + " - Transform EPC to BPMN",
					    width:			400,
						id:				'transform-epc-bpmn-id-panel',
						cls:			'transform-epc-bpmn-window',
					    items: 			new Ext.Panel({frame:true,autoHeight:true,items:[mainForm, groupButton , advanceForm]}),
						floating:		true,
						shim:			true,
						modal:			true,
						resizable:		false,
						autoHeight:		true,			    
						buttons:[{
								text:	'Import',
								handler: function(){
									var res = {};
									
									var urlField = Ext.getCmp('transform-epc-bpmn-id-main').findByType('textfield')[0]
									
									if( urlField.validate() ){
										res.url 			= urlField.getValue();
									}
									
									if( !Ext.getCmp('transform-epc-bpmn-id-advance').collapsed ){
										res.events_catch	= Ext.getCmp('transform-epc-bpmn-id-advance').findByType('textfield')[0].getValue();
										if( this.isBPMN1_1 ){
											res.events_throw = Ext.getCmp('transform-epc-bpmn-id-advance').findByType('textfield')[1].getValue();
										}
										res.organization	= Ext.getCmp('transform-epc-bpmn-id-advance').findByType('checkbox')[0].getValue();
										res.autolayout 		= Ext.getCmp('transform-epc-bpmn-id-advance').findByType('checkbox')[1].getValue();
									}
									
									Ext.getCmp('transform-epc-bpmn-id-panel').close();
								
									callback( res );
								}.bind(this)
							},{
								text:	'Cancel',
								handler: function(){
									Ext.getCmp('transform-epc-bpmn-id-panel').close();
								}
							}]  
					})
						
		windowPanel.show()		
	}
	
});


var Facade = undefined;
/**
 * Copyright (c) 2010
 * Christian Ress <bart@oryx-uml.the-bart.org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * The UML plugin provides layout methods referring to the UML stencilset. 
 * 
 * @class ORYX.Plugins.UML
 * @extends Clazz
 * @param {Object} facade The facade of the editor
 */
ORYX.Plugins.UML = 
/** @lends ORYX.Plugins.UML.prototype */
{
	/**
	 * Creates a new instance of the UML plugin and registers it on the
	 * layout events listed in the UML stencil set.
	 * 
	 * @constructor
	 * @param {Object} facade The facade of the editor
	 */
	construct: function(facade) {
		this.facade = facade;
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
		this.facade.registerOnEvent('layout.uml.class', this.handleLayoutClass.bind(this));
		this.facade.registerOnEvent('layout.uml.list', this.handleLayoutList.bind(this));
		this.facade.registerOnEvent('layout.uml.association', this.handleLayoutAssociation.bind(this));
		this.facade.registerOnEvent('layout.uml.qualified_association', this.handleLayoutQualifiedAssociation.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.addReadingDirectionOnLoad.bind(this));

	},
	
	/**
	 * Add reading direction on load.
	 *
	 * Because the reading direction arrow is added to the
	 * label of an edge, we have to iterate over all edges
	 * and add the arrow on load for it to appear.
	 *
	 * @param {Object} event
	 */
	addReadingDirectionOnLoad : function(event) {
		this.facade.getCanvas().edges.each(function(shape){
			if (shape.properties["oryx-direction"] == "left" || shape.properties["oryx-direction"] == "right") {
				this.addReadingDirection(shape);
			}
		}.bind(this));
	},
	
	/**
	 * calculates the height of a text, taking line breaks into consideration
	 *
	 * @param {Object} labelElement the label
	 * @param {String} the label test
	 */
	
	calculateLabelHeight : function (labelElement, labelValue) {
		var fontSize = labelElement.getFontSize();
		var newlineOccurences = 1;
		
		labelValue.scan('\n', function() { newlineOccurences += 1; });
		
		// 0.75 account for padding around the label
		return newlineOccurences * fontSize + 0.75;
	},
	
	/**
	 * Add Reading Direction to the name label after it has been changed
	 */
	handlePropertyChanged : function(event) {
		if (event["key"] == "oryx-name") {
			this.addReadingDirection(event.elements[0]);
		}
	},
	
	/**
	 * Layout class shapes.
	 *   - make text italic when abstract
	 *   - resize methods and attributes boxes according to their content
	 */
	handleLayoutClass : function(event) {
		var shape = event.shape;
		
		if (shape.propertiesChanged["oryx-abstract"] == true) {
			var className = event.shape.getLabels().find(
					function(label) { return label.id == (event.shape.id + "className") }
				);
			
			if (shape.properties["oryx-abstract"] == true) {
				className.node.setAttribute("font-style", "italic");
			} else {
				className.node.setAttribute("font-style", "normal");
			}
		}
		
		if (shape.propertiesChanged["oryx-attributes"] == true || shape.propertiesChanged["oryx-methods"]) {
			var attributesValue = event.shape.properties["oryx-attributes"];
			var methodsValue = event.shape.properties["oryx-methods"];
			var attributes = event.shape.getLabels().find(
					function(label) { return label.id == (event.shape.id + "attributes") }
				);
			var methods = event.shape.getLabels().find(
					function(label) { return label.id == (event.shape.id + "methods") }
				);
			var separator = event.shape._svgShapes.find(
					function(element) { return element.element.id == (event.shape.id + "separator") }
				).element;
					
					
			var attributesHeight = this.calculateLabelHeight(attributes, attributesValue);
			var methodsHeight = this.calculateLabelHeight(methods, methodsValue);
			
			// 24px account for the class name
			var distanceTilSeparator = 24 + attributesHeight + 2;
			var distanceTilBottom = distanceTilSeparator + methodsHeight + 2;
			
			separator.setAttribute("y1", distanceTilSeparator);
			separator.setAttribute("y2", distanceTilSeparator);
			
			// realign methods label (so that oryx' internal references are correct)
			methods.y = distanceTilSeparator + 3;
			methods.node.setAttribute("y", distanceTilSeparator + 3);
			// realign the methods line by line (required for a visual change)
			for (var i = 0; i < methods.node.childElementCount; i++) {
				methods.node.childNodes[i].setAttribute("y", distanceTilSeparator + 2);
			}
			
			// resize shape
			shape.bounds.set(
				shape.bounds.a.x, 
				shape.bounds.a.y, 
				shape.bounds.b.x, 
				shape.bounds.a.y + distanceTilBottom + 5
			);
		}
	},
	
	/**
	 * Layout the interface and enumeration shape. Resize according to their content.
	 */
	handleLayoutList : function(event) {
		var shape = event.shape;
		
		if (shape.propertiesChanged["oryx-items"] == true) {
			var itemsValue = shape.properties["oryx-items"];
			var items = shape.getLabels().find(
					function(label) { return label.id == (event.shape.id + "items") }
				);
			
			var itemsHeight = this.calculateLabelHeight(items, itemsValue);
		
			var distanceTilBottom = 32 + itemsHeight + 2;
			
			// resize shape
			shape.bounds.set(
				shape.bounds.a.x, 
				shape.bounds.a.y, 
				shape.bounds.b.x, 
				shape.bounds.a.y + distanceTilBottom + 5
			);
		}
	},
	
	/**
	 * Draws the reading direction arrow when an association is changed.
	 */
	handleLayoutAssociation : function(event) {
		this.addReadingDirection(event.shape);
	},
	
	/**
	 * Adds the reading direction to the "name" label of an association.
	 */ 
	addReadingDirection : function(shape) {
		var name = shape.getLabels().find(
					function(label) { return label.id == (shape.id + "name") }
				);
		
		if (shape.properties["oryx-direction"] == "left") {
			name.text("◀ " + shape.properties["oryx-name"]);
		}
		else if (shape.properties["oryx-direction"] == "right") {
			name.text(shape.properties["oryx-name"] + " ▶");
		}
		else {
			name.text(shape.properties["oryx-name"]);
		}
		
		name.update();
	},
	
	
	/**
	 * Resizes the qualifier box of a qualified association according to its content.
	 */
	handleLayoutQualifiedAssociation : function(event) {
		var shape = event.shape;
		var qualifier = shape.getLabels().find(
					function(label) { return label.id == (event.shape.id + "qualifier") }
				);
		
		var size = qualifier._estimateTextWidth(shape.properties["oryx-qualifier"], 12);
		// enforce minimum size, looks bad otherwise
		if (size < 40) size = 40;
		shape._markers.values()[0].element.lastElementChild.setAttribute("width", size+5);
		shape._markers.values()[0].element.setAttributeNS(null, "markerWidth", size+5)
	},
};

ORYX.Plugins.UML = Clazz.extend(ORYX.Plugins.UML);
/**
 * Copyright (c) 2010
 * Ralf Diestelkaemper
 *
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * The UMLUseCase plugin provides layout methods referring to the UMLUseCase stencilset. 
 * 
 * @class ORYX.Plugins.UMLUseCase
 * @extends Clazz
 * @param {Object} facade The facade of the editor
 */
ORYX.Plugins.UMLUseCase = 
/** @lends ORYX.Plugins.UMLUseCase.prototype */
{
	/**
	 * Creates a new instance of the UML plugin and registers it on the
	 * layout events listed in the UML UseCase stencil set.
	 * 
	 * @constructor
	 * @param {Object} facade The facade of the editor
	 */
	construct: function(facade) {
		this.facade = facade;
		this.facade.registerOnEvent('layout.uml.useCaseExtended', this.handleUseCaseExtendedLayout.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_LOADED, this.handleDiagramOnLoad.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_PROPWINDOW_PROP_CHANGED, this.handlePropertyChanged.bind(this));
	},
	
	/**
	 * Handles the layouting after loading a diagram
	 * This Function starts a recursion 
	 * which layouts the stereotypes of all systems and
	 * the UseCaseExtended.
	 *
	 * @param {Object} event The event, that is fired after a Use Case diagram is loaded
	 */
	handleDiagramOnLoad : function(event) {
		this.layoutAllSystems(this.facade.getCanvas());
	},
	
	/**
	* Recursivly layouts the system, 
	* all child systems and the UseCasesExtended the system includes
	*
	* @param {ORYX.Core.Node} system A system shape
	*/
	layoutAllSystems : function(system){
		
		this.layoutAllUseCaseExtended(system);
		
		var systems = system.getChildNodes().findAll( function(child) {
			if (this.isSystemNode(child)) {
				return child;
			}
		}.bind(this));
		
		systems.each(function(systemNode){ 
			this.layoutStereotype(systemNode);
			this.layoutAllSystems(systemNode); //recursion
		}.bind(this));
	
	},
	
	/**
	* Layouts all UseCasesExtended contained in the system
	*
	* @param {ORYX.Core.Node} system A system shape
	*/
	layoutAllUseCaseExtended : function(system){
		
		var useCasesExtended = system.getChildNodes().findAll(function(child) {
			if (this.isUseCaseExtendedNode(child)) {
				return child;
			}
		}.bind(this));
		
		useCasesExtended.each(function(useCaseExtendedNode){ 
			this.layoutUseCaseExtended(useCaseExtendedNode);
		}.bind(this));
	
	},
	
	/**
	* This method is called when a UseCaseExtended shape is modified.
	* It registers another handling method to the selection changed event, 
	* since that event is fired late enough to do the needed layouting.
	*
	* The chain of called methods, to do the layouting:
	*		handleUseCaseExtendedLayout(...) | layouting event fired
	*	->	handleUseCaseExtendedSelection(...) | selection event fired
	*	->	layoutUseCaseExtended(...) | simple method call
	*
	* @param {Object} event The event which is fired after the UseCaseExtended shape is modified
	*/
	handleUseCaseExtendedLayout : function(event) {
		
		var shape = event.shape;
		if (shape.isResized){
			this.SelectionEventFunction = this.handleUseCaseExtendedSelection.bind(this);
			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.SelectionEventFunction);
		}		
	},
	
	/**
	* This method is called after a UseCaseExtended shape is modified.
	* It deregisters itself on the selection changed event, 
	* since this event is fired late enough to do the needed layouting.
	*
	* First the method checks whether the event has a reference to a UseCaseExtended shape, 
	* since there is no guarantee.
	* 
	* @param {Object} event The event which is fired after the UseCaseExtended is resized
	*/
	handleUseCaseExtendedSelection : function(event) {
		
		var shape = event.elements.first();
		if (!this.isUseCaseExtendedNode(shape)) {return;}
		
		this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_SELECTION_CHANGED, this.SelectionEventFunction);
		this.layoutUseCaseExtended(shape);
	},
	
	/**
	* This method layouts the UseCaseExtended shape
	* It places the textframe and text which describe the extensions directly underneath 
	* the text "Extension Points"
	* Neither the resize attribute nor the anchors attribute had the desired effect.
	* 
	* @param {ORYX.Core.Node} useCaseExtended A UseCaseExtended shape
	*/
	layoutUseCaseExtended : function(useCaseExtended){
	
		var extensionPointTextFrame = useCaseExtended._svgShapes.find(
				function(element) { return element.element.id == (useCaseExtended.id + "extension_point_text_frame"); 
			}).element;
		var extensionPointText = useCaseExtended.getLabels().find(
				function(label) { return label.id == (useCaseExtended.id + "extensions"); 
			});
		var extensionText = useCaseExtended.getLabels().find(
				function(label) { return label.id == (useCaseExtended.id + "extensionpoint"); 
			});
		var verticalDifference = extensionPointTextFrame.y.baseVal.value - extensionText.y-16;
		extensionPointTextFrame.y.baseVal.value= extensionText.y+16;
		extensionPointText.y= extensionText.y+16;
		extensionPointTextFrame.height.baseVal.value += verticalDifference;	
	
	},	

	
	/**
	* Initiates the Stereotype layout
	* This method is called whenever a property of a shape is changed. 
	* It filters the events, which belong to a System shape and are fired,
	* when the stereotype or name is changed.
	*
	*@param {Object} event The event that is fired after changing a property of a shape.
	*/
	handlePropertyChanged : function(event) {
		var shape = event.elements.first();
		if (!this.isSystemNode(shape)) {return;}
		if (!(this.isStereotypeKeyEvent(event) || this.isNameKeyEvent(event))) {return;}
		this.layoutStereotype(shape);			
	},
	
	/**
	* Layouts the stereotype and name properties of a System shape
	* It places the stereotype and property of a System properly and hides the stereotype when necessary
	*
	*@param {ORYX.Core.Node} system The System shape the user modified the stereotype/name from.
	*/
	layoutStereotype: function(system) {
	
		var stereotype = system.getLabels().find(
				function(label) { return label.id == (system.id + "stereotype"); 
			});
		var name = system.getLabels().find(
				function(label) { return label.id == (system.id + "text"); 
			});
		
		if (stereotype.text().empty()){
					name.y=stereotype.y;
					stereotype.hide();
				}else{
					name.y = stereotype.y+14;
					stereotype.show();
					stereotype.text("≪" + system.properties["oryx-stereotype"] + "≫");
				}
		name.update();
		stereotype.update();
	},
	
	/**
	* Helper method, which returns true, if the received shape is an extended Use Case. 
	*@private
	*@param {Object} shape The shape that is checked for beeing an extended Use Case.
	*@return {boolean} The result is true, if the shape is an extended Use Case.
	*/
	isUseCaseExtendedNode : function(shape) {
		return "http://b3mn.org/stencilset/umlusecase#usecaseextended" == shape.getStencil().id().toLowerCase();
	},
	
	/**
	* Helper method, which returns true, if the received shape is an  Use Case. 
	*@private
	*@param {Object} shape The shape that is checked for beeing an  Use Case.
	*@return {boolean} The result is true, if the shape is an  Use Case.
	*/
	isUseCaseNode : function(shape) {
		return "http://b3mn.org/stencilset/umlusecase#usecase" == shape.getStencil().id().toLowerCase();
	},

	
	/**
	* Helper method, which returns true, if the received shape is a system. 
	*@private
	*@param {Object} shape The shape that is checked for beeing a system.
	*@return {boolean} The result is true, if the shape is a system
	*/
	isSystemNode : function(shape) {
		return "http://b3mn.org/stencilset/umlusecase#system" == shape.getStencil().id().toLowerCase();
	},
	
	/**
	* Helper method, which returns true, if the received shape is an include edge. 
	*@private
	*@param {Object} shape The shape that is checked for beeing an include edge.
	*@return {boolean} The result is true, if the shape is an include edge
	*/
	isIncludeEdge : function(shape) {
		return "http://b3mn.org/stencilset/umlusecase#include" == shape.getStencil().id().toLowerCase();
	},
	
	/**
	* Helper method, which returns true, if the received shape is an extend edge. 
	*@private
	*@param {Object} shape The shape that is checked for beeing an extend edge.
	*@return {boolean} The result is true, if the shape is an extend edge
	*/
	isExtendEdge : function(shape) {
		return "http://b3mn.org/stencilset/umlusecase#extend" == shape.getStencil().id().toLowerCase();
	},
	
	/**
	* Helper method, which returns true, if the received event handles a stereotype.
	*@private 
	*@param {Object} event The event that is checked for handling an oryx-stereotype.
	*@return {boolean} The result is true, if event handles a stereotype
	*/
	isStereotypeKeyEvent : function(event) {
		return event["key"] == "oryx-stereotype";
	},
	
	/**
	* Helper method, which returns true, if the received event handles a name.
	*@private 
	*@param {Object} event The event that is checked for handling an oryx-name.
	*@return {boolean} The result is true, if event handles a name
	*/
	isNameKeyEvent : function(event) {
		return event["key"] == "oryx-name";
	}
};

ORYX.Plugins.UMLUseCase = Clazz.extend(ORYX.Plugins.UMLUseCase);

/**
 * Copyright (c) 2010
 * Ralf Diestelkaemper
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

/**
 * @namespace Oryx name space for plugins
 * @name ORYX.Plugins
*/
 if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

/**
 * The UMLActivity plugin provides layout methods referring to the UMLActivity stencilset. 
 * 
 * @class ORYX.Plugins.UMLActivity
 * @extends Clazz
 * @param {Object} facade The facade of the editor
 */
 ORYX.Plugins.UMLActivity = 
/** @lends ORYX.Plugins.UMLActivity.prototype */
{
	/**
	 * Creates a new instance of the UMLActivity plugin and registers it on the
	 * layout events listed in the UMLActivity stencil set.
	 * 
	 * @constructor
	 * @param {Object} facade The facade of the editor
	 */
	construct: function(facade) {
		this.facade = facade;
		this.facade.registerOnEvent('layout.uml.activityPartition', this.handleLayoutActivityPartition.bind(this));
	},
	
	/**
	  * Global variable which contains a hashmap of the bounds of the activityPartions in the diagram
	  * @private
	  */
	hashedBounds : {}, 
	
	/**
	 * Handler for layouting event 'layout.uml.activityPartition'
	 * Initiates also the layouting and hashing of the bounds of all activityPartitions
	 * @param {Object} event This event is fired when an activityPartition Node is moved/resized/edited
	 */
	handleLayoutActivityPartition: function(event){
		
		var rootPartition = event.shape;
		var directChildPartitions = this.getChildActivityPartitions(rootPartition, false);
		
		var currentShape = this.facade.getSelection().first(); 
		currentShape = currentShape || rootPartition;
		
		//Guards
		if (this.isActivityPartitionNode(rootPartition.parent)) {return;}
		if(!this.isActivityPartitionNode(rootPartition)) {return;}
		if (!this.isActivityPartitionNode(currentShape)) {return;}
		if (directChildPartitions.length <= 0) {return;}
		
		this.currentRootPartition = rootPartition;
		
		if (!this.hashedBounds[rootPartition.resourceId]) {
			this.hashedBounds[rootPartition.resourceId] = {};
		}
				
		var allChildPartitions = this.getChildActivityPartitions(rootPartition, true);
		var addedPartitions = this.getAllAddedPartitions(allChildPartitions);
		var deletedPartitions = this.getAllDeletedPartitions(allChildPartitions);
				
		if (addedPartitions.length > 0){
			currentShape = addedPartitions.first();
		}
		
		// layouting 
		if (deletedPartitions.length > 0 || addedPartitions.length > 0) {
			this.resizeAfterAddorDeleteOfPartition(rootPartition, directChildPartitions);
		}
		else if (rootPartition == currentShape) {
			this.resizeAfterRootPartitionChangend ( rootPartition, directChildPartitions);
		}	
		else {
			this.resizeAfterChildPartitionChanged ( rootPartition, directChildPartitions, currentShape);
		}
				
		this.cachePositions(rootPartition, allChildPartitions);
	},
	/**
	 * Caches the bounds of an activityPartiton in a two dimensional array
	 * The in the first dimension the rootPartition is saved, in the second dimension allChildPartitions are saved
	 * @private
	 * @param {ORYX.Core.Node} rootPartition This parameter a an activityPartition, whose parent is not an activityPartition
	 * @param {ORYX.Core.Node[]} allChildPartitions This parameter is an array of all child partitions of the rootPartition
	 * 
	 */
	cachePositions : function(rootPartition, allChildPartitions) {
		this.hashedBounds[rootPartition.resourceId] = {};
		allChildPartitions.each(function(partition){
				this.hashedBounds[rootPartition.resourceId][partition.resourceId] = partition.absoluteBounds();
				this.forceToUpdateActivityPartition(partition);
			}.bind(this));
	},
	
	/**
	 * Resizes all activityPartitions which belong to the rootPartition
	 * after a partition is added or deleted
	 * @private
	 * @param {ORYX.Core.Node} rootPartition This parameter a an activityPartition, whose parent is not an activityPartition
	 * @param {ORYX.Core.Node[]} directChildPartitions This parameter is an array of all direct child partitions of the rootPartition
	 */
	resizeAfterAddorDeleteOfPartition : function (rootPartition, directChildPartitions){
		var width, height;
		width = this.updateActivityPartitionWidth(rootPartition);
		height = this.adjustActivityPartitionHeight(directChildPartitions, rootPartition.bounds.height());	
		rootPartition.update();
		this.setActivityPartitionDimensions(rootPartition, width, height);
	},
	
	/**
	 * Resizes all activityPartitions which belong to the rootPartition
	 * after the rootPartition is resized/moved
	 * @private
	 * @param {ORYX.Core.Node} rootPartition This parameter a an activityPartition, whose parent is not an activityPartition
	 * @param {ORYX.Core.Node[]} directChildPartitions This parameter is an array of all direct child partitions of the rootPartition
	 */
	resizeAfterRootPartitionChangend : function (rootPartition, directChildPartitions){
		var width, height;
		width = this.adjustActivityPartitionWidth(directChildPartitions, undefined, rootPartition.bounds.width());
		height = this.adjustActivityPartitionHeight(directChildPartitions, rootPartition.bounds.height());
		this.setActivityPartitionDimensions(rootPartition, width, height);
	},
	
	/**
	 * Resizes all activityPartitions which belong to the rootPartition
	 * after the rootPartition is resized/moved
	 * @private
	 * @param {ORYX.Core.Node} rootPartition This parameter a an activityPartition, whose parent is not an activityPartition
	 * @param {ORYX.Core.Node[]} directChildPartitions This parameter is an array of all direct child partitions of the rootPartition
	 * @param {ORYX.Core.Node} currentShape This parameter is the shape that caused the event
	 */
	resizeAfterChildPartitionChanged : function ( rootPartition, directChildPartitions, currentShape){
		var width, height;
		width = this.adjustActivityPartitionWidth(directChildPartitions, currentShape);
		height = this.adjustActivityPartitionHeight(directChildPartitions, currentShape.bounds.height()+(this.getDepth(currentShape,rootPartition)*30));
		this.setActivityPartitionDimensions(rootPartition, width, height);
	},
	
	/**
	 * Finds all Partitions, which are added to the currentRootPartition
	 * At the time a layouting event is fired the lanes are already children 
	 * of the currentRootPartition, but they are not added to the hashedBounds
	 * @private
	 * @param {ORYX.Core.Node[]} allChildPartitions This parameter is an array of all child partitions of the rootPartition
	 * @return {ORYX.Core.Node[]} The result is an array of all added partitions
	 */
	getAllAddedPartitions : function (allChildPartitions){
			return allChildPartitions.findAll(function(shape) {
					if (!this.hashedBounds[this.currentRootPartition.resourceId][shape.resourceId]) {return shape;}
					}.bind(this));
	},
	
	/**
	 * Finds all Partitions, which are deleted from the currentRootPartition
	 * At the time a layouting event is fired the lanes are not children of the 
	 * currentRootPartition any more, but they are still referenced in the hashedBounds 
	 * @private
	 * @param {ORYX.Core.Node[]} allChildPartitions This parameter is an array of all child partitions of the rootPartition
	 * @return {ORYX.Core.Node[]} The result is an array of all deleted partitions
	 */
	getAllDeletedPartitions : function (allChildPartitions){
	
		var resourceIds = $H(this.hashedBounds[this.currentRootPartition.resourceId]).keys();
		
		var deletedResourceIds = resourceIds.reject(function (resourceId){
			return allChildPartitions.any(function(partition){ 
				return partition.resourceId == resourceId;
		});}); 
		
		var deletedPartitions = deletedResourceIds.findAll(function(resourceId) {
			return this.hashedBounds[this.currentRootPartition.resourceId][resourceId];
		}.bind(this));
		
		return deletedPartitions;
		
	},
	
	/**
	 * Forces an activityPartition to update itself, 
	 * if the width saved in the stencil, that belongs to 
	 * the shape is different, to avoid inconsistencies
	 * @private
	 * @param {ORYX.Core.Node} partition This parameter is an Partition in an incosistent layouting state
	 */
	forceToUpdateActivityPartition: function(partition){
		
		if (partition.bounds.width() !== partition._svgShapes[0].width) {	
			partition.isChanged = true;
			partition.isResized = true;
			partition._update();
		}
	},
	
	/**
	 * Forces an activityPartition to update itself, 
	 * if the width saved in the stencil, that belongs to 
	 * the shape is different, to avoid inconsistencies
	 * @private
	 * @param {ORYX.Core.Node} partition This parameter is an Partition in an incosistent layouting state
	 */
	getDepth: function(child, parent){
		
		var i=0;
		while(child && child.parent && child !== parent){
			child = child.parent;
			++i;
		}
		return i;
	},
	
	/**
	 * Sets the bounds and therefore the size of an ActivityPartition
	 * @private
	 * @param {ORYX.Core.Node} partition This parameter is an Partition which gets new bounds
	 * @param {number} width The new width of the Partition
	 * @param {number} height The new height of the Partition
	 */
	setActivityPartitionDimensions: function (partition, width, height){
		var isChildActivityPartition = this.isActivityPartitionNode(partition);
		isChildActivityPartition = (isChildActivityPartition && this.isActivityPartitionNode(partition.parent));
		partition.bounds.set(
			partition.bounds.a.x,
			isChildActivityPartition ? 30 : partition.bounds.a.y,
			width ? partition.bounds.a.x + width : partition.bounds.b.x,
			height ? partition.bounds.a.y + height - (isChildActivityPartition ? 30:0) : partition.bounds.b.y
		);
	},
	
	/**
	 * Lowers an ActivityPartition, so that the head of the parent partition is visible
	 * @private
	 * @param {ORYX.Core.Node} shape This parameter is a shape which gets new position
	 * @param {number} x The new relative Offset to the left edge of parent partition 
	 */
	setActivityPartitionPosition: function(shape, x){
		shape.bounds.moveTo(x, 30);
	},
	
	/**
	 * Sets recursively the new height of the child partitions
	 * @private
	 * @param {ORYX.Core.Node[]} partitions Array of all direct child nodes
	 * @param {number} height The new height for the partitions 
	 */
	adjustActivityPartitionHeight: function(partitions, height) {
		(partitions||[]).each(function(partition){
			this.setActivityPartitionDimensions(partition, null, height);
			this.adjustActivityPartitionHeight(this.getChildActivityPartitions(partition), height-30);
		}.bind(this));
		return height;
	},
	
	/**
	 * Sets recursively the new width of the child partitions 
	 * regarding to the partition which was changed
	 * @private
	 * @param {ORYX.Core.Node[]} activityPartitions Array of all direct childPartitions
	 * @param {ORYX.Core.Node} activityPartition The activityPartition which is not changed
	 * @param {number} propagateWidth The width 
	 * @return {number} The new width for the parent activityPartition
	 */
	adjustActivityPartitionWidth: function(activityPartitions, changedActivityPartition, propagateWidth){
		
		// you cannot place oldWidth in the else if part even though the condition is the same, 
		// because down there you are inside the inject part at var width
		var oldWidth = 0;	
		if(!changedActivityPartition && propagateWidth){
			oldWidth = activityPartitions.inject(0, function(widthAcc, partition) {
				return widthAcc + partition.bounds.width();});
		} 
		
		var width = activityPartitions.inject(0, function (widthAcc, partition) {
				
			if (partition === changedActivityPartition) {
				this.propagateWidthToChildren(partition, widthAcc); //recursive
			} else if (!changedActivityPartition && propagateWidth) {
				this.setChildWidthProportionallyToTheOldWidth(partition, widthAcc, propagateWidth, oldWidth); //recursive
			} else {
				this.getWidthFromChildPartitions(partition, widthAcc, propagateWidth, changedActivityPartition); //recursive
			}				
				return widthAcc + partition.bounds.width();
			}.bind(this));
		return width;
	},
	
	/**
	 * Sets the size of the changed partition and informs the children of the partition
	 * that the partition was horizontally resized
	 * @private
	 * @param {ORYX.Core.Node} partition The partition which needs resizing
	 * @param {number} currentWidth The width the partition will receive
	 */
	propagateWidthToChildren: function(partition, currentWidth){
		this.adjustActivityPartitionWidth(this.getChildActivityPartitions(partition), undefined, partition.bounds.width()); //recursion
		partition.bounds.set({y:30, x:currentWidth}, {y:partition.bounds.height()+30, x:partition.bounds.width()+currentWidth});
	},
	
	/**
	 * Sets the width of the partition (which was actually not resized by the user) 
	 * proportionally to the width of its sibling and informs the children
	 * of the partition that the partition was horizontally resized
	 * @private
	 * @param {ORYX.Core.Node} partition The partition which is resized
	 * @param {number} offset The horizontal offset this partition receives, since it may have siblings to its left
	 * @param {number} propagateWidth The new width the parent partition has
	 * @param {number} oldWidth The width the parent partition had before
	 */
	setChildWidthProportionallyToTheOldWidth: function(partition, offset, propagateWidth, oldWidth){
				
		var newWidth = (partition.bounds.width() * propagateWidth) / oldWidth;
				this.adjustActivityPartitionWidth(this.getChildActivityPartitions(partition), undefined, newWidth); //recursion
				this.setActivityPartitionDimensions(partition,newWidth, null);
				this.setActivityPartitionPosition(partition, offset);
	},
	
	/**
	 * Sets the width of the partition (which was actually not resized by the user) 
	 * proportionally to the width of its sibling and informs the children
	 * of the partition that the partition was horizontally resized
	 * @private
	 * @param {ORYX.Core.Node} partition The partition which is resized
	 * @param {number} offset The horizontal offset this partition receives, since it may have siblings to its left
	 * @param {number} propagateWidth The new recommended width of the partition
	 * @param {ORYX.Core.Node} changedActivityPartition The partition the user changed
	 */
	getWidthFromChildPartitions: function(partition, offset, propagateWidth, changedActivityPartition){
				var newWidth = this.adjustActivityPartitionWidth(this.getChildActivityPartitions(partition), changedActivityPartition, propagateWidth);//recursion
				
				if (!newWidth) {
					newWidth = partition.bounds.width();
				}
				
				this.setActivityPartitionDimensions(partition, newWidth, null);
				this.setActivityPartitionPosition(partition, offset);
	},
	
	/**
	 * Updates the width of all partitions when partitions were added or deleted
	 * @private
	 * @param {ORYX.Core.Node} rootPartition The partition which is resized 
	 */
	updateActivityPartitionWidth: function(rootPartition){
		var activityPartitions = this.getChildActivityPartitions(rootPartition);
		if (activityPartitions.length === 0){
			return rootPartition.bounds.width();
		}
		
		var width = activityPartitions.inject(0,function (widthAcc, partition){
			this.setActivityPartitionPosition(partition, widthAcc);
			return widthAcc + this.updateActivityPartitionWidth(partition);
		}.bind(this));
		
		
		this.setActivityPartitionDimensions(rootPartition, width, null);
		
		return width;
	},
	
	/**
	 * Returns the hashed bounds of the partition if they are available
	 * otherwise a copy of the partition's bounds.
	 * @private
	 * @param {ORYX.Core.Node} partition The partition for which there are hashed bounds if it is an activityPartition
	 * @return {ORYX.Core.Bounds} The hashed bounds or a copy of the partition's bounds
	 */
	getHashedBounds: function(partition){
		return this.currentRootPartition && this.hashedBounds[this.currentRootPartition.resourceId][partition.resourceId] ? this.hashedBounds[this.currentRootPartition.resourceId][partition.resourceId] : partition.bounds.clone();
	},
	
	/**
	* Helper method, which returns true, if the received shape is an Activiy Partition. 
	*@private
	*@param {ORYX.Core.Node} shape The shape that is checked for being an Activiy Partition.
	*@return {boolean} The result is true, if the shape is an Activiy Partition.
	*/
	isActivityPartitionNode : function (shape) {
		return "http://b3mn.org/stencilset/umlactivity#activitypartition" == shape.getStencil().id().toLowerCase();
	},
	
	/**
	 * Returns a sorted set on all child activityPartitions for the given partition. If recursive is TRUE, also indirect children will be returned (default is FALSE)
	 * The set is sorted with the first child the lowest x-coordinate and the last one the highest.
	 * @param {ORYX.Core.Node} partition The partition the direct/all children were asked for
	 * @param {boolean} recursive Specifies, whether the you receive the direct or all children (default is FALSE = direct children)
	 * @return {ORYX.Core.Node[]} An ordered set of the child nodes with the first child the lowest x-coordinate and the last one the highest
	 */
	getChildActivityPartitions: function(partition, recursive){
		var activityPartitions = partition.getChildNodes(recursive||false).findAll(function(node) { 
			if (this.isActivityPartitionNode(node)) {
				return node;
			}}.bind(this));
		activityPartitions = activityPartitions.sort(function(a, b){
			// Get x coordinate
			var ax = Math.round(a.bounds.upperLeft().x);
			var bx = Math.round(b.bounds.upperLeft().x);
					
			// If equal, than use the old one
			if (ax == bx) {
				ax = Math.round(this.getHashedBounds(a).upperLeft().x);
				bx = Math.round(this.getHashedBounds(b).upperLeft().x);
			}
				return  ax < bx ? -1 : (ax > bx ? 1 : 0);
			}.bind(this));
		return activityPartitions;
	}
};

ORYX.Plugins.UMLActivity = Clazz.extend(ORYX.Plugins.UMLActivity);
/** * Copyright (c) 2006 * Martin Czuchra, Nicolas Peters, Daniel Polak, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if (!ORYX.Plugins)     ORYX.Plugins = new Object();ORYX.Plugins.OverlayExample = Clazz.extend({    facade: undefined,        construct: function(facade){		        this.facade = facade;        		this.active = false;		this.el 	= undefined;		this.callback = undefined;		        this.facade.offer({            'name': "Overlay Test",            'functionality': this.testing.bind(this),            'group': "Overlay",            'icon': ORYX.PATH + "images/disk.png",            'description': "Overlay Test",            'index': 1,            'minShape': 0,            'maxShape': 0        });		    },    	testing: function(){		if (this.active) {						this.facade.raiseEvent({				type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,				id: "overlaytest.test"			});					} else {						var els = this.facade.getCanvas().getChildShapes(true);						this.el = els[0]			this.showOverlay( this.el )					}				this.active = !this.active;					if( this.active ){			this.callback = this.doMouseUp.bind(this)			this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)		} else {			this.facade.unregisterOnEvent(ORYX.CONFIG.EVENT_MOUSEUP, this.callback)			this.callback = undefined;		}							},		doMouseUp: function(event, arg){		if( arg instanceof ORYX.Core.Shape && arg != this.el){			this.el = arg;			this.showOverlay( this.el )		}	},		showOverlay: function(shape){		var cross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,					['path', {						"stroke-width": 5.0, "stroke":"red", "d":  "M0,0 L-15,-15 M-15,0 L0,-15", "line-captions": "round"						}]);									this.facade.raiseEvent({				type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,				id: 			"overlaytest.test",				shapes: 		[shape],				attributes: 	{fill: "red", stroke:"green", "stroke-width":4},				node:			cross,				nodePosition:	shape instanceof ORYX.Core.Edge ? "START" : "NE"			});						}	    });if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.PluginLoader = Clazz.extend({
	
    facade: undefined,
	mask: undefined,
	processURI: undefined,
	
    construct: function(facade){
		this.facade = facade;
		
		this.facade.offer({
			'name': ORYX.I18N.PluginLoad.AddPluginButtonName,
			'functionality': this.showManageDialog.bind(this),
			'group': ORYX.I18N.SSExtensionLoader.group,
			'icon': ORYX.PATH + "images/labs/script_add.png",
			'description': ORYX.I18N.PluginLoad.AddPluginButtonDesc,
			'index': 8,
			'minShape': 0,
			'maxShape': 0
		});},
	showManageDialog: function(){
			this.mask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.Oryx.pleaseWait});
			this.mask.show();
	var data=[];
	//(var plugins=this.facade.getAvailablePlugins();
	var plugins=[];
	var loadedStencilSetsNamespaces = this.facade.getStencilSets().keys();
	//get all plugins which could be acivated
	this.facade.getAvailablePlugins().each(function(match) {
	if ((!match.requires 	|| !match.requires.namespaces 	
			|| match.requires.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }) )
		&&(!match.notUsesIn 	|| !match.notUsesIn.namespaces 	
				|| !match.notUsesIn.namespaces.any(function(req){ return loadedStencilSetsNamespaces.indexOf(req) >= 0 }))){
		plugins.push( match );

	}});
	
	plugins.each(function(plugin){
			data.push([plugin.name, plugin.engaged===true]);
			})
		if(data.length==0){return};
		var reader = new Ext.data.ArrayReader({}, [
        {name: 'name'},
		{name: 'engaged'} ]);
		
		var sm = new Ext.grid.CheckboxSelectionModel({
			listeners:{
			beforerowselect: function(sm,nbr,exist,rec){
			this.mask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.Oryx.pleaseWait});
			this.mask.show();
				this.facade.activatePluginByName(rec.data.name, 
						function(sucess,err){
						this.mask.hide();

							if(!!sucess){
								sm.suspendEvents();
								sm.selectRow(nbr, true);
								sm.resumeEvents();
							}else{
								Ext.Msg.show({
		   							   title: ORYX.I18N.PluginLoad.loadErrorTitle,
									   msg: ORYX.I18N.PluginLoad.loadErrorDesc + ORYX.I18N.PluginLoad[err],
									   buttons: Ext.MessageBox.OK
									});
							}}.bind(this));
				return false;
				}.bind(this),
			rowdeselect: function(sm,nbr,rec){
						sm.suspendEvents();
						sm.selectRow(nbr, true);
						sm.resumeEvents();
					}
			}});
	    var grid2 = new Ext.grid.GridPanel({
	    		store: new Ext.data.Store({
		            reader: reader,
		            data: data
		        	}),
		        cm: new Ext.grid.ColumnModel([
		            
		            {id:'name',width:390, sortable: true, dataIndex: 'name'},
					sm]),
			sm: sm,
	        width:450,
	        height:250,
	        frame:true,
			hideHeaders:true,
	        iconCls:'icon-grid',
			listeners : {
				render: function() {
					var recs=[];
					this.grid.getStore().each(function(rec){

						if(rec.data.engaged){
							recs.push(rec);
						}
					}.bind(this));
					this.suspendEvents();
					this.selectRecords(recs);
					this.resumeEvents();
				}.bind(sm)
			}
	    });

		var newURLWin = new Ext.Window({
					title:		ORYX.I18N.PluginLoad.WindowTitle, 
					//bodyStyle:	"background:white;padding:0px", 
					width:		'auto', 
					height:		'auto',
					modal:		true
					//html:"<div style='font-weight:bold;margin-bottom:10px'></div><span></span>",
				});
		newURLWin.add(grid2);
		newURLWin.show();
		this.mask.hide();

		}
		})
			/** * Copyright (c) 2008-2009 * Sven Wagner-Boysen, Willi Tscheschner * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.BPMN = {	/**	 *	Constructor	 *	@param {Object} Facade: The Facade of the Editor	 */	construct: function(facade) {		this.facade = facade;		this.facade.registerOnEvent('layout.bpmn.pool', this.handleLayoutBPMNPool.bind(this));				//this.facade.registerOnEvent('layout.bpmn11.lane', this.handleLayoutLane.bind(this));	},	handleLayoutBPMNPool: function(event){				var shape = event.shape;			var lanes = shape.getChildNodes(false).findAll(function(node) {			return (node.getStencil().id() === "http://b3mn.org/stencilset/bpmn#Lane");		});				if(lanes.length > 0) {					lanes = lanes.sortBy(function(lane) {				return lane.bounds.upperLeft().y;			});						var shapeWidth = shape.bounds.width();			var shapeHeight = 0;			var topBound = 0;			lanes.each(function(lane) {				var ul = lane.bounds.upperLeft();				var lr = lane.bounds.lowerRight();				ul.y = shapeHeight;				lr.y = ul.y + lane.bounds.height();				shapeHeight += lane.bounds.height();				ul.x = 30;				lr.x = shapeWidth;				lane.bounds.set(ul, lr);			});						var upl = shape.bounds.upperLeft();			shape.bounds.set(upl.x, upl.y, shape.bounds.lowerRight().x, upl.y + shapeHeight);		}		}};ORYX.Plugins.BPMN = ORYX.Plugins.AbstractPlugin.extend(ORYX.Plugins.BPMN);/**
 * Copyright (c) 2009, Matthias Kunze, Kai Schlichting
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = {};

if (!ORYX.Config)
	ORYX.Config = {};

ORYX.Config.Feedback = {
	VISIBLE_STATE: "visible",
	HIDDEN_STATE: "hidden",
	INFO: "Lorem ipsum dolor sit amet, consectetur adipiscing elit, set eiusmod tempor incidunt et labore et dolore magna aliquam. Ut enim ad minim veniam, quis nostrud exerc. Irure dolor in reprehend incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse molestaie cillum. Tia non ob ea soluad incommod quae egen ium improb fugiend. Officia",
	CSS_FILE: ORYX.PATH + "/css/feedback.css"
}

ORYX.Plugins.Feedback = ORYX.Plugins.AbstractPlugin.extend({
	
    construct: function(facade, data){
		/*
		 * data.name == "ORYX.Plugins.Feedback"
		 * data.source == "feedback.js"
		 * data.properties ... properties defined in plugins.xml/profiles.xml [{key:value}, ...]
		 */
	
		this.facade = facade;
	
		// extract properties, we're interested in
		((data && data.properties) || []).each(function(property){
			if (property.cssfile) {ORYX.Config.Feedback.CSS_FILE = property.css_file}
		}.bind(this));
		
        // load additional css information
        var fileref = document.createElement("link");
            fileref.setAttribute("rel", "stylesheet");
            fileref.setAttribute("type", "text/css");
            fileref.setAttribute("href", ORYX.Config.Feedback.CSS_FILE);
        document.getElementsByTagName("head")[0].appendChild(fileref);

        // declare HTML references
        this.elements = {
    		container: null,
    		tab: null,
    		dialog: null,
			form: null,
			info: null
    	}
        
        // create feedback tab
        this.createFeedbackTab();
        
    },
    
    /**
     * Creates the feedback tab, which is used to open the feedback dialog.
     */
    createFeedbackTab: function(){
    	this.elements.tab = document.createElement("div");
    	this.elements.tab.setAttribute("class", "tab");
		this.elements.tab.innerHTML = (ORYX.I18N.Feedback.name + " &#8226;")
    	
    	this.elements.container = document.createElement("div");
    	this.elements.container.setAttribute("id", "feedback");
    	
    	this.elements.container.appendChild(this.elements.tab);
    	document.body.appendChild(this.elements.container);
          	    	
    	// register events
    	Event.observe(this.elements.tab, "click", this.toggleDialog.bindAsEventListener(this));
    },
    
    /**
     * Hides or shows the feedback dialog
     */
    toggleDialog: function(event) {

		if (event) {
			Event.stop(event);			
		}

    	var dialog = this.elements.dialog || this.createDialog();
    	
    	if (ORYX.Config.Feedback.VISIBLE_STATE == dialog.state) {
			this.elements.tab.innerHTML = (ORYX.I18N.Feedback.name + " &#8226;");
    		Element.hide(dialog);
    		dialog.state = ORYX.Config.Feedback.HIDDEN_STATE;
    	} 
    	else {
			this.elements.tab.innerHTML = (ORYX.I18N.Feedback.name + " &#215;");
    		Element.show(dialog);
    		dialog.state = ORYX.Config.Feedback.VISIBLE_STATE;
    	}

    },
    
    /**
     * Creates the feedback dialog
     */
    createDialog: function() {
    	if (this.elements.dialog) {
    		return this.elements.dialog;
    	}

		// reset the input formular
		var resetForm = function() {
			[description, title, mail].each(function(element){
				element.value = element._defaultText || "";
				element.className = "low";
			});
		}

		// wrapper for field focus behavior
		var fieldOnFocus = function(event) {
			var e = Event.element(event);
			if (e._defaultText && e.value.strip() == e._defaultText.strip()) {
				e.value = "";
				e.className = "high";
			}
		}		
		var fieldOnBlur = function(event) {
			var e = Event.element(event);
			if (e._defaultText && e.value.strip() == "") {
				e.value = e._defaultText;
				e.className = "low";
			}
		}

    	// create form and submit logic (ajax)
		this.elements.form = document.createElement("form");
		this.elements.form.action = ORYX.CONFIG.ROOT_PATH + "feedback";
		this.elements.form.method = "POST";
		this.elements.form.onsubmit = function(){
			
			try {
				
				var failure = function() {
					Ext.Msg.alert(ORYX.I18N.Feedback.failure, ORYX.I18N.Feedback.failureMsg);
	                this.facade.raiseEvent({
	                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
	                });
					// show dialog again with old information
					this.toggleDialog();
				}
				
				var success = function(transport) {
					if (transport.status < 200 || transport.status >= 400) {
						return failure(transport);
					}
					this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_LOADING_STATUS,
						text:ORYX.I18N.Feedback.success
					});
					resetForm();
				}
				
			
				this.elements.form.model.value = this.facade.getSerializedJSON();
				this.elements.form.environment.value = this.getEnv();
			
				var params = {};
				$A(this.elements.form.elements).each(function(element){
					params[element.name] = element.value;
				});
				params["name"]= ORYX.Editor.Cookie.getParams().identifier;
				params["subject"] = ("[" + params["subject"] + "] " + params["title"]);
				this.facade.raiseEvent({
					type:ORYX.CONFIG.EVENT_LOADING_STATUS,
					text:ORYX.I18N.Feedback.sending
				});
				new Ajax.Request(ORYX.CONFIG.ROOT_PATH + "feedback", {
					method: "POST",
					parameters: params,
					onSuccess: success.bind(this),
					onFailure: failure.bind(this)
				});
			
				// hide dialog immediately 
				this.toggleDialog();
			}
			catch(e) {
				failure();
				ORYX.Log.warn(e);
			}
			// stop form submission through browser
			return false; 
		}.bind(this);
		
		
		// create input fields
		var fieldset = document.createElement("div");
			fieldset.className = "fieldset";
		    
		var f_subject = document.createElement("input");
		    f_subject.type = "hidden";
			f_subject.name = "subject";
			f_subject.style.display = "none";
		
		var description = document.createElement("textarea");
			description._defaultText = ORYX.I18N.Feedback.descriptionDesc;
		    description.name = "description";
		Event.observe(description, "focus", fieldOnFocus.bindAsEventListener());
		Event.observe(description, "blur", fieldOnBlur.bindAsEventListener());
		
		var title = document.createElement("input");
			title._defaultText = ORYX.I18N.Feedback.titleDesc;
			title.type = "text";
			title.name = "title";
		Event.observe(title, "focus", fieldOnFocus.bindAsEventListener());
		Event.observe(title, "blur", fieldOnBlur.bindAsEventListener());
			
		var mail = document.createElement("input");
			mail._defaultText = ORYX.I18N.Feedback.emailDesc;
			mail.type = "text";
			mail.name = "email";
		Event.observe(mail, "focus", fieldOnFocus.bindAsEventListener());
		Event.observe(mail, "blur", fieldOnBlur.bindAsEventListener());
		
		var submit = document.createElement("input");
			submit.type = "button";
			submit.className = "submit";
			submit.onclick=this.elements.form.onsubmit;
			if (ORYX.I18N.Feedback.submit) {
				submit.value = ORYX.I18N.Feedback.submit;
			}
			
		var environment = document.createElement("input");
			environment.name = "environment";
			environment.type = "hidden";
			environment.style.display = "none";
			
		var model = document.createElement("input");
			model.name = "model"
			model.type = "hidden";
			model.style.display = "none";
			
		fieldset.appendChild(f_subject);
		fieldset.appendChild(description);
		fieldset.appendChild(title);
		fieldset.appendChild(mail);
		fieldset.appendChild(environment);
		fieldset.appendChild(model);
		fieldset.appendChild(submit);
		
		// (p)reset default values of input fields
		resetForm();
			
		// create subjects
		var list = document.createElement("ul");
	    list.setAttribute("class", "subjects");
		
		var l_subjects = [];
		
		$A(ORYX.I18N.Feedback.subjects).each( function(subject, index){
			try {
				
				// create list item
				var item = document.createElement("li");
					item._subject = subject.id;
				    item.className = subject.id;
					item.innerHTML = subject.name;
					item.style.width = parseInt(100/$A(ORYX.I18N.Feedback.subjects).length)+"%"; // set width corresponding to number of subjects
				
				// add subjects to list
				l_subjects.push(item);
				list.appendChild(item);

				var handler = function(){
					l_subjects.each(function(element) {
						if (element.className.match(subject.id)) { // if current element is selected
							element.className = element._subject + " active";
							f_subject.value = subject.name;
							
							// update description, depending on subject if input field is empty
							if (description.value == description._defaultText) {
								description.value = subject.description;
							}
							
							// set _defaultText to newly selected subject
							description._defaultText = subject.description;
							
							// set info pane if appropriate
							if (subject.info && (""+subject.info).strip().length > 0) {
								this.elements.info.innerHTML = subject.info;
							}
							else {
								this.elements.info.innerHTML = ORYX.I18N.Feedback.info || "";
							}
						}
						else {
							element.className = element._subject;
						}
					}.bind(this));
				}.bind(this);
				
				// choose/unchoose topics
				Event.observe(item, "click", handler);
				
				// select last item
				if (index == (ORYX.I18N.Feedback.subjects.length - 1)) {
					description.value = "";
					description._defaultText = "";
					
					handler();
				}
				
			} // if something goes wrong, we wont give up, just ignore it
			catch (e) {
				ORYX.Log.warn("Incomplete I10N for ORYX.I18N.Feedback.subjects", subject, ORYX.I18N.Feedback.subjects)
			}
		}.bind(this));
	
		this.elements.form.appendChild(list);
		this.elements.form.appendChild(fieldset);
		
		this.elements.info = document.createElement("div");
		this.elements.info.setAttribute("class", "info");
		this.elements.info.innerHTML = ORYX.I18N.Feedback.info || "";
		
		var head = document.createElement("div");
			head.setAttribute("class", "head");

    	this.elements.dialog = document.createElement("div");
		this.elements.dialog.setAttribute("class", "dialog");
		this.elements.dialog.appendChild(head);
		this.elements.dialog.appendChild(this.elements.info);
		this.elements.dialog.appendChild(this.elements.form);

		
		this.elements.container.appendChild(this.elements.dialog);
		
    	return this.elements.dialog;
    },

    getEnv: function(){
        var env = "";
        
        env += "Browser: " + navigator.userAgent;
        
        env += "\n\nBrowser Plugins: ";
        if (navigator.plugins) {
            for (var i = 0; i < navigator.plugins.length; i++) {
                var plugin = navigator.plugins[i];
                env += plugin.name + ", ";
            }
        }
        
        if ((typeof(screen.width) != "undefined") && (screen.width && screen.height)) 
            env += "\n\nScreen Resolution: " + screen.width + 'x' + screen.height;
        
        return env;
    }
});
/**
 * Copyright (c) 2009
 * Matthias Kunze
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
*/

if (!ORYX.Plugins) {
	ORYX.Plugins = {};
}  

if (!ORYX.Config) {
	ORYX.Config = {};
}

ORYX.Config.SignavioFileRepositoryModelHandler = "/signavio/p/model/"; 

ORYX.Plugins.FileRepositorySave = Clazz.extend({
	
    facade: undefined,
	modelUri: window.location.hash.substring(1).strip() || undefined,
	
    construct: function(facade){
		this.facade = facade;

		this.facade.offer({
			'name': ORYX.I18N.Save.save,
			'functionality': this.save.bind(this, false),
			'group': ORYX.I18N.Save.group,
			'icon': ORYX.PATH + "images/disk.png",
			'description': ORYX.I18N.Save.saveDesc,
			'index': 1,
			'minShape': 0,
			'maxShape': 0
		});
		
		this.facade.offer({
			'name': ORYX.I18N.Save.saveAs,
			'functionality': this.save.bind(this, true),
			'group': ORYX.I18N.Save.group,
			'icon': ORYX.PATH + "images/disk_multi.png",
			'description': ORYX.I18N.Save.saveAsDesc,
			'index': 2,
			'minShape': 0,
			'maxShape': 0
		});
		

		// ask before closing the window
		this.changeDifference = 0;		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_EXECUTE, function(){ this.changeDifference++; });
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_EXECUTE_COMMANDS, function(){this.changeDifference++; });
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_ROLLBACK, function(){this.changeDifference--; });
		
		window.onbeforeunload = function(){
			if (this.changeDifference > 0){
				return ORYX.I18N.Save.unsavedData;
			}
		}.bind(this);
	},

	saveAs: function(){
		return this.save(true);
	},
	
	save: function(_saveAs) {
		// saveAs requires to save it as a new file
		// save first time requires to save it as a new file
		_saveAs = _saveAs || !this.modelUri;

		var svgDOM = DataManager.serialize(this.facade.getCanvas().getSVGRepresentation(true));
		var serializedDOM = Ext.encode(this.facade.getJSON());
		
		var modelData = {
			name: "New Process",
			description: "",
			comment: "",
			namespace: this.facade.getStencilSets().values()[0].namespace(),
			json_xml: serializedDOM,
			parent: undefined,
			svg_xml: svgDOM,
			type: this.facade.getStencilSets().values()[0].namespace()
		};
		
		// try to load available information
		if (this.modelUri) {
			var request = new Ajax.Request(ORYX.Config.SignavioFileRepositoryModelHandler + this.modelUri.replace(/^\/?/,"") + "/info", {
				method: "GET",
				asynchronous: false
			});
			
			if (!request.transport || !request.transport.status == 200) {
				Ext.Msg.show({
				   title: "Unable to load model data",
				   msg: "The model does not seem to exist anymore or the model storage is unavailable. Remove the model-id (everything behind #) and try again.",
				   buttons: Ext.MessageBox.OK
				});
				
				return false;
			}
			
			var data = request.transport.responseText.evalJSON();
			["name", "description", "comment", "parent", "type"].each(function(key) {
				modelData[key] = data[key] || modelData[key];
			});
		}
		else {
			// model has no URI, so it should at least have parent assigned in the editor URL
			var parent = Ext.urlDecode(location.search.substring(1))["directory"];
			if (!parent) {
				Ext.Msg.show({
				   title: "Parent Directory Missing",
				   msg: "The model does not semm to be saved yet, however I can't find a parent diractory. Thus the model cannot be saved at all. My bad. :( \n PS: Your best shot is to try to export the model, create a new one, import andh hope for the best.",
				   buttons: Ext.MessageBox.OK
				});
				
				return false;
			}
			modelData.parent = parent;
		}
		
			
		if (!_saveAs) {
			this.submit(modelData, false);
			return true;
		}
			
		var form = new Ext.XTemplate(		
			'<form class="oryx_repository_edit_model" action="#" id="edit_model" onsubmit="return false;">',
				'<fieldset>',
					'<p class="description">' + ORYX.I18N.Save.dialogDesciption + '</p>',
					'<input type="hidden" name="namespace" value="{namespace}" />',
					'<p><label for="edit_model_title">' + ORYX.I18N.Save.dialogLabelTitle + '</label><input type="text" class="text" name="title" value="{name}" id="edit_model_title" onfocus="this.className = \'text activated\'" onblur="this.className = \'text\'"/></p>',
					'<p><label for="edit_model_summary">' + ORYX.I18N.Save.dialogLabelDesc + '</label><textarea rows="5" name="summary" id="edit_model_summary" onfocus="this.className = \'activated\'" onblur="this.className = \'\'">{description}</textarea></p>',
					'<p><label for="edit_model_type">' + ORYX.I18N.Save.dialogLabelType + '</label><input type="text" name="type" class="text disabled" value="{type}" disabled="disabled" id="edit_model_type" /></p>',
				'</fieldset>',
			'</form>'
		);

		var win = new Ext.Window({
			// id:		'Propertie_Window',
	        width:	'auto',
	        height:	'auto',
		    title:	(_saveAs ? ORYX.I18N.Save.saveAsTitle : ORYX.I18N.Save.save),
	        modal:	true,
			bodyStyle: 'background:#FFFFFF',
	        html: 	form.apply(modelData),
	        
			buttons:[
			    {
			    	text: ORYX.I18N.Save.saveBtn,
			    	handler: function(){
			    	
			    		modelData.name = $("edit_model_title").value.strip(); 
			    		modelData.description = $("edit_model_summary").value.strip()

			    		this.submit(modelData, true);
						win.close();
						
					}.bind(this)
			    },{
			    	text: ORYX.I18N.Save.close,
			    	handler: function(){
			    		win.close();
            		}
			    }
			],
			listeners: {
				close: function(){					
                	win.close();
				}
			}
	    });
	
		win.show();
		
		return true;
	
	},
	
	submit: function(params, _saveAs) {
		
		this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
			text: ORYX.I18N.Save.saving
        });
		
		if (_saveAs) {
			new Ajax.Request(ORYX.Config.SignavioFileRepositoryModelHandler, {
				method: "POST",
				parameters: params,
				asynchronous: true,
				onSuccess: function success(transport){
					this.modelUri = transport.responseText.evalJSON()["href"].replace(/^\/?(model)?\/?/,"");
					location.hash =  this.modelUri;
					this.changeDifference = 0;
					
					this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_LOADING_STATUS,
						text:ORYX.I18N.Save.saved
					});
					
					
					
				}.bind(this),
				onFailure: function failure(){
					alert("fail");
				}.bind(this),
				on403: function f403(){
					alert("403");
				}.bind(this)
			});
		}
		else {			
			new Ajax.Request(ORYX.Config.SignavioFileRepositoryModelHandler + this.modelUri, {
				method: "PUT",
				parameters: params,
				asynchronous: true,
				onSuccess: function success(transport){
					this.changeDifference = 0;					
					this.facade.raiseEvent({
						type:ORYX.CONFIG.EVENT_LOADING_STATUS,
						text:ORYX.I18N.Save.saved
					});
					
				}.bind(this),
				onFailure: function failure(){
					alert("fail");
				}.bind(this),
				on403: function f403(){
					alert("403");
				}.bind(this)
			});
		}
	}
});

onOryxResourcesLoaded = function () {
	if (location.hash.slice(1).length == 0 || location.hash.slice(1).indexOf('new')!=-1) {
		var stencilset = ORYX.Utils.getParamFromUrl('stencilset') 
			? ORYX.Utils.getParamFromUrl('stencilset')
			: ORYX.CONFIG.SSET;

		new ORYX.Editor({
			id: 'oryx-canvas123',
			stencilset: {
				url: ORYX.PATH + '/'+stencilset
			}
		});
	}
	else {
		ORYX.Editor.createByUrl(ORYX.Config.SignavioFileRepositoryModelHandler + location.hash.slice(1).replace(/^\/?/,"") + "/json", {
			id: 'oryx-canvas123'
		});
	};
};/**
 * Copyright (c) 2010
 * Robert Böhme, Philipp Berger
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.DockerCreation = Clazz.extend({
	
	construct: function( facade ){
		this.facade = facade;		
		this.active = false; //true-> a ghostdocker is shown; false->ghostdocker is hidden

		//visual representation of the Ghostdocker
		this.circle = ORYX.Editor.graft("http://www.w3.org/2000/svg", null ,
				['g', {"pointer-events":"none"},
					['circle', {cx: "8", cy: "8", r: "3", fill:"yellow"}]]); 	
		
		//Event registrations
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOVER, this.handleMouseOver.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOUT, this.handleMouseOut.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEMOVE, this.handleMouseMove.bind(this));
		/*
		 * Double click is reserved for label access, so abort action
		 */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_DBLCLICK,function(){window.clearTimeout(this.timer)}.bind(this));
		/*
		 * click is reserved for selecting, so abort action when mouse goes up
		 */
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEUP,function(){window.clearTimeout(this.timer)}.bind(this));

	},
	
	/**
	 * MouseOut Handler
	 * 
	 *hide the Ghostpoint when Leaving the mouse from an edge
	 */
	handleMouseOut: function(event, uiObj) {
		
		if (this.active) {		
			this.hideOverlay();
			this.active = false;
		}	
	},
	
	/**
	 * MouseOver Handler
	 * 
	 *show the Ghostpoint if the edge is selected
	 */
	handleMouseOver: function(event, uiObj) {
		//show the Ghostdocker on the edge
		if (uiObj instanceof ORYX.Core.Edge && this.isEdgeDocked(uiObj)){
			this.showOverlay(uiObj, this.facade.eventCoordinates(event));
		}
		//ghostdocker is active
		this.active = true;
		
	},
	
	/**
	 * MouseDown Handler
	 * 
	 *create a Docker when clicking on a selected edge
	 */
	handleMouseDown: function(event, uiObj) {	
		if (event.which==1 && uiObj instanceof ORYX.Core.Edge && this.isEdgeDocked(uiObj)){
			//Timer for Doubleclick to be able to create a label
			window.clearTimeout(this.timer);
			
			this.timer = window.setTimeout(function () {
				// Give the event to enable one click creation and drag
				this.addDockerCommand({
		            edge: uiObj,
					event: event,
		            position: this.facade.eventCoordinates(event)
		        });
	
			}.bind(this),200);
			this.hideOverlay();
	
		}
	},
	
	/**
	 * MouseMove Handler
	 * 
	 *refresh the ghostpoint when moving the mouse over an edge
	 */
	handleMouseMove: function(event, uiObj) {		
			if (uiObj instanceof ORYX.Core.Edge && this.isEdgeDocked(uiObj)){
				if (this.active) {	
					//refresh Ghostpoint
					this.hideOverlay();			
					this.showOverlay( uiObj, this.facade.eventCoordinates(event));
				}else{
					this.showOverlay( uiObj, this.facade.eventCoordinates(event));	
				}		
			}	
	},
	
	/**
	 * returns true if the edge is docked to at least one node
	 */
	isEdgeDocked: function(edge){
		return !!(edge.incoming.length || edge.outgoing.length);
	},
	
	
	/**
	 * Command for creating a new Docker
	 * 
	 * @param {Object} options
	 */
	addDockerCommand: function(options){
	    if(!options.edge)
	        return;
	    
	    var commandClass = ORYX.Core.Command.extend({
	        construct: function(edge, docker, pos, facade, options){            
	            this.edge = edge;
	            this.docker = docker;
	            this.pos = pos;
	            this.facade = facade;
				this.options= options;
	        },
	        execute: function(){
	            this.docker = this.edge.addDocker(this.pos, this.docker);
				this.index = this.edge.dockers.indexOf(this.docker);                                    
	            this.facade.getCanvas().update();
	            this.facade.updateSelection();
	            this.options.docker=this.docker;
	
	        },
	        rollback: function(){
	          
	             if (this.docker instanceof ORYX.Core.Controls.Docker) {
	                    this.edge.removeDocker(this.docker);
	             }             
	            this.facade.getCanvas().update();
	            this.facade.updateSelection(); 
	        }
	    });
	    var command = new commandClass(options.edge, options.docker, options.position, this.facade, options);    
	    this.facade.executeCommands([command]);
	
	    
		this.facade.raiseEvent({
			uiEvent:	options.event,
			type:		ORYX.CONFIG.EVENT_DOCKERDRAG}, options.docker );
	    
	},
	
	/**
	 *show the ghostpoint overlay
	 *
	 *@param {Shape} edge
	 *@param {Point} point
	 */
	showOverlay: function(edge, point){
		var best = point;
		var pair = [0,1];
		var min_distance = Infinity;
	
		// calculate the optimal point ON THE EDGE to display the docker
		for (var i=0, l=edge.dockers.length; i < l-1; i++) {
			var intersection_point = ORYX.Core.Math.getPointOfIntersectionPointLine(
				edge.dockers[i].bounds.center(),
				edge.dockers[i+1].bounds.center(),
				point,
				true // consider only the current segment instead of the whole line ("Strecke, statt Gerade") for distance calculation
			);
			
			
			if(!intersection_point) {
				continue;
			}
	
			var current_distance = ORYX.Core.Math.getDistancePointToPoint(point, intersection_point);
			if (min_distance > current_distance) {
				min_distance = current_distance;
				best = intersection_point;
			}
		}
	
		this.facade.raiseEvent({
				type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
				id: 			"ghostpoint",
				shapes: 		[edge],
				node:			this.circle,
				ghostPoint:		best,
				dontCloneNode:	true
			});			
	},
	
	/**
	 *hide the ghostpoint overlay
	 */
	hideOverlay: function() {
		
		this.facade.raiseEvent({
			type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
			id: "ghostpoint"
		});	
	}

});/**
 * Copyright (c) 2009
 * Robert Böhme
 * 
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.LabelLayout = Clazz.extend({
		
	construct: function( facade ){
		this.facade = facade;	
		this.myLabel = undefined; //defines the current label
		this.labelSelected = false; //true->label is selected
		this.labelLength = undefined; //length of a label
		this.rotationPointCoordinates = {x:0, y:0};
		this.mouseCoordinates = {x:0, y:0};
		this.labelCoordinates = {x:0, y:0};
		this.myEdge = undefined;	// set the Edge Parent for the RotaionPoint	
		this.rotate = false; //true ->Rotation of label is active; False -> Rotation of Label is not active
		this.State = 0; 	//current States for Rotation
		this.prevState = 0;	//previous State for Rotation
		this.canvasLabel = undefined; //Reference to Canvas
		this.canvas = false; //true if Reference to Canvas was saved
		
		//Register Events
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEDOWN, this.handleMouseDown.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEOVER, this.handleMouseOver.bind(this));
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MOUSEMOVE, this.handleMouseMove.bind(this));
		
		//Visual representaion of the default RotationPoint		
		this.rotationPoint = ORYX.Editor.graft("http://www.w3.org/2000/svg", null,
				['path', {
					"stroke-width": 2.0, "stroke":"black", "d":  "M4,4 L0,6 M0,6 L-4,4 M-4,4 L-6,0 M-6,0 L-4,-4 M-4,-4 L0,-6 M0,-6 L4,-4 M4,-4 L6,2 M6,2 L2,0 M6,2 L8,0", "line-captions": "round"
					}]);		
		
		//Visual representation of the association line
		this.line = ORYX.Editor.graft("http://www.w3.org/2000/svg", null,
				['path', {
					'stroke-width': 1, stroke: 'silver', fill: 'none',
					'pointer-events': 'none'}]);
		
		//Visual representation of the moving arrows
		this.startMovingCross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null,
				['path', {
					"stroke-width": 1.0, "stroke":"black", "d":  "M0,0 L-10,0 M-10,0 L-6,-4 M-10,0 L-6,4 M0,0 L10,0 M10,0 L6,4 M10,0 L6,-4 M0,0 L0,10 M0,10 L4,6 M0,10 L-4,6 M0,0 L0,-10 M0,-10 L4,-6 M0,-10 L-4,-6", "line-captions": "round"
					}]);
		
		//visual represetation to the set the position of a label
		this.endMovingCross = ORYX.Editor.graft("http://www.w3.org/2000/svg", null,
				['path', {
					"stroke-width": 1.0, "stroke":"black", "d":  "M-2,0 L-10,0 M2,0 L10,0 M0,2 L0,10 M0,-2 L0,-10 M-2,0 L-6,4 M-2,0 L-6,-4 M2,0 L6,4 M2,0 L6,-4 M0,-2 L4,-6 M0,-2 L-4,-6 M0,2 L4,6 M0,2 L-4,6", "line-captions": "round"
					}]);
		
		//Visual representation to move the mouse left/right to rotate the label
		this.moveLeftRight = ORYX.Editor.graft("http://www.w3.org/2000/svg", null,
				['path', {
					"stroke-width": 2.0, "stroke":"black", "d":  "M0,0 L-15,0 M-15,0 L-11,-4 M-15,0 L-11,4 M0,0 L15,0 M15,0 L11,4 M15,0 L11,-4", "line-captions": "round"
					}]);
		
		 /*
		 this.facade.offer({
	            'name': "Label rotate left",
	            'functionality': this.rotate_left.bind(this),
	            'group': "Rotation",
	            'icon': ORYX.PATH + "images/rotate_left.png",
	            'description': "rotate a label left",
	            'index': 1,
	            'minShape': 0,
	            'maxShape': 0
	        });
		 
		 this.facade.offer({
	            'name': "Label rotate right",
	            'functionality': this.rotate_right.bind(this),
	            'group': "Rotation",
	            'icon': ORYX.PATH + "images/rotate_right.png",
	            'description': "rotate a label right",
	            'index': 1,
	            'minShape': 0,
	            'maxShape': 0
	        });*/		 
},

/**
 * Mouse Over Handler
 */
handleMouseOver: function(event, uiObj) {

	//Save Canvas for Reference(used for showing Line between edge and label)
	if(this.canvas == false){
		if(uiObj instanceof ORYX.Core.Canvas){
			this.canvasLabel = uiObj;
			canvas = true;
		}
	}	
},

/**
 * Mouse Down Handler
 */
handleMouseDown: function(event, uiObj) {	
	
	if(this.myLabel && this.myLabel._text != ""){	
		//save MousePosition
		var MouseX = this.facade.eventCoordinates(event).x;
		var MouseY = this.facade.eventCoordinates(event).y;
		
		//refresh Coordinates
		this.calculateLabelCoordinates();
		this.calculateRotationPointCoordinates();
	
		//Set LabelPosition to MousePosition	
		if(this.labelSelected == true){				
			if(this.myLabel._rotate == 270 || this.myLabel._rotate == 315 || this.myLabel._rotate == 360 || this.myLabel._rotate == 45) {
				this.myLabel.x = this.facade.eventCoordinates(event).x+5;
				this.myLabel.y = this.facade.eventCoordinates(event).y-5;
			}else if (this.myLabel._rotate == 90 || this.myLabel._rotate == 135 || this.myLabel._rotate == 180 || this.myLabel._rotate == 225){
				this.myLabel.x = this.facade.eventCoordinates(event).x-5;
				this.myLabel.y = this.facade.eventCoordinates(event).y+5;
			}
			else {
				this.myLabel.x = this.facade.eventCoordinates(event).x+10;
				this.myLabel.y = this.facade.eventCoordinates(event).y-5;
			}
			
			//refresh real Rotationpoint
			if(this.myLabel._rotationPoint){
				this.myLabel._rotationPoint.x = MouseX;
				this.myLabel._rotationPoint.y = MouseY;
			}
			
			// save the current position of the label in edge.js, mark the label as free moved
			this.myLabel.edgePosition = "freeMoved";
			this.myLabel.update();			
		
			//Refresh Coordinates
			this.calculateLabelCoordinates();
			this.calculateRotationPointCoordinates();				
			this.showOverlay("RotationPoint", this.myEdge, this.rotationPointCoordinates, this.rotationPoint);
			this.hideOverlay("SettingArrows");
			
			//Show Moving Arrows		
			this.mouseCoordinates = {x:this.labelCoordinates.x, y:this.labelCoordinates.y};			
			this.showOverlay("MovingArrows", this.myEdge, this.mouseCoordinates, this.startMovingCross);			
			
			//show the Association line
			this.showLine();
		}
		else {		
			this.hideLine();
			this.hideOverlay("RotationPoint");
			this.hideOverlay("MovingArrows");
			this.hideOverlay("SettingArrows");
		}
	
		//Check if Mouse is in the ClickArea of the Label 
		if(	this.labelSelected == false && 
				MouseX >= this.labelCoordinates.x-20 && 
				MouseX <= this.labelCoordinates.x+20 && 
				MouseY <= this.labelCoordinates.y+20 && 
				MouseY >= this.labelCoordinates.y-20){		
		
			//Set Label as Selected
			this.labelSelected=true;
						
			//refresh and show RotationPoint
			this.calculateRotationPointCoordinates();
			this.showOverlay("RotationPoint", this.myEdge, this.rotationPointCoordinates, this.rotationPoint);
		}
		else {
			//Set Label as not selected
			this.labelSelected = false;	
		}
	
		//Check if MouseClick is on RotationPoint
		if(	this.rotate == false && 
			MouseX >= this.rotationPointCoordinates.x-20 && 
			MouseX <= this.rotationPointCoordinates.x+20 && 
			MouseY >= this.rotationPointCoordinates.y-20 && 
			MouseY <= this.rotationPointCoordinates.y+20){
		
			//acitvate Rotation
			this.rotate = true;
			
			//Set current RotationState
			this.State = 0;
			
			//show RotationArrows to show that rotation is active
			this.showOverlay("RotationPointActive", this.myEdge, this.rotationPointCoordinates, this.moveLeftRight);
		}
		else{
			//deactivate Rotation
			this.rotate = false;
			
			//Hide yellow RotationArrows
			this.hideOverlay("RotationPointActive");
		}	
	}
	
	//clicking on an Edge saves the label and show the line
	if( uiObj instanceof ORYX.Core.Edge){  		
		//Identify and set the label of the current Edge	
		if(uiObj._labels[uiObj.id+"condition"]){
			this.myLabel = uiObj._labels[uiObj.id+"condition"]; //for BPMN
		}else if (uiObj._labels[uiObj.id+"name"]){
			this.myLabel = uiObj._labels[uiObj.id+"name"]; //for UML
		}else {
			this.myLabel = uiObj._labels[uiObj.id+"text"];
		}
	 
		//save the edge for adding rotationpoint	
		this.myEdge = uiObj;

		//Show the RotationPoint and line of the label of the current Edge
		if(this.myLabel && this.myLabel._text != ""){
			this.calculateLabelCoordinates();
			this.calculateRotationPointCoordinates();
			this.showLine();			
			this.mouseCoordinates = {x:this.labelCoordinates.x, y:this.labelCoordinates.y};			
			this.showOverlay("MovingArrows", this.myEdge, this.mouseCoordinates, this.startMovingCross);
			this.showOverlay("RotationPoint", this.myEdge, this.rotationPointCoordinates, this.rotationPoint);
		}
	}
},

/**
 * Mouse Move Handler
 */
handleMouseMove: function(event, uiObj) {

	//if label is selected Posision is set to MousePosition
	if(this.labelSelected == true){
		if(this.myLabel){			
			//Set Label positon for different Rotations
			if(this.myLabel._rotate == 270 || this.myLabel._rotate == 315 || this.myLabel._rotate == 360 || this.myLabel._rotate == 45) {
				this.myLabel.x = this.facade.eventCoordinates(event).x+5;
				this.myLabel.y = this.facade.eventCoordinates(event).y-5;
				this.myLabel._rotationPoint.x = this.facade.eventCoordinates(event).x+10;
				this.myLabel._rotationPoint.y = this.facade.eventCoordinates(event).y-10;
			}else if(this.myLabel._rotate == 90 || this.myLabel._rotate == 135 || this.myLabel._rotate == 180 || this.myLabel._rotate == 225){
				this.myLabel.x = this.facade.eventCoordinates(event).x-5;
				this.myLabel.y = this.facade.eventCoordinates(event).y+5;
				this.myLabel._rotationPoint.x = this.facade.eventCoordinates(event).x-10;
				this.myLabel._rotationPoint.y = this.facade.eventCoordinates(event).y+10;
			}else {
				this.myLabel.x = this.facade.eventCoordinates(event).x+10;
				this.myLabel.y = this.facade.eventCoordinates(event).y-5;
				this.myLabel._rotationPoint.x = this.facade.eventCoordinates(event).x+10;
				this.myLabel._rotationPoint.y = this.facade.eventCoordinates(event).y-10;
			}
				
			this.myLabel.update();
		
			//refresh Coordinates
			this.calculateLabelCoordinates();
			this.calculateRotationPointCoordinates();		

			this.hideOverlay("RotationPoint");
			this.hideOverlay("MovingArrows");
			this.hideOverlay("SettingArrows");			
			
			//refresh Position of the Overlay arrows
			if(this.myLabel._rotate == 270 || this.myLabel._rotate == 315 || this.myLabel._rotate == 360 || this.myLabel._rotate == 45) {	
				this.mouseCoordinates = {x:this.facade.eventCoordinates(event).x, y:this.facade.eventCoordinates(event).y};	
				this.showOverlay("SettingArrows", this.myEdge, this.mouseCoordinates, this.endMovingCross);
			}else {
				this.mouseCoordinates = {x:this.facade.eventCoordinates(event).x, y:this.facade.eventCoordinates(event).y};	
				this.showOverlay("SettingArrows", this.myEdge, this.mouseCoordinates, this.endMovingCross);
			}			
			//Refresh the Line
			this.hideLine();
			this.showLine();
		}
	}
	
	//perform the Statevalidation for Rotation
	if(this.rotate == true) {
		
		//save MouseCoordinates
		var MouseX = this.facade.eventCoordinates(event).x;
		var MouseY = this.facade.eventCoordinates(event).y;

		//refresh Coordinates
		this.calculateLabelCoordinates();
		this.calculateRotationPointCoordinates();
		
		//defines the States for Rotation(every 20px there is a new State)
		if(MouseX < this.rotationPointCoordinates.x-150 ){
			this.State = -8;
		}
		else if (MouseX < this.rotationPointCoordinates.x-130 && MouseX >= this.rotationPointCoordinates.x-150){
			this.State = -7;	
		}
		else if (MouseX < this.rotationPointCoordinates.x-110 && MouseX >= this.rotationPointCoordinates.x-130){
			this.State =- 6;	
		}
		else if (MouseX < this.rotationPointCoordinates.x-90 && MouseX >= this.rotationPointCoordinates.x-110){
			this.State = -5;	
		}
		else if (MouseX < this.rotationPointCoordinates.x-70 && MouseX >= this.rotationPointCoordinates.x-90){
			this.State = -4;	
		}
		else if (MouseX < this.rotationPointCoordinates.x-50 && MouseX >= this.rotationPointCoordinates.x-70){
			this.State = -3;	
		}
		else if (MouseX < this.rotationPointCoordinates.x-30 && MouseX >= this.rotationPointCoordinates.x-50){
			this.State = -2;	
		}
		else if (MouseX < this.rotationPointCoordinates.x-10 && MouseX >= this.rotationPointCoordinates.x-30){
			this.State = -1;
		}
		else if (MouseX < this.rotationPointCoordinates.x+10 && MouseX >= this.rotationPointCoordinates.x-10){
			this.State = 0;	
		}
		else if (MouseX < this.rotationPointCoordinates.x+30 && MouseX >= this.rotationPointCoordinates.x+10){
			this.State = 1;	
		}
		else if (MouseX < this.rotationPointCoordinates.x+50 && MouseX >= this.rotationPointCoordinates.x+30){
			this.State = 2;
		}
		else if (MouseX < this.rotationPointCoordinates.x+70 && MouseX >= this.rotationPointCoordinates.x+50){
			this.State = 3;
		}
		else if ( MouseX < this.rotationPointCoordinates.x+90 && MouseX >= this.rotationPointCoordinates.x+70){
			this.State = 4;	
		}
		else if ( MouseX < this.rotationPointCoordinates.x+110 && MouseX >= this.rotationPointCoordinates.x+90){
			this.State = 5;	
		}
		else if ( MouseX < this.rotationPointCoordinates.x+130 && MouseX >= this.rotationPointCoordinates.x+110){
			this.State = 6;	
		}
		else if ( MouseX < this.rotationPointCoordinates.x+150 && MouseX >= this.rotationPointCoordinates.x+130){
			this.State7;	
		}
		else if(MouseX >= this.rotationPointCoordinates.x+150){
			this.State = 8;
		}
		
		//checks the way of moving the Mouse through the states and rotate
		if(this.State > this.prevState){
			this.rotate_right();
			this.prevState = this.State;
		}
		else if(this.State < this.prevState){
			this.rotate_left();
			this.prevState = this.State;
		}
	}
},

/**
 * rotate the label to the right with 45° (clockwise)
 * 
 */
rotate_right:function() {

	var myRotPoint = {x:this.labelCoordinates.x, y:this.labelCoordinates.y};
	var myRotation = this.myLabel._rotate;
	
	if(myRotation == 0 || myRotation < 45 && myRotation > 0 || myRotation == 360){
		this.myLabel.rotate(45, myRotPoint);
	}
	else if(myRotation == 45 || myRotation < 90 && myRotation > 45){
		this.myLabel.rotate(90, myRotPoint);
	}
	else if(myRotation == 315 || myRotation > 315 && myRotation < 360){
		this.myLabel.rotate(360,myRotPoint);
	}
	else if(myRotation == 270 || myRotation > 270 && myRotation < 315){
		this.myLabel.rotate(315,myRotPoint);
	}
	else if(myRotation == 90 || myRotation < 135 && myRotation > 90){
		this.myLabel.rotate(135,myRotPoint);
	}
	else if(myRotation == 135 || myRotation < 180 && myRotation > 135){
		this.myLabel.rotate(180,myRotPoint);
	}
	else if(myRotation == 180 || myRotation < 225 && myRotation > 180){
		this.myLabel.rotate(225,myRotPoint);		
	}
	else if(myRotation == 225 || myRotation < 270 && myRotation > 225){
		this.myLabel.rotate(270,myRotPoint);
	}
	this.myLabel.update();
},

/**
 * rotate the label to the left with 45° (anticlockwise)
 * 
 */
rotate_left:function() {
	var myRotPoint = {x:this.labelCoordinates.x, y:this.labelCoordinates.y};
	var myRotation = this.myLabel._rotate;
	
	if(myRotation == 0 || myRotation < 360 && myRotation > 315 || myRotation == 360){
		this.myLabel.rotate(315,myRotPoint);
	}
	else if(myRotation == 315 || myRotation < 315 && myRotation > 270){
		this.myLabel.rotate(270,myRotPoint);
	}
	else if(myRotation == 45||myRotation <45 && myRotation >0){
		this.myLabel.rotate(360,myRotPoint);
	}
	else if(myRotation == 90||myRotation < 90 && myRotation > 45){
		this.myLabel.rotate(45,myRotPoint);
	}
	else if(myRotation == 135 || myRotation < 135 && myRotation > 90){
		this.myLabel.rotate(90,myRotPoint);
	}
	else if(myRotation == 180 || myRotation < 180 && myRotation > 135){
		this.myLabel.rotate(135,myRotPoint);
	}
	else if(myRotation == 225 || myRotation < 225 && myRotation > 180){
		this.myLabel.rotate(180,myRotPoint);
	}
	else if(myRotation == 270 || myRotation < 270 && myRotation > 225){
		this.myLabel.rotate(225,myRotPoint);
	}
	this.myLabel.update();	
},

/**
 * set the Coordinates of the RotationPoint for different degree values
 * 
 */
calculateRotationPointCoordinates: function(){	
	if(this.rotate == false) {
		this.labelLength = this.myLabel._estimateTextWidth(this.myLabel._text,14);
	
		if(this.myLabel._rotate == 360){
			this.rotationPointCoordinates.x = this.labelCoordinates.x-8 + this.labelLength/3;
			this.rotationPointCoordinates.y = this.labelCoordinates.y-35;	
		}
		else if(this.myLabel._rotate == 90) {
			this.rotationPointCoordinates.x = this.labelCoordinates.x + 35;
			this.rotationPointCoordinates.y = this.labelCoordinates.y-8 + this.labelLength/3;			
		}
		else if(this.myLabel._rotate == 180) {
			this.rotationPointCoordinates.x = this.labelCoordinates.x - this.labelLength/2;
			this.rotationPointCoordinates.y = this.labelCoordinates.y+35;
		}
		else if(this.myLabel._rotate == 270) {
			this.rotationPointCoordinates.x = this.labelCoordinates.x-35;
			this.rotationPointCoordinates.y = this.labelCoordinates.y+8 - this.labelLength/2;	
		}
		else if(this.myLabel._rotate == 45) {
			this.rotationPointCoordinates.x = this.labelCoordinates.x+40;
			this.rotationPointCoordinates.y = this.labelCoordinates.y;	
		}
		else if(this.myLabel._rotate == 135) {
			this.rotationPointCoordinates.x = this.labelCoordinates.x;
			this.rotationPointCoordinates.y = this.labelCoordinates.y+40;	
		}
		else if(this.myLabel._rotate == 225) {
			this.rotationPointCoordinates.x = this.labelCoordinates.x-40;
			this.rotationPointCoordinates.y = this.labelCoordinates.y;	
		}
		else if(this.myLabel._rotate == 315) {
			this.rotationPointCoordinates.x = this.labelCoordinates.x;
			this.rotationPointCoordinates.y = this.labelCoordinates.y-40;	
		}
		else {
			//Default
			this.rotationPointCoordinates.x = this.labelCoordinates.x-8 + this.labelLength/3;
			this.rotationPointCoordinates.y = this.labelCoordinates.y-35;	
		}
	}
},

/**
 * set the Coordinates of the Label
 * 
 */
calculateLabelCoordinates: function(){		
		this.labelCoordinates.x = this.myLabel.x;
		this.labelCoordinates.y = this.myLabel.y;
},

/**
 * show a Overlay with a certain id and add it to parent Shape
 * 
 * @param {String} id
 * @param {Shape} shape
 * @param {Point} position
 * @param {SVG} visualObject
 */
showOverlay: function(id, shape, position, visualObject) {
	this.facade.raiseEvent({
		type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
		id: 			id,
		shapes: 		[shape],
		node:			visualObject,
		labelPoint:		position,
		dontCloneNode:	true
	});		
},

/**
 * hide a Overlay
 * 
 * @param {String} id
 */
hideOverlay: function(id) {
	this.facade.raiseEvent({
		type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
		id: id
	});	
},


/**
 * show the Association Line between Edge and Label
 * 
 */
showLine: function() {
	var x = this.myEdge.dockers[0].bounds.b.x-8;
	var y = this.myEdge.dockers[0].bounds.b.y-8;
	
	//Set the Position of the Line
	this.line.setAttributeNS(null, 'd', 'M'+x+' '+y+' L '+this.labelCoordinates.x+' '+this.labelCoordinates.y);

	this.facade.raiseEvent({
		type: 			ORYX.CONFIG.EVENT_OVERLAY_SHOW,
		id: 			"line",
		shapes: 		[this.canvasLabel],
		node:			this.line,
		position:		"northeast",
		dontCloneNode:	true
	});
	
},

/**
 * hide the Association Line between Edge and Label
 * 
 */
hideLine: function() {
	this.facade.raiseEvent({
		type: ORYX.CONFIG.EVENT_OVERLAY_HIDE,
		id: "line"
	});
}

});/** * Copyright (c) 2010 * Markus Goetz * * * Permission is hereby granted, free of charge, to any person obtaining a * copy of this software and associated documentation files (the "Software"), * to deal in the Software without restriction, including without limitation * the rights to use, copy, modify, merge, publish, distribute, sublicense, * and/or sell copies of the Software, and to permit persons to whom the * Software is furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in * all copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER * DEALINGS IN THE SOFTWARE. **/if(!ORYX.Plugins)	ORYX.Plugins = new Object();ORYX.Plugins.BPMN2XPDL20 = ORYX.Plugins.AbstractPlugin.extend({		construct: function() {		arguments.callee.$.construct.apply(this, arguments);			this.facade.offer({			'name'				: ORYX.I18N.BPMN2XPDL.xpdlExport,			'functionality'		: this.transform.bind(this),			'group'				: ORYX.I18N.BPMN2XPDL.group,            dropDownGroupIcon   : ORYX.PATH + "images/export2.png",			'icon'				: ORYX.PATH + "images/page_white_gear.png",			'description'		: ORYX.I18N.BPMN2XPDL.xpdlExport,			'index'				: 1,			'minShape'			: 0,			'maxShape'			: 0});				this.facade.offer({			'name'				: ORYX.I18N.BPMN2XPDL.xpdlImport,			'functionality'		: this.importXPDL.bind(this),			'group'				: ORYX.I18N.BPMN2XPDL.group,            dropDownGroupIcon   : ORYX.PATH + "images/import.png",			'icon'				: ORYX.PATH + "images/page_white_gear.png",			'description'		: ORYX.I18N.BPMN2XPDL.xpdlImport,			'index'				: 1,			'minShape'			: 0,			'maxShape'			: 0});		},	transform: function() {		var url = ORYX.CONFIG.BPMN2XPDLPATH;		var json = this.facade.getSerializedJSON();				Ext.Ajax.request({			url: url,			method: 'POST',			success: function(request) {				this.openDownloadWindow(window.document.title + ".xml", request.responseText);}.bind(this),			failure: function() {Ext.Msg.alert("Conversion failed");},			params: {data: json,					 action: "Export"}		})	},		importXPDL: function( successCallback ){		var url = ORYX.CONFIG.BPMN2XPDLPATH;	    var form = new Ext.form.FormPanel({			baseCls: 		'x-plain',	        labelWidth: 	50,	        defaultType: 	'textfield',	        items: [{	            text : 		ORYX.I18N.BPMN2XPDL.selectFile, 				style : 	'font-size:12px;margin-bottom:10px;display:block;',	            anchor:		'100%',				xtype : 	'label' 	        },{	            fieldLabel: ORYX.I18N.BPMN2XPDL.file,	            name: 		'subject',				inputType : 'file',				style : 	'margin-bottom:10px;display:block;',				itemCls :	'ext_specific_window_overflow'	        }, {	            xtype: 'textarea',	            hideLabel: true,	            name: 'msg',	            anchor: '100% -63'  	        }]	    });		// Create the panel		var dialog = new Ext.Window({ 			autoCreate: true, 			layout: 	'fit',			plain:		true,			bodyStyle: 	'padding:5px;',			title: 		ORYX.I18N.BPMN2XPDL.impXPDL, 			height: 	350, 			width:		500,			modal:		true,			fixedcenter:true, 			shadow:		true, 			proxyDrag: 	true,			resizable:	true,			items: 		[form],			buttons:[				{					text:ORYX.I18N.BPMN2XPDL.impBtn,					handler:function(){												var loadMask = new Ext.LoadMask(Ext.getBody(), {msg:ORYX.I18N.BPMN2XPDL.impProgress});						loadMask.show();												window.setTimeout(function(){																			var xpdlString =  form.items.items[2].getValue();							Ext.Ajax.request({								url: url,								method: 'POST',								success: function(request){this.facade.importJSON(request.responseText); loadMask.hide();dialog.hide()}.bind(this),								failure: function() {loadMask.hide(); Ext.Msg.alert("Import failed");},								params: {data: xpdlString,										 action: "Import"}							});																							}.bind(this), 100);								}.bind(this)				},{					text:ORYX.I18N.BPMN2XPDL.close,					handler:function(){												dialog.hide();										}.bind(this)				}			]		});				// Destroy the panel when hiding		dialog.on('hide', function(){			dialog.destroy(true);			delete dialog;		});		// Show the panel		dialog.show();								// Adds the change event handler to 		form.items.items[1].getEl().dom.addEventListener('change',function(evt){				var text = evt.target.files[0].getAsText('UTF-8');				form.items.items[2].setValue( text );			}, true)	}});if(!ORYX.Plugins)
	ORYX.Plugins = new Object();
if (!ORYX.Config) {
	ORYX.Config = new Object();
}
/*
 * http://oryx.processwave.org/gadget/oryx_stable.xml
 */
ORYX.Config.WaveThisGadgetUri = "http://ddj0ahgq8zch6.cloudfront.net/gadget/oryx_stable.xml";
ORYX.Plugins.WaveThis = Clazz.extend({
	
	/**
	 *	Constructor
	 *	@param {Object} Facade: The Facade of the Editor
	 */
	construct: function(facade) {
		this.facade = facade;
		this.facade.offer({
			'name':				ORYX.I18N.WaveThis.name,
			'functionality': 	this.waveThis.bind(this),
			'group': 			ORYX.I18N.WaveThis.group,
			'icon': 			ORYX.PATH + "images/waveThis.png",
			'description': 		ORYX.I18N.WaveThis.desc,
            'dropDownGroupIcon':ORYX.PATH + "images/export2.png",

		});
		
		this.changeDifference = 0;
		
		// Register on events for executing commands and save, to monitor the changed status of the model 
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_EXECUTE, function(){ this.changeDifference++ }.bind(this) );
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_EXECUTE_COMMANDS, function(){ this.changeDifference++ }.bind(this) );
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_UNDO_ROLLBACK, function(){ this.changeDifference-- }.bind(this) );
		
		this.facade.registerOnEvent(ORYX.CONFIG.EVENT_MODEL_SAVED, function(){ this.changeDifference =0}.bind(this) );

	},
	waveThis: function(){
		var modelUri;
		if(!location.hash.slice(1)){
			Ext.Msg.alert(ORYX.I18N.WaveThis.name, ORYX.I18N.WaveThis.failUnsaved);
			return;
		}
		else{
			modelUri = ORYX.CONFIG.WEB_URL+'/backend/poem/'+(location.hash.slice(1).replace(/^\/?/,"").replace(/\/?$/,""))+"/json";
		}
		if(this.changeDifference!=0){
	        Ext.Msg.confirm(ORYX.I18N.WaveThis.name, "You have unsaved changes in your model. Proceed?", function(id){
	        	if(id=="yes"){
	        		this._openWave(modelUri);
	        	}
	        },this);
		}else{
			this._openWave(modelUri);
		}
		
	},
	_openWave: function(modelUri){
		var win = window.open("");
		if (win != null) {
			win.document.open();
			win.document.write("<html><body>");
			var submitForm = win.document.createElement("form");
			win.document.body.appendChild(submitForm);
			
			var createHiddenElement = function(name, value) {
				var newElement = document.createElement("input");
				newElement.name=name;
				newElement.type="hidden";
				newElement.value = value;
				return newElement
			}
			
			submitForm.appendChild( createHiddenElement("u", modelUri) );
			submitForm.appendChild( createHiddenElement("g", ORYX.Config.WaveThisGadgetUri) );
			
			
			submitForm.method = "POST";
			win.document.write("</body></html>");
			win.document.close();
			submitForm.action= "https://wave.google.com/wave/wavethis?t=Oryx%20Model%20Export";
			submitForm.submit();
		}
	}
})/**
 * Copyright (c) 2010, Matthias Kunze
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 **/
if (!ORYX.Plugins) 
    ORYX.Plugins = {};

if (!ORYX.Config)
	ORYX.Config = {};

ORYX.Config.Timeline = {
	LAYOUT_ERROR_NO_DATE: "ORYX.Config.Timeline.LAYOUT_ERROR_NO_DATE"
}

ORYX.Plugins.Timeline = ORYX.Plugins.AbstractPlugin.extend({
	
	construct: function(facade, data) {
		ORYX_LOGLEVEL = 4;
		ORYX.Log.warn("Set ORYX_LOGLEVEL to " + ORYX_LOGLEVEL);
		
		if ("undefined" != typeof(data) && "undefined" != typeof(data.properties)) {
			// access configuration from plugin.xml, profile.xml
			// data.properties.<name> = <value>

			// register layout button
			this.facade = facade;
			this.bibliography = [];
			
			this.facade.offer({
				name:"Layout",
				functionality: function(){
				
/* read only mode -- does not seem to work
 * 					var events = [
						ORYX.CONFIG.EVENT_MOUSEDOWN,
						ORYX.CONFIG.EVENT_MOUSEUP,
						ORYX.CONFIG.EVENT_MOUSEOVER,
						ORYX.CONFIG.EVENT_MOUSEOUT,
						ORYX.CONFIG.EVENT_MOUSEMOVE,
						ORYX.CONFIG.EVENT_DBLCLICK,
						ORYX.CONFIG.EVENT_KEYDOWN,
						ORYX.CONFIG.EVENT_KEYUP
					];

					events.each(function(event){
						this.facade.disableEvent(event);
					}.bind(this))
*/
					
					try {
						this.layout();
					}
					catch(e) {
						if (ORYX.Config.Timeline.LAYOUT_ERROR_NO_DATE == e) {
							Ext.Msg.alert('Layout', 'Layouting aborted, due to invalid dates in the diagram'); 
						}
						else {
							Ext.Msg.alert('Layout', 'Layouting aborted, due to internal error'); 
							ORYX.Log.error(e);
						}
					}
					
/* read only mode -- does not seem to work
					events.each(function(event){
						this.facade.enableEvent(event);
					}.bind(this))
*/			
				}.bind(this),
				group: "Alignment",
				icon: ORYX.PATH + "images/auto_layout.png",
				description: "Automagic layouting. Orders events from left to right, according to their date, to form a tree, based on causal relations.",
				index: 0,
				minShape: 0,
				maxShape: 0});
		}
	},
	
	isEventNode: function(shape) {
		return "http://matthias-kunze.info/oryx/stencilsets/timeline#event" == shape.getStencil().id().toLowerCase();
	},
	
	isCauseEdge: function(shape) {
		return "http://matthias-kunze.info/oryx/stencilsets/timeline#cause" == shape.getStencil().id().toLowerCase();
	},
	
	getParentEvent: function(shape) {
		var parent = null;
		shape.getIncomingShapes(function(edge) {
			if (this.isCauseEdge(edge)) {
				edge.getIncomingShapes(function(node) {
					if (this.isEventNode(node)) {
	 					parent = node;
					}
				}.bind(this));
			}
		}.bind(this));
		return parent;
	},
	
	getChildEvents: function(shape) {
		var children = []
		shape.getOutgoingShapes(function(edge) {
			if (this.isCauseEdge(edge)) {
				edge.getOutgoingShapes(function(node) {
					if (this.isEventNode(node)) {
	 					children.push(node);
					}
				}.bind(this));
			}
		}.bind(this));
		return children;
	},
	
	dateFromString: function(str) {
		if (str.length == 0 || isNaN(Date.parse(str))) {
			throw ORYX.Config.Timeline.LAYOUT_ERROR_NO_DATE;	
		} 
		return Date.parse(str);
	},
	
	layout: function() {
		
		// dir contains a directory of layoutinformation for shapes
		var dir = {};
		
		// inspect the tree
		this.facade.getCanvas().getChildShapes().each(function(shape){
			if (this.isEventNode(shape)) {
				// if this is a leaf node, move up to the root and add
				// weights
				if (this.getChildEvents(shape).length == 0) {
					dir[shape.id] = {
						w: 1, 
						leaf: true,
						date: this.dateFromString(shape.properties["oryx-date"]),
						center: shape.bounds.center(),
						shape: shape,
						id: shape.id
					}
					
					var root = shape;
					var parent = this.getParentEvent(shape); 					
					while (parent) {
						dir[parent.id] = dir[parent.id] || {
							w:0,
							date: this.dateFromString(parent.properties["oryx-date"]),
							center: parent.bounds.center(),
							shape: parent,
							id: parent.id
						};
						dir[parent.id].w ++;
						root = parent
						parent = this.getParentEvent(parent);
					}
					dir[root.id].root = true;
				}
			}
		}.bind(this));
		
		var min_date = Infinity;
		var max_date = -Infinity;
		var min_x = Infinity;
		var max_x = -Infinity;
		var min_y = Infinity;
		
		for (i in dir) {
			min_date = Math.min(min_date, parseInt(dir[i].date));
			max_date = Math.max(max_date, parseInt(dir[i].date));
			min_x = Math.min(min_x, dir[i].center.x);
			max_x = Math.max(max_x, dir[i].center.x);
			min_y = Math.min(min_y, dir[i].center.y);
		};
		
		// calculates position of event within given space, relative to its date
		function getXCoordinate(id) {
			if (0 == max_date - min_date) {
				return min_x;
			}
			
			var d = parseInt(dir[id].date - min_date) * (max_x - min_x) / (max_date - min_date) + min_x;
			return d;
		}
		
		// preserve vertical ordering of events (within a subtree)
		function compare_fn(a,b) {
			if (a.center.y < b.center.y) return -1;
			if (a.center.y > b.center.y) return 1;
			return 0;
		}
		
		// storage for move commands
		var commands = [];
		
		// find root nodes
		var roots = [];	
		for (var i in dir) {
			if ("undefined" != dir[i].root && dir[i].root) {
				roots.push(dir[i]);
			}
		}
	
		// layout recursively, starting from root nodes
		(function _layout(nodes, y_offset) {

			nodes.sort(compare_fn);
			nodes.each(function(node) {
				
				var c = [];
				this.getChildEvents(node.shape).each(function(shape){
					c.push(dir[shape.id]);
				});
				if (c.length > 0) {
					_layout.apply(this, [c, y_offset]);
				}

				var coords = { //offset
					x: getXCoordinate(node.id),
					y: y_offset + 70 * (node.w - 1) / 2
				};

				y_offset = y_offset + 70 * (node.w)
				
				//collect commands
				commands.push(new ORYX.Core.Command.Move(
					[node.shape], 
					{
						x: coords.x - dir[node.id].center.x,
						y: coords.y - dir[node.id].center.y
					}, 
					null, //this.containmentParentNode, 
					null, //this.currentShapes, 
					this
				));
				
			}.bind(this))
		}.bind(this))(roots, min_y);
		
		// execute all moves as one command, 
		// allows for rollback of layouting with a single undo
		this.facade.executeCommands(commands);
		
	}
});/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the Global-scope presence pattern according to my thesis*/

if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.GlobalPresencePattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.GlobalPresencePattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.GlobalPresencePattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/GlobalPresencePattern.png",
            'description': ORYX.I18N.GlobalPresencePattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
   },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			//alert("Not Pressed");
			return true;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createGlobalPresencePattern(options);
		button.toggle();
    },
    createGlobalPresencePattern:function(options){
    	//alert("Create Global Presence Pattern");
    	try
    	{
       		var posx=-30;
       		var from = this.drawStartEvent(posx);
       		posx = posx+150;
       		var to = this.drawActivity(posx);
       		this.drawPath(from, to);
       	}
       	catch(error)
       	{
       		Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
       	}
       	
    },
    drawStartEvent:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        //alert("ssn is "+ssn);
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "StartEvent");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","A");
        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
//		alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Leads to");
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the Global-scope presence pattern according to my thesis*/

if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.GlobalAbsencePattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.GlobalAbsencePattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.GlobalAbsencePattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/GlobalAbsencePattern.png",
            'description': ORYX.I18N.GlobalAbsencePattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
   },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			//alert("Not Pressed");
			return true;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createGlobalAbsencePattern(options);
		button.toggle();
    },
    createGlobalAbsencePattern:function(options){
    	//alert("Create Global Presence Pattern");
    	try
    	{
       		var posx=-30;
       		var from = this.drawStartEvent(posx);
       		posx = posx+150;
       		var to = this.drawEndEvent(posx);
       		this.drawPath(from, to);
       	}
       	catch(error)
       	{
       		Ext.Msg.alert(ORYX.I18N.Oryx.title, error);
       	}
       	
    },
    drawStartEvent:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        //alert("ssn is "+ssn);
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "StartEvent");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawEndEvent:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "EndEvent");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        
        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
//		alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Leads to");
		newSequenceFlow.setProperty("oryx-exclude","Some Activity");
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the After-scope presence pattern according to my thesis*/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.BeforePresencePattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    // processGraph:undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.BeforePresencePattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.BeforePresencePattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/PrecedencePattern.png",
            'description': ORYX.I18N.BeforePresencePattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
				
        
		
    },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createPrecedencePattern(options);
	},
    createPrecedencePattern:function(options){
    	
    	var posx=-30;
       	var from = this.drawStartActivity(posx);
       	posx = posx+150;
       	var to = this.drawEndActivity(posx);
       	this.drawPath(from, to);
    },
    drawStartActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","A");
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawEndActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","B");
        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
		//alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Precedes");
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the After-scope presence pattern according to my thesis*/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.BeforeAbsencePattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    // processGraph:undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.BeforeAbsencePattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.BeforeAbsencePattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/BeforeAbsencePattern.png",
            'description': ORYX.I18N.BeforeAbsencePattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
				
        
		
    },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createBeforeAbsencePattern(options);
	},
    createBeforeAbsencePattern:function(options){
    	
    	var posx=-30;
       	var from = this.drawStartEvent(posx);
       	posx = posx+150;
       	var to = this.drawEndActivity(posx);
       	this.drawPath(from, to);
    },
    drawStartEvent:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "StartEvent");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawEndActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","A");
        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
		//alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Precedes");
		newSequenceFlow.setProperty("oryx-exclude","Some Activity");
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the After-scope presence pattern according to my thesis*/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.AfterPresencePattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    // processGraph:undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.AfterPresencePattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.AfterPresencePattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/ResponsePattern.png",
            'description': ORYX.I18N.AfterPresencePattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
				
        
		
    },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createResponsePattern(options);
	},
    createResponsePattern:function(options){
    	
    	var posx=-30;
       	var from = this.drawStartActivity(posx);
       	posx = posx+150;
       	var to = this.drawEndActivity(posx);
       	this.drawPath(from, to);
    },
    drawStartActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","A");
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawEndActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","B");
        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
		//alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Leads to");
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the After-scope presence pattern according to my thesis*/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.AfterAbsencePattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    // processGraph:undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.AfterAbsencePattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.AfterAbsencePattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/AfterAbsencePattern.png",
            'description': ORYX.I18N.AfterAbsencePattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
				
        
		
    },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createAfterAbsencePattern(options);
	},
    createAfterAbsencePattern:function(options){
    	
    	var posx=-30;
       	var from = this.drawStartActivity(posx);
       	posx = posx+150;
       	var to = this.drawEndEvent(posx);
       	this.drawPath(from, to);
    },
    drawStartActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","A");
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawEndEvent:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "EndEvent");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);

        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
		//alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Leads to");
		newSequenceFlow.setProperty("oryx-exclude","Some Activity");	
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the After-scope presence pattern according to my thesis*/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.BetweenAbsenceTypeIPattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    // processGraph:undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.BetweenAbsenceTypeIPattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.BetweenAbsenceTypeIPattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/BetweenAbsenceTypeIPattern.png",
            'description': ORYX.I18N.BetweenAbsenceTypeIPattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
				
        
		
    },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createBetweenAbsenceTypeIPattern(options);
	},
    createBetweenAbsenceTypeIPattern:function(options){
    	
    	var posx=-30;
       	var from = this.drawStartActivity(posx);
       	posx = posx+150;
       	var to = this.drawEndActivity(posx);
       	this.drawPath(from, to);
    },
    drawStartActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","A");
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawEndActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","B");
        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
		//alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Leads to");
		newSequenceFlow.setProperty("oryx-exclude","Some Activity");
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/**
 * Copyright (c) 2010 Ahmed Awad

 * 
 * WARNING THIS IS ONLY TO PROVE A CONCEPT!!!! NOT TO BE USED IN PRODUCTION
 * ENVIRONMENT!!!!
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
 /* This plugin is meant to create an instance of the After-scope presence pattern according to my thesis*/
if (!ORYX.Plugins) 
    ORYX.Plugins = new Object();

ORYX.Plugins.BetweenAbsenceTypeIIPattern = ORYX.Plugins.AbstractPlugin.extend({

    facade: undefined,
    
    // processGraph:undefined,
    
    construct: function(facade){
		
        this.facade = facade;
        
        this.active 		= false;
        this.raisedEventIds = [];
		
		this.facade.offer({
            'name': ORYX.I18N.BetweenAbsenceTypeIIPattern.name,
            'functionality': this.showOverlay.bind(this),
            'group': ORYX.I18N.BetweenAbsenceTypeIIPattern.group,
            'dropDownGroupIcon' : ORYX.PATH +  "images/controlFlow.png",
            'icon': ORYX.PATH + "images/BetweenAbsenceTypeIIPattern.png",
            'description': ORYX.I18N.BetweenAbsenceTypeIIPattern.desc,
            'index': 0,
            'toggle': true,
			'minShape': 0,
            'maxShape': 0
        });
				
        
		
    },
    showOverlay: function(button, pressed){

		if (!pressed) {
			
			this.raisedEventIds = [];
			this.active 		= !this.active;
			
			return;
		} 
		
		var options = {
			command : 'undef'
		}
	
		this.createBetweenAbsenceTypeIIPattern(options);
	},
    createBetweenAbsenceTypeIIPattern:function(options){
    	
    	var posx=-30;
       	var from = this.drawStartActivity(posx);
       	posx = posx+150;
       	var to = this.drawEndActivity(posx);
       	this.drawPath(from, to);
    },
    drawStartActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	var pos={};
        pos['x']=posX;
        pos['y']=0;
        
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","A");
        this.facade.getCanvas().add(newShape);
        return newShape;
            
    },
    drawEndActivity:function(posX){
    	var parentShape=this.facade.getCanvas();
        var newShape;
    	
    	
        var pos={};
        pos['x']=posX;
        pos['y']=0;
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil;
        stencil = ORYX.Core.StencilSet.stencil(ssn + "Task");
        newShape=new ORYX.Core.Node({
                'eventHandlerCallback':this.facade.raiseEvent
            },stencil);
        newShape.setProperty("oryx-name","B");
        this.facade.getCanvas().add(newShape);
        return newShape;
    },
    drawPath:function(from,to){
    	
        //    	alert(from);
        //    	alert(to);
    	
        var newSequenceFlow;
        var parentShape=this.facade.getCanvas();
    	
        var ssn 	= this.facade.getStencilSets().keys()[0];
        var stencil = ORYX.Core.StencilSet.stencil(ssn + "Path");
   	
        newSequenceFlow=new ORYX.Core.Edge({
            'eventHandlerCallback':this.facade.raiseEvent
        },stencil);
        
    	
        // Set the docker
        newSequenceFlow.dockers.first().setDockedShape( from );
        newSequenceFlow.dockers.first().setReferencePoint({
            x: from.bounds.width() / 2.0,
            y: from.bounds.height() / 2.0
        });
    	
        newSequenceFlow.dockers.last().setDockedShape( to );
        newSequenceFlow.dockers.last().setReferencePoint({
            x: to.bounds.width() / 2.0,
            y: to.bounds.height() / 2.0
        });
		//newSequenceFlow.setProperty("oryx-temporalproperty","leadsto");
		//alert(newSequenceFlow.getProperty("oryx-temporalproperty"));
		newSequenceFlow.setProperty("oryx-temporalproperty","Precedes");
		newSequenceFlow.setProperty("oryx-exclude","Some Activity");
        //
        this.facade.getCanvas().add(newSequenceFlow);
        return newSequenceFlow;
    }
    
    
});



/*global ORYX, Ext, Ajax*/ //for JSLint

if (!ORYX.Plugins) {
    ORYX.Plugins = {};
}

/**
 * A Plugin for generating Process-Logs from Petrinets. This plugin uses a
 * server-side plugin to actually generate the log. This client-side plugin
 * only shows an options-dialog, sends the log-generation-request to the server
 * and offers the generated log for download. 
 * 
 * @class
 * @author Thomas Milde
 * */
ORYX.Plugins.ProcessLogGenerator = ORYX.Plugins.AbstractPlugin.extend({
    
    /**
     * The URL, that handles Requests for creating a Process-Log
     * @constant
     * @private
     * @fieldof ORYX.Plugins.ProcessLogGenerator#
     * */
    processLogGeneratorHandleURL: ORYX.PATH + "processloggenerator",
    
    /**
     * Creates a new instance of the Process-Log-Generation plugin and registers
     * it at the supplied facade.
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     * @param {Facade} facade The plugin facade (interface between
     * plugin and editor)
     * */
    construct: function (facade) {
    
        arguments.callee.$.construct.apply(this, arguments);
        // Call super class constructor
    
        this.facade.offer({
            'name'          : ORYX.I18N.ProcessLogGenerator.generate,
            'functionality' : this.perform.bind(this),
            'description'   : ORYX.I18N.ProcessLogGenerator.generateDescription,
            'icon'          : ORYX.PATH + "images/processLogGeneratorIcon.png",
            'index'         : 0,
            'minShape'      : 0,
            'maxShape'      : 0
        });    
    },
    
    /**
     * Perform the plugin's action. Checks in advance, the stencil set 
     * extension to configure petrinet execution is loaded.
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     * */
    perform: function () {
    	
    	this.confirmed_petrinettimeandprobability_extension_missing = this.confirmed_petrinettimeandprobability_extension_missing || false;
    	if (!this.confirmed_petrinettimeandprobability_extension_missing) {
    		
    		// warn about missing stencil set extension only once
    		this.confirmed_petrinettimeandprobability_extension_missing = true;
    		
    		// Search for the time and probability extension
        	var petrinettimeandpropability_extension_missing = true;
        	this.facade.getStencilSets().values().each(function(ss) {
        		ss.extensions().values().each(function(sse){
        			if (sse.namespace.match(/petrinettimeandpropability/)) {
        				petrinettimeandpropability_extension_missing = false;
        			}
        		});
        	});
    	   	
        	// inform user about missing extension
        	if (petrinettimeandpropability_extension_missing) {
        		Ext.MessageBox.show({
    				title:'Time and Probability Extension',
    				msg: '<p>An exension for petrinets allows you to configure execution time and probability of transitions and thus further control the generated log for this model.' +
    					 '<br/> To use this feature load the <strong>\"Time and Probability Extension\"</strong> from the stencil set extensions menu.</p>'+
    					 '<br/>Do you want to proceed anyways?',
    				buttons: Ext.MessageBox.YESNO,
    				fn: function(answer){
        				if ("yes" == answer) {
        					this.checkTokens();
        				}
        			}.bind(this),
        			animEl: 'mb4',
        			icon: Ext.MessageBox.QUESTION
        		});
        	}
    		else {
    			this.checkTokens();
    		}
    	}
    	else {
    		this.checkTokens();
    	}
    },
    
    /**
     * Informs the user, if the net has no tokens, i.e., logs will be empty.
     *
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     */
    checkTokens: function(){
    	// find all tokens in the net
    	var net_has_tokens = this.getPlaces().any(function(place) {
    		var tokens = parseInt(place.properties["oryx-numberoftokens"]);
            return !(isNaN(tokens) || tokens == 0);
    	});
    	
    	if (!net_has_tokens) {
    		Ext.MessageBox.show({
				title:'No Tokens',
				msg: 'The net has no tokens, and thus cannot be executed. Generated logs will be empty.<br/>Do you want to proceed?',
				buttons: Ext.MessageBox.YESNO,
				fn: function(answer){
    				if ("yes" == answer) {
    					this.showDialog();
    				}
    			}.bind(this),
    			animEl: 'mb4',
    			icon: Ext.MessageBox.QUESTION
    		});
    	}
    	else {
    		this.showDialog();
    	}
    },
    
    
    /**
     * open a Properties-window and send a
     * request for creating a log to the server, when the form was submitted.
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     */
    showDialog: function() {
    	
    	var completenessSelector = this.createCompletenessSelector(),
        //the select-(drop-down-list) field for choosing, whether some kind
        //of completeness is desired.
        noiseField = this.createNoiseField(),
        //the input-field for choosing the degree of noise (percentage) in
        //the generated log
        traceCountField = this.createTraceCountField(),
        //the input-field for selecting, how many traces should be generated
        dialog = this.createDialog();
        //the dialog-window, which will present all those fields
    
	    this.addFormPanelToWindow(completenessSelector, noiseField, traceCountField, dialog);
	    //generate a FormPanel with the three fields and add it to the dialog
	    
	    dialog.show();
    },
    
    /** 
     * Returns a set of all places in the Net
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     */
    getPlaces: function(){
        return this.facade.getCanvas().getChildShapes().select(function(shape){
            return shape.getStencil().id().search(/Place/) > -1;
        });
    },
    
    /**
     * Creates a ComboBox, that allows selecting, whether Trace-Completeness,
     * Ordering-Completeness or no completeness is required.
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     * @return {Ext.form.ComboBox} the new ComboBox
     * */
    createCompletenessSelector: function () {
        var completenessOptions = [['None'], ['Trace'], ['Ordering']],
            dataStore = new Ext.data.SimpleStore({
                fields    : ['value'],
                data    : completenessOptions
            });
        //dataStore is necessary, because a ComboBox cannot be directly provided
        //with an array.
        
        return new Ext.form.ComboBox({
            fieldLabel: ORYX.I18N.ProcessLogGenerator.completenessSelect,
            store: dataStore,
            displayField: 'value',
            valueField: 'value',
            typeAhead: true,
            mode: 'local',
            triggerAction: 'all',
            selectOnFocus: true,
            forceSelection: true,
            value: this.completeness || 'Trace',
            emptyText: ORYX.I18N.ProcessLogGenerator.pleaseSelect
        });
    },
    
    /**
     * Creates an input-field, that allows entering a number from 0
     * to 100 (percentage), that specifies the degree of noise in the generated
     * log.
     * 
     *  @methodof ORYX.Plugins.ProcessLogGenerator#
     *  @return {Ext.form.NumberField} the new input-field
     * */
    createNoiseField: function () {
        return new Ext.form.NumberField({
            fieldLabel        : ORYX.I18N.ProcessLogGenerator.degreeOfNoise,
            allowBlank        : false,
            allowDecimals    : false,
            value           : this.noise || 5,
            minValue        : 0,
            maxValue        : 100
        });
    },
    
    /**
     * Creates an input-field for a number from 1 to 10,000 specifying the
     * number of traces, that the generated log should contain.
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     * @return {Ext.form.NumberField} the new input-field
     * */
    createTraceCountField: function () {
        return new Ext.form.NumberField({
            fieldLabel        : ORYX.I18N.ProcessLogGenerator.numberOfTraces,
            allowBlank        : false,
            allowDecimals    : false,
            value          : this.tracecount || 10,
            minValue        : 1,
            maxValue        : 10000
        });
    },
    
    /**
     * Creates a new dialog-window carrying the title and having the size needed
     * for displaying the configuration-options for log-generation.
     *  
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     * @return {Ext.Window} the new dialog-window.
     * */
    createDialog: function () {
        var dialog = new Ext.Window({ 
            autoCreate: true, 
            title: ORYX.I18N.ProcessLogGenerator.preferencesWindowTitle, 
            height: 240, 
            width: 400, 
            modal: true,
            collapsible: false,
            fixedcenter: true, 
            shadow: true, 
            style: 'font-size:12px;',
            proxyDrag: true,
            resizable: true,
            items: [
                new Ext.form.Label({
                    text: ORYX.I18N.ProcessLogGenerator.dialogDescription, 
                    style: 'font-size:12px;'
                })//this is the title of the dialog. the content is not added
                  //in this method.
            ]
        });
        
        dialog.on('hide', function () {
            dialog.destroy(true);
        });
        
        return dialog;
    },
    
    /**
     * Creates a new FormPanel with the first three parameters (
     * completenessSelector, noiseField and traceCountField) as its elements
     * and adds the new FormPanel to the window, which is the fourth parameter.
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     * @param {Ext.form.ComboBox} completenessSelector the ComboBox, that allows
     * selecting the type of completeness and will be the first field in the 
     * Form.
     * @param {Ext.form.NumberField} noiseField the input-field, which allows
     * selecting the percentage of noise in the generated log and will be the 
     * second field of the Form.
     * @param {Ext.form.NumberField} tracecountField the input-field, which
     * allows selecting the desired number of traces and will be the last entry
     * in the Form.
     * @param {Ext.Window} window the dialog-window, which the form should be 
     * added to.
     * */
    addFormPanelToWindow: function (
            completenessSelector, noiseField, traceCountField, window) {
        var panel = new Ext.form.FormPanel({
            frame : false,
            defaultType : 'textfield',
            waitMsgTarget : true,
            labelAlign : 'left',
            buttonAlign: 'right',
            enctype : 'multipart/form-data',
            style: 'font-size:12px;',
            monitorValid: true,
            items : [
                completenessSelector,
                noiseField,
                traceCountField
            ],
            buttons: [{
                text: "Submit",
                formBind: true,//ensures, that the button can only be clicked,
                //when the form's constraints are met (e.g. all fields are 
                handler: function () {
            		this.completeness = completenessSelector.getValue();
            		this.noise = noiseField.getValue();
            		this.tracecount = traceCountField.getValue();
            	
                    this.generateLog({
                        completeness: this.completeness,
                        noise: this.noise,
                        traceCount: this.tracecount
                    });//this will send a request to the server for generating
                    //a log with the desired options (->parameter)
                    window.hide();//will destroy the dialog
                }.bind(this)
            }]
        });
        window.add(panel);
    },
    
    /**
     * Sends a Request for creating a log with the desired parameters from the
     * current model to the server and opens a new window for downloading the 
     * log, when generating is completed.
     * 
     * @methodof ORYX.Plugins.ProcessLogGenerator#
     * @param {Object} options The options for generating the log. This object
     * must have the fields completeness, noise and traceCount. completeness is
     * "None", "Trace" or "Ordering"; noise is a number from 0 to 100
     * (percentage of noise in the generated log); traceCount is a number from
     * 1 to 10,000 (number of traces in the generated log).
     * */
    generateLog: function (options) {
        var erdf = this.getRDFFromDOM(),
            optionsString = JSON.stringify(options);
        this.facade.raiseEvent({
            type: ORYX.CONFIG.EVENT_LOADING_ENABLE,
            text: ORYX.I18N.ProcessLogGenerator.shortWaitText
        });//will show a "please wait"-style message in the editor's topleft
        //corner (like the one for "Saving")
        new Ajax.Request(this.processLogGeneratorHandleURL, {
                method: 'POST',
                parameters: {
                    'options'    : optionsString,
                    'model'        : erdf
            },
            onSuccess: function (request) {
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });//remove the "please wait"-message
                this.openDownloadWindow("generated_log.mxml",
                        request.responseText);//request.responseText contains
                //the log, which will be offered as a file
                //named generated_log.mxml
            }.bind(this),
            
            onFailure: function () {
                this.facade.raiseEvent({
                    type: ORYX.CONFIG.EVENT_LOADING_DISABLE
                });//remove the "please wait"-message
                Ext.Msg.alert(ORYX.I18N.Oryx.title,
                        ORYX.I18N.ProcessLogGenerator.failed);
                //shows an error-message
            }.bind(this)
        });
    }
    
});/** Import of Visio BPMN diagrams, that have been build with supported stencil sets.
 *  Currently supported: 0MG 0.9, BPT 1.1, Official Visio 2010 BPMN 1.1
 *	Created in the PMP seminar 2010. 
 *  Author: Lauritz Thamsen
 **/

if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.VisioBPMNImport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	construct: function(facade) {
	
		// Call super class constructor
		arguments.callee.$.construct.apply(this, arguments);
		
		this.facade = facade;
					
		this.facade.offer({
			'name':				ORYX.I18N.VisioImport.BPMNName,
			'functionality': 	this.importVDX.bind(this),
			'group': 			'Export',
			'dropDownGroupIcon':ORYX.PATH + "images/import.png",
			'icon': 			ORYX.PATH + "images/visio_icon.png",
			'description': 		ORYX.I18N.VisioImport.desc,
			'index': 			1,
			'minShape': 		0,
			'maxShape': 		0
		});
	},

	// Imports VDX - file
	importVDX: function() {
		this._showImportDialog();
	},			
	

// -------------------------------------------- Import Functions ------------------------
	
	// Import through form.getForm().submit because .vdx can be up to 10 mb and
	// that's too much for the other text-area using ajax request, which is used
	// in most other imports into oryx-editor.
	
	 // Opens a upload dialog
	_showImportDialog: function( successCallback ) {
		
		// Define the form panel
		var form = new Ext.form.FormPanel({
			defaultType 	: 'textfield',
			layout     		: "anchor",
			border     		: false,
			fileUpload 		: true,   
			// replace regex: MIME type of the response is plain text, because app/json is interpreted as download
			// to import the text as json to a oryx model, <pre> and </pre> must be escaped
			reader			: {read:function(r){ return r.responseText.replace(/\s*<(pre|\/pre)>\s*/gi, ""); }},
			items: [{
				text    	: ORYX.I18N.VisioImport.PleaseSelect,
	            style   	: 'font-size:12px;margin-bottom:10px;display:block;',
	            xtype   	: 'label'
	        }, {
	            name      	: 'vdxFile',
	            inputType  	: 'file',
	            style      	: 'margin-bottom:10px;display:block;',
	            itemCls    	: 'ext_specific_window_overflow'
	        }, {
                name       	: 'stencil',
                inputType  	: 'hidden',
                value      	: 'bpmn'
	        }]
	    });
	   
		// replace regex: MIME type of the response is plain text, because app/json is interpreted as download
		// to import the text as json to a oryx model, <pre> and </pre> must be escaped
		form.getForm().errorReader = {read:function(e){ return {success:e.responseText.replace(/\s*<(pre|\/pre)>\s*/gi, "").startsWith("{"),records:[]}}};
	   
	    // Create the panel
		var dialog = new Ext.Window({
			autoCreate  : true,
			cls         : "x-window-security-center",
			bodyStyle   : 'padding:5px;background:white;',
			title       : ORYX.I18N.VisioImport.Label,
		    width       : 400,
		    modal       : true,
		    resizable   : false,
		    items       : [form],
		    buttons: [{
		    	text    : ORYX.I18N.VisioImport.UploadButton,
		        handler	: function(){
		           
		    		if (form.items.items[1].el.dom.value) {
		    			form.getForm().submit({
		    				url		: ORYX.CONFIG.VISIOIMPORT,
		                    waitMsg	: ORYX.I18N.VisioImport.ImportWait,
		                    method	: "POST",
		                    success	: function(a, request) {                                                                       
		                        dialog.close();
		                        // replace regex: MIME type of the response is plain text, because app/json is interpreted as download
		                		// to import the text as json to a oryx model, <pre> and </pre> must be escaped
		                        this.facade.importJSON(request.response.responseText.replace(/\s*<(pre|\/pre)>\s*/gi, ""));
		                  	}.bind(this),
		                    failure	: function(a, request) {
		                      	dialog.close();
		                      	Ext.Msg.alert(ORYX.I18N.VisioImport.ImportFailure, ORYX.I18N.VisioImport.ImportFailureDescription)
		                      		.setIcon(Ext.MessageBox.INFO);
		                  	}
		    			});
		    		} else {
		    			dialog.close();
		          	}      
		    	}.bind(this)
		    }, {
		    	text	: Ext.MessageBox.buttonText.cancel,
		    	handler	: function(){
		        	dialog.close();
		      	}.bind(this)
		    }]	
		});
	    
	    // Show the panel
	    dialog.show();
	}			
});
/** Import of Visio EPC diagrams, that have been build with the visio EPC stencil sets.
 *	Created in the PMP seminar 2010. 
 *  Author: Lauritz Thamsen
 **/
if(!ORYX.Plugins)
	ORYX.Plugins = new Object();

ORYX.Plugins.VisioEPCImport = ORYX.Plugins.AbstractPlugin.extend({

	facade: undefined,
	
	construct: function(facade) 
	{
		// Call super class constructor
		arguments.callee.$.construct.apply(this, arguments);
		
		this.facade = facade;
					
		this.facade.offer({
			'name':				ORYX.I18N.VisioImport.EPCName,
			'functionality': 	this.importVDX.bind(this),
			'group': 			'Export',
			'dropDownGroupIcon':ORYX.PATH + "images/import.png",
			'icon': 			ORYX.PATH + "images/visio_icon.png",
			'description': 		ORYX.I18N.VisioImport.desc,
			'index': 			2,
			'minShape': 		0,
			'maxShape': 		0
		});
		
	},

	// Imports VDX - file
	importVDX: function()
	{
		this._showImportDialog();
	},		

	// Request
	
	_sendRequest: function( url, method, params, successcallback, failedcallback ){

		var suc = false;

		new Ajax.Request(
		url, 
		{
           method			: method,
           asynchronous		: false,
           parameters		: params,
		   onSuccess		: function(transport) 
		   {
				suc = true;
		
				if(successcallback)
				{
					successcallback( transport.responseText )	
				}
		
		   }.bind(this),
		   onFailure		: function(transport) 
		   {
				if(failedcallback)
				{							
					failedcallback();							
				} 
				else 
				{
					this._showErrorMessageBox(ORYX.I18N.Oryx.title, ORYX.I18N.VisioImport.connectionError);
					ORYX.log.warn("Communication failed: " + transport.responseText);	
				}					
		   }.bind(this)		
		});
		
		return suc;		
	},	


// -------------------------------------------- Import Functions ------------------------
	
	// Import through form.getForm().submit because .vdx can be up to 10 mb and
	// that's too much for the other text-area using ajax request, which is used
	// in most other imports into oryx-editor.
	
	 // Opens a upload dialog
	_showImportDialog: function( successCallback ) {
		
		// Define the form panel
		var form = new Ext.form.FormPanel({
			defaultType 	: 'textfield',
			layout     		: "anchor",
			border     		: false,
			fileUpload 		: true,   
			// replace regex: MIME type of the response is plain text, because app/json is interpreted as download
			// to import the text as json to a oryx model, <pre> and </pre> must be escaped
			reader			: {read:function(r){ return r.responseText.replace(/\s*<(pre|\/pre)>\s*/gi, ""); }},
			items: [{
				text    	: ORYX.I18N.VisioImport.PleaseSelect,
	            style   	: 'font-size:12px;margin-bottom:10px;display:block;',
	            xtype   	: 'label'
	        }, {
	            name      	: 'vdxFile',
	            inputType  	: 'file',
	            style      	: 'margin-bottom:10px;display:block;',
	            itemCls    	: 'ext_specific_window_overflow'
	        }, {
                name       	: 'stencil',
                inputType  	: 'hidden',
                value      	: 'epc'
	        }]
	    });
	   
		// replace regex: MIME type of the response is plain text, because app/json is interpreted as download
		// to import the text as json to a oryx model, <pre> and </pre> must be escaped
		form.getForm().errorReader = {read:function(e){ return {success:e.responseText.replace(/\s*<(pre|\/pre)>\s*/gi, "").startsWith("{"),records:[]}}};
	   
	    // Create the panel
		var dialog = new Ext.Window({
			autoCreate  : true,
			cls         : "x-window-security-center",
			bodyStyle   : 'padding:5px;background:white;',
			title       : ORYX.I18N.VisioImport.Label,
		    width       : 400,
		    modal       : true,
		    resizable   : false,
		    items       : [form],
		    buttons: [{
		    	text    : ORYX.I18N.VisioImport.UploadButton,
		        handler	: function(){
		           
		    		if (form.items.items[1].el.dom.value) {
		    			form.getForm().submit({
		    				url		: ORYX.CONFIG.VISIOIMPORT,
		                    waitMsg	: ORYX.I18N.VisioImport.ImportWait,
		                    method	: "POST",
		                    success	: function(a, request) {                                                                       
		                        dialog.close();
		                        // replace regex: MIME type of the response is plain text, because app/json is interpreted as download
		                		// to import the text as json to a oryx model, <pre> and </pre> must be escaped
		                        this.facade.importJSON(request.response.responseText.replace(/\s*<(pre|\/pre)>\s*/gi, ""));
		                  	}.bind(this),
		                    failure	: function(a, request) {
		                      	dialog.close();
		                      	Ext.Msg.alert(ORYX.I18N.VisioImport.ImportFailure, ORYX.I18N.VisioImport.ImportFailureDescription)
		                      		.setIcon(Ext.MessageBox.INFO);
		                  	}
		    			});
		    		} else {
		    			dialog.close();
		          	}      
		    	}.bind(this)
		    }, {
		    	text	: Ext.MessageBox.buttonText.cancel,
		    	handler	: function(){
		        	dialog.close();
		      	}.bind(this)
		    }]	
		});
	    
	    // Show the panel
	    dialog.show();
	}			
});
/**
 * Copyright (c) 2011 Tobias Pfeiffer
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
if (!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}

/**
 * Plugin for the uml state machine stencilset of Oryx.
 * It enables templates for the more complex shapes of the stencilsets, 
 * controlflow and state with actions that is.
 * Templates offer the user an easier way of editing. If you doubeclick on
 * an empty edge all the options get presented just like that:
 * 
 * Event [Guard] /Action
 * 
 * This plugin also required changes in renameShape.js.
 * Check out the Wikipage for more information.
 */

ORYX.Plugins.UMLState = Clazz
		.extend({

			facade : undefined,

			construct : function(facade) {

				this.facade = facade;

				// We raise an Event, that registers our templating functions in
				// renameShape.js
				// the edit template function takes the value of a property and
				// changes it so the
				// user sees something different to edit
				// the render template function takes the input the user
				// submitted and reformats
				// it in the way it should be saved as a property
				// So for more information on what this does exactly refer to
				// renameShape.js

				this.facade.raiseEvent({
					type : ORYX.CONFIG.EVENT_REGISTER_LABEL_TEMPLATE,
					edit_template : this.templatizeValue.bind(this),
					render_template : this.untemplatizeValue.bind(this)
				});
				
				// register the event that fires every time a seperator is modified
				// as we want to center the x-coordinate according to the parent
				this.facade.registerOnEvent('layout.uml.state.seperator',
						this.centerSeperatorOnParent.bind(this));
			},
			/**
			 * Templatize value is the funcation that is called, when a user
			 * starts editing a field. For UML State this function decides which
			 * template to use based on the element which is being edited. If it
			 * is neither the controlflow edge nor the state with actions,
			 * nothing is done.
			 * 
			 * templatize value expects the oldValue to be in format of the
			 * template... if not the old value will get returned.
			 * 
			 * @param oldValue the value that is currently saved for the field
			 * currently edited
			 * 
			 * @param propId the id of the property currently edited, we need it
			 * in order to differentiate between the 2 textfiels of the state with actions
			 * 
			 * @param shape the shape currently edited
			 * 
			 * @return the template version of the inputstring (oldValue) according to
			 * the element currently edited (might be the same as oldValue)
			 */
			templatizeValue : function templatizeValue(oldValue, propId, shape) {

				var stencilID = shape._stencil.id();
				// It is the edge (controlflow)
				if (stencilID === "http://b3mn.org/stencilset/umlstate#controlFlow") {
					return this.templatizeEdgeValue(oldValue);
				}
				// Make sure it's the state with actions and it is the textfield
				// actions, not the the textfiel name (name has no template)
				else if ((stencilID === "http://b3mn.org/stencilset/umlstate#stateWithActions")
						&& (propId.indexOf("actions") !== -1)) {
					return this.templatizeStateWithActionsValue(oldValue);
				}
				// Otherweise nothing special to do, so the old value gets
				// returned
				else {
					return oldValue;
				}
			},

			/**
			 * templatizes the old value an edge has. The template looks as
			 * follows:
			 * 
			 * Event [Guard] /Action
			 * 
			 * so if the old value is: "Rain" it considers this as an event and
			 * returns:
			 * 
			 * Rain [Guard] /Action
			 * 
			 * @param oldValue the value saved in the property without any template
			 * 
			 * @return the template version of oldValue
			 */
			templatizeEdgeValue : function templatizeEdgeValue(oldValue) {
				// optimization: just query the strings once for the relevant
				// indexes
				var indexOfBracket = oldValue.indexOf("[");
				var indexOfSlash = oldValue.indexOf("/");
				// following are all the different possible cases,
				// the comment indicates which case the if construct should
				// catch

				// Case of: blank field ""
				if (oldValue === "") {
					return "Event [Guard] /Action";
				}
				// Case of: Event
				if ((indexOfBracket === -1) && (indexOfSlash === -1)) {
					return oldValue + " [Guard] /Action";
				}
				// Case of: [Guard]
				if ((indexOfBracket === 0) && (indexOfSlash === -1)) {
					return "Event " + oldValue + " /Action";
				}
				// Case of: /Action
				if (indexOfSlash === 0) {
					return "Event [Guard] " + oldValue;
				}
				// Case of: Event [Guard]
				if ((indexOfBracket !== -1) && (indexOfSlash === -1)) {
					return oldValue + " /Action";
				}
				// Case of: Event /Action
				if ((indexOfBracket === -1) && (indexOfSlash > 0)) {
					var splitter = oldValue.split("/");
					return splitter[0] + "[Guard] /" + splitter[1];
				}
				// Case of:[Guard] /Action
				if ((indexOfBracket === 0) && (indexOfSlash !== -1)) {
					return "Event " + oldValue;
				}

				// Case of: Event [Guard] /Action
				if ((indexOfBracket > 0) && (indexOfSlash > 0)) {
					return oldValue;
				}

				// We didn't return so far: WTF happened?
				return oldValue;
			},
			/**
			 * This function templatizes the actions of the state with actions
			 * in the scheme of: entry / action do / action exit / action
			 * 
			 * @param oldValue the value saved in the property without any template
			 * 
			 * @return the template version of oldValue
			 */
			templatizeStateWithActionsValue : function templatizeStateWithActionsValue(
					oldValue) {
				// performance optimization, save the values of the indexes so
				// we don't need to query them every time
				var indexOfEntry = oldValue.indexOf("entry /");
				var indexOfDo = oldValue.indexOf("do /");
				var indexOfExit = oldValue.indexOf("exit /");

				// \n is used as a line end character because \r\n was causing
				// trouble in Firefox although I was using windows.

				// standardize the ending of the oldValue, with \n that is. (The
				// rest is simpler that way)
				if (oldValue.charAt(oldValue.length - 1) !== "\n") {
					oldValue = oldValue + "\n";
				}

				// you see, here we match against \n because we add it above.
				// (but it really is the case of an empty value)
				if (oldValue === "\n") {
					return "entry / action\ndo / action\nexit / action";
				}
				// entry / action
				if ((indexOfEntry === 0) && (indexOfDo === -1)
						&& (indexOfExit === -1)) {
					return oldValue + "do / action\nexit / action";
				}
				// do / action
				if ((indexOfEntry === -1) && (indexOfDo === 0)
						&& (indexOfExit === -1)) {
					return "entry / action\n" + oldValue + "exit / action";
				}
				// exit / action
				if ((indexOfEntry === -1) && (indexOfDo === -1)
						&& (indexOfExit === 0)) {
					return "entry / action\ndo / action\n" + oldValue;
				}
				// entry / action
				// do / action
				if ((indexOfEntry === 0) && (indexOfDo !== -1)
						&& (indexOfExit === -1)) {
					return oldValue + "exit / action";
				}
				// entry / action
				// exit / action
				if ((indexOfEntry === 0) && (indexOfDo === -1)
						&& (indexOfExit !== -1)) {
					return oldValue.slice(0, indexOfExit) + "do / action\n"
							+ oldValue.slice(indexOfExit);
				}
				// do / action
				// exit / action
				if ((indexOfEntry === -1) && (indexOfDo === 0)
						&& (indexOfExit !== -1)) {
					return "entry / action\n" + oldValue;
				}
				// the whole bunch
				// entry / action
				// do / action
				// exit / action
				if ((indexOfEntry === 0) && (indexOfDo !== -1)
						&& (indexOfExit !== -1)) {
					return oldValue;
				}

				// If we got this far something went wrong
				return oldValue;
			},

			/**
			 * untemplatize value is called when the user is done editing a
			 * property now we want to remove the template and only keep the
			 * part the user changed. This particular function just decides
			 * which more specific method to call based on the shape which is
			 * currently edited.
			 * 
			 * @param newValue the value the user typed into the editbox
			 * 
			 * @param propId the id of the property currently edited, we need it
			 * in order to differentiate between the 2 textfiels of the state with actions
			 * 
			 * @param shape the shape currently edited
			 * 
			 * @return the value without the template specific substrings
			 */
			untemplatizeValue : function untemplatizeValue(newValue, propId,
					shape) {

				var stencilID = shape._stencil.id();
				// It is the edge (controlflow)
				if (stencilID === "http://b3mn.org/stencilset/umlstate#controlFlow") {
					return this.untemplatizeEdgeValue(newValue);
				}
				// Make sure it's the state with actions and it is the textfield
				// actions, not the the textfiel name (there is no template for
				// name)
				else if ((stencilID === "http://b3mn.org/stencilset/umlstate#stateWithActions")
						&& (propId.indexOf("actions") !== -1)) {
					return this.untemplatizeStateWithActionsValue(newValue);
				}
				// Otherweise nothing special to do (as we don't want to affect
				// every stencil)
				else {
					return newValue;
				}
			},

			/**
			 * The intent of this function is that if the user does something
			 * like this one a controlFlow edge:
			 * 
			 * Event [x >= 5] /Action
			 * 
			 * what gets saved and displayed is
			 * 
			 * [x >= 5]
			 * 
			 * Therefore we'll try to delete any occurences of Event, [Guard]
			 * and /Action
			 * 
			 * @param value the value the user edited
			 * 
			 * @return the value without the template specific substrings
			 */
			untemplatizeEdgeValue : function untemplatizeEdgeValue(value) {
				// Quiet a chain, I love message chaining.
				// we actually don't replace but replace the occurance with an
				// empty string
				var newValue = value.replace("Event ", "").replace("[Guard]",
						"").replace(" /Action", "");
				return newValue;
			},

			/**
			 * The intent of this function is that if the user does something
			 * like this one a state with actions edge:
			 * 
			 * entry / action do / write JavaScript exit / action
			 * 
			 * what gets saved and displayed is
			 * 
			 * do / write JavaScript
			 * 
			 * Therefore we'll try to delete any occurences of entry / action,
			 * do / action\n and exit / action
			 * 
			 * @param value the value left after the user finished editing
			 * 
			 * @return the value without the template specific substrings
			 */
			untemplatizeStateWithActionsValue : function untemplatizeStateWithActionsValue(
					value) {
				// the \n at the end is wanted because otherwise it would remain
				// and things would look ugly
				// moreover a user couldn't do something like entry / action go
				// to (or something like this)
				var newValue = value.replace("entry / action\n", "").replace(
						"do / action\n", "").replace("exit / action", "");
				return newValue;
			},
			
			/**
			 * Centers the x-coordinate of the seperator on its parent the composite state.
			 * This makes handling it a lot smoother. Centering the y-coordinate wouldn't make sense
			 * since you can have multiple seperators since you might need more than 2 areas.
			 * 
			 * @param event the event created every time a seperator is moved
			 */
			centerSeperatorOnParent : function centerOnParent(event) {
				var shape = event.shape;
				// the parent element of a seperator is always a composite state (see JSON)
				var parent = shape.getParentShape();
				var difference = parent.absoluteCenterXY().x - shape.absoluteCenterXY().x;
				// move the seperator by the calculated difference on the x-axis 
				shape.bounds.moveBy(difference, 0);
			}
		});/**
 * Copyright (c) 2011 Tobias Pfeiffer
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
if (!ORYX.Plugins) {
	ORYX.Plugins = new Object();
}
/**
 * Plugin for the UML sequence diagrams. It realizes the following things: -
 * send every combined fragment to the back so they don't interfere with the
 * interactions of the user.
 */
ORYX.Plugins.UMLSequence = Clazz.extend({

	facade : undefined,

	/**
	 * Constructor registering all the events important for us
	 * 
	 * @param facade the facade
	 */
	construct : function(facade) {

		this.facade = facade;
		this.facade.registerOnEvent('layout.uml.sequence.combinedFragment',
				this.sendToBack.bind(this));
		this.facade.registerOnEvent('layout.uml.sequence.onLifeline',
				this.centerOnLifeline.bind(this));
		this.facade.registerOnEvent('layout.uml.sequence.terminator',
				this.centerTerminatorOnLifeline.bind(this));
		

	},

	/**
	 * Sends the element on which this function is called to the back, so it
	 * doesn't block the interaction with other objects-
	 * 
	 * This is called whenever a combined Fragment is moved, as they are
	 * supposed to be somewhat behind the interaction as you can't draw arrows
	 * while they are in front.
	 * 
	 * If you want to know what combined Fragments are, please refer to the
	 * umlsequence.json in the stencilsets folder.
	 * 
	 * @param event the event of the combined fragment which was modified
	 */
	sendToBack : function sendToBack(event) {
		var shape = event.shape;
		// basically taken from arrangement.js of the setToBack function
		shape.node.parentNode.insertBefore(shape.node,
				shape.node.parentNode.firstChild);
	},

	/**
	 * This function is used for umlsequence active line elements. They work
	 * just through some more or less rough hacks, a lifeline "contains" active
	 * lines. This makes it basically work, but one can make it look bad by
	 * dropping the activeline not really in the center of a lifeline. This
	 * function is used to standardize the layout.
	 * 
	 * @param event the event of the active line which was modified
	 */
	centerOnLifeline : function centerOnLifeline(event) {
		var shape = event.shape;
		// The parent element is always a lifeline so we don't have to check for this (see the JSON)
		var parent = shape.getParentShape();

		// compute the difference of the x-coordinates of the center of the lifeline 
		// and the center of the activeline
		var difference = parent.absoluteCenterXY().x - shape.absoluteCenterXY().x;
		// move the active line by the calculated difference on the x-axis 
		shape.bounds.moveBy(difference, 0);
	},
	centerTerminatorOnLifeline: function centerTerminatorOnLifeline(event) {
		var shape = event.shape;
		// The parent element is always a lifeline so we don't have to check for this (see the JSON)
		var parent = shape.getParentShape();
		// compute the difference of the x-coordinates of the center of the lifeline 
		// and the center of the activeline
		var differenceX = parent.absoluteCenterXY().x - shape.absoluteCenterXY().x;
		var differenceY = parent.bounds.lowerRight().y - shape.absoluteCenterXY().y;

		// move the active line by the calculated difference on the x-axis 
		shape.bounds.moveBy(differenceX, differenceY);
	}

});